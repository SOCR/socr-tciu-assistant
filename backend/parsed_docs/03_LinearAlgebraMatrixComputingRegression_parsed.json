{
  "metadata": {
    "created_at": "2024-11-30T13:46:16.125635",
    "total_sections": 5,
    "total_code_chunks": 98,
    "total_tables": 3,
    "r_libraries": [
      "BART",
      "GGally",
      "MASS",
      "RWeka",
      "faraway",
      "glmnet",
      "plotly",
      "psych",
      "rattle",
      "reshape2",
      "rgl",
      "rpart",
      "rpart.plot",
      "scatterplot3d"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"DSPA2: Data Science and Predictive Analytics (UMich HS650)\"\nsubtitle: \"<h2><u>Linear Algebra, Matrix Computing &amp; Regression</u></h2>\"\nauthor: \"<h3>SOCR/MIDAS (Ivo Dinov)</h3>\"\ndate: \"`r format(Sys.time(), '%B %Y')`\"\ntags: [DSPA, SOCR, MIDAS, Big Data, Predictive Analytics] \noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: SOCR_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n      smooth_scroll: true\n    code_folding: show\nIn this chapter we present the fundamental linear algebra concepts underpinning many modern matrix computing operations, vector-based operations, linear modeling techniques, eigenspectra decompositions, multivariate linear regression modeling, ordinary least squares estimation, machine learning and artificial intelligence algorithms. We will demonstrate these techniques using simulated data and real observed data of baseball players and clinical heart attack patients.\n\nSome students and readers may find it useful to first review some of the [fundamental mathematical representations, analytical modeling techniques, and basic concepts](https://socr.umich.edu/BPAD/BPAD_notes/Biophysics430_Chap01_MathFoundations.html). These foundations play critical roles in all subsequent chapters and sections. Examples of core mathematical principles include calculus of differentiation and integration; representation of scalars, vectors, matrices, and tensors; displacement, velocity, and acceleration; polynomials, exponents, and logarithmic functions; Taylorâ€™s series; complex numbers; ordinary and partial differential equations; probability and statistics; statistical moments; and probability distributions.",
      "word_count": 191
    },
    {
      "title": "Linear Algebra",
      "content": "*Linear algebra* is a branch of mathematics that studies linear associations using vectors, vector-spaces, linear equations, linear  transformations and matrices. Although it is generally challenging to visualize complex data, e.g., large vectors, tensors, and tables in n-dimensional Euclidean spaces ($n\\ge 3$), linear algebra allows us to represent, model, synthesize and summarize such complex data.\n\nVirtually all natural processes permit first-order linear approximations. This is useful because linear equations are easy (to write, interpret, solve) and these first order approximations may be useful to practically assess the process, determine general trends, identify potential patterns, and suggest associations in the data.\n\nLinear equations represent the simplest type of models for many processes. Higher order models may include additional nonlinear terms, e.g., [Taylor-series expansion](https://en.wikipedia.org/wiki/Taylor_series). Linear algebra provides the foundation for linear representation, analytics, solutions, inference and visualization of first-order affine models. Linear algebra is a small part of the larger mathematics *functional analysis* field, which is actually the infinite-dimensional version of linear algebra.\n\nSpecifically, *linear algebra* allows us to **computationally** manipulate, model, solve, and interpret complex systems of equations representing large numbers of dimensions/variables. Arbitrarily large problems can be mathematically transformed into simple matrix equations of the form $A x = b$ or $A x = \\lambda x$.\n\nIn this chapter, we review the fundamentals of linear algebra, matrix manipulation and their applications to representation, modeling, and analysis of real data. Specifically, we will cover (1) construction of matrices and matrix operations, (2) general matrix algebra notations, (3) eigenvalues and eigenvectors of linear operators, (4) least squares estimation, and (5) linear regression and variance-covariance matrices.\n\n## Building Matrices\n\nThe easiest way to create a matrix in `R` is by using the `matrix()` or `array()` functions, which allow splicing a long vector into a matrix or a tensor of certain size. \n\n\nThe function `diag()` is very useful. When the object is a vector, it creates a diagonal matrix with the vector in the principal diagonal.\n\n\nWhen the object is a matrix, `diag()` returns its principal diagonal.\n\n\nWhen the object is a scalar, `diag(k)` returns a $k\\times k$ identity matrix.\n\n\nThe functions `cbind()` and `rbind()` are also useful for building matrices from vectors by column or row concatenation.\n\n\nNote that `m5` has a row name `r1` in the *4*th row. We remove row/column names by naming them as `NULL`. \n\n\n## Matrix subscripts\n\nEach element in a matrix has a location indexed by the corresponding row and column. `A[i, j]` stores the element in the *i*th row and *j*th column in the matrix `A`. We can also access some specific rows or columns using matrix subscripts.\n\n\nThe ordinal scalar operations addition, subtraction, multiplication and division can be generalized as matrix operations.\n\n## Addition and subtraction\n\nMatrix addition and subtraction require matrices of the same dimensions. The sum or difference of two matrices are matrices containing elements representing the scalar sum or difference, respectively, of the values in corresponding positions in the two matrices.\n\n\n\n## Multiplication\n\nElement-wise matrix multiplication is valid for matrices of the same sizes. However, *matrix multiplication* is different from component-wise scalar multiplication, and requires a special match between the dimensions of the multiplied matrices, $P_{m\\times k}=L_{m\\times n} \\cdot R_{n\\times k}$. That is, the number of *columns* in the left matrix, $L$,, must equal to the number of *rows* of the right matrix, $R$. Then, the $row\\times column$ matrix multiplication rule yields a product matrix of dimensions corresponding to the number of rows ($m$) of $L$ and the number of columns ($k$) of $R$, i.e.,  $P_{m\\times k}$.\n\n### Element-wise multiplication\n\n*Element-wise matrix multiplication* ($*$) involves scalar products of the elements in the same positions.\n\n\n### Matrix multiplication (Product)\n\nMatrix product ($\\%*\\%$) generates an output matrix having the same number of rows as the left matrix and the same number of columns as the right matrix.\n\n\nThe product of multiplying two matrices $m^8_{2\\times 3}$ * $m^9_{3\\times 2}$ is another matrix $M_{2\\times 2}$ of dimensions $2\\times 2$.\n\nThe process of multiplying two vectors is called **outer product**. Assume we have two vectors $u$ and $v$. Using matrix multiplication, their outer product is the same as $u\\ \\underbrace{\\% * \\%}_{product}\\ \\overbrace{t(v)}^{transpose}$ or mathematically $uv^t$. In `R` the vector outer product operator is `%o%`, which generates second order tensors (matrices). \n\n\nWhat are the differences between $u \\%*\\% v$, $u \\%*\\% t(v)$, $u * t(v)$, and $u * v$?\n\n### Matrix Inversion (Division)\n\nElement-wise matrix (or scalar) division is well defined for matrices of the same dimensions.\n\n\nHowever, matrix inversion is different. Recall that the *transpose* of a matrix is a matrix with swapped columns and rows. In `R`, matrix transposition is done by the function `t()`.\n\n\nNotice that the $[1, 2]$ element in `m8[1, 2]` is the same as the $[2, 1]$ element in `t(m8)[2, 1]`.\n\nThe *right inverse* of a matrix, ($A^{-1}_{m\\times n}$), is a special matrix with the property that multiplying the original matrix ($A_{n\\times m}$) on the *right* by this inverse  ($A^{-1}$) yields the identity matrix, which has $1$'s on the main diagonal and $0$'s off the diagonal. That is,\n\n$$A_{n\\times m}\\ A^{-1}_{m\\times n} = I_{n\\times n}.$$\nSimilarly, a *left matrix inverse* is defined as a matrix, ($A^{-1}_{m\\times n}$), with the property that multiplying the original matrix ($A_{n\\times m}$) on the *left * by this inverse  ($A^{-1}$) yields the identity matrix.\n\n$$ A^{-1}_{m\\times n}\\ A_{n\\times m} = I_{m\\times m}.$$\n\nA *matrix inverse* is only defined for square matrices, $m=n$.\n\nGiven four numbers satisfying $ad-bc \\not= 0$, the following $2\\times 2$ matrix.\n\n$$A_{2\\times 2}=\\left(\\begin{array}{cc} \na & b \\\\\nc & d\n\\end{array}\\right) ,$$\n\nhas an inverse matrix given by\n\n$$A^{-1}_{2\\times 2} =\\frac{1}{ad-bc}\\left(\\begin{array}{cc} \nd & -b \\\\\n-c & a\n\\end{array}\\right) .$$\n\nIt's easy to validate that $A_{2\\times 2} A^{-1}_{2\\times 2} =I_{2\\times 2}$.\n\nIn higher dimensions, the [Cramer's rule](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution) may be used to compute the matrix inverse. Matrix inversion is available in `R` via the `solve()` function.\n\n\nNote that only special matrices are invertible, not all.  These matrices are *square* (have the same number of rows and columns) and non-singular.\n\nAnother function that can help us to get the inverse of a matrix is the `ginv()` function in the `MASS` package. This function gives us the Moore-Penrose Generalized Inverse of a matrix.\n\n\nIn addition, the function `solve()` can be used to solve matrix equations. For instance, `solve(A, b)` returns a vector $x$ satisfying the equation $b = Ax$, i.e., $x= A^{-1}b$.\n\n\nThe following table summarizes some of the basic matrix operation functions.",
      "word_count": 1065
    },
    {
      "title": "Matrix Computing",
      "content": "Let's look at the basics of matrix notation and matrix algebra.  The product $AB$ between matrices $A$ and $B$ is defined only if the number of columns in $A$ equals the number of rows in $B$. That is, we can multiply an $m\\times n$ matrix $A$ by an $n\\times k$ matrix $B$ and the result will be $AB_{m\\times k}$ matrix. Each element of the product matrix, $(AB_{i, j})$, represents the product of the $i$-th row in $A$ and the $j$-th column in $B$, which are of the same size $n$. Matrix multiplication is `row-by-column`.\n\nLinear algebra notation simplifies the mathematical descriptions and manipulations of linear models, as well as coding in `R`.\n\nThe main point is to show how we can write *linear models* using matrix notation. Later, we'll explain how this is useful for solving the *least squares problems*. \n\n## Solving Systems of Equations\n\nLinear algebra notation enables the mathematical analysis and derivation of solutions of systems of linear equations and provides a generic machinery for solving linear problems. \n\n$$\\begin{align*}\na + b + 2c &= 6\\\\\n3a - 2b + c &= 2\\\\\n2a + b  - c &= 3\n\\end{align*} $$\n\n\n$$\\underbrace{\\begin{pmatrix}\n1&1&2\\\\\n3&-2&1\\\\\n2&1&-1\n\\end{pmatrix}}_{\\text{A}}\n\\underbrace{\\begin{pmatrix}\na\\\\\nb\\\\\nc\n\\end{pmatrix}}_{\\text{x}} =\n\\underbrace{\\begin{pmatrix}\n6\\\\\n2\\\\\n3\n\\end{pmatrix}}_{\\text{b}}$$\n\nThat is, $Ax = b$, which implies that:\n\n$$\\begin{pmatrix}\na\\\\\nb\\\\\nc\n\\end{pmatrix} =\n\\begin{pmatrix}\n1&1&2\\\\\n3&-2&1\\\\\n2&1&-1\n\\end{pmatrix}^{-1}\n\\begin{pmatrix}\n6\\\\\n2\\\\\n3\n\\end{pmatrix}$$\n\nIn other words, $A^{-1}A x ==x = A^{-1}b$.\n\nNotice that this approach parallels the strategy for solving of simple (univariate) linear equations like: \n$$\\underbrace{2}_{\\text{(design matrix) A }} \\overbrace{x}^{\\text{unknown x }} \\underbrace{-3}_{\\text{simple constant term}} = \\overbrace{5}^{\\text{b}}.$$\n\nThe constant term, $-3$, can be moved and integrated into the right-hand-side, $b$, to form a new term $b'=5+3=8$. Thus, the shifting factor is mostly ignored in linear models, or linear equations, which simplifies the linear matrix equation to:\n$$\\underbrace{2}_{\\text{(design matrix) A }} \\overbrace{x}^{\\text{unknown x }}  = \\underbrace{5+3}_{b'}=\\overbrace{8}^{b'}.$$\n\nThis (simple) linear equation is solved by multiplying both hand sides by the inverse (reciprocal) of the $x$ multiplier, $2$.\n\n$$\\frac{1}{2} 2 x  = \\frac{1}{2} 8.$$\nThus, the unique solution is:\n$$x  = \\frac{1}{2} 8=4.$$\n\nSo, let's use exactly the same strategy to solve the corresponding *matrix equation* (linear equation, $Ax = b$) using `R`, where the *unknown* is $x$, and the *design matrix* $A$ and the *constant* vector $b$ are known.\n\n$$\\underbrace{\\begin{pmatrix}\n1&1&2\\\\\n3&-2&1\\\\\n2&1&-1\n\\end{pmatrix}}_{\\text{A}}\n\\underbrace{\\begin{pmatrix}\na\\\\\nb\\\\\nc\n\\end{pmatrix}}_{\\text{x}} =\n\\underbrace{\\begin{pmatrix}\n6\\\\\n2\\\\\n3\n\\end{pmatrix}}_{\\text{b}}.$$\n\n\n\nHow about if we want to triple-check the consistency of the `solve()` method to provide accurate solutions to matrix-based systems of linear equations?\n\nWe can generate the solution ($x$) to the equation $Ax=b$ by using first principles.\n$$ x = A^{-1}b.$$\n\n\n## The identity matrix\n\nThe *identity matrix* is the matrix analog to the multiplicative numeric identity, the number $1$. Multiplying the identity matrix by any other matrix ($B$) does not change the matrix $B$. This property requires that the *multiplicative identity matrix* must look like this.\n\n$$\\mathbf{I} = \\begin{pmatrix} 1&0&0&\\dots&0&0\\\\\n0&1&0&\\dots&0&0\\\\\n0&0&1&\\dots&0&0\\\\\n\\vdots &\\vdots & \\vdots & \\ddots&\\vdots&\\vdots\\\\\n0&0&0&\\dots&1&0\\\\\n0&0&0&\\dots&0&1 \\end{pmatrix}.$$\n\nThe identity matrix is always a square matrix with diagonal elements $1$ and $0$ at the off-diagonal elements.\n\nFollowing the above matrix multiplication rules, we can see that:\n\n$$\\mathbf{X\\times I} = \\begin{pmatrix} x_{1, 1} & \\dots & x_{1, p}\\\\\n& \\vdots & \\\\ x_{n, 1} & \\dots & x_{n, p} \\end{pmatrix} \n\\begin{pmatrix} 1&0&0&\\dots&0&0\\\\\n0&1&0&\\dots&0&0\\\\\n0&0&1&\\dots&0&0\\\\\n & & &\\vdots & &\\\\\n 0&0&0&\\dots&1&0\\\\\n0&0&0&\\dots&0&1\n\\end{pmatrix}=$$\n\n$$\\begin{pmatrix} x_{1, 1} & \\dots & x_{1, p}\\\\ & \\vdots & \\\\ x_{n, 1} & \\dots & x_{n, p} \\end{pmatrix}= \\mathbf{X}.$$\n\nIn `R`, we can express the identity matrix as follows.\n\n\n## Vectors, Matrices, and Scalars\n\nLet's look at this notation deeper using the [Baseball players data](https://wiki.socr.umich.edu/index.php/SOCR_Data_MLB_HeightsWeights) containing three quantitative variables, `Heights`, `Weight`, and `Age`. Suppose the variable `Weight` is considered as a random `response` (outcome vector) denoted by $Y_1, Y_2, \\dots, Y_n$.\n\nWe can express each player's `Weight` as a function of `Age` and `Height`. \n\n\nIn matrix form, we can express the outcome using one symbol, $\\mathbf{Y}$. We usually use **bold face** to distinguish between scalars, vectors, matrices and tensors.\n\n$$\\mathbf{Y} = \n\\begin{pmatrix}\nY_1\\\\\nY_2\\\\\n\\vdots\\\\\nY_n\n\\end{pmatrix}.$$\n\nIn `R`, the default representation of vector data is as *columns*, i.e., our outcome vector dimension is $n\\times 1$, as opposed to $1 \\times n$ used for row vectors (e.g., $\\mathbf{Y}^t$).\n\nSimilarly, we can use matrix notation to represent the covariates, or predictors, `Age` and `Height`. In a case with two predictors, we can represent them like this:\n\n$$\\mathbf{X}_1 = \\begin{pmatrix}\nx_{1, 1}\\\\\n\\vdots\\\\\nx_{n, 1}\n\\end{pmatrix} \\mbox{ and }\n\\mathbf{X}_2 = \\begin{pmatrix}\nx_{1, 2}\\\\\n\\vdots\\\\\nx_{n, 2}\n\\end{pmatrix}.$$\n\nIn the that for the Baseball players study, $x_{1, 1}= Age_1$ and $x_{i, 1}=Age_i$ with $Age_i$ representing the `Age` of the $i$-th player, and similarly, $x_{i, 2}= Height_i$ is the height of the $i$-th player. These vectors can be thought of as $n\\times 1$ matrices. For instance, it is convenient to represent the covariates as *design matrices*.\n\n$$\\mathbf{X} = [ \\mathbf{X}_1 \\mathbf{X}_2 ] = \\begin{pmatrix}\nx_{1, 1}&x_{1, 2}\\\\\n\\vdots\\\\\nx_{n, 1}&x_{n, 2}\n\\end{pmatrix}. $$\n\nThis design matrix has dimension $n \\times 2$.\n\n\n\nWe can also use this notation to denote an arbitrary number ($k$) of covariates with the following $n\\times k$ matrix.\n\n$$\\mathbf{X} = \\begin{pmatrix}\n  x_{1, 1}&\\dots & x_{1, k} \\\\\n  x_{2, 1}&\\dots & x_{2, k} \\\\\n   & \\vdots & \\\\\n  x_{n, 1}&\\dots & x_{n, k} \n  \\end{pmatrix}. $$\n\nYou can simulate such a design matrix in `R` using `matrix()`, instead of `cbind`.\n\n\nBy default,  matrices are filled *column-by-column order*, however using the `byrow=TRUE` argument allows us to change the order to *row-by-row.*\n\n\n*Scalars* are just one-dimensional values, typically numbers, that are different from their higher-dimensional counterparts, vectors, matrices, and tensors, which are usually denoted by  bold characters. \n\n## Sample Statistics\n\nTo compute the sample *average* and *variance* of a dataset, we use the formulas:\n$$\\bar{Y}=\\frac{1}{n} \\sum_{i=1}^n {Y_i}$$ \n\nand \n\n$$\\mbox{var}(Y)=\\frac{1}{n-1} \\sum_{i=1}^n {(Y_i - \\bar{Y})}^2, $$\nwhich can be represented as matrix multiplications. \n\nDefine an $n \\times 1$ matrix made of $1$'s.\n\n$$A=\\begin{pmatrix}\n1\\\\\n1\\\\\n\\vdots\\\\\n1\n\\end{pmatrix}.$$\n\nThis implies that.\n\n$$\\frac{1}{n}\n\\mathbf{A}^\\top Y = \\frac{1}{n}\n\\begin{pmatrix}1&1& \\dots&1\\end{pmatrix}\n\\begin{pmatrix}\nY_1\\\\\nY_2\\\\\n\\vdots\\\\\nY_n\n\\end{pmatrix}=\n\\frac{1}{n} \\sum_{i=1}^n {Y_i}= \\bar{Y}.$$\n\nRecall that we multiply matrices and scalars, like $\\frac{1}{n}$, by `*`, whereas we multiply matrices using the matrix product operator, `%*%`.\n\n\nMultiplying the transpose of a matrix with another matrix is very common in linear modeling and statistical computing, so there is an appropriate function in `R`, `crossprod()`.\n\n\nThere is a similar matrix algebra for computing the variance.\n\n$$\\mathbf{Y'}\\equiv \\begin{pmatrix}\nY_1 - \\bar{Y}\\\\\n\\vdots\\\\\nY_n - \\bar{Y}\n\\end{pmatrix}, \\, \\, \n\\frac{1}{n-1} \\mathbf{Y'}^\\top\\mathbf{Y'} = \n\\frac{1}{n-1}\\sum_{i=1}^n (Y_i - \\bar{Y})^2. $$\n\nA `crossprod` with only one matrix computes $Y^\\top Y$.\n\n\n\n## Applications of Matrix Algebra in Linear Modeling\n\nLet's use the following pair of matrices.\n \n$$\\overbrace{\\mathbf{Y}}^{outcome} = \\begin{pmatrix}\nY_1\\\\\nY_2\\\\\n\\vdots\\\\\nY_n\n\\end{pmatrix}\n, \n\\underbrace{\\mathbf{X}}_{design} = \\begin{pmatrix}\n1&x_1\\\\\n1&x_2\\\\\n\\vdots\\\\\n1&x_n\n\\end{pmatrix}\n, \n\\overbrace{\\mathbf{\\beta}}^{effects} = \\begin{pmatrix}\n\\beta_0\\\\\n\\beta_1\n\\end{pmatrix} \\mbox{ and   }\n\\underbrace{\\mathbf{\\varepsilon}}_{error} = \\begin{pmatrix}\n\\varepsilon_1\\\\\n\\varepsilon_2\\\\\n\\vdots\\\\\n\\varepsilon_n\n\\end{pmatrix}.$$\n\nThen, we can express the problem as a linear model.\n\n$$Y_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i, i=1, \\dots, n$$\n\nWe can also express the complete problem formulation into a corresponding succinct matrix notation formula.\n\n$$\\begin{pmatrix}\nY_1\\\\\nY_2\\\\\n\\vdots\\\\\nY_n\n\\end{pmatrix} = \n\\begin{pmatrix}\n1&x_1\\\\\n1&x_2\\\\\n\\vdots\\\\\n1&x_n\n\\end{pmatrix}\n\\begin{pmatrix}\n\\beta_0\\\\\n\\beta_1\n\\end{pmatrix} +\n\\begin{pmatrix}\n\\varepsilon_1\\\\\n\\varepsilon_2\\\\\n\\vdots\\\\\n\\varepsilon_n\n\\end{pmatrix}. $$\n\nAnd in its matrix form.\n\n$$\\mathbf{Y}=\\mathbf{X}\\boldsymbol{\\beta}+\\boldsymbol{\\varepsilon},$$\n\nwhich is a  simpler way to write the same model equation. \n\nOne way to obtain an *optimal solution* is by minimizing all residuals ($\\epsilon_i$). This *high-fidelity* criterion indicates a good model fit. The *least squares (LS) solution* represents one way to solve this matrix equation ($Y=X\\beta+\\epsilon$). The LS solution is obtained by minimizing the *residual sum square error* \n$$\\langle\\epsilon^t, \\epsilon \\rangle = (Y-X\\beta)^t \\times (Y-X\\beta).$$ \n\nLet's define the LS objective function using the cross-product notation.\n\n$$f(\\beta) = (\\mathbf{Y}-\\mathbf{X}\\boldsymbol{\\beta})^t\n(\\mathbf{Y}-\\mathbf{X}\\boldsymbol{\\beta}). $$\n\nWe can determine the *effect size estimates*, ${\\hat {\\beta}}$, are obtained by minimizing this expression. Of course, we can derive an analytic solution using calculus to find the minimum of the cost (objective) function, $f(\\beta)$. \n\n## Finding function extrema (min/max) using calculus\n\nThere are a number of rules that help with solving partial derivative equations in matrix form. recall that the *critical points* of the objective functions are either at the domain border or at values where the derivative of a objective function is trivial, $f'(x)=0$. hence, solving for the unknown parameter $\\beta$ requires identifying the critical points, ${\\hat {\\beta}}$, which will represent candidate solution(s). The derivative of the above equation is\n\n$$2 \\mathbf{X}^t (\\mathbf{Y} - \\mathbf{X} \\boldsymbol{\\hat{\\beta}})=0,$$\n\n$$\\mathbf{X}^t \\mathbf{X} \\boldsymbol{\\hat{\\beta}} = \\mathbf{X}^t \\mathbf{Y},$$\n\n$$\\boldsymbol{\\hat{\\beta}} = (\\mathbf{X}^t \\mathbf{X})^{-1} \\mathbf{X}^t \\mathbf{Y}.$$\n\nThis estimate ${\\hat {\\beta}}$ represents the desired LS solution to the linear modeling problem. The hat notation, ${\\hat {\\cdot}}$, is used to denote *estimates.* For instance, the solution for the unknown $\\beta$ parameters is denoted by the (data-driven) estimate $\\hat{\\beta}$.\n\nThe least squares minimization works because minimizing a function corresponds to finding the roots of its (first) derivative. With ordinary least squares (OLS), we square the residuals.\n\n$$(\\mathbf{Y}-\\mathbf{X}\\boldsymbol{\\beta})^t\n(\\mathbf{Y}-\\mathbf{X}\\boldsymbol{\\beta}).$$ \n\nNotice that the minimum of $f(x)$ and $f^2(x)$ are achieved at the same roots of $f'(x)$, as the derivative of $f^2(x)$ is $\\frac{d}{dx}f^2(x) = 2f(x)f'(x)$. \n\nHere is how we obtain the Least Square estimation in `R`.\n\n\nNow we can see the results of this by computing the estimated $\\hat{\\beta}_0+\\hat{\\beta}_1 x$ (fitted model prediction) corresponding to any covariate input value of $x$.\n\n\nThe closed-form analytical expression for the LS estimate\n$$\\hat{\\boldsymbol{\\beta}}=(\\mathbf{X}^t \\mathbf{X})^{-1} \\mathbf{X}^t \\mathbf{Y}$$\nis one of the most widely used results in data analysis. One of the advantages of this approach is that we can use it in many different situations. \n\n## Linear modeling in `R` \n\nIn `R`, there is a very convenient function `lm()` that fits these linear models. We will learn more about this function later, but here is a demonstration that it agrees with a simple manual LS estimation approach we showed above.\n\n\n## Eigenspectra - Eigenvalues and Eigenvectors\n\nStarting in the 18th century, the work of Euler's on rotational motion and later Lagrange on the study of inertia matrices, the notions of principal axes (*eigenvectors*) and characteristic roots (*eigenvectors*) arose. However, it took close to 200 years until Hilbert and others working on integral operators settled on using the terminology **eigen**, \"own\", to denote eigenvalues (proper characteristic values) and eigenvectors (principal axes).\n\nThe *eigen-spectrum* (eigenspace) decomposition of linear operators (matrices) into *eigenvalues* and *eigenvectors* enables us to understand linear transformations and characterize their properties. The eigenvectors represent the \"axes\" (directions) along which a linear transformation acts by *stretching*, *compressing*, or *flipping*. \n\nThe eigenvalues represent the amounts of this linear transformation into the specified eigen-vector direction. In higher dimensions, there are more directions along which we need to understand the behavior of the linear transformation. The eigen-spectrum makes it easier to understand the linear transformation especially when many (all?) of the eigenvectors are linearly independent (orthogonal).\n\nFor a given matrix $A$, if we have $A\\vec{v}=\\lambda \\vec{v}$, then we say that a nonzero vector $\\vec{v}$ is a right eigenvector of the matrix $A$ and the scale factor $\\lambda$ is the eigenvalue corresponding to that eigenvector.\n\nWith some calculations we can show that $A\\vec{v}=\\lambda \\vec{v}$ is the same as $(\\lambda I_n-A)\\vec{v}=\\vec{0}$, where $I_n$ is the $n\\times n$ identity matrix. So, when we solve this equation, we get the corresponding eigenvalues and eigenvectors. As this is a very common operation, we don't need to do that by hand - the method `eigen()` provides this functionality.\n\n\nWe can easily validate that $(\\lambda I_n-A)\\vec{v}=\\vec{0}$.\n\n\nAs we mentioned earlier, `diag(n)` creates a $n\\times n$  identity matrix. Thus, `diag(2)` is the $I_2$ matrix in the above equation. The zero output matrix proves that the equation $(\\lambda I_n-A)\\vec{v}=\\vec{0}$ holds true.\n\nMany interesting [applications of the eigen-spectrum are shown here](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Applications).\n\n## Other commonly used matrix computing functions\n\nOther important functions about matrix operation are listed in the following table.\n\n## Matrix notation\n\nSome flexible matrix operations can help us save time calculating row or column averages. For example, *column averages* can be calculated by the following matrix operation.\n\n$$AX = \\left(\\begin{array}{cccc} \n\\frac{1}{N}&\\frac{1}{N}&\\cdots&\\frac{1}{N}\n\\end{array}\\right)\n\\left(\\begin{array}{cccc} \nX_{1, 1}&\\cdots&X_{1, p}\\\\\nX_{2, 1}&\\cdots&X_{2, p}\\\\\n\\vdots&\\vdots&\\vdots\\\\\nX_{N, 1}&\\cdots&X_{N, p}\n\\end{array}\\right)=\n\\left(\\begin{array}{cccc} \n\\bar{X}_1&\\bar{X}_2&\\cdots &\\bar{X}_N\n\\end{array}\\right).$$\n\nThe *row averages* can be calculated similarly.\n\n$$XB = \\left(\\begin{array}{cccc} \nX_{1, 1}&\\cdots &X_{1, p}\\\\\nX_{2, 1}&\\cdots &X_{2, p}\\\\\n\\vdots &\\vdots &\\vdots \\\\\nX_{N, 1}&\\cdots&X_{N, p}\n\\end{array}\\right)\n\\left(\\begin{array}{c} \n\\frac{1}{p}\\\\\n\\frac{1}{p}\\\\\n\\vdots\\\\\n\\frac{1}{p}\n\\end{array}\\right)=\n\\left(\\begin{array}{c} \n\\bar{X}_1\\\\\n\\bar{X}_2\\\\\n\\vdots\\\\\n\\bar{X}_q\n\\end{array}\\right). $$\n\nExpeditious matrix calculations can be done by multiplying a matrix on the left or at the right by another matrix. In general multiplying by a vector on the left can amounts to *weight averaging*.\n\n$$AX = \\left(\\begin{array}{cccc} \na_1&a_2&\\cdots &a_N\n\\end{array}\\right)\n\\left(\\begin{array}{cccc} \nX_{1, 1}&\\cdots &X_{1, p}\\\\\nX_{2, 1}&\\cdots &X_{2, p}\\\\\n\\vdots&\\vdots &\\vdots \\\\\nX_{N, 1}&\\cdots &X_{N, p}\n\\end{array}\\right)=\n\\left(\\begin{array}{cccc} \n\\sum_{i=1}^N a_i \\bar{X}_{i, 1}&\\sum_{i=1}^N a_i \\bar{X}_{i, 2}&\\cdots &\\sum_{i=1}^N a_i \\bar{X}_{i, N}\n\\end{array}\\right). $$\n\nNow let's try this matrix notation to look at genetic expression data including $8,793$ different genes for $208$ subjects. These gene expression data represents a microarray experiment - GSE5859 - comparing [Gene Expression Profiles from Lymphoblastoid cells](http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE5859). Specifically, the data compares the expression level of genes in lymphoblasts from individuals in three HapMap populations {*CEU*, *CHB*, *JPT*}. The study found that the mean expression levels between the {CEU} and {CHB+JPT} samples were significantly different ($p < 0.05$) for more than a thousand genes.\n\nThe [gene expression profiles data](https://umich.instructure.com/courses/38100/files/folder/Case_Studies/CaseStudy16_GeneExpression_GSE5859) has two components:\n\n - The [gene expression intensities](https://umich.instructure.com/files/2001417/download?download_frd=1) (*exprs_GSE5859.csv*): rows represent features on the microarray (e.g., genes), and columns represent different microarray samples, and \n - [Meta-data about each of the samples](https://umich.instructure.com/files/2001418/download?download_frd=1) (*exprs_MetaData_GSE5859.csv*) rows represent samples and\tcolumns represent meta-data (e.g., sex, age, treatment status, the date of the sample processing).\n\n\nRecall that the `lapply()` function that we talked about in [Chapter 2](https://socr.umich.edu/DSPA2/DSPA2_notes/02_Visualization.html) and the `sapply()` function can be used to calculate column and row averages. Let's compare the outputs of `sapply` and the corresponding matrix algebra process.\n\n\nThe same outputs are generated by both protocols. Note that we uses `rep(1/nrow(gene1), nrow(gene1))` to create the vector\n\n$$\\left(\\begin{array}{cccc} \n\\frac{1}{N}&\\frac{1}{N}&\\cdots &\\frac{1}{N}\n\\end{array}\\right). $$\n\nneeded to obtain manually the column averages by matrix algebra. Similarly, we can compute the column means.\n\n\nThe histogram shows that the distribution is symmetric, unimodal and bell-shaped, i.e., roughly normal.\n\nWe can also solve harder problems using matrix algebra. For example, let's calculate the differences between genders for each gene. First, we need to get the gender information for each subject. \n\n\nThen, we have to reorder the columns to make it consistent with the feature matrix `gene1`.\n\n\nNext, we are going to design the matrix. We want to multiply it with the feature matrix. The plan is to multiply the following two matrices.\n\n$$\\left(\\begin{array}{cccc} \nX_{1, 1}&\\cdots&X_{1, p}\\\\\nX_{2, 1}&\\cdots&X_{2, p}\\\\\n\\vdots & \\vdots &\\vdots \\\\\nX_{N, 1}&\\cdots&X_{N, p}\n\\end{array}\\right)\n\\left(\\begin{array}{cc} \n\\frac{1}{p}&a_1\\\\\n\\frac{1}{p}&a_2\\\\\n\\vdots & \\vdots \\\\\n\\frac{1}{p}&a_p\n\\end{array}\\right)=\n\\left(\\begin{array}{cc} \n\\bar{X}_1&gender.diff_1\\\\\n\\bar{X}_2&gender.diff_2\\\\\n\\vdots & \\vdots \\\\\n\\bar{X}_N&gender.diff_N\n\\end{array}\\right),$$\nwhere $a_i=-\\frac{1}{N_F}$ if the subject is *female* and $a_i=\\frac{1}{N_M}$ if the subject is *male.* Thus, we gave each female and male the same weight before the subtraction. We average each gender and get their difference. $\\bar{X}_i$ is the average across both genders and $gender.diff_i$ represents the gender difference for the *i*-th gene.",
      "word_count": 2528
    },
    {
      "title": "Linear regression",
      "content": "As we mentioned earlier, the formula for linear regression can be written as\n\n$$Y_i=\\beta_0+X_{i, 1}\\beta_1+\\cdots+X_{i, p}\\beta_p +\\epsilon_i, i=1, \\cdots, N$$\nThis formula can also be expressed in matrix form.\n\n$$\\left(\\begin{array}{c} \nY_1\\\\\nY_2\\\\\n\\vdots\\\\\nY_N\n\\end{array}\\right)=\n\\left(\\begin{array}{c} \n1\\\\\n1\\\\\n\\vdots\\\\\n1\n\\end{array}\\right)\\beta_0+\n\\left(\\begin{array}{c} \nX_{1, 1}\\\\\nX_{2, 1}\\\\\n\\vdots\\\\\nX_{N, 1}\n\\end{array}\\right)\\beta_1+\\cdots +\n\\left(\\begin{array}{c} \nX_{1, p}\\\\\nX_{2, p}\\\\\n\\vdots \\\\\nX_{N, p}\n\\end{array}\\right)\\beta_p+\n\\left(\\begin{array}{c} \n\\epsilon_1\\\\\n\\epsilon_2\\\\\n\\vdots \\\\\n\\epsilon_N\n\\end{array}\\right), $$\n\nwhich can be compressed into a simple matrix equation $Y=X\\beta +\\epsilon$.\n\n$$\\left(\\begin{array}{c} \nY_1\\\\\nY_2\\\\\n\\vdots \\\\\nY_N\n\\end{array}\\right)=\n\\left(\\begin{array}{cccc} \n1&X_{1, 1}&\\cdots&X_{1, p}\\\\\n1&X_{2, 1}&\\cdots&X_{2, p}\\\\\n\\vdots&\\vdots&\\vdots&\\vdots\\\\\n1&X_{N, 1}&\\cdots&X_{N, p}\n\\end{array}\\right)\n\\left(\\begin{array}{c} \n\\beta_o\\\\\n\\beta_1\\\\\n\\vdots\\\\\n\\beta_p\n\\end{array}\\right)+\n\\left(\\begin{array}{c} \n\\epsilon_1\\\\\n\\epsilon_2\\\\\n\\vdots\\\\\n\\epsilon_N\n\\end{array}\\right). $$\nAs $Y=X\\beta +\\epsilon$ implies that $X^tY \\sim X^t(X\\beta)=(X^tX)\\beta$, and thus, the LS solution for $\\beta$ is obtained by multiplying both hand sides by the inverse of the square cross product matrix $(X^tX)^{-1}$:\n$$\\hat{\\beta}=(X^tX)^{-1}X^tY.$$\n\nMatrix calculations are much faster, especially on specialized computer chips, than fitting a manual regression model. Let's apply this to the [Lahman baseball data](https://seanlahman.com/files/database/readme2014.txt) representing yearly stats and standings. Let's download it first via this link [baseball.data](https://umich.instructure.com/files/2018445/download?download_frd=1) and save it in the `R` working directory. We can use the `load()` function to import the local RData. For this example, we subset the dataset by `G==162` and `yearID < 2002`. Also, we create a new feature named `Singles` that is equal to `H(Hits by batters) - X2B(Doubles) - X3B(Tripples) - HR(Home Runs by batters)`. Finally, we only pick four features *R* (Runs scored), *Singles*, *HR* (Home Runs by batters), and *BB* (Walks by batters).\n\n\nIn this example, let's work with *R* as the response variable and *BB* as the independent variable. For a full linear model, we need to add another column of $1$'s to the design matrix $X$. \n\n\nWe use the LS analytical formula to obtain the beta (effects) estimates \n\n$$\\hat{\\beta}=(X^t X)^{-1}X^t Y.$$\n\n\nTo confirm this manual calculation, we can refit the linear equation using the `lm()` function, and compare the computational times. In this simple example, is there evidence of higher computational efficiency using matrix calculations?\n\n\nFor a better model, we can expand the covariates to include multiple predictors and compare the resulting estimates.\n\n\nA scatter plot would show visually the relationship between the outcome *R* and one of the predictors *BB*.\n\n\nHere the color model line represents our regression model estimated using matrix algebra.\n\nThe power of matrix algebra becomes more apparent when we use multiple variables. We can add the variable *HR* to the model.\n\n\n## Sample covariance matrix\n\nWe can also express the covariance matrix for our features using matrix operation. Suppose\n\n$$X_{N\\times K}=\\left(\\begin{array}{cccc} \nX_{1, 1}&\\cdots&X_{1, K}\\\\\nX_{2, 1}&\\cdots&X_{2, K}\\\\\n\\vdots&\\ddots&\\vdots\\\\\nX_{N, 1}&\\cdots&X_{N, K}\n\\end{array}\\right)\n=[X_1 \\ X_2\\ \\cdots\\ X_K]. $$\n\nThen the $K\\times K$ (square) covariance matrix is:\n$$\\Sigma_{K\\times K} = (\\Sigma_{i, j}),$$\nwhere $\\Sigma_{i, j}=Cov(X_i, X_j)=E\\left( (X_i-\\mu_i)(X_j-\\mu_j)\\right)$, $1\\leq i, j, \\leq K$. Note that earlier, we denoted the *number of variables* by $p$, whereas here we use $K$; this is to avoid potential confusion with probabilities, $p$.\n\nThe sample covariance matrix is:\n$$\\Sigma_{i, j}=\\frac{1}{N-1}\\sum_{m=1}^{N}\\left(  x_{m, i}-\\bar{x}_i \\right)  \\left( x_{m, j}-\\bar{x}_j \\right) , $$\n\nwhere \n$$\\bar{x}_{i}=\\frac{1}{N}\\sum_{m=1}^{N}x_{m, i}, \\quad i=1, \\cdots, K .$$  \n\nIn general, \n$$\\Sigma=\\frac{1}{n-1}(X-\\bar{X})^t(X-\\bar{X}).$$\n\nSuppose that we want to get the sample covariance matrix of the following $5\\times 3$ feature matrix $x$.\n\n\nNotice that this matrix represents the design matrix of $3$ features and $5$ observations. Let's compute the column means first.\n\n\nIn the covariance matrix, $S[i, i]$ is the variance of the *i*-th feature and $S[i, j]$ is the covariance of *i*-th and *j*-th features.\n\nCompare this to the automated calculation of the variance-covariance matrix.\n\n\n\n## Linear multivariate linear regression modeling\n\nLater, in [Chapter 5 (Supervised classification)](https://socr.umich.edu/DSPA2/DSPA2_notes/05_SupervisedClassification.html), we will cover some classification methods that use this mathematical framework for model-based and model-free ML/AI prediction. However, let's start with linear model-based statistical methods providing forecasting and classification functionality. Specifically, we will (1) demonstrate the predictive power of multivariate linear regression, (2) show the foundation of regression trees and model trees, and (3) examine two complementary case-studies (Baseball Players and Heart Attack).\n\nRegression represents a model of a relationship between a *dependent variable* (value to be predicted) and a group of *independent variables* (predictors or features). We assume the relationships between the outcome dependent variable and the independent variables is linear.\n\n## Simple linear regression\n\nEarlier, we discussed the straightforward case of regression as simple linear regression, which involves a single predictor\n$$y=a+bx.$$ \n\nIn this *slope-intercept* formula, `a` is the model *intercept* and `b` is the model *slope*. Thus, simple linear regression may be expressed as a bivariate equation. If we know `a` and `b`, for any given `x` we can estimate, or predict, `y` via the regression formula. If we plot `x` against `y` in a 2D coordinate system, where the two variables are exactly linearly related, the results will be a straight line.\n\nHowever, this is the ideal case. Bivariate scatterplots using real world data may show patterns that are not necessarily precisely linear, see [Chapter 2](https://socr.umich.edu/DSPA2/DSPA2_notes/02_Visualization.html). Let's look at a bivariate scatterplot and try to fit a simple linear regression line using two variables, e.g., `hospital charges` or `CHARGES` as a dependent variable, and `length of stay` in the hospital or `LOS` as an independent predictor. The data is available in the [DSPA Data folder](https://umich.instructure.com/courses/38100/files/folder/Case_Studies) as `CaseStudy12_AdultsHeartAttack_Data`. We can remove the pair of observations with missing values using the command `heart_attack<-heart_attack[complete.cases(heart_attack), ]`. \n\n\nAs expected, longer hospital stays are expected to be associated with higher medical costs, or hospital charges. The scatterplot shows dots for each pair of observed measurements ($x=LOS$ and $y=CHARGES$), and an increasing linear trend. \n\nThe estimated expression for this regression line is:\n$$\\hat{y}=4582.70+212.29\\times x$$\n\nor equivalently\n\n$$CHARGES=4582.70+212.29\\times LOS.$$\n\nOnce the linear model is fit, i.e., its coefficients are estimated, we can make predictions using this `explicit` regression model. Assume we have a patient that spent 10 days in hospital, then we have `LOS=10`. The predicted charge is likely to be $\\$ 4582.70 + \\$ 212.29 \\times 10= \\$ 6705.6$. Plugging `x` into the expression equation automatically gives us an estimated value of the outcome `y`. This [chapter of the Probability and statistics EBook provides an introduction to linear modeling](https://wiki.socr.umich.edu/index.php/EBook#Chapter_X:_Correlation_and_Regression).\n\n## Ordinary least squares estimation\n\nHow did we get the estimated expression? The most common estimating method in statistics is *ordinary least squares* (OLS). OLS estimators are obtained by minimizing the sum of the squared errors - that is the sum of squared vertical distance from each dot on the scatter plot to the regression line. \n\n\nOLS is minimizing the following expression:\n\n$$\\langle\\epsilon , \\epsilon\\rangle^2 \\equiv \\sum_{i=1}^{n}(y_i-\\hat{y}_i)^2=\\sum_{i=1}^{n}\\left (\\underbrace{y_i}_{\\text{observed outcome}}-\\underbrace{(a+b\\times x_i)}_{\\text{predicted outcome}}\\right )^2=\\sum_{i=1}^{n}\\underbrace{\\epsilon_i^2}_{\\text{squared residual}}.$$\n\nSome calculus-based calculations suggest that the value `b` minimizing the squared error is:\n\n$$b=\\frac{\\sum(x_i-\\bar x)(y_i-\\bar y)}{\\sum(x_i-\\bar x)^2}.$$\n\nThen, the corresponding constant term ($y$-intercept) `a` is\n\n$$a=\\bar y-b\\bar x.$$\n\nThese expressions would become apparent if you review the material in [Chapter 2](https://socr.umich.edu/DSPA2/DSPA2_notes/02_Visualization.html). Recall that the variance is obtained by averaging sums of squared deviations ($var(x)=\\frac{1}{n}\\sum^{n}_{i=1} (x_i-\\mu)^2$). When we use $\\bar{x}$ to estimate the mean of $x$, we have the following formula for variance: $var(x)=\\frac{1}{n-1}\\sum^{n}_{i=1} (x_i-\\bar{x})^2$. Note that this is $\\frac{1}{n-1}$ times the denominator of *b*. Similar to the variance, the covariance of *x* and *y* is measuring the average sum of the deviance of *x* times the deviance of *y*:\n\n$$Cov(x, y)=\\frac{1}{n}\\sum^{n}_{i=1} (x_i-\\mu_x)(y_i-\\mu_y).$$\n\nIf we utilize the sample averages ($\\bar{x}$, $\\bar{y}$) as estimates of the corresponding population means, we have:  \n\n$$Cov(x, y)=\\frac{1}{n-1}\\sum^{n}_{i=1} (x_i-\\bar{x})(y_i-\\bar{y}).$$\n\nThis is $\\frac{1}{n-1}$ times the numerator of *b*. Thus, combining the above 2 expressions, we get an estimate of the slope coefficient (effect-size of LOS on Charge) expressed as: \n\n$$b=\\frac{Cov(x, y)}{var(x)}.$$\n\nLet's use the [heart attack data](https://umich.instructure.com/courses/38100/files/folder/Case_Studies) to demonstrate these calculations.\n\n\nWe can see that this is exactly the same as the previously computed estimate of the constant intercept terms using `lm()`.\n\n## Regression Model Assumptions\n\nRegression modeling has five key assumptions:\n\n - Linear relationship between dependent outcome and the independent predictor(s),\n - [Multivariate normality](https://en.wikipedia.org/wiki/Multivariate_normal_distribution),\n - No or little [multicollinearity](https://en.wikipedia.org/wiki/Multicollinearity),\n - No auto-correlation, independence, \n - [Homoscedasticity](https://en.wikipedia.org/wiki/Homoscedasticity).\n\nIf these assumptions are violated, the model may provide invalid estimates and unreliable predictions.\n\n## Correlations\n\n*Note*: The [SOCR Interactive Scatterplot Game (requires Java enabled browser)](https://socr.umich.edu/html/gam/SOCR_Games.html) provides a dynamic interface demonstrating linear models, trends, correlations, slopes and residuals.\n\nBased on covariance we can calculate correlation, which indicates how closely the relationship between two variables follows a straight line.\n\n$$\\rho_{x, y}=Corr(x, y)=\\frac{Cov(x, y)}{\\sigma_x\\sigma_y}=\\frac{Cov(x, y)}{\\sqrt{Var(x)Var(y)}}.$$\n\nIn `R`, the correlation may be computed using the method `cor()` and the square root of the variance, or the standard deviation, is computed by `sd()`.\n\n\nSame outputs are obtained. This correlation is a positive number that is relatively small. We can say there is a weak positive linear association between these two variables. If we have a negative number then it is a negative linear association. We have a weak association when $0.1 \\leq Cor < 0.3$, a moderate association for $0.3 \\leq Cor < 0.5$, and a strong association for $0.5 \\leq Cor \\leq 1.0$. If the correlation is below $0.1$ then it suggests little to no linear relation between the variables.\n\n## Multiple Linear Regression\n\nIn practice, we usually have more situations with multiple predictors and one dependent variable, which may follow a multiple linear model.  That is:\n\n$$y=\\alpha+\\beta_1x_1+\\beta_2x_2+ \\cdots +\\beta_kx_k+\\epsilon,$$\n\nor equivalently\n\n$$y=\\beta_0+\\beta_1x_1+\\beta_2x_2+ \\cdots  +\\beta_kx_k+\\epsilon .$$\n\nWe usually use the second notation method in statistics. This equation shows the linear relationship between *k* predictors and a dependent variable. In total we have *k+1* coefficients to estimate.\n\nThe matrix notation for the above equation is\n\n$$Y=X\\beta+\\epsilon,$$\n\nwhere \n\n$$Y=\\left(\\begin{array}{c} \ny_1 \\\\\ny_2\\\\\n\\vdots \\\\\ny_n\n\\end{array}\\right),$$\n\n$$X=\\left(\\begin{array}{ccccc} \n1 & x_{11}&x_{21}&\\cdots&x_{k1} \\\\\n1 & x_{12}&x_{22}&\\cdots&x_{k2} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots\\\\\n1 & x_{1n}&x_{2n}&\\cdots&x_{kn} \n\\end{array}\\right) $$\n$$\\beta=\\left(\\begin{array}{c} \n\\beta_0 \\\\\n\\beta_1\\\\\n\\vdots\\\\\n\\beta_k\n\\end{array}\\right),$$\n\nand\n\n$$\\epsilon=\\left(\\begin{array}{c} \n\\epsilon_1 \\\\\n\\epsilon_2\\\\\n\\vdots \\\\\n\\epsilon_n\n\\end{array}\\right)$$ \nis the *error* term.\n\nSimilar to simple linear regression, our goal is to minimize the sum of squared errors. Solving the matrix equation for $\\beta$, we get the OLS solution for the parameter vector:\n\n$$\\hat{\\beta}=(X^tX)^{-1}X^tY .$$\n\nThe solution is presented in a matrix form, where $X^{-1}$ and $X^t$ are the *inverse* and the *transpose* matrices of the original design matrix $X$. This example demonstrates making *de novo* a simple regression (least squares estimating) function `reg()`.\n\n\nWe saw earlier that a clever use of matrix multiplication (`%*%`) and `solve()` can help with the explicit OLS solution.\n\nNext, we will apply our function `reg()` to the heart attack data. To begin with, let's check if the simple linear regression (`lm()`) output coincides with the results of our manual regression estimator, `reg()`.\n\n\nThe results of the official (`lm()`) and the manual (`reg()`) simple linear models agree and we can proceed with testing the multivariate  functionality using additional variables as predictors, e.g., just adding `age` as a second variable into the model. \n\n\nThe following sections provide additional examples of simple and multivariate regression, and [Chapter 9](https://socr.umich.edu/DSPA2/DSPA2_notes/11_FeatureSelection.html) will generalize the OLS regression modeling to regularized linear model estimation, which facilitates joint model fitting and feature selection.\n\n## Case Study 1: Baseball Players\n\n### Step 1 - collecting data\n\nIn this example, we will utilize the [MLB data (01a_data.txt)](https://umich.instructure.com/files/330381/download?download_frd=1). The data contains $1,034$ records of heights and weights for some recent Major League Baseball (MLB) Players. These data were obtained from different resources (e.g., IBM Many Eyes). \n\nVariables:\n\n - *Name*: MLB Player Name \n - *Team*: The Baseball team the player was a member of at the time the data was acquired\n - *Position*: Player field position\n - *Height*: Player height in inch \n - *Weight*: Player weight in pounds\n - *Age*: Player age at time of record.\n\n### Step 2 - exploring and preparing the data\n\nLet's first load this dataset using `as.is=T` to keep non-numerical vectors as characters. Also, we will delete the `Name` variable because we don't need the players' names in this case study. \n\n\nBy looking at the `str()` output we notice that the variables `TEAM`  and `Position` are misspecified as characters. To fix this we can use the function `as.factor()` to convert numeric or character vectors to factors.\n\n\nThe data is now ready to compute some summary statistics and generate simple plots.\n\n\nThe above plot illustrates our dependent variable `Weight`. As we saw in [Chapter 1](https://socr.umich.edu/DSPA2/DSPA2_notes/01_Introduction.html), this distribution appears a little right-skewed.\n\nDisplaying `pairs plots` provides a compact summary of different features in the data.\n\n\n\nLet's try to summarize certain candidate predictors.\n\n\nHere we have two *numerical predictors* and two *categorical predictors* for $1,034$ observations. Let's see how `R` treats these three different classes of variables.\n\n## Exploring relationships among features - the correlation matrix\n\nBefore fitting linear models, let's examine the independence of our potential predictors and the dependent variable. Multiple linear regressions assume that predictors are all independent with each other. Is this assumption valid? As we mentioned earlier, the correlation function, `cor()`, can help with this question in the case of linear pairwise dependencies for numerical variables.\n\n\nOf course, the correlation is symmetric, $cor(y, x)=cor(x, y)$ and $cov(x, x)=1$. Also, our `Height` variable is weakly (negatively) related to the players' age. The results look very good and do not suggest potential multicollinearity problems. If two of our predictors are highly correlated, they both provide similar information. Such multicollinearity may cause undue bias in the model and one common practice is to remove one of the highly correlated predictors prior to fitting the model.\n\nIn general multivariate regression analysis, we can use the `variance inflation factors (VIFs)` to detect potential multicollinearity between all covariates. The variance inflation factor quantifies the amount of artificial inflation of the variance due to observed multicollinearity in the covariates. The $VIF_l$'s represent the expected inflation of the corresponding estimated variances. In a simple linear regression model with a single predictor $x_l$, $y_i=\\beta_o + \\beta_1 x_{i,l}+\\epsilon_i,$ relative to the *baseline variance*, $\\sigma$, the *lower bound (min) of the variance* of the estimated effect-size, $\\beta_l$, is:\n\n$$Var(\\beta_l)_{min}=\\frac{\\sigma^2}{\\sum_{i=1}^n{\\left ( x_{i,l}-\\bar{x}_l\\right )^2}}.$$\n\nThis allows us to track the inflation of the $\\beta_l$ variance $\\left (Var(\\beta_l)\\right )$ in the presence of correlated predictors in the regression model. Suppose the linear model includes $k$ covariates with some of them being  multicollinear or correlated.\n\n$$y_i=\\beta_o+\\beta_1x_{i,1} + \\beta_2 x_{i,2} + \\cdots + \\underbrace{\\beta_l x_{i,l}}_{\\text{effect*feature}} + \\cdots + \\beta_k x_{i,k} +\\epsilon_i.$$\n\nAssume some of the predictors are correlated with the feature ${x_l}$, then the variance of its effect, $Var(\\beta_l)$, will be inflated as follows:\n\n$$Var(\\beta_l)=\\frac{\\sigma^2}{\\sum_{i=1}^n{\\left ( x_{i,l}-\\bar{x}_l\\right )^2}}\\times \\frac{1}{1-R_l^2},$$\n\nwhere $R_l^2$ is the $R^2$-value computed by regressing the $l^{th}$ feature on the remaining $(k-1)$ predictors. The stronger the *linear dependence* between the $l^{th}$ feature and the remaining predictors, the larger the corresponding $R_l^2$ value will be, the smaller the denominator in the inflation factor ($VIF_l$), and the larger the variance estimate of $\\beta_l$.\n\nThe *variance inflation factor* ($VIF_l$) is the ratio of the two variances - the variance of the effect (numerator) and the lower bound minimum variance of the effect (denominator).\n\n$$VIF_l=\\frac{Var(\\beta_l)}{Var(\\beta_l)_{min}}=\n\\frac{\\frac{\\sigma^2}{\\sum_{i=1}^n{\\left ( x_{i,l}-\\bar{x}_l\\right )^2}}\\times \\frac{1}{1-R_l^2}}{\\frac{\\sigma^2}{\\sum_{i=1}^n{\\left ( x_{i,l}-\\bar{x}_l\\right )^2}}}=\\frac{1}{1-R_l^2}.$$\n\nThe regression model's VIFs measure how much the variance of the estimated regression coefficients, $\\beta_l$, may be \"inflated\" by unavoidable presence of multicollinearity among the model predictor features. $VIF_l\\sim 1$ implies that there is no substantial multicollinearity involving the $l^{th}$ predictor and the remaining features, and hence, the variance estimate of $\\beta_l$ is not inflated. On the other hand, when $VIF_l > 4$, potential multicollinearity is likely, when $VIF_l> 10$, there may be serious multicollinearity in the data, which may require some model correction to account for variance estimates that may be significantly biased.\n\nWe can use the function `car::vif()` to compute and report the VIF factors.\n\n\n## Multicollinearity and feature-selection in high-dimensional data\n\nIn [Chapters 11 (Feature Selection)](https://socr.umich.edu/DSPA2/DSPA2_notes/11_FeatureSelection.html), we will discuss the methods and computational strategies to identify salient features in high-dimensional datasets. Let's briefly identify some practical approaches to address multicollinearity problems and tackle challenges related to large numbers of inter-dependencies in the data. Data that contains a large number of predictors is likely to include completely unrelated variables having high sample correlation. To see the nature of this problem, assume we are generating a random Gaussian $n\\times k$ matrix, $X=(X_1,X_2, \\cdots, X_k)$ of $k$ feature vectors, $X_i, 1\\leq i\\leq k$, using IID standard normal random samples. Then, the expected maximum correlation between any pair of columns, $\\rho(X_{i_1},X_{i_2})$, can be as large as $k\\gg n$. \n\nEven in this IID sampling problem, we still expect a high rate of intrinsic and strong feature correlations. In general, this phenomenon is amplified for high-dimensional observational data, which would be expected to have a high degree of collinearity. This problem presents a number of computational, model-fitting, model-interpretation, and selection of salient predictors challenges, e.g., function singularities and negative definite Hessian matrices.\n\nThere are some techniques that allow us to resolve such multicollinearity issues in high-dimensional data. Let's denote $n$ to be the number of cases (samples, subjects, units, etc.) and and $k$ be the number of features. Using a divide-and-conquer strategy, we can split the problem into two special cases:\n\n - When $n \\geq k$, we can use the VIF to solve the problem parametrically. \n - When $n \\ll k$, VIF does not apply and other creative approaches are necessary. In this case, examples of strategies that can be employed include:\n    + Use a [dimensionality-reduction (PCA, ICA, FA, SVD, PLSR, t-SNE)](https://socr.umich.edu/DSPA2/DSPA2_notes/04_DimensionalityReduction.html) to reduce the problem to $n \\geq k'$ (using only the top $k'$ bases, functions, or directions).\n    + Compute the (Spearman's rank-order based) pair correlation (matrix) and do [some kind of feature selection](https://socr.umich.edu/DSPA2/DSPA2_notes/11_FeatureSelection.html), e.g., choosing only features with lower paired-correlations.\n    + The [Sure Independence Screening (SIS) technique](https://orfe.princeton.edu/~jqfan/papers/06/SIS.pdf) is based on correlation learning utilizing the sample correlation between a response and a given predictor. SIS reduces the feature-dimension ($k$) to a moderate dimension $O(n)$.\n    + The basic SIS method estimates marginal linear correlations between predictor and responses, which can be done by fitting a simple linear model. [Non-parametric Independence Screening (NIS)](https://doi.org/10.1198/jasa.2011.tm09779) expands this model-based SIS strategy to use non-parametric models and allow more flexibility for the predictor ranking. Models' diagnostics for predictor-ranking may use the magnitude of the marginal  estimators,  non-parametric  marginal-correlations, or marginal residual sum of squares.\n    + [Generalized Correlation screening](https://doi.org/10.1198/jcgs.2009.08041) employs an empirical sample-driven estimate of a generalized correlation to rank the individual predictors. \n    + *Forward Regression* using best subset regression is computationally very expensive because of the large combinatorial space, as the utility of each predictor depends on many other predictors.  It generates a nested sequence of models, each having one additional predictor than the prior model.  The model expansion adds new variables to the model based on their effect to improve the model quality, e.g., the largest decrease of the regression sum of squares, compared to the prior model. \n    + [Model-Free Screening](https://dx.doi.org/10.1198%2Fjasa.2011.tm10563) strategy basically uses  empirical  estimates  for  conditional  densities  of  the  response  given the predictors.  Most methods have  [consistency  in  ranking  (CIR) property](https://dl.acm.org/doi/abs/10.5555/2999134.2999272), which ensures that the objective utility function ranks unimportant predictors lower than important predictors with high probability (as $p \\rightarrow 1$).\n\n## Visualizing relationships between features\n\nThere are many alternative ways to visualize correlations, e.g., `pairs()`, `ggpairs()`, or `plot_ly()`. \n\n\nSome of these plots may give a sense of variable associations or show specific patterns in the data. The `psych::pairs.panels()` function provides another sophisticated display (*SPLOM* = scatter plot matrix) that is often useful in exploring multivariate relations. \n\n\nThis plot gives us much more information about the selected three variables. Above the diagonal, we have our correlation coefficients in numerical form. On the diagonal, there are histograms of variables. Below the diagonal, more visual information is presented to help us understand the corresponding bivariate trends. Specifically, this graph shows that height and weight are strongly positively correlated. Also there are some weaker relationships, e.g., between age and height, and age and weight (horizontal red line in the below diagonal graphs indicates weak relationships). \n\n### Step 3 - training a model on the data\n\nThe base `R` method we are going to use now is the linear modeling function, `lm()`. No extra package is needed when using this function. The `lm()` function has the following invocation protocol:\n\n**m <- lm(dv ~ iv, data=mydata)**\n\n - *dv*: dependent variable\n - *iv*: independent variables. Also see the function `OneR()` in [Chapter 5](https://socr.umich.edu/DSPA2/DSPA2_notes/05_SupervisedClassification.html). If we use `.` as `iv`, then all of the variables, except the dependent variable ($dv$), are included as model predictors.\n - *data*: specifies the data object containing both a dependent variable and independent variables.\n\n\nThe output model report includes both numeric and factor predictors. For each factor variable, the model creates a set of several indicators (one-hot-encoding, dummy variables) with corresponding coefficients matching each factor level (except for all reference factor levels, as the effects of all factors are reported *relative* to the corresponding reference level). For each numerical variable, there is just one coefficient (the matching effect).\n\n### Step 4 - evaluating model performance\n\nLet's examine the linear model performance.\n\n\nThe **summary** shows how well the model fits the dataset.\n\n - *Residuals*: This tells us about the residuals. If we have extremely large or extremely small residuals for some observations compared to the rest of residuals, either they are outliers due to reporting error or the model fits data poorly. We have $73.649$ as our maximum and $-48.692$ as our minimum. Their extremeness could be examined by residual diagnostic plot.\n\n - *Coefficients*: In this section, strong effects are indicated by more stars ($*$) in the right-most column. Stars, or dots, next to probability-value for each variable indicate whether the variable is a significant predictor of the outcome, and therefore should be included in the model. However, an empty field there suggests that (statistically speaking), this variable does not contribute significantly (in the specified model) to predicting the outcome, i.e., there is no strong evidence to suggest its estimated effect is non-zero. The column `Pr(>|t|)` contains the estimated probability corresponding to the t-statistic for this covariate. Smaller values (close to $0$$) indicate the variable is a significant covariate, and conversely, larger values indicate lack of significance and indication that the variable may be dropped from the model. In our examples, only some of the teams and positions are not significant, whereas `Age` and `Height` are significant predictors of the outcome, `Weight`.\n\n - *R-squared*: Quantifies what percent in $Y$ (outcome) is explained by included predictors ($X$). Here, we have $R^2=38.58\\%$, which indicates the model is not bad but could be improved. Usually a well-fitted linear regression would have over $R^2>50\\%$.\n\n**Diagnostic plots** are also helpful for understanding the model performance relative to the data.\n\n - *Residual vs Fitted*: This is the residual diagnostic plot. We can see that the residuals of observations indexed $65$, $160$ and $237$ are relatively far apart from the rest. They are potential influential points or outliers.\n\n - *Normal Q-Q*: This plot examines the normality assumption of the model. If these dots follow the line on the graph, the normality assumption is valid. In our case, it is relatively close to the line. So, we can say that our model is valid in terms of normality.\n\n### Step 5 - improving model performance\n\nWe can employ the `step` function to perform *forward* or *backward* selection of important features/predictors. It works for both `lm()` and `glm()` models. In most cases, backward-selection is preferable because it tends to retain much larger models. On the other hand, there are various criteria to evaluate a model. Commonly used criteria include Akaike Information Criterion (*AIC*), Bayesian Information Criterion (*BIC*), *Adjusted* $R^2$, etc. Let's compare the backward and forward model selection approaches. The `step` function argument `direction` allows this control (default is `both`, which will select the better result from either backward or forward selection). Later, in [Chapter 11](https://socr.umich.edu/DSPA2/DSPA2_notes/11_FeatureSelection.html), we will present details about alternative feature selection approaches.\n\n\nWe can observe that `forward` selection retains the whole model. The better feature selection model uses `backward` stepwise selection. Both backward and forward feature selection methods utilize greedy algorithms and do not guarantee an optimal model selection result. Identifying the best feature selection requires exploring every possible combination of the predictors, which is often not practically feasible due to computational complexity associated with model selection using $n \\choose k$ combinations of features.\n\nAlternatively, we can choose models based on various **information criteria**. \n\n\nSetting the parameter $k = 2$ yields the genuine AIC criterion, and $k = log(n)$ refers to BIC. Let's try to evaluate the model performance again.\n\n\nSometimes, simpler models are preferable, even when there is a little bit of loss of performance. In this case, we have a simpler model and $R^2=0.365$. The whole model is still very significant. We can see that observations $65$, $160$ and $237$ are relatively far from the bulk of other residuals. These cases represent potentially influential points, or outliers. \n\nAlso, we can observe the *leverage points* - those that are either outliers, influential points, or both. In a regression model setting, *observation leverage* is the relative distance of the observation (data point) from the mean of the explanatory variable. Observations near the mean of the explanatory variable have *low leverage* and those far from the mean have *high leverage.* Yet, not all points of high leverage are necessarily influential.\n\n\nA deeper discussion of variable selection, controlling the false discovery rate, is provided in [Chapter 11](https://socr.umich.edu/DSPA2/DSPA2_notes/11_FeatureSelection.html).\n\n## Adding non-linear relationships\n\nIn linear regression, the relationship between independent and dependent variables is assumed to be affine. However, in general, this might not be the case. The relationship between age and weight could be quadratic, logarithmic, exponential, etc. For instance, if middle-aged people are expected to gain weight dramatically and then lose it as they age. This is an example of adding a non-linear (quadratic) term to the linear model. Note that the model is still referred to as *linear*, as it still has a linear matrix representation.\n\n\nIncluding a quadratic factor may change the overall $R^2$.\n\n## Converting a numeric variable to a binary indicator\n\nAs discussed earlier, middle-aged people might exhibit a different weight pattern, compared to younger or older people. The overall pattern may not always be cumulative, i.e., weight may represent two separate trajectories for young and middle-aged people. For concreteness, let's use the age of 30 as a threshold segregating young and middle-aged people. People over 30 may have a steeper line for weight change than those under 30. Here we use an `ifelse()` conditioning statement to create a new indicator variable ($age30$) based on this threshold value. \n\n\nThis model performs worse than the quadratic model in terms of $R^2$. Moreover, `age30` does not appear as a significant predictor of weight. Therefore, such a pseudo factor does not contribute to explaining the observed variability in the dataset. However, if including such binary indicator (dummy variable, or one-hot-encoding feature) improved the model (e.g., increased $R^2$), then we can leave the binary feature in the model and interpret its coefficient estimate in terms of a difference of expectations:\n\n - $E(Weight_i | age30_i=0)=\\beta_{o} + \\beta_{Team}Team + \\beta_{Position}Position + \\beta_{Age}Age +\\beta_{Height}Height$, is the expected Weight where $age30_i=0$, i.e., for younger people,\n - $E(Weight_i | age30_i=1)=\\beta_{o} + \\beta_{Team}Team + \\beta_{Position}Position + \\beta_{Age}Age + \\underbrace{\\beta_{age30}}_{\\text{effect size}}\\overbrace{Age30}^{\\text{dummy var.}}  +\\beta_{Height}Height$, is the expected Weight, where $age30_i=1$, i.e., for older people. In other words, $\\beta_{age30}\\equiv E(Weight_i | age30_i=1) - E(Weight_i | age30_i=0)$. Therefore, $\\beta_{age30}$ is the difference in age-group specific expectations, i.e., the difference in expected Weight between older and younger people.\n\n## Adding interaction effects\n\nSo far, we only accounted for the individual and independent effects of each variable included in the linear model. It is also possible that pairs of features *jointly* affect the independent outcome variable. *Interactions* represent combined effects of two features on the outcome. If we are uncertain whether two variables interact, we could include them along with their interaction in the model, and then test the significance of the interaction term. If the interaction is significant, then it remains in the model, if not, this term can be dropped.\n\n\nIn this example, we see that the overall $R^2$ improved by including a $Age\\times Position$ interaction and we can interpret its significance level.",
      "word_count": 4660
    },
    {
      "title": "Understanding regression trees and model trees",
      "content": "In [Chapter 5](https://socr.umich.edu/DSPA2/DSPA2_notes/05_SupervisedClassification.html), we will discuss decision trees built by multiple conditional logical decisions that lead to natural classifications of all observations. We could also add regression into decision tree modeling to make numerical predictions.\n\n## Adding regression to trees\n\nNumeric prediction trees are built in the same way as classification trees. In [Chapter 5](https://socr.umich.edu/DSPA2/DSPA2_notes/05_SupervisedClassification.html) we will show how data are partitioned first by a  *divide-and-conquer* strategy based on features. The homogeneity of the resulting classification trees is measured by various metrics, e.g., entropy. *In regression-tree prediction, node homogeneity (which is used to determine if a node needs to be split) is measured by various statistics such as variance, standard deviation, or absolute deviation from the mean*. A common splitting criterion for decision trees is the *standard deviation reduction (SDR)*.\n\n$$SDR=sd(T)-\\sum_{i=1}^n \\left | \\frac{T_i}{T} \\right | \\times sd(T_i),$$\n\nwhere `sd(T)` is the standard deviation for the original data. After the summation of all segments, $|\\frac{T_i}{T}|$ is the proportion of observations in the $i^{th}$ segment compared to total number of observations, and $sd(T_i)$ is the standard deviation for the $i^{th}$ segment.\n\nLet's look at a simple example\n\n$${\\text{Original data}}:\\{1, 2, 3, 3, 4, 5, 6, 6, 7, 8\\}$$\n$${\\text{Split method 1}}:\\left \\{\\underbrace{1, 2, 3}_{T_1}\\ |\\ \\underbrace{3, 4, 5, 6, 6, 7, 8}_{T_2}\\right \\}$$\n$${\\text{Split method 2}}:\\left \\{\\underbrace{1, 2, 3, 3, 4, 5}_{T_1'}\\ | \\ \\underbrace{6, 6, 7, 8}_{T_2'}\\right \\}.$$\n\nIn split method 1, $T_1=\\{1, 2, 3\\}$, $T_2=\\{3, 4, 5, 6, 6, 7, 8\\}$.\nIn split method 2, $T_1'=\\{1, 2, 3, 3, 4, 5\\}$, $T_2'=\\{6, 6, 7, 8\\}$.\n\n\nThe method `length()` is used above to get the number of elements in a specific vector.\n\n*Larger SDR indicates greater reduction in standard deviation after splitting*. Here we have split method 2 yielding greater SDR, so the tree splitting decision would prefer the *second method*, which is expected to produce more homogeneous subsets (children nodes), compared to *method 1*. \n\nNow, the tree will be split under `bt1` and `bt2` following the same rules (greater SDR wins). Assume we cannot split further (`bt1` and `bt2` are terminal nodes). The observations classified into `bt1` will be predicted with $mean(bt1)=3$ and those classified as `bt2` with $mean(bt2)=6.75$.\n\n## Bayesian Additive Regression Trees (BART)\n\nBayesian Additive Regression Trees (BART) represent sums of regression trees models that rely on boosting the constituent Bayesian regularized trees.\n\nThe `R` packages `BayesTree` and `BART` provide computational implementation of fitting BART models to data. In supervised setting where $x$ and $y$ represent the predictors and the outcome, the BART model is mathematically represented as:\n\n$$y=f(x)+\\epsilon = \\sum_{j=1}^m{f_j(x)} +\\epsilon.$$\n\nMore specifically,\n\n$$y_i=f(x_i)+\\epsilon = \\sum_{j=1}^m{f_j(x_i)} +\\epsilon,\\  \\forall 1\\leq i\\leq n.$$\n\nThe residuals are typically assumed to be white noise, $\\epsilon_i \\sim N(o,\\sigma^2), \\ iid$.\nThe function $f$ represents the boosted ensemble of weaker regression trees, $f_i=g( \\cdot | T_j, M_j)$, where $T_j$ and $M_j$ represent the $j^{th}$ tree and the set of values, $\\mu_{k,j}$,\nassigned to each terminal node $k$ in $T_j$, respectively.\n\nThe BART model may be estimated via Gibbs sampling, e.g., Bayesian backfitting Markov Chain Monte Carlo (MCMC) algorithm. For instance, iteratively sampling $(T_j ,M_j)$ and $\\sigma$, conditional on all other variables, $(x,y)$, for each $j$ until meeting a certain convergence criterion. Given $\\sigma$, conditional sampling of $(T_j ,M_j)$ may be accomplished via the partial residual \n\n$$\\epsilon_{j_o} = \\sum_{i=1}^n{\\left (y_i - \\sum_{j\\not= j_o}^m{g( x_i | T_j, M_j)} \\right )}.$$\n\nFor prediction on *new data*, $X$, data-driven priors on $\\sigma$ and the parameters defining $(T_j ,M_j)$ may be used to allow sampling a model from the posterior distribution:\n\n$$p\\left (\\sigma, \\{(T_1 ,M_1), (T_2 ,M_2), \\cdots, (T_2 ,M_2)\\} | X, Y \\right )=$$\n$$= p(\\sigma) \\prod_{(tree)j=1}^m{\\left ( \\left ( \\prod_{(node)k} {p(\\mu_{k,j}|T_j)} \\right )p(T_j)   \\right )}  .$$\nIn this posterior factorization, model regularization is achieved by four criteria:\n\n - Enforcing reasonable marginal probabilities, $p(T_j)$, to ensure that the probability of a depth $d$ node in the tree $T_j$ has children decreases as $d$ increases. That is, the probability a current bottom node, at depth $l$, is split into a left and right child nodes is $\\frac{\\alpha}{(1+l)^{\\beta}}$, where the base ($\\alpha$) and power ($\\beta$) parameters are selected to optimize the fit (including regularization);\n - For each interior (non-terminal) node, the distribution on the splitting variable assignments is uniform over the range of values taken by a variable;\n - For each interior (non-terminal) node, the distribution on the splitting rule assignment, conditional on the splitting variable, is uniform over the discrete set of splitting values;\n - All other priors are chosen as $p(\\mu_{k,j} |T_j) = N(\\mu_{k,j} |\\mu, \\sigma)$ and $p(\\sigma)$ where $\\sigma^2$ is inverse chi-square distributed. To facilitate the calculations, this introduces prior conjugate structure with the corresponding hyper-parameters estimated using the observed data.\n\nUsing the BART model to forecast a response corresponding to newly observed data $x$ is achieved by using one individual (or ensembling/averaging multiple) prediction models near algorithmic convergence.\n\nThe BART algorithm involves three steps:\n\n - Initialize a prior on the model parameters $(f,\\sigma)$, where $f=\\{f_i=g( . | T_j, M_j)\\}_i$,\n - Run a Markov chain with state $(f,\\sigma)$ where the stationary distribution is the posterior $p \\left ((f,\\sigma)|Data=\\{(x_i,y_i)\\}_{i=1}^n\\right )$,\n - Examine the draws as a representation of the full posterior. Even though $f$ is complex and changes its dimensional structure, for a given $x$, we can explore the marginals of $\\sigma$ and $f(x)$ by selecting a set of data $\\{x_j\\}_{j}$ and computing $f(x_j)$. If $f_l$ represents the $l^{th}$ MCMC draw, then the homologous Bayesian tree structures at every draw will yield results of the same dimensions $\\left ( f_l(x_i), f_l(x_2), \\cdots\\right )$.\n\n### 1D Simulation\n\nThis example illustrates a simple 1D BART simulation, based on a simple analytical process model $h(x)=x^3\\sin(x)$, where we can nicely track the performance of the BART classifier.\n\n\nIf we increase the sample size, $n$, the computational complexity increases and the BART model bounds should get tighter.\n\n\n### Higher-Dimensional Simulation\n\nIn this second BART example, we will simulate $n=5,000$ cases with $p=20$ features.\n\n\n###  Heart Attack Hospitalization Case-Study\n\nLet's use BART to model the [heart attack dataset (CaseStudy12_ AdultsHeartAttack_Data.csv)](https://umich.instructure.com/courses/38100/files/folder/Case_Studies). The data includes about $150$ observations and $8$ features, including hospital charges (`CHARGES`), which will be used as a response variable.\n\n\nIn [Chapter 11](https://socr.umich.edu/DSPA2/DSPA2_notes/11_FeatureSelection.html), we will learn more about *LASSO* regularized linear modeling. Now, let's use the `glmnet::glmnet()` method to fit a LASSO model and compare it to BART using the Heart Attack hospitalization case-study.\n\n\nPlot BART vs. LASSO predictions.\n\n\nIf the default prior estimate (`sigest` of the error variance ($\\sigma^2$) is inverted chi-squared, i.e., using a standard conditionally conjugate prior) yields reasonable results, we can try longer BART runs (`ndpost=5000`). Mind the stable distribution of the $\\hat{\\sigma}^2$ ($y$-axis) with respect to the number of posterior draws ($x$-axis).\n\n\nThe BART model indicates there is quite a bit of uncertainty in predicting the outcome (`CHARGES`) for each of the 148 cases using the other covariate features in the heart attack hospitalization data (DRG, DIED, LOS, AGE, gender).\n\n## Another look at Case study 2: Baseball Players\n\n### Step 2 - exploring and preparing the data\n\nWe will again use the [mlb dataset](https://umich.instructure.com/files/330381/download?download_frd=1) for this section. This dataset has $1,034$ observations which we will separate them into *training* and *testing* sets.\n\n\nHere we use a randomized split ($75\\%-25\\%$) to divide the training and testing sets.\n\n### Step 3 - training a model on the data\n\nIn `R`, the `rpart::rpart()` function provides an implementation for prediction using regression-tree modeling.\n\n**m <- rpart(dv~iv, data=mydata)**\n\n - *dv*: dependent variable\n - *iv*: independent variable\n - *mydata*: training data containing `dv` and `iv`.\n\nWe use two numerical features in the [mlb data (01a_data.txt)](https://umich.instructure.com/files/330381/download?download_frd=1) `Age` and `Height` as features.\n\n\nThe output contains rich information. `split` indicates the method to split; `n` is the number of observations that falls in this segment; `yval` is the predicted value if the test data falls into the specific segment (tree node decision cluster).\n\n### Visualizing regression decision trees\n\nA useful way of displaying the `rpart` decision tree is by using the `rpart.plot()` function in the `rpart.plot` package.\n\n\nA more detailed graph can be obtained by specifying additional options in the function call.\n\n\nAlso, you can use the `rattle::fancyRpartPlot()` method to display regression trees and explain the order and rules of node splits.\n\n\n### Step 4 - evaluating model performance\n\nLet's make predictions using the model prediction tree and the general `predict()` method.\n\n\nWe can compare the five-number statistics for the predicted estimates and the observed `Weight` values. Note that the model cannot precisely identify extreme cases, such as the maximum. However, within the IQR, the predictions are relatively accurate.  Correlation could also be used to measure the correspondence of two equal length numeric variables. Let's use `cor()` to examine the prediction accuracy.\n\n\nThe predicted values ($Weights$) are moderately correlated with their true value counterparts. [Chapter 9](https://socr.umich.edu/DSPA2/DSPA2_notes/09_ModelEvalImprovement.html) provides additional strategies for model quality assessment.\n\n### Measuring performance with mean absolute error\n\nTo measure the distance between predicted value and the true value, we can use a measurement called *mean absolute error (MAE)*. MAE is calculated using the following formula\n\n$$MAE=\\frac{1}{n}\\sum_{i=1}^{n}|pred_i-obs_i|,$$\nwhere for each case $i$, `pred_i` and `obs_i` represent  the $i^{th}$ predicted value and the $i^{th}$ observed value. Let's manually construct a MAE function in `R` and evaluate our model performance.\n\n\nThis implies that *on average*, the difference between the predicted value and the observed value is $15.1$. Considering that the range of the `Weight` variable in our test dataset is $[150, 260]$, the model performs well.\n\nFor comparison, suppose we used the most primitive method for prediction - the **sample mean**. How much larger would the MAE be?\n\n\nThis example illustrates that the predictive decision tree is better than using the **over all mean** strategy to predict every observation in the test dataset. However, it is not dramatically better. There might be room for further improvement.\n\n### Step 5 - improving model performance\n\nTo improve the performance of our regression-tree forecasting, we are going to use a model tree instead of a regression tree. The `RWeka::M5P()` function implements the `M5` algorithm and uses a similar syntax as `rpart::rpart()`.\n\n**m <- M5P(dv ~ iv, data=mydata)**\n\n\nInstead of using segment averages to predict an outcome, the `M5` model uses a linear regression (`LM1`) as the terminal node. In some datasets with more variables, `M5P` could give us multiple linear models under different terminal nodes. Much like the general regression trees, `M5` builds tree-based models. The difference is that regression trees produce univariate forecasts (values) at each terminal node, whereas the `M5` model-based regression trees generate multivariate linear models at each node. These model-based forecasts represent piece-wise linear functional models that can be used to numerically estimate outcomes at every node based on very high dimensional data (feature-rich spaces).\n\n\nWe can use `summary(mlb.m5)` to report some rough diagnostic statistics for the model. Notice that the correlation and MAE for the `M5` model are better compared to the results of the previous `rpart()` model.\n\n## Practice Problem: Heart Attack Data\n\nLet's use the heart attack dataset as another example.\n\n\nTo begin with, we need to convert the `CHARGES` (independent variable) to numerical form. NA's are created so let's remain only the complete cases as mentioned in the beginning of this chapter. Also, let's create a gender variable as an indicator for female patients using `ifelse()` and delete the previous `SEX` column.\n\n\nNow we can build a model tree using `M5P()` with all the features in the model. As usual, we need to separate the `heart_attack` data into training and test datasets (use the 75%-25% way of separation).\n\nAfter using the model to predict `CHARGES` in the test dataset we can obtain the following correlation and MAE.\n\n\nWe can see that the predicted values and observed values are strongly correlated. In terms of MAE, it may seem very large at first glance.\n\n\nHowever, the test data itself has a wide range and the MAE is within 20% of the range. With only 148 observations, the model did a fairly good job in predicting the outcome. Can you reproduce or perhaps improve these results?\n\nTry to apply these techniques to [other data from the list of our Case-Studies](https://umich.instructure.com/courses/38100/files/).\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\"\n\t\t\t\t\t\t\t\tsrc=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" \n\t\t\t\t\t\t\t\talt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 2100
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    self_contained: yes\n---",
      "row_count": 2
    },
    {
      "section": "Linear Algebra",
      "content": "Expression    |Explanation\n--------------|----------------------------------------------------------------\n`t(x)`| transpose\n`diag(x)`| diagonal\n`%*%`| matrix multiplication\n`solve(a, b)`| solves `a %*% x = b` for x\n`solve(a)`| matrix inverse of a\n`rowsum(x)`| sum of rows for a matrix-like object. `rowSums(x)` is a faster version\n`colSums(x)`, `colSums(x)`| id. for columns \n`rowMeans(x)`| fast version of row means \n`colMeans(x)`| id. for columns",
      "row_count": 11
    },
    {
      "section": "Matrix Computing",
      "content": "Functions              | Math expression or explanation\n-----------------------|---------------------------------------------\n`crossprod(A, B)`       | $A^TB$ Where $A$, $B$ are matrices\n`y<-svd(A)`            | the output has the following components \n   -`y$d`              | vector containing the singular values of A, \n   -`y$u`              | matrix with columns contain the left singular vectors of A, \n   -`y$v`              | matrix with columns contain the right singular vectors of A  \n`k <- qr(A)`           | the output has the following components \n   -`k$qr`             | has an upper triangle that contains the decomposition and a lower triangle that contains information on the Q decomposition.\n   -`k$rank`           |  is the rank of A. \n   -`k$qraux`          |  a vector which contains additional information on Q. \n   -`k$pivot`          |  contains information on the pivoting strategy used. \n`rowMeans(A)`/`colMeans(A)`|  returns vector of row/column means\n`rowSums(A)`/`colSums(A)`   |  returns vector of row/column sums",
      "row_count": 14
    }
  ],
  "r_code": [
    {
      "section": "Linear Algebra",
      "code": "seq1<-seq(1:6)\nm1<-matrix(seq1, nrow=2, ncol=3)\nm1\nm2<-diag(seq1)\nm2\nm3<-matrix(rnorm(20), nrow=5)\nm3",
      "line_count": 7
    },
    {
      "section": "Linear Algebra",
      "code": "diag(c(1, 2, 3))",
      "line_count": 1
    },
    {
      "section": "Linear Algebra",
      "code": "diag(m1)",
      "line_count": 1
    },
    {
      "section": "Linear Algebra",
      "code": "diag(4)",
      "line_count": 1
    },
    {
      "section": "Linear Algebra",
      "code": "c1<-1:5\nm4<-cbind(m3, c1)\nm4\nr1<-1:4\nm5<-rbind(m3, r1)\nm5",
      "line_count": 6
    },
    {
      "section": "Linear Algebra",
      "code": "dimnames(m5)<-list(NULL, NULL)\nm5",
      "line_count": 2
    },
    {
      "section": "Linear Algebra",
      "code": "m6<-matrix(1:12, nrow=3)\nm6\nm6[1, 2]\nm6[1, ]\nm6[, 2]\nm6[, c(2, 3)]",
      "line_count": 6
    },
    {
      "section": "Linear Algebra",
      "code": "m7<-matrix(1:6, nrow=2)\nm7\nm8<-matrix(2:7, nrow = 2)\nm8\nm7+m8",
      "line_count": 5
    },
    {
      "section": "Linear Algebra",
      "code": "m8-m7\nm8-1",
      "line_count": 2
    },
    {
      "section": "Linear Algebra",
      "code": "m8 * m7",
      "line_count": 1
    },
    {
      "section": "Linear Algebra",
      "code": "dim(m8)\nm9<-matrix(3:8, nrow=3)\nm9\ndim(m9)\nM = m8 %*% m9\nM",
      "line_count": 6
    },
    {
      "section": "Linear Algebra",
      "code": "u<-c(1, 2, 3, 4, 5)\nv<-c(4, 5, 6, 7, 8)\nu %o% v\nu %*% t(v)",
      "line_count": 4
    },
    {
      "section": "Linear Algebra",
      "code": "m8 / m7\nm8 / 2",
      "line_count": 2
    },
    {
      "section": "Linear Algebra",
      "code": "m8\nt(m8)",
      "line_count": 2
    },
    {
      "section": "Linear Algebra",
      "code": "m10 <- matrix(1:4, nrow=2)\nm10\nsolve(m10)\nm10 %*% solve(m10)",
      "line_count": 4
    },
    {
      "section": "Linear Algebra",
      "code": "require(MASS)\nginv(m10)",
      "line_count": 2
    },
    {
      "section": "Linear Algebra",
      "code": "s1 <- diag(c(2, 4, 6, 8))\ns2 <- c(1, 2, 3, 4)\nsolve(s1, s2)",
      "line_count": 3
    },
    {
      "section": "Linear Algebra",
      "code": "mat1 <- cbind(c(1, -1/5), c(-1/3, 1))\nmat1.inv <- solve(mat1)\n\nmat1.identity <- mat1.inv %*% mat1\nmat1.identity\nb <- c(1, 2)\nx <- solve (mat1, b)\nx",
      "line_count": 8
    },
    {
      "section": "Matrix Computing",
      "code": "A_matrix_values <- c(1, 1, 2, 3, -2, 1, 2, 1, -1)\n# matrix elements are arranged by columns, so, we need to transpose them to arrange them by rows.\nA <- t(matrix(A_matrix_values, nrow=3, ncol=3))  \n\nb <- c(6, 2, 3)\n# to solve Ax = b, x=A^{-1}*b\nx <- solve (A, b)\n# Ax = b ==> x = A^{-1} * b\nx\n\n# Check the Solution x=(1.35 1.75 1.45)\nLHS <- A %*% x\nround(LHS-b, 6)",
      "line_count": 13
    },
    {
      "section": "Matrix Computing",
      "code": "A.inverse <- solve(A) # the inverse matrix A^{-1} \nx1 <- A.inverse %*% b\n# check if X and x1 are the same\nx; x1\nround(x - x1, 6)",
      "line_count": 5
    },
    {
      "section": "Matrix Computing",
      "code": "n <- 3 #pick dimensions\nI <- diag(n); I\nA %*% I; I %*% A",
      "line_count": 3
    },
    {
      "section": "Matrix Computing",
      "code": "# Data: https://umich.instructure.com/courses/38100/files/folder/data   (01a_data.txt)\ndata <- read.table('https://umich.instructure.com/files/330381/download?download_frd=1', as.is=T, header=T)    \nattach(data)\nhead(data)",
      "line_count": 4
    },
    {
      "section": "Matrix Computing",
      "code": "X <- cbind(Age, Height)\nhead(X)\ndim(X)",
      "line_count": 3
    },
    {
      "section": "Matrix Computing",
      "code": "n <- 1034; k <- 5\nX <- matrix(1:(n*k), n, k)\nhead(X)\ndim(X)",
      "line_count": 4
    },
    {
      "section": "Matrix Computing",
      "code": "n <- 1034; k <- 5\nX <- matrix(1:(n*k), n, k, byrow=TRUE)\nhead(X)\ndim(X)",
      "line_count": 4
    },
    {
      "section": "Matrix Computing",
      "code": "# Using the Baseball dataset\ny <- data$Height\nprint(mean(y))\n\nn <- length(y)\nY <- matrix(y, n, 1)\nA <- matrix(1, n, 1)\nbarY = (t(A) %*% Y) / n\n\nprint(barY)\n# double-check the result\nmean(data$Height)",
      "line_count": 12
    },
    {
      "section": "Matrix Computing",
      "code": "barY = (crossprod(A, Y)) / n\nprint(barY)",
      "line_count": 2
    },
    {
      "section": "Matrix Computing",
      "code": "Y1 <- y - mean(y)\ncrossprod(Y1)/(n-1)  # Y1.man <- (1/(n-1))* t(Y1) %*% Y1\n\n# Check the result\nvar(y)",
      "line_count": 5
    },
    {
      "section": "Matrix Computing",
      "code": "library(plotly)\n#x=cbind(data$Height, data$Age)\nx=data$Height\ny=data$Weight\nX <- cbind(1, x) \nbeta_hat <- solve( t(X) %*% X ) %*% t(X) %*% y \n###or\nbeta_hat <- solve( crossprod(X) ) %*% crossprod( X, y ) ",
      "line_count": 8
    },
    {
      "section": "Matrix Computing",
      "code": "# newx <- seq(min(x), max(x), len=100)\nX <- cbind(1, x)\nfitted <- X%*%beta_hat\n# or directly: fitted <- lm(y ~ x)$fitted\n# plot(x, y, xlab=\"MLB Player's Height\", ylab=\"Player's Weight\")\n# lines(x, fitted, col=2)\n\nplot_ly(x = ~x) %>% \n  add_markers(y = ~y, name=\"Data Scatter\") %>% \n  add_lines(x = ~x, y = ~fitted[,1], name=\"(Manual) Linear Model (Weight ~ Height)\") %>% \n  add_lines(x = ~x, y = ~lm(y ~ x)$fitted, name=\"(Direct) lm(Weight ~ Height)\", \n            line = list(width = 4, dash = 'dash')) %>% \n    layout(title='Baseball Players: Linear Model of Weight vs. Height', \n           xaxis = list(title=\"Height (in)\"), yaxis = list(title=\"Weight (lb)\"),\n           legend = list(orientation = 'h'))",
      "line_count": 15
    },
    {
      "section": "Matrix Computing",
      "code": "# X <- cbind(data$Height, data$Age) # more complicated model\nX <- data$Height    # simple model\ny <- data$Weight\nfit <- lm(y ~ X)",
      "line_count": 4
    },
    {
      "section": "Matrix Computing",
      "code": "m11 <- diag(nrow = 2, ncol=2)\nm11\neigen(m11)",
      "line_count": 3
    },
    {
      "section": "Matrix Computing",
      "code": "(eigen(m11)$values*diag(2)-m11) %*% eigen(m11)$vectors",
      "line_count": 1
    },
    {
      "section": "Matrix Computing",
      "code": "gene <- read.csv(\"https://umich.instructure.com/files/2001417/download?download_frd=1\", \n                 header = T) # exprs_GSE5859.csv\ninfo<-read.csv(\"https://umich.instructure.com/files/2001418/download?download_frd=1\", \n               header=T)  # exprs_MetaData_GSE5859.csv",
      "line_count": 4
    },
    {
      "section": "Matrix Computing",
      "code": "colmeans <- sapply(gene[, -1], mean)\ngene1 <- as.matrix(gene[, -1])\n# can also use built in functions\n# colMeans <- colMeans(gene1)\ncolmeans.matrix <- crossprod(rep(1/nrow(gene1), nrow(gene1)), gene1)\ncolmeans[1:15]\ncolmeans.matrix[1:15]",
      "line_count": 7
    },
    {
      "section": "Matrix Computing",
      "code": "colmeans <- as.matrix(colmeans)\nh <- hist(colmeans, plot=F)\n\nplot_ly(x = h$mids, y = h$counts, type = \"bar\", name = \"Column Averages\") %>% \n    layout(title='Average Gene Expression Histogram', \n          xaxis = list(title = \"Column Means\"),\n          yaxis = list(title = \"Average Expression\", side = \"left\"),\n           legend = list(orientation = 'h'))",
      "line_count": 8
    },
    {
      "section": "Matrix Computing",
      "code": "gender <- info[, c(3, 4)]\nrownames(gender) <- gender$filename",
      "line_count": 2
    },
    {
      "section": "Matrix Computing",
      "code": "gender <- gender[colnames(gene1), ]",
      "line_count": 1
    },
    {
      "section": "Matrix Computing",
      "code": "table(gender$sex)\ngender$vector <- ifelse(gender$sex==\"F\", -1/86, 1/122)\nvec1 <- as.matrix(data.frame(rowavg=rep(1/ncol(gene1), ncol(gene1)), gender.diff=gender$vector))\ngender.matrix <- gene1 %*% vec1\ngender.matrix[1:15, ]",
      "line_count": 5
    },
    {
      "section": "Linear regression",
      "code": "#If you downloaded the .RData locally first, then you can easily load it into the`R`workspace by:\n# load(\"Teams.RData\")\n\n# Alternatively you can also download the data in CSV format from https://umich.instructure.com/courses/38100/files/folder/data (teamsData.csv)\nTeams <- read.csv('https://umich.instructure.com/files/2798317/download?download_frd=1', header=T)\n\ndat <- Teams[Teams$G==162&Teams$yearID<2002, ]\ndat$Singles <- dat$H-dat$X2B-dat$X3B-dat$HR\ndat <- dat[, c(\"R\", \"Singles\", \"HR\", \"BB\")]\nhead(dat)",
      "line_count": 10
    },
    {
      "section": "Linear regression",
      "code": "Y <- dat$R\nX <- cbind(rep(1, n=nrow(dat)), dat$BB)\nX[1:10, ]",
      "line_count": 3
    },
    {
      "section": "Linear regression",
      "code": "beta <- solve(t(X) %*% X) %*% t(X) %*% Y\nbeta",
      "line_count": 2
    },
    {
      "section": "Linear regression",
      "code": "fit <- lm(R~BB, data=dat)\n# fit <- lm(R~., data=dat) \n# '.' indicates all other variables, very useful when fitting models with many predictors\nfit\nsummary(fit)\nsystem.time(fit <- lm(R~BB, data=dat))\nsystem.time(beta1 <- solve(t(X) %*% X) %*% t(X) %*% Y)",
      "line_count": 7
    },
    {
      "section": "Linear regression",
      "code": "X <- cbind(rep(1, n=nrow(dat)), dat$BB, dat$Singles, dat$HR)\nX[1:10, ]\nsystem.time(fit <- lm(R ~ BB+ Singles + HR, data=dat))\nsystem.time(beta2 <- solve(t(X) %*% X) %*% t(X) %*% Y)\n\nfit$coefficients; t(beta2)",
      "line_count": 6
    },
    {
      "section": "Linear regression",
      "code": "# plot(dat$BB, dat$R, xlab = \"BB\", ylab = \"R\", main = \"Scatter plot/regression for baseball data\")\n# abline(beta1[1, 1], beta1[2, 1], lwd=4, col=\"red\")\n\nplot_ly(x = ~dat$BB) %>% \n  add_markers(y = ~dat$R, name=\"Data Scatter\") %>% \n  add_lines(x = ~dat$BB, y = ~lm(dat$R ~ dat$BB)$fitted, \n            name=\"lm(Runs scored ~ Walks by batters)\", line = list(width = 4)) %>% \n    layout(title='Scatter plot/regression for baseball data', \n           xaxis = list(title=\"(BB) Walks by batters\"), yaxis = list(title=\"(R) Runs scored\"),\n           legend = list(orientation = 'h'))",
      "line_count": 10
    },
    {
      "section": "Linear regression",
      "code": "library(reshape2)\nX <- cbind(rep(1, n=nrow(dat)), dat$BB, dat$HR)\nbeta <- solve(t(X) %*% X) %*% t(X) %*% Y\nbeta\n# #install.packages(\"scatterplot3d\")\n# library(scatterplot3d)\n# myScatter3D <- scatterplot3d(dat$BB, dat$HR, dat$R)\n# \n# fit = lm(dat$R ~ dat$BB + dat$HR, data = dat)\n# # Plot the linear model\n# # get the BB & HR ranges summary(dat$BB); summary(dat$HR)\n# cf = fit$coefficients\n# pltx = seq(344, 775,length.out = 100)\n# plty = seq(11,264,length.out = 100)\n# pltz = cf[1] + cf[2]*pltx + cf[3]*plty\n# #Add the line to the plot\n# myScatter3D$points3d(pltx,plty,pltz, type = \"l\", col = \"red\", lwd=3)\n\n# # interactive *rgl* 3D plot\n# library(rgl)\n# fit <- lm(dat$R ~ dat$BB + dat$HR)\n# coefs <- coef(fit)\n# a <- coefs[\"dat$BB\"]\n# b <- coefs[\"dat$HR\"]\n# c <- -1\n# d <- coefs[\"(Intercept)\"]\n# open3d()\n# plot3d(dat$BB,  dat$HR, dat$R, type = \"s\", col = \"red\", size = 1)\n# planes3d(a, b, c, d, alpha = 0.5)\n# # planes3d(b, a, -1.5, d, alpha = 0.5)\n# # planes3d draws planes using the parametrization a*x + b*y + c*z + d = 0.\n# # Multiple planes may be specified by giving multiple values for the normal\n# # vector (a, b, c) and the offset parameter d\n# \n# pca1 <- prcomp(as.matrix(cbind(dat$BB,  dat$HR, dat$R)), center = T); summary(pca1)\n# \n# # Given two vectors PCA1 and PCA2, the cross product V = PCA1 x PCA2 \n# # is orthogonal to both A and to B, and a normal vector to the \n# # plane containing PCA1 and PCA2\n# # If PCA1 = (a,b,c) and PCA2 = (d, e, f), then the cross product is\n# # PCA1 x PCA2 =  (bf - ce, cd - af, ae - bd)\n# # PCA1 = pca1$rotation[,1] and PCAS2=pca1$rotation[,2]\n# # https://en.wikipedia.org/wiki/Cross_product#Names\n# # prcomp$rotation contains the matrix of variable loadings, \n# # i.e., a matrix whose columns contain the eigenvectors\n# #normVec = c(pca1$rotation[,1][2]*pca1$rotation[,2][3]-\n# #              pca1$rotation[,1][3]*pca1$rotation[,2][2],\n# #            pca1$rotation[,1][3]*pca1$rotation[,2][1]-\n# #              pca1$rotation[,1][1]*pca1$rotation[,2][3],\n# #            pca1$rotation[,1][1]*pca1$rotation[,2][2]-\n# #              pca1$rotation[,1][2]*pca1$rotation[,2][1]\n# #            )\n# normVec = c(pca1$rotation[2,1]*pca1$rotation[3,2]-\n#                  pca1$rotation[3,1]*pca1$rotation[2,2],\n#              pca1$rotation[3,1]*pca1$rotation[1,2]-\n#                  pca1$rotation[1,1]*pca1$rotation[3,2],\n#              pca1$rotation[1,1]*pca1$rotation[2,2]-\n#                  pca1$rotation[2,1]*pca1$rotation[1,2]\n# )\n# \n# # Plot the PCA Plane\n# plot3d(dat$BB,  dat$HR, dat$R, type = \"s\", col = \"red\", size = 1)\n# planes3d(normVec[1], normVec[2], normVec[3], 90, alpha = 0.5)\n# myScatter3D <- scatterplot3d(dat$BB, dat$HR, dat$R)\n\ndat$name <- Teams[Teams$G==162&Teams$yearID<2002, \"name\"]\n\nfit = lm(dat$R ~ dat$BB + dat$HR, data = dat)\n# Plot the linear model\n# get the BB & HR ranges summary(dat$BB); summary(dat$HR)\ncf = fit$coefficients\npltx = seq(344, 775,length.out = length(dat$BB))\nplty = seq(11,264,length.out = length(dat$BB))\npltz = cf[1] + cf[2]*pltx + cf[3]*plty\n\n# Plot Scatter and add the LM line to the plot\nplot_ly() %>%\n  add_trace(x = ~pltx, y = ~plty, z = ~pltz, type=\"scatter3d\", mode=\"lines\",\n        line = list(color = \"red\", width = 4), name=\"lm(R ~ BB + HR\") %>% \n  add_markers(x = ~dat$BB, y = ~dat$HR, z = ~dat$R, color = ~dat$name, mode=\"markers\") %>% \n  layout(scene = list(xaxis = list(title = '(BB) Walks by batters'),\n                        yaxis = list(title = '(HR) Home runs by batters'),\n                        zaxis = list(title = '(R) Runs scored')))\n\n# Plot Scatter and add the LM PLANE to the plot\nlm <- lm(R ~ 0 + HR + BB, data = dat)\n\n#Setup Axis\naxis_x <- seq(min(dat$HR), max(dat$HR), length.out=100)\naxis_y <- seq(min(dat$BB), max(dat$BB), length.out=100)\n\n#Sample points\nlm_surface <- expand.grid(HR = axis_x, BB = axis_y, KEEP.OUT.ATTRS = F)\nlm_surface$R <- predict.lm(lm, newdata = lm_surface)\nlm_surface <- acast(lm_surface, HR ~ BB, value.var = \"R\") #`R`~ 0 + HR + BB\n\nplot_ly(dat, x = ~HR, y = ~BB, z = ~R,\n        text = ~name, type = \"scatter3d\", mode = \"markers\", color = ~dat$name) %>%\n  add_trace(x = ~axis_x, y = ~axis_y, z = ~lm_surface, type=\"surface\", color=\"gray\", opacity=0.3) %>%\n  layout(title=\"3D Plane Regression (R ~ BB + HR); Color=BB Team\", showlegend = F,\n         xaxis = list(title = '(BB) Walks by batters'),\n         yaxis = list(title = '(HR) Home runs by batters'),\n         zaxis = list(title = '(R) Runs scored')) %>% \n  hide_colorbar()",
      "line_count": 104
    },
    {
      "section": "Linear regression",
      "code": "x <- matrix(c(4.0, 4.2, 3.9, 4.3, 4.1, 2.0, 2.1, 2.0, 2.1, 2.2, 0.60, 0.59, 0.58, 0.62, 0.63), ncol=3)\nx",
      "line_count": 2
    },
    {
      "section": "Linear regression",
      "code": "vec2 <- matrix(c(1/5, 1/5, 1/5, 1/5, 1/5), ncol=5)\n#column means\nx.bar <- vec2 %*% x\nx.bar\n\nx.bar <- matrix(rep(x.bar, each=5), nrow=5)\nS <- 1/4*t(x-x.bar) %*% (x-x.bar)\nS",
      "line_count": 8
    },
    {
      "section": "Linear regression",
      "code": "autoCov <- cov(x)\nautoCov",
      "line_count": 2
    },
    {
      "section": "Linear regression",
      "code": "library(plotly)\nheart_attack <- read.csv(\"https://umich.instructure.com/files/1644953/download?download_frd=1\", stringsAsFactors = F)\nheart_attack$CHARGES <- as.numeric(heart_attack$CHARGES)\nheart_attack <- heart_attack[complete.cases(heart_attack), ]\n\nfit1 <- lm(CHARGES ~ LOS, data=heart_attack)\n# par(cex=.8)\n# plot(heart_attack$LOS, heart_attack$CHARGES, xlab=\"LOS\", ylab = \"CHARGES\")\n# abline(fit1, lwd=2, col=\"red\")\n\nplot_ly(heart_attack, x = ~LOS, y = ~CHARGES, type = 'scatter', mode = \"markers\", name=\"Data\") %>%\n    add_trace(x=~mean(LOS), y=~mean(CHARGES), type=\"scatter\", mode=\"markers\",\n            name=\"(mean(LOS), mean(Charge))\", marker=list(size=20, color='blue', line=list(color='yellow', width=2))) %>%\n    add_lines(x = ~LOS, y = fit1$fitted.values, mode = \"lines\", name=\"Linear Model\") %>%\n    layout(title=paste0(\"lm(CHARGES ~ LOS), Cor(LOS,CHARGES) = \", \n                        round(cor(heart_attack$LOS, heart_attack$CHARGES),3)))",
      "line_count": 16
    },
    {
      "section": "Linear regression",
      "code": "# plot(heart_attack$LOS, heart_attack$CHARGES, xlab=\"LOS\", ylab = \"CHARGES\")\n# abline(fit1, lwd=2, col=\"red\")\n# segments(15, 7767.05, 15, 10959, col = 'blue', lwd=2)\n# text(18, 9363.025, \"error\", cex=1.5)\n# text(16, 9363.025, '}', cex = 7)\n# text(15, 10959, '.', col = \"green\", cex=5)\n# text(16, 11500, \"true value(y)\", cex = 1.5)\n# text(15, 7767.05, '.', col = \"green\", cex=5)\n# text(15, 7400.05, \"estimated value(y.hat)\", cex = 1.5)\n\nplot_ly(heart_attack, x = ~LOS, y = ~CHARGES, type = 'scatter', mode = \"markers\", name=\"Data\") %>% \n  add_lines(x = ~LOS, y = fit1$fitted.values, mode = \"lines\", name=\"Linear Model\") %>%\n  add_segments(x=15, xend=15, y=7767.05, yend = 10959, showlegend=F) %>%\n  add_markers(x = 15, y = 7767.05, name=\"Model-estimated prediction (x=15,y=7767)\",\n      marker=list(size=20, color='red', line=list(color='yellow', width=2))) %>%\n  add_markers(x = 15, y = 10959, name=\"True (observed) value (x=15,y=10959)\",\n      marker=list(size=20, color='green', line=list(color='yellow', width=2))) %>%\n  layout(title=paste0(\"lm(CHARGES ~ LOS), Cor(LOS,CHARGES) = \", \n                        round(cor(heart_attack$LOS, heart_attack$CHARGES),3))) %>%\n  layout(title=\"Ordinary Least Squares\",\n         xaxis=list(title=\"LOS\"),  # control the y:x axes aspect ratio\n         yaxis = list(title=\"CHARGES\"),\n         legend = list(orientation = 'h'),\n         annotations = list(text=\"OLS Error\",  x=15.5, y=9300, textangle=90,\n                  font=list(size=15, color=\"black\"), showarrow=FALSE))",
      "line_count": 25
    },
    {
      "section": "Linear regression",
      "code": "b <- cov(heart_attack$LOS, heart_attack$CHARGES)/var(heart_attack$LOS)\nb\na<-mean(heart_attack$CHARGES)-b*mean(heart_attack$LOS)\na\n# compare to the lm() estimate:\nfit1$coefficients[1]\n# we can do the same for the slope parameter (b==fit1$coefficients[2]",
      "line_count": 7
    },
    {
      "section": "Linear regression",
      "code": "r <- cov(heart_attack$LOS, heart_attack$CHARGES)/(sd(heart_attack$LOS)*sd(heart_attack$CHARGES))\nr\ncor(heart_attack$LOS, heart_attack$CHARGES)",
      "line_count": 3
    },
    {
      "section": "Linear regression",
      "code": "reg <- function(y, x){\n  x<-as.matrix(x)\n  x<-cbind(Intercept=1, x)\n  solve(t(x)%*%x)%*%t(x)%*%y\n}",
      "line_count": 5
    },
    {
      "section": "Linear regression",
      "code": "reg(y=heart_attack$CHARGES, x=heart_attack$LOS)\nfit1  # recall that fit1 <- lm(CHARGES ~ LOS, data=heart_attack)",
      "line_count": 2
    },
    {
      "section": "Linear regression",
      "code": "str(heart_attack)\nreg(y=heart_attack$CHARGES, x=heart_attack[, c(7, 8)])\n# and compare the result to lm()\nfit2 <- lm(CHARGES ~ LOS+AGE, data=heart_attack); fit2",
      "line_count": 4
    },
    {
      "section": "Linear regression",
      "code": "mlb <- read.table('https://umich.instructure.com/files/330381/download?download_frd=1', as.is=T, header=T)\nstr(mlb)\nmlb <- mlb[, -1]",
      "line_count": 3
    },
    {
      "section": "Linear regression",
      "code": "mlb$Team <- as.factor(mlb$Team)\nmlb$Position <- as.factor(mlb$Position)",
      "line_count": 2
    },
    {
      "section": "Linear regression",
      "code": "summary(mlb$Weight)\n# hist(mlb$Weight, main = \"Histogram for Weights\")\n\nplot_ly(x = mlb$Weight, type = \"histogram\", name= \"Histogram for Weights\") %>%\n  layout(title=\"Baseball Players' Weight Histogram\", bargap=0.1,\n         xaxis=list(title=\"Weight\"),  # control the y:x axes aspect ratio\n         yaxis = list(title=\"Frequency\"))",
      "line_count": 7
    },
    {
      "section": "Linear regression",
      "code": "# require(GGally)\n# mlb_binary = mlb\n# mlb_binary$bi_weight = as.factor(ifelse(mlb_binary$Weight>median(mlb_binary$Weight),1,0))\n# g_weight <- ggpairs(data=mlb_binary[-1], title=\"MLB Light/Heavy Weights\",\n#            mapping=ggplot2::aes(colour = bi_weight),\n#            lower=list(combo=wrap(\"facethist\",binwidth=1)),\n#            # upper = list(continuous = wrap(\"cor\", size = 4.75, alignPercent = 1))\n#            )\n# g_weight\n\nplot_ly(mlb) %>%\n    add_trace(type = 'splom', dimensions = list( list(label='', values=~Position), # Position\n    list(label='Height', values=~Height), list(label='Weight', values=~Weight), \n    list(label='Age', values=~Age), list(label='', values=~Team)), # Team\n        text=~Team,\n        marker = list(color = as.integer(mlb$Team),\n            size = 7, line = list(width = 1, color = 'rgb(230,230,230)')\n        )\n    ) %>%\n    style(diagonal = list(visible = FALSE)) %>%\n    layout(title= 'MLB Pairs Plot', hovermode='closest', dragmode= 'select',\n        plot_bgcolor='rgba(240,240,240, 0.95)')",
      "line_count": 22
    },
    {
      "section": "Linear regression",
      "code": "# We may also mark player positions by different colors in the ggpairs plot\n# g_position <- ggpairs(data=mlb[-1], title=\"MLB by Position\",\n#               mapping=ggplot2::aes(colour = Position),\n#               lower=list(combo=wrap(\"facethist\",binwidth=1)))\n# g_position",
      "line_count": 5
    },
    {
      "section": "Linear regression",
      "code": "table(mlb$Team)\ntable(mlb$Position)\nsummary(mlb$Height)\nsummary(mlb$Age)",
      "line_count": 4
    },
    {
      "section": "Linear regression",
      "code": "cor(mlb[c(\"Weight\", \"Height\", \"Age\")])",
      "line_count": 1
    },
    {
      "section": "Linear regression",
      "code": "car::vif(lm(Weight ~ Height + Age, data=mlb))",
      "line_count": 1
    },
    {
      "section": "Linear regression",
      "code": "# pairs(mlb[c(\"Weight\", \"Height\", \"Age\")])\nplot_ly(mlb) %>%\n    add_trace(type = 'splom', dimensions = list( list(label='Height', values=~Height),\n              list(label='Weight', values=~Weight), list(label='Age', values=~Age)),\n        text=~Position,\n        marker = list(color = as.integer(mlb$Team),\n            size = 7, line = list(width = 1, color = 'rgb(230,230,230)')\n        )\n    ) %>%\n    layout(title= 'MLB Pairs Plot', hovermode='closest', dragmode= 'select',\n        plot_bgcolor='rgba(240,240,240, 0.95)')",
      "line_count": 11
    },
    {
      "section": "Linear regression",
      "code": "# install.packages(\"psych\")\nlibrary(psych)\npairs.panels(mlb[, c(\"Weight\", \"Height\", \"Age\")])",
      "line_count": 3
    },
    {
      "section": "Linear regression",
      "code": "fit <- lm(Weight ~ ., data=mlb)\nfit",
      "line_count": 2
    },
    {
      "section": "Linear regression",
      "code": "summary(fit)\n#plot(fit, which = 1:2)\n\nplot_ly(x=fit$fitted.values, y=fit$residuals, type=\"scatter\", mode=\"markers\") %>%\n  layout(title=\"LM: Fitted-values vs. Model-Residuals\",\n         xaxis=list(title=\"Fitted\"), yaxis = list(title=\"Residuals\"))",
      "line_count": 6
    },
    {
      "section": "Linear regression",
      "code": "step(fit,direction = \"backward\")\nstep(fit,direction = \"forward\")\nstep(fit,direction = \"both\")",
      "line_count": 3
    },
    {
      "section": "Linear regression",
      "code": "step(fit, k=2)\nstep(fit, k=log(nrow(mlb)))",
      "line_count": 2
    },
    {
      "section": "Linear regression",
      "code": "fit2 = step(fit,k=2,direction = \"backward\")\nsummary(fit2)\n#plot(fit2, which = 1:2)\nplot_ly(x=fit2$fitted.values, y=fit2$residuals, type=\"scatter\", mode=\"markers\") %>%\n  layout(title=\"LM: Fitted-values vs. Model-Residuals\",\n         xaxis=list(title=\"Fitted\"), \n         yaxis = list(title=\"Residuals\"))\n\n# compute the quantiles\nQQ <- qqplot(fit2$fitted.values, fit2$residuals, plot.it=FALSE)\n# take a smaller sample size to expedite the viz\nind <-  sample(1:length(QQ$x), 1000, replace = FALSE)\nplot_ly() %>%\n  add_markers(x=~QQ$x, y=~QQ$y, name=\"Quantiles Scatter\", type=\"scatter\", mode=\"markers\") %>%\n  add_trace(x = ~c(160,260), y = ~c(-50,80), type=\"scatter\", mode=\"lines\",\n        line = list(color = \"red\", width = 4), name=\"Line\", showlegend=F) %>%\n  layout(title='Quantile plot',\n           xaxis = list(title=\"Fitted\"),\n           yaxis = list(title=\"Residuals\"),\n           legend = list(orientation = 'h'))",
      "line_count": 20
    },
    {
      "section": "Linear regression",
      "code": "# Half-normal plot for leverages\n# install.packages(\"faraway\")\nlibrary(faraway)\nhalfnorm(lm.influence(fit)$hat, nlab = 2, ylab=\"Leverages\")\nmlb[c(226,879),]\nsummary(mlb)",
      "line_count": 6
    },
    {
      "section": "Linear regression",
      "code": "mlb$age2 <- (mlb$Age)^2\nfit2     <- lm(Weight ~ ., data=mlb)\nsummary(fit2)",
      "line_count": 3
    },
    {
      "section": "Linear regression",
      "code": "mlb$age30 <- ifelse(mlb$Age>=30, 1, 0)\nfit3      <- lm(Weight ~ Team+Position+Age+age30+Height, data=mlb)\nsummary(fit3)",
      "line_count": 3
    },
    {
      "section": "Linear regression",
      "code": "fit4 <- lm(Weight ~ Team + Height +Age*Position + age2, data=mlb)\nsummary(fit4)",
      "line_count": 2
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "ori<-c(1, 2, 3, 3, 4, 5, 6, 6, 7, 8)\nat1<-c(1, 2, 3)\nat2<-c(3, 4, 5, 6, 6, 7, 8)\nbt1<-c(1, 2, 3, 3, 4, 5)\nbt2<-c(6, 6, 7, 8)\nsdr_a<-sd(ori)-(length(at1)/length(ori)*sd(at1)+length(at2)/length(ori)*sd(at2))\nsdr_b<-sd(ori)-(length(bt1)/length(ori)*sd(bt1)+length(bt2)/length(ori)*sd(bt2))\nsdr_a\nsdr_b",
      "line_count": 9
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "# simulate training data\nsig = 0.2  # sigma\nfunc = function(x) {\n  return (sin(x) * (x^(3)))\n}\n\nset.seed(1234)\nn = 300\nx = sort(2*runif(n)-1)        # define the input\ny = func(x) + sig * rnorm(n)  # define the output\n\n# xtest: values we want to estimate func(x) at; this is also our prior prediction for y.\nxtest = seq(-pi, pi, by=0.2)\n\n##plot simulated data\n# plot(x, y, cex=1.0, col=\"gray\")\n# points(xtest, rep(0, length(xtest)), col=\"blue\", pch=1, cex=1.5)\n# legend(\"top\", legend=c(\"Data\", \"(Conjugate) Flat Prior\"),\n#    col=c(\"gray\", \"blue\"), lwd=c(2,2), lty=c(3,3), bty=\"n\", cex=0.9, seg.len=3)\n\nplot_ly(x=x, y=y, type=\"scatter\", mode=\"markers\", name=\"data\") %>%\n  add_trace(x=xtest, y=rep(0, length(xtest)), mode=\"markers\", name=\"prior\") %>%\n  layout(title='(Conjugate) Flat Prior',\n           xaxis = list(title=\"X\", range = c(-1.3, 1.3)),\n           yaxis = list(title=\"Y\", range = c(-0.6, 1.6)),\n           legend = list(orientation = 'h'))\n\n# run the weighted BART (BART::wbart) on the simulated data  \n# install.packages(\"BART\")\nlibrary(BART)\nset.seed(1234) # set seed for reproducibility of MCMC\n# nskip=Number of burn-in MCMC iterations; ndpost=number of posterior draws to return\nmodel_bart <- wbart(x.train=as.data.frame(x), y.train=y, x.test=as.data.frame(xtest), \n                    nskip=300, ndpost=1000, printevery=1000) \n# result is a list containing the BART run \n\n# explore the BART model fit\nnames(model_bart)\ndim(model_bart$yhat.test)\n\n# The (l,j) element of the matrix `yhat.test` represents the l^{th} draw of `func` evaluated at the j^{th} value of x.test\n# A matrix with ndpost rows and nrow(x.train) columns. Each row corresponds to a draw f* from the posterior of f\n# and each column corresponds to a row of x.train. The (i,j) value is f*(x) for the i^th kept draw of f \n# and the j^th row of x.train\n\n# # plot the data, the BART Fit, and the uncertainty\n# plot(x, y, cex=1.2, cex.axis=0.8, cex.lab=0.8, mgp=c(1.3,.3,0), tcl=-0.2, col=\"gray\")\n# lines(xtest, func(xtest), col=\"blue\", lty=1, lwd=2)\n# lines(xtest, apply(model_bart$yhat.test, 2, mean), col=\"green\", lwd=2, lty=2) # show the mean of f(x_j)\n# quant_marg = apply(model_bart$yhat.test, 2, quantile, probs=c(0.025, 0.975)) # plot the 2.5% and 97.5% quantiles\n# lines(xtest, quant_marg[1,], col=\"red\", lty=1, lwd=2)\n# lines(xtest, quant_marg[2,], col=\"red\", lty=1,lwd=2)\n# legend(\"top\", legend=c(\"Data\", \"True Signal\",\"Posterior Mean\",\"95% CI\"),\n#    col=c(\"black\", \"blue\",\"green\",\"red\"), lwd=c(2, 2,2,2), lty=c(3, 1,1,1), bty=\"n\", cex=0.9, seg.len=3)\n\nquant_marg = apply(model_bart$yhat.test, 2, quantile, probs=c(0.025, 0.975)) # plot the 2.5% and 97.5% quantiles\nplot_ly(x=x, y=y, type=\"scatter\", mode=\"markers\", name=\"Data\") %>%\n  add_trace(x=xtest, y=func(xtest), mode=\"markers\", name=\"True Signal\") %>%\n  add_trace(x=xtest, y=apply(model_bart$yhat.test, 2, mean), mode=\"lines\", name=\"Posterior Mean\") %>%\n  add_trace(x=xtest, y=apply(model_bart$yhat.test, 2, quantile, probs=c(0.025, 0.975)),\n            mode=\"markers\", name=\"95% CI\") %>%\n  add_trace(x=xtest, y=quant_marg[1,], mode=\"lines\", name=\"Lower Band\") %>%\n  add_trace(x=xtest, y=quant_marg[2,], mode=\"lines\", name=\"Upper Band\") %>%\n  layout(title='BART Model  (n=300)',\n           xaxis = list(title=\"X\", range = c(-1.3, 1.3)),\n           yaxis = list(title=\"Y\", range = c(-0.6, 1.6)),\n           legend = list(orientation = 'h'))\n\nnames(model_bart)\ndim(model_bart$yhat.train)\nsummary(model_bart$yhat.train.mean-apply(model_bart$yhat.train, 2, mean))\nsummary(model_bart$yhat.test.mean-apply(model_bart$yhat.test, 2, mean))\n# yhat.train(test).mean: Average the draws to get the estimate of the posterior mean of func(x)",
      "line_count": 73
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "n = 3000 # 300 --> 3,000\nset.seed(1234)\nx = sort(2*runif(n)-1)\ny = func(x) + sig*rnorm(n)\n\nmodel_bart_2 <- wbart(x.train=as.data.frame(x), y.train=y, x.test=as.data.frame(xtest), \n                      nskip=300, ndpost=1000, printevery=1000)\n\n# plot(x, y, cex=1.2, cex.axis=0.8, cex.lab=0.8, mgp=c(1.3,.3,0), tcl=-0.2, col=\"gray\")\n# lines(xtest, func(xtest), col=\"blue\", lty=1, lwd=2)\n# lines(xtest, apply(model_bart_2$yhat.test, 2, mean), col=\"green\", lwd=2, lty=2) # show the mean of f(x_j)\n# quant_marg = apply(model_bart_2$yhat.test, 2, quantile, probs=c(0.025, 0.975)) # plot the 2.5% and 97.5% CI\n# lines(xtest, quant_marg[1,], col=\"red\", lty=1, lwd=2)\n# lines(xtest, quant_marg[2,], col=\"red\", lty=1,lwd=2)\n# legend(\"top\",legend=c(\"Data (n=3,000)\", \"True Signal\", \"Posterior Mean\",\"95% CI\"),\n#    col=c(\"gray\", \"blue\",\"green\",\"red\"), lwd=c(2, 2,2,2), lty=c(3, 1,1,1), bty=\"n\", cex=0.9, seg.len=3)\n\nquant_marg2 = apply(model_bart_2$yhat.test, 2, quantile, probs=c(0.025, 0.975)) # plot the 2.5% and 97.5% CI\nplot_ly(x=x, y=y, type=\"scatter\", mode=\"markers\", name=\"Data\") %>%\n  add_trace(x=xtest, y=func(xtest), mode=\"markers\", name=\"True Signal\") %>%\n  add_trace(x=xtest, y=apply(model_bart_2$yhat.test, 2, mean), mode=\"lines\", name=\"Posterior Mean\") %>%\n  add_trace(x=xtest, y=apply(model_bart_2$yhat.test, 2, quantile, probs=c(0.025, 0.975)),\n            mode=\"markers\", name=\"95% CI\") %>%\n  add_trace(x=xtest, y=quant_marg2[1,], mode=\"lines\", name=\"Lower Band\") %>%\n  add_trace(x=xtest, y=quant_marg2[2,], mode=\"lines\", name=\"Upper Band\") %>%\n  layout(title='BART Model (n=3,000)',\n           xaxis = list(title=\"X\", range = c(-1.3, 1.3)),\n           yaxis = list(title=\"Y\", range = c(-0.6, 1.6)),\n           legend = list(orientation = 'h'))",
      "line_count": 29
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "# simulate data\nset.seed(1234)\nn=5000; p=20\nbeta = 3*(1:p)/p\nsig=1.0\nX = matrix(rnorm(n*p), ncol=p) # design matrix)\ny = 10 + X %*% matrix(beta, ncol=1) + sig*rnorm(n) # outcome\ny=as.double(y)\n\nnp=100000\nXp = matrix(rnorm(np*p), ncol=p)\nset.seed(1234)\nt1 <- system.time(model_bart_MD <- \n        wbart(x.train=as.data.frame(X), y.train=y, x.test=as.data.frame(Xp),\n        nkeeptrain=200, nkeeptest=100, nkeeptestmean=500, nkeeptreedraws=100, printevery=1000)\n      )\n\ndim(model_bart_MD$yhat.train)\ndim(model_bart_MD$yhat.test)\nnames(model_bart_MD$treedraws)\n# str(model_bart_MD$treedraws$trees)\n\n# The trees are stored in a long character string and there are 100 draws each consisting of 200 trees.\n\n# To predict using the Multi-Dimensional BART model (MD)\nt2 <- system.time({pred_model_bart_MD2 <- predict(model_bart_MD, as.data.frame(Xp), mc.cores=6)})\n\ndim(pred_model_bart_MD2)\nt1\nt2\n\n# pred_model_bart_MD2 has row dimension equal to the number of kept tree draws (100) and\n# column dimension equal to the number of rows in Xp (100,000).  \n\n# Compare the BART predictions using 1K trees vs. 100 kept trees (very similar results)\n# plot(model_bart_MD$yhat.test.mean, apply(pred_model_bart_MD2, 2, mean),\n#       xlab=\"BART Prediction using 1,000 Trees\", ylab=\"BART Prediction using 100 Kept Trees\")\n# abline(0,1, col=\"red\", lwd=2)\n\nplot_ly() %>%\n  add_trace(x = c(-30,50), y = c(-30,50), type=\"scatter\", mode=\"lines\",\n        line = list(width = 4), name=\"Consistent BART Prediction (1,000 vs. 100 Trees)\") %>%\n  add_markers(x=model_bart_MD$yhat.test.mean, y=apply(pred_model_bart_MD2, 2, mean), \n              name=\"BART Prediction Mean Estimates\", type=\"scatter\", mode=\"markers\") %>%\n  layout(title='Scatter of BART Predictions (1,000 vs. 100 Trees)',\n           xaxis = list(title=\"BART Prediction (1,000 Trees)\"),\n           yaxis = list(title=\"BART Prediction (100 Trees)\"),\n           legend = list(orientation = 'h'))\n\n# Compare BART Prediction to a linear fit  \nlm_func = lm(y ~ ., data.frame(X,y))\npred_lm = predict(lm_func, data.frame(Xp))\n\n# plot(pred_lm, model_bart_MD$yhat.test.mean, xlab=\"Linear Model Predictions\", ylab=\"BART Predictions\",\n#         cex=0.5, cex.axis=1.0, cex.lab=0.8, mgp=c(1.3,.3,0), tcl=-0.2)\n# abline(0,1, col=\"red\", lwd=2)\n\nplot_ly() %>%\n  add_markers(x=pred_lm, y=model_bart_MD$yhat.test.mean, \n              name=\"LM vs. BART Prediction\", type=\"scatter\", mode=\"markers\") %>%\n  add_trace(x = c(-30,50), y = c(-30,50), type=\"scatter\", mode=\"lines\",\n        line = list(width = 4), name=\"Perfectly Consistent LM/BART Prediction\") %>%\n  layout(title='Scatter of Linear Model vs. BART Predictions',\n           xaxis = list(title=\"Linear Model Prediction\"),\n           yaxis = list(title=\"BART Prediction\"),\n           legend = list(orientation = 'h'))",
      "line_count": 66
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "heart_attack<-read.csv(\"https://umich.instructure.com/files/1644953/download?download_frd=1\", \n                       stringsAsFactors = F)\nstr(heart_attack)\n\n# convert the CHARGES (independent variable) to numerical form. \n# NA's are created so let's remain only the complete cases \nheart_attack$CHARGES <- as.numeric(heart_attack$CHARGES)\nheart_attack <- heart_attack[complete.cases(heart_attack), ]\nheart_attack$gender <- ifelse(heart_attack$SEX==\"F\", 1, 0)\nheart_attack <- heart_attack[, -c(1,2,3)]\ndim(heart_attack); colnames(heart_attack)\n\nx.train <- as.matrix(heart_attack[ , -3]) # x training, excluding the charges (output)\ny.train = heart_attack$CHARGES # y=output for modeling (BART, lm, lasso, etc.)\n\n# Data should be standardized for all model-based predictions (e.g., lm, lasso/glmnet), but\n# this is not critical for BART\n\n# We'll just do some random train/test splits and report the out of sample performance of BART and lasso\nRMSE <- function(y, yhat) {\n  return(sqrt(mean((y-yhat)^2)))\n}\n\nnd <- 10 # number of train/test splits (ala CV validation)\nn <- length(y.train)\nntrain <- floor(0.8*n) # 80:20 train:test split each time\n\nRMSE_BART <- rep(0, nd) # initialize BART and LASSO RMSE vectors \nRMSE_LASSO <- rep(0, nd) \n\npred_BART <- matrix(0.0, n-ntrain,nd) # Initialize the BART and LASSO out-of-sample predictions\npred_LASSO <- matrix(0.0, n-ntrain,nd) ",
      "line_count": 32
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "library(glmnet)\nfor(i in 1:nd) {\n   set.seed(1234*i)  \n   # train/test split index\n   train_ind <- sample(1:n, ntrain)\n   \n   # Outcome (CHARGES)\n   yTrain <- y.train[train_ind]; yTest <- y.train[-train_ind]\n   \n   # Features for BART\n   xBTrain <- x.train[train_ind, ]; xBTest <- x.train[-train_ind, ]\n   \n   # Features for LASSO (scale)\n   xLTrain <- apply(x.train[train_ind, ], 2, scale)\n   xLTest <- apply(x.train[-train_ind, ], 2, scale)\n\n   # BART: parallel version of mc.wbart, same arguments as in wbart\n   # model_BART <- mc.wbart(xBTrain, yTrain, xBTest, mc.cores=6, keeptrainfits=FALSE)\n   model_BART <- wbart(xBTrain, yTrain, xBTest, printevery=1000)\n   \n   # LASSO\n   cv_LASSO <- cv.glmnet(xLTrain, yTrain, family=\"gaussian\", standardize=TRUE)\n   best_lambda <- cv_LASSO$lambda.min\n   model_LASSO <- glmnet(xLTrain, yTrain, family=\"gaussian\", lambda=c(best_lambda), standardize=TRUE)\n\n   #get predictions on testing data\n   pred_BART1 <- model_BART$yhat.test.mean\n   pred_LASSO1 <- predict(model_LASSO, xLTest, s=best_lambda, type=\"response\")[, 1]\n  \n    #store results\n   RMSE_BART[i] <- RMSE(yTest, pred_BART1); pred_BART[, i] <- pred_BART1\n   RMSE_LASSO[i] <- RMSE(yTest, pred_LASSO1);   pred_LASSO[, i] <- pred_LASSO1; \n}",
      "line_count": 33
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "# compare the out of sample RMSE measures\n# qqplot(RMSE_BART, RMSE_LASSO)\n# abline(0, 1, col=\"red\", lwd=2)\n\nplot_ly() %>%\n  add_markers(x=RMSE_BART, y=RMSE_LASSO, \n              name=\"\", type=\"scatter\", mode=\"markers\") %>%\n  add_trace(x = c(2800,4000), y = c(2800,4000), type=\"scatter\", mode=\"lines\",\n        line = list(width = 4), name=\"\") %>%\n  layout(title='Scatter of Linear Model vs. BART RMSE',\n           xaxis = list(title=\"RMSE (BART)\"),\n           yaxis = list(title=\"RMSE (Linear Model)\"),\n           legend = list(orientation = 'h'))\n\n# Next compare the out of sample predictions\nmodel_lm <- lm(B ~ L, data.frame(B=as.double(pred_BART), L=as.double(pred_LASSO)))\nx1 <- c(2800,9000)\ny1 <- model_lm$coefficients[1] + model_lm$coefficients[2]*x1\n\n# plot(as.double(pred_BART), as.double(pred_LASSO),xlab=\"BART Predictions\",ylab=\"LASSO Predictions\", col=\"gray\")\n# abline(0, 1, col=\"red\", lwd=2)\n# abline(model_lm$coef, col=\"blue\", lty=2, lwd=3)\n# legend(\"topleft\",legend=c(\"Scatterplot Predictions (BART vs. LASSO)\", \"Ideal Agreement\", \"LM (BART~LASSO)\"),\n#    col=c(\"gray\", \"red\",\"blue\"), lwd=c(2,2,2), lty=c(3,1,1), bty=\"n\", cex=0.9, seg.len=3)\n\nplot_ly() %>%\n  add_markers(x=as.double(pred_BART), y=as.double(pred_LASSO), \n              name=\"BART Predictions vs. Observed Scatter\", type=\"scatter\", mode=\"markers\") %>%\n  add_trace(x = c(2800,9000), y = c(2800,9000), type=\"scatter\", mode=\"lines\",\n        line = list(width = 4), name=\"Ideal Agreement\") %>%\n  add_trace(x = x1, y = y1, type=\"scatter\", mode=\"lines\",\n        line = list(width = 4), name=\"LM (BART ~ LASSO)\") %>%\n  layout(title='Scatter Plot Predictions (BART vs. LASSO)',\n           xaxis = list(title=\"BART Predictions\"),\n           yaxis = list(title=\"LASSO Predictions\"),\n           legend = list(orientation = 'h'))",
      "line_count": 36
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "model_BART_long <- wbart(x.train, y.train, nskip=1000, ndpost=5000, printevery=5000) \n\n# plot(model_BART_long$sigma, xlab=\"Number of Posterior Draws Returned\")\n\nplot_ly() %>%\n  add_markers(x=c(1:length(model_BART_long$sigma)), y=model_BART_long$sigma, \n              name=\"BART vs. LASSO Scatter\", type=\"scatter\", mode=\"markers\") %>%\n  layout(title='Scatter Plot BART Sigma (post burn in draws of sigma)',\n           xaxis = list(title=\"Number of Posterior Draws Returned\"),\n           yaxis = list(title=\"model_BART_long$sigma\"),\n           legend = list(orientation = 'h'))\n\n# plot(model_BART_long$yhat.train.mean, y.train, xlab=\"BART Predicted Charges\", ylab=\"Observed Charges\",\n#      main=sprintf(\"Correlation (Observed,Predicted)=%f\", \n#                          round(cor(model_BART_long$yhat.train.mean, y.train), digits=2)))\n# abline(0, 1, col=\"red\", lty=2)\n# legend(\"topleft\",legend=c(\"BART Predictions\", \"LM (BART~LASSO)\"),\n#    col=c(\"gray\", \"red\",\"blue\"), lwd=c(2,2,2), lty=c(3,1,1), bty=\"n\", cex=0.9, seg.len=3)\n\nplot_ly() %>%\n  add_markers(x=model_BART_long$yhat.train.mean, y=y.train, \n              name=\"BART vs. LASSO Scatter\", type=\"scatter\", mode=\"markers\") %>%\n  add_trace(x = c(2800,9000), y = c(2800,9000), type=\"scatter\", mode=\"lines\",\n        line = list(width = 4), name=\"LM (BART~LASSO)\") %>%\n  layout(title=sprintf(\"Observed vs. BART-Predicted Hospital Charges: Cor(BART,Observed)=%f\", \n                         round(cor(model_BART_long$yhat.train.mean, y.train), digits=2)),\n           xaxis = list(title=\"BART Predictions\"),\n           yaxis = list(title=\"Observed Values\"),\n           legend = list(orientation = 'h'))\n\nind <- order(model_BART_long$yhat.train.mean)\n\n# boxplot(model_BART_long$yhat.train[ , ind], ylim=range(y.train), xlab=\"case\", \n#             ylab=\"BART Hospitalization Charge Prediction Range\")\n\ncaseIDs <- paste0(\"Case\",rownames(heart_attack))\nrowIDs <- paste0(\"\", c(1:dim(model_BART_long$yhat.train)[1]))\ncolnames(model_BART_long$yhat.train) <- caseIDs\nrownames(model_BART_long$yhat.train) <- rowIDs\n\ndf1 <- as.data.frame(model_BART_long$yhat.train[ , ind])\ndf2_wide <- as.data.frame(cbind(index=c(1:dim(model_BART_long$yhat.train)[1]), df1))\n# colnames(df2_wide); dim(df2_wide)\n\ndf_long <- tidyr::gather(df2_wide, case, measurement, Case138:Case8)\n# str(df_long )\n# 'data.frame':\t74000 obs. of  3 variables:\n#  $ index      : int  1 2 3 4 5 6 7 8 9 10 ...\n#  $ case       : chr  \"Case138\" \"Case138\" \"Case138\" \"Case138\" ...\n#  $ measurement: num  5013 3958 4604 2602 2987 ...\n\nactualCharges <- as.data.frame(cbind(cases=caseIDs, value=y.train))\n\nplot_ly() %>%\n  add_trace(data=df_long, y = ~measurement, color = ~case, type = \"box\") %>%\n  add_trace(x=~actualCharges$cases, y=~actualCharges$value, type=\"scatter\", mode=\"markers\",\n            name=\"Observed Charge\", marker=list(size=20, color='green', line=list(color='yellow', width=2))) %>%\n  layout(title=\"Box-and-whisker Plots across all 148 Cases (Highlighted True Charges)\",\n           xaxis = list(title=\"Cases\"),\n           yaxis = list(title=\"BART Hospitalization Charge Prediction Range\"),\n           showlegend=F)",
      "line_count": 61
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "set.seed(1234)\ntrain_index <- sample(seq_len(nrow(mlb)), size = 0.75*nrow(mlb))\nmlb_train <- mlb[train_index, ]\nmlb_test <- mlb[-train_index, ]",
      "line_count": 4
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "#install.packages(\"rpart\")\nlibrary(rpart)\nmlb.rpart <- rpart(Weight~Height+Age, data=mlb_train)\nmlb.rpart",
      "line_count": 4
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "# install.packages(\"rpart.plot\")\nlibrary(rpart.plot)\nrpart.plot(mlb.rpart, digits=3)",
      "line_count": 3
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "rpart.plot(mlb.rpart, digits = 4, fallen.leaves = T, type=3, extra=101)",
      "line_count": 1
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "library(rattle)\nfancyRpartPlot(mlb.rpart, cex = 0.8)",
      "line_count": 2
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "mlb.p <- predict(mlb.rpart, mlb_test)\nsummary(mlb.p)\nsummary(mlb_test$Weight)",
      "line_count": 3
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "cor(mlb.p, mlb_test$Weight)",
      "line_count": 1
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "MAE <- function(obs, pred){\n  mean(abs(obs-pred))\n}\nMAE(mlb_test$Weight, mlb.p)",
      "line_count": 4
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "mean(mlb_test$Weight)\nMAE(mlb_test$Weight, mean(mlb_test$Weight))   # 202.556",
      "line_count": 2
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "#install.packages(\"RWeka\")\n\n# Sometimes RWeka installations may be off a bit, see:\n# http://stackoverflow.com/questions/41878226/using-rweka-m5p-in-rstudio-yields-java-lang-noclassdeffounderror-no-uib-cipr-ma\n\nSys.getenv(\"WEKA_HOME\") # where does it point to? Maybe some obscure path? \n# if yes, correct the variable:\nSys.setenv(WEKA_HOME=\"C:\\\\MY\\\\PATH\\\\WEKA_WPM\")\nlibrary(RWeka)\n# WPM(\"list-packages\", \"installed\")\n\nmlb.m5 <- M5P(Weight~Height+Age, data=mlb_train)\nmlb.m5",
      "line_count": 13
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "summary(mlb.m5)\nmlb.p.m5 <- predict(mlb.m5, mlb_test)\nsummary(mlb.p.m5)\ncor(mlb.p.m5, mlb_test$Weight)\nMAE(mlb_test$Weight, mlb.p.m5)",
      "line_count": 5
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "heart_attack<-read.csv(\"https://umich.instructure.com/files/1644953/download?download_frd=1\", stringsAsFactors = F)\nstr(heart_attack)",
      "line_count": 2
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "heart_attack$CHARGES <- as.numeric(heart_attack$CHARGES)\nheart_attack <- heart_attack[complete.cases(heart_attack), ]\nheart_attack$gender <- ifelse(heart_attack$SEX==\"F\", 1, 0)\nheart_attack <- heart_attack[, -3]",
      "line_count": 4
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "set.seed(1234)\ntrain_index <- sample(seq_len(nrow(heart_attack)), size = 0.75*nrow(heart_attack))\nha_train <- heart_attack[train_index, ]\nha_test <- heart_attack[-train_index, ]\n\nha.m5 <- M5P(CHARGES~., data=ha_train)\nha.pred <- predict(ha.m5, ha_test)\ncor(ha.pred, ha_test$CHARGES)\nMAE(ha_test$CHARGES, ha.pred)",
      "line_count": 9
    },
    {
      "section": "Understanding regression trees and model trees",
      "code": "range(ha_test$CHARGES)\n# 17137- 815\n# 2867.884/16322",
      "line_count": 3
    }
  ]
}