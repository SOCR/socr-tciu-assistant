{
  "metadata": {
    "created_at": "2024-11-30T13:46:17.330421",
    "total_sections": 5,
    "total_code_chunks": 7,
    "total_tables": 1,
    "r_libraries": [
      "dplyr",
      "httr",
      "jsonlite",
      "plotly",
      "purrr",
      "tidyr"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"DSPA2: Data Science and Predictive Analytics (UMich HS650)\"\nsubtitle: \"<u>Appendix 13: Mathematical Modeling and Data Science Analytics of the Duration of Daylight</u>\"\nauthor: \"SOCR/MIDAS (Ivo Dinov)\"\ndate: \"`r format(Sys.time(), '%B %d, %Y')`\"\ntags: [DSPA, SOCR, MIDAS, Big Data, Predictive Analytics] \noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: SOCR_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 3\n    toc_float:\n      collapsed: false\n      smooth_scroll: true\n    code_folding: show\t\nExpanding on [other DSPA2 appendices)](https://dspa2.predictive.space/),\nthis [DSPA2 appendix](https://www.socr.umich.edu/DSPA2/) covers a discussion of building a mathematical model the length/duration of daylight and demonstrating supporting data science analytics for predicting the exact length of daylight (sunset to sunrise) for a given day, longitude, latitude, and altitude. \n\n**Note**: [Part 2 of this DSPA Appendix 13 (Mathematical Modeling and Data Science Analytics of the Duration of Daylight)](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_13_DaylightMathModeling_Part2.html) is intentionally separated as it includes large data and JavaScript code supporting the plotly app. It includes the interactive 3D temporal animation app that allows manual navigation across longitude, latitude, altitude and time (daily).\n\nA model for computing the exact length of daylight (difference between the sunset and sunrise times) for a given day, latitude, longitude, and altitude, must utilize astronomical calculations. This requires converting the *geographic position* into *solar coordinates* and using the [solar declination](https://en.wikipedia.org/wiki/Declination), $\\delta$, for a specific spacetime location and calculating the proper sunrise and sunset times.\n\nThe *solar declination* angle, \\(\\delta\\), represents the latitude at which the Sun is directly overhead at solar noon. It varies throughout the year due to Earth’s tilt and orbit around the Sun. The declination can be approximated by\n\\[\\delta = 23.44^\\circ \\times \\sin\\left(\\frac{2\\pi}{365} \\times (N - 81)\\right),\\]\nwhere \\( N \\) is the day of the year ($N=1$ for January 1, $N=365$ for December 31, for non leap years).\n\nThe *hour angle* (\\(H\\)) is the angle that represents the time difference from solar noon to the point at which the Sun appears on the horizon (sunrise or sunset). At sunrise and sunset, the hour angle \\( H_0 \\) can be calculated by\n\\[H_0 = \\cos^{-1}\\left(\\frac{-\\sin(\\phi) \\cdot \\sin(\\delta)}{\\cos(\\phi) \\cdot \\cos(\\delta)}\\right),\\]\nwhere \\( \\phi \\) is the latitude of the observer and \\(\\delta\\) is the solar declination calculated earlier. \n\nThis formula assumes observation at sea level. However, at elevations above sea level, we need to adjust for *altitude.* For a location at altitude \\( h \\) (in meters), the horizon drops by an angle \\( \\Delta h \\approx -\\frac{\\sqrt{2h/R}}{180/\\pi} \\) radians, where \\( R \\approx 6,371,000 \\, \\text{m} \\) (Earth's radius). The corrected hour angle \\( H_{\\text{alt}} \\) becomes\n\\[H_{\\text{alt}} = \\cos^{-1}\\left(\\frac{-\\sin(\\phi) \\cdot \\sin(\\delta) - \\sin(\\Delta h)}{\\cos(\\phi) \\cdot \\cos(\\delta)}\\right) .\\]\n\nThe *daylight duration* \\( D \\) in hours is twice the time from solar noon to sunset (or sunrise to solar noon), since both are symmetric around solar noon\n\\(D = \\frac{2 H_{\\text{alt}}}{15} ,\\)\nwhere we divide by $15$ because each hour angle degree corresponds to $4$ minutes.\n\nPutting it all together, the daylight duration function \\(D(\\phi, N, h)\\) in hours for a given latitude \\( \\phi \\), day \\( N \\), and altitude \\( h \\) is\n\\[D(\\phi, N, h) = \\frac{2}{15} \\cdot \\cos^{-1}\\left(\\frac{-\\sin(\\phi) \\cdot \\sin\\left(23.44^\\circ \\times \\sin\\left(\\frac{2\\pi}{365} \\times (N - 81)\\right)\\right) - \\sin\\left(-\\frac{\\sqrt{2h/R}}{180/\\pi}\\right)}{\\cos(\\phi) \\cdot \\cos\\left(23.44^\\circ \\times \\sin\\left(\\frac{2\\pi}{365} \\times (N - 81)\\right)\\right)}\\right) ,\\]\nwhere \\( h \\) is in meters (altitude above sea level) and \\( R = 6,371,000 \\) meters is the Earth’s radius.",
      "word_count": 551
    },
    {
      "title": "Example Calculation",
      "content": "For an example location at \\( \\phi = 40^\\circ \\), on the summer solstice (\\( N \\approx 172 \\)), and an altitude of \\( h = 1000 \\) meters\n\n 1. Compute \\( \\delta \\).\n 2. Compute \\( H_{\\text{alt}} \\) using the altitude correction.\n 3. Calculate \\( D \\) using the formula above.",
      "word_count": 52
    },
    {
      "title": "`R` Implementation",
      "content": "Let's write an `R` script that generates an animated 3D geomap of the earth \nwhere mouse over a geographic location (longitude, latitude, altitude) reports\nthe *daylight length* for a given date that is provided by the user with a slider day between $1$ and $365$ (January 1 through December 31). \nThis 3D geomap app requires combining `plotly` with `dplyr` and `purrr` for data processing and animation in R. The approach involves (1) Generate a grid of latitude and longitude values; (2) Calculate the daylight length for each latitude, longitude, and day of the year using the daylight duration formula; and (3) Visualize the daylight length as an animated 3D plot using `plotly`.\n\n\nIn this implementation, the `daylight_duration()` function computes the daylight duration for a given latitude, day of the year, and altitude using the astronomical formula. We generated a 2D grid of *latitudes* and *longitudes* by using `expand.grid`, and daylight length is calculated for each coordinate and day of the year using the functions `mutate()` and `map2_dbl()`. Finally, `plot_ly()` creates a 3D *scatter plot*, `scatter3d`, with color-map reflecting the daylight duration for the spatiotemporal location. The animation frames are used to animate each day, and `sliders` allow users to control the day of the year.",
      "word_count": 205
    },
    {
      "title": "Incorporating Altitude",
      "content": "To make a more topographically-realistic geomap, we need *altitude* data by latitude and longitude. The near-global digital elevation models (DEMs) like the *TessaDEM* dataset or the *ASTER Global Digital Elevation Map (GDEM)*. These datasets provide high-resolution global elevation information, typically covering latitudes from about 84°N to 80°S, with a spatial resolution of approximately 30 meters. For example, TessaDEM combines multiple sources like AW3D30 and MERIT DEM to offer a near-global 3D topographic model, accessible through an *Elevation API* that retrieves altitude data for specific coordinates in JSON format, which would be ideal for integration in data processing workflows.\n\nAlternatively, [ElevationMap.net](https://ElevationMap.net) allows for individual point lookups or programmatic access through their API, letting you retrieve altitude information for specific latitude and longitude coordinates across the globe. This can be helpful to build a more comprehensive dataset with *latitude, longitude*, and *altitude* values.\n This will make your daylight duration model more accurate, accounting for altitude-based variations in sunrise and sunset times. TessaDEM’s API and documentation and ElevationMap.net offer interactive and API-driven altitude lookup options for single or multiple $(lon, lat)$ geo-coordinates.\n\nTo retrieve altitude values for a grid of latitude and longitude points in R, you can use an API like the *TessaDEM Elevation API* or *Open-Elevation API*. These APIs allow you to pull altitude data for multiple geographic coordinates. Below is an example of how to perform this in R using the `httr` and `jsonlite` libraries.\n\n\nWe have pre-loaded the `longitude`, `latitude`, and `altitude` data and the code below, shows the protocol using a coarse version of the triple geo-surface data. For more detailed, higher spatial resolution, and more accurate assessment, we can swap the data accordingly or dynamically pull data from cloud services.\n\nThe static image below shows the 3D geomap of the Earth daylight duration across\nEarth's spatiotemporal coordinates. [Part 2 of this DSPA Appendix 13 (Mathematical Modeling and Data Science Analytics of the Duration of Daylight)](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_13_DaylightMathModeling_Part2.html) includes the interactive 3D temporal animation app that allows manual navigation across longitude, latitude, altitude and time (daily).\n\n![DSPA Appendix 13: Spatiotemporal Global Longitudinal Dynamics of Daylight Length](https://wiki.socr.umich.edu/images/2/2e/DSPA_Appendix13_DaylightLength_DST.png)\n\n\n\n\nNote the use of `expand.grid` to create a data frame (`grid_df` and `grid_df1`) containing each latitude-longitude-altitude triple from the specified grids.\nThe `get_altitude()` function makes a `GET` request to Open-Elevation’s API for each latitude-longitude pair and obtain elevation data in meters.\nUsing `mutate()` with `rowwise()`, the `get_altitude()` function is applied to each coordinate pair in `grid_df`, retrieving altitude values and adding them as a new column.\nWe have saved the data to canvas, as free elevation APIs like Open-Elevation may have request limits. For larger datasets, we can also batch request or pause between requests.\nTessaDEM provides an alternative higher-resolution elevation data but may require setup with access credentials.",
      "word_count": 455
    },
    {
      "title": "Daylight Savings Time",
      "content": "In 1895, New Zealand entomologist [George Hudson](https://en.wikipedia.org/wiki/George_Hudson_(entomologist)) proposed *Daylight Saving Time* (DST) to utilize the extra daylight for collecting insects after work. Later, motivated by the desire to enjoy more daylight in the evenings, the British builder William Willett popularized the idea in 1907. Germany and Austria-Hungary were the first to implement DST on April 30, 1916, as a way to conserve fuel during World War I. Other countries, including the UK and the US, soon adopted DST during the war, with the practice continuing in various forms thereafter, especially in regions with seasonal daylight variations.\n\n*Daylight Saving Time Pros*: \n\n 1. *Energy Conservation*: DST was originally intended to reduce energy usage by extending daylight hours in the evening, reducing the need for artificial lighting and heating.\n 2. *More Daylight for Activities*: Longer daylight hours in the evening encourage outdoor activities and exercise, benefiting physical and mental health.\n 3. *Economic Boost*: Retailers, restaurants, and tourism businesses may see increased activity and sales as people spend more time outside after work.\n 4. *Reduced Traffic Accidents*: Studies suggest that DST can reduce traffic accidents due to better visibility in evening hours.\n\n*Daylight Saving Time Cons*:\n\n 1. *Health Disruptions*: Shifting clocks disrupts circadian rhythms, potentially leading to sleep problems, fatigue, and increased health risks like heart attacks and strokes shortly after the time change.\n 2. *Limited Energy Savings*: Modern research questions DST’s energy-saving benefits due to changes in how we use energy today (e.g., air conditioning in warmer months).\n 3. *Increased Accident Risks*: While evening accidents might decrease, studies show an increase in accidents and workplace injuries immediately following the spring transition due to disrupted sleep.\n 4. *Complexity and Confusion*: Switching clocks can cause logistical issues, particularly in global business and communication, and can be confusing for individuals living near time zone borders.\n\nIn *temperate zones*, where seasonal variations in daylight are more pronounced than the tropical/subtropical areas, but less extreme than the acrtic zones, DST can have tangible benefits by aligning waking hours more closely with daylight hours during spring and summer. This provides more evening light, which is highly valued in regions with shorter winter days, enhancing outdoor leisure and reducing electricity demand for lighting. However, in tropical zones, where day length varies little across the year, DST provides minimal benefit. In temperate regions, DST’s value lies in extending evening daylight during months when daylight hours increase, providing both social and economic benefits during the warmer months when outdoor activities are popular.\n\n## DST - Quantitative Optimization and Inference\n\nTo quantify the benefits of *Daylight Saving Time (DST)* versus *year-round standard time* and transform this into an optimization problem, we can define several objective functions. Each function can measure different aspects of DST's impact. Some of the key categories influencing the perception of benefots to DST include *economic impact*, *health benefits*, *environmental impact*, and *social factors*. \n\nThese objectives can be combined or optimized individually based on specific weights or goals. Below, I outline potential objective functions for each category, discuss how to set up the optimization, and provide example R code to model and optimize these objectives.\n\n### A. Economic Impact\n\n*Objective Function*: Maximize retail and hospitality revenue by aligning business hours with daylight hours.\n \n - Hypothesis: Increased evening daylight under DST boosts consumer spending on leisure activities.\n - *Metric*: \\( f_{\\text{economic}} = \\sum_{t=1}^{T} (S_t \\cdot L_t) \\)\n   - \\( S_t \\): Average spending per hour in the evening.\n   - \\( L_t \\): Number of evening daylight hours.\n  \n### B. Health Benefits\n*Objective Function*: Minimize health risks associated with DST transitions (e.g., sleep disruptions).\n\n - Hypothesis: Sudden time changes disrupt sleep and increase risks of cardiovascular issues and accidents.\n - *Metric*: \\( f_{\\text{health}} = -\\sum_{d=1}^{D} R_d \\)\n   - \\( R_d \\): Risk factor (e.g., accident rate, heart attack risk) on day \\(d\\).\n   - *Optimization*: Minimize \\( f_{\\text{health}} \\) by reducing DST transitions.\n\n### C. Environmental Impact\n*Objective Function*: Minimize energy consumption by aligning active hours with daylight.\n\n - Hypothesis: DST reduces artificial lighting in the evening, but its impact may vary based on modern energy usage.\n - *Metric*: \\( f_{\\text{environment}} = -\\sum_{t=1}^{T} (E_t \\cdot L_t) \\)\n   - \\( E_t \\): Energy saved per hour in the evening.\n   - \\( L_t \\): Number of evening daylight hours.\n\n### D. Social Factors\n*Objective Function*: Maximize time available for outdoor social activities in daylight.\n\n  Hypothesis: Extended daylight supports social well-being by allowing more outdoor activities.\n - *Metric*: \\( f_{\\text{social}} = \\sum_{t=1}^{T} (A_t \\cdot L_t) \\)\n   - \\( A_t \\): Social activity value per hour (e.g., based on participation rates).\n   - *Optimization*: Maximize \\( f_{\\text{social}} \\) by aligning active hours with evening daylight.\n\nLet’s create a *weighted sum* of these objective functions to evaluate the overall benefit\n\\[\\text{Objective} = w_{\\text{economic}} \\cdot f_{\\text{economic}} + w_{\\text{health}} \\cdot f_{\\text{health}} + w_{\\text{environment}} \\cdot f_{\\text{environment}} + w_{\\text{social}} \\cdot f_{\\text{social}} ,\\]\nwhere \\( w_{\\text{economic}}, w_{\\text{health}}, w_{\\text{environment}}, w_{\\text{social}} \\) are weights assigned to each factor based on their importance.\n\nThis is a *multi-objective optimization problem*, but we can solve it as a single-objective problem by tuning the weights.\n\nBelow is an `R` example simulating and optimizing these objective functions. For simplicity, we’ll use hypothetical values.\n\n*Step 1*: Define Parameters and Objective Functions\n\n\n*Step 2*: Optimize by Adjusting Weights or Daylight Hours. Suppose we want to see how different weights impact the total objective.\n\n\n*Step 3*: Optimize Daylight Hours (DST vs Standard Time). To simulate DST’s impact, we can adjust the `L` vector (representing daylight hours) to see how it affects the objective.\n\n\nBy comparing `objective_standard` and `objective_dst`, you can quantify the overall benefit of DST versus year-round standard time under different weight configurations. You can also adjust weights based on priorities (e.g., if health is more important than economic factors) and observe how the optimal choice between DST and standard time shifts.\nThis approach provides a flexible way to simulate and optimize DST’s impact across multiple factors. For a real-world application, replace the random data with actual metrics and refine the objective functions based on empirical evidence.\n\nShow some examples of using the above mathematical model to predict daylight and \nvalidate using real data from [DaylightMap.org](https://daylightmap.org/).\n\n[Part 2 of this DSPA Appendix 13 (Mathematical Modeling and Data Science Analytics of the Duration of Daylight)](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_13_DaylightMathModeling_Part2.html) is intentionally separated as it includes large data and JavaScript code supporting the plotly app. It includes the interactive 3D temporal animation app that allows manual navigation across longitude, latitude, altitude and time (daily).\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number \n\t\t\t\t<img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 1160
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    self_contained: yes\t\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "`R` Implementation",
      "code": "# Load necessary libraries\nlibrary(plotly)\nlibrary(dplyr)\nlibrary(purrr)\n\n# Define the function to compute daylight duration with checks\ndaylight_duration <- function(latitude, day_of_year, altitude = 0) {\n  # Constants\n  R <- 6371000  # Earth's radius in meters\n  \n  # Solar declination angle\n  declination <- 23.44 * sin((2 * pi / 365) * (day_of_year - 81))\n  \n  # Adjust for altitude in radians\n  altitude_correction <- -sqrt(2 * altitude / R) * (180 / pi)\n  \n  # Compute the hour angle argument safely within [-1, 1]\n  hour_angle_arg <- -tan(latitude * pi / 180) * tan(declination * pi / 180) - sin(altitude_correction * pi / 180)\n  hour_angle_arg <- pmax(pmin(hour_angle_arg, 1), -1)\n  \n  # Calculate hour angle\n  hour_angle <- acos(hour_angle_arg)\n  \n  # Calculate daylight duration in hours\n  daylight_hours <- (2 * hour_angle) / (pi / 12)  # Convert radians to hours\n  \n  # Handle cases of 24-hour daylight or darkness near the poles\n  if (hour_angle_arg <= -1) {\n    daylight_hours <- 24  # Continuous daylight\n  } else if (hour_angle_arg >= 1) {\n    daylight_hours <- 0   # Continuous night\n  }\n  \n  return(daylight_hours)\n}\n\n# Define the grid of latitudes and longitudes\nlatitude_grid <- seq(-89, 89, by = 10)\nlongitude_grid <- seq(-180, 180, by = 10)\ndays <- 1:365\n\n# Calculate daylight duration for each (latitude, longitude, day)\ndata <- expand.grid(latitude=latitude_grid, longitude=longitude_grid, day=days) %>%\n  mutate(daylight = map2_dbl(latitude, day, ~daylight_duration(.x, .y)))\n\n# Create plotly animation\nfig <- plot_ly(data = data, x = ~longitude, y = ~latitude, z = ~daylight,\n               color = ~daylight, colors = \"Blues\",\n               frame = ~day, type = \"scatter3d\", mode = \"markers\",\n               marker = list(size = 3)) %>%\n  layout(scene = list(\n    xaxis = list(title = \"Longitude\"),\n    yaxis = list(title = \"Latitude\"),\n    zaxis = list(title = \"Daylight Hours\")),\n    title = \"Daylight Length Over Earth Throughout the Year\"\n    # , sliders = list(\n    #   list(pad = list(t = 50),\n    #     currentvalue = list(visible = TRUE, prefix = \"Day of Year: \"),\n    #     steps = lapply(1:365, function(i) list(label = i, method = \"animate\", args = list(list(frame = i))))\n    #   )\n    # )\n  )\nfig # Show the plot",
      "line_count": 63
    },
    {
      "section": "`R` Implementation",
      "code": "# Load necessary libraries\nlibrary(plotly)\nlibrary(dplyr)\nlibrary(purrr)\n\n# Define the function to compute daylight duration with checks\ndaylight_duration <- function(latitude, day_of_year, altitude = 0) {\n  # Constants\n  R <- 6371000  # Earth's radius in meters\n  \n  # Solar declination angle\n  declination <- 23.44 * sin((2 * pi / 365) * (day_of_year - 81)) \n  # Should 81 be 81.25 to account for leap years?\n  \n  # Adjust for altitude in radians\n  altitude_correction <- -sqrt(2 * altitude / R) * (180 / pi)\n  \n  # Compute the hour angle argument safely within [-1, 1]\n  hour_angle_arg <- -tan(latitude * pi / 180) * tan(declination * pi / 180) - sin(altitude_correction * pi / 180)\n  hour_angle_arg <- pmax(pmin(hour_angle_arg, 1), -1)\n  \n  # Calculate hour angle\n  hour_angle <- acos(hour_angle_arg)\n  \n  # Calculate daylight duration in hours\n  daylight_hours <- (2 * hour_angle) / (pi / 12)  # Convert radians to hours\n  \n  # Handle cases of 24-hour daylight or darkness near the poles\n  if (hour_angle_arg <= -1) { daylight_hours <- 24  # Continuous daylight\n  } else if (hour_angle_arg >= 1) {  daylight_hours <- 0   # Continuous night\n  }\n  \n  return(daylight_hours)\n}\n\n# Define the grid of latitudes and longitudes\nlatitude_grid <- seq(-90, 90, by = 5)\nlongitude_grid <- seq(-180, 180, by = 5)\ndays <- 1:365\n\n# Calculate daylight duration for each (latitude, longitude, day)\ndata <- expand.grid(latitude=latitude_grid, longitude=longitude_grid, day=days) %>%\n  mutate(daylight = map2_dbl(latitude, day, ~daylight_duration(.x, .y)))\n\ng2 <- list(projection = list(type = 'orthographic'),\n    showland = TRUE, landcolor = \"lightgray\", lakecolor = \"lightblue\")\n\nfig <- plot_ly(data = data, type = 'scattergeo', mode = 'markers',\n               lat = ~latitude, lon = ~longitude, frame = ~day,\n               marker = list(size = 6, opacity = 0.95), color = ~(daylight),\n               colors = \"RdYlBu\", # https://plotly.com/r/builtin-colorscales/\n               label = data$daylight, text = data$day,\n               hovertemplate = paste('<i>Latitude</i>: %{lat:.2f}',\n                                     '<br><i>Longitude</i>: %{lon:.2f}',\n                                     '<br><i>Day</i>: %{text}',\n                                     '<br><i>Daylight</i>: %{marker.color:.2f}',\n                                     '<extra></extra>'),\n               showlegend = FALSE) %>%\n    layout(geo = g2, title = \"Daylight Length Over Earth Throughout the Year\",\n        coloraxis = list(colorbar = list(title = \"Daylight Hours\")))\nfig # Show the plot",
      "line_count": 61
    },
    {
      "section": "Incorporating Altitude",
      "code": "# Install necessary packages if not already installed\n# install.packages(c(\"httr\", \"jsonlite\", \"dplyr\"))\n# Load required libraries\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(dplyr)\nlibrary(purrr)\n\n# Define the latitude and longitude grid - LOW resolution\nlatitude_grid <- seq(-85, 85, by = 10)\nlongitude_grid <- seq(-180, 180, by = 10)\n# for HIGHER resolution, use\n# latitude_grid <- seq(-85, 85, by = 5)\n# longitude_grid <- seq(-180, 180, by = 5)\n\n# Create a data frame to store the grid\ngrid_df <- expand.grid(latitude = latitude_grid, longitude = longitude_grid)\n# grid_df <- expand.grid(latitude = latitude_grid[8:17], longitude = longitude_grid[20:30])\n\n# Read from local file\n# d <- read.csv(file=\"C:/Users/IvoD/Desktop/DaylightDataset_Long_Lat_Alt_2024.csv\",\n#               header = TRUE)\n\n# Or pull from Elevation API service: Define the base URL for the Open-Elevation API\nbase_url <- \"https://api.open-elevation.com/api/v1/lookup\"\n\n# Function to get altitude for a single latitude and longitude\nget_altitude <- function(lat, lon) {\n  response <- GET(base_url, query = list(locations = paste(lat, lon, sep = \",\")))\n  # Parse JSON response\n  data <- fromJSON(content(response, as = \"text\", encoding = \"UTF-8\"))\n  # str(data$results)\n  # Extract the altitude value\n  if (!is.null(data$results)) {\n    # return(data$results[[1]]$elevation)\n    return(data$results$elevation)\n  } else {\n    return(NA)  # Return NA if no data is available\n  }\n}\n\n# Apply the function to each row in the grid_df\ngrid_df1 <- grid_df %>%\n  rowwise() %>%\n  mutate(altitude = get_altitude(latitude, longitude)) %>%\n  ungroup()\n\n# write.csv(grid_df1, file=\"C:/Users/IvoD/Desktop/DaylightDataset_Long_Lat_Alt_HighRes2024.csv\")\n\n# hist(grid) # View the results\n# head(grid_df$altitude)\n\n# Calculate daylight duration for each (latitude, longitude, day)\ndata <- grid_df1 %>% \n  expand.grid(latitude = latitude_grid, longitude = longitude_grid, day = days) %>%\n  mutate(altitude = map2_dbl(latitude, longitude, ~get_altitude(.x, .y))) %>%  # Retrieve altitude\n  mutate(daylight = pmap_dbl(list(latitude, day, altitude), ~daylight_duration(..1, ..2, ..3)))\n\n\n# Finally plot the 3D geo-map\n# Define geo settings for orthographic projection\ng2 <- list(\n  projection = list(type = 'orthographic'),\n  showland = TRUE,\n  landcolor = \"lightgray\",\n  lakecolor = \"lightblue\"\n)\n\n# Plotly code with altitude included in the hovertemplate\nfig <- plot_ly(data = data, type = 'scattergeo', mode = 'markers',\n               lat = ~latitude, lon = ~longitude, frame = ~day,\n               # marker = list(size = 6, opacity = 0.95), color = ~(daylight),\n               marker = list(size = ~(altitude/1000), opacity = 0.95), color = ~(daylight),\n               colors = \"RdYlBu\", text = data$day, \n               hovertemplate = paste(\n                 '<i>Latitude</i>: %{lat:.2f}', '<br><i>Longitude</i>: %{lon:.2f}',\n                 '<br><i>Altitude (m)</i>: %{customdata:.2f}',  # Show altitude in meters\n                 '<br><i>Day</i>: %{text}', '<br><i>Daylight Hours</i>:\n                 %{marker.color:.2f}', '<extra></extra>'),\n               customdata = ~altitude,  # Add altitude data for use in hovertemplate\n               showlegend = FALSE) %>%\n  layout(geo = g2, title = \"Daylight Length Over Earth Throughout the Year\",\n    coloraxis = list(colorbar = list(title = \"Daylight Hours\"))  )\nfig  # Show the plot",
      "line_count": 84
    },
    {
      "section": "Incorporating Altitude",
      "code": "# Load necessary libraries\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(plotly)\nlibrary(tidyr)\n\n# Assume location_data is the pre-existing data frame with columns: latitude, longitude, altitude\n# Example structure of location_data:\n# location_data <- data.frame(\n#   latitude = c(-90, -80, -70, -60, -50),\n#   longitude = c(-180, -180, -180, -180, -180),\n#   altitude = c(0, 0, 0, 0, 0)\n# )\n\nlocation_data <- # download the low geospatial resolution lon-lat-alt data\n  read.csv(\"https://umich.instructure.com/files/37840607/download?download_frd=1\", \n            header = TRUE)\n\n# Define the days of the year\ndays <- 1:365\n\n# Function to calculate daylight duration, including altitude\ndaylight_duration <- function(latitude, day_of_year, altitude) {\n  if (is.na(latitude) || is.na(day_of_year) || is.na(altitude)) {\n    return(NA)  # Return NA if any input is missing\n  }\n  \n  R <- 6371000  # Earth's radius in meters\n  \n  # Solar declination angle\n  declination <- 23.44 * sin((2 * pi / 365) * (day_of_year - 81))\n  \n  # Altitude correction in radians, only for positive altitudes\n  if (altitude > 0) {\n    altitude_correction <- -sqrt(2 * altitude / R) * (180 / pi)\n  } else {\n    altitude_correction <- 0  # No correction for sea level or below\n  }\n  \n  # Calculate hour angle argument, clamped within [-1, 1]\n  hour_angle_arg <- -tan(latitude * pi / 180) * tan(declination * pi / 180) -\n    sin(altitude_correction * pi / 180)\n  hour_angle_arg <- pmax(pmin(hour_angle_arg, 1), -1)\n  \n  # Calculate hour angle\n  hour_angle <- acos(hour_angle_arg)\n  \n  # Calculate daylight duration in hours\n  daylight_hours <- (2 * hour_angle) / (pi / 12)  # Convert radians to hours\n  \n  # Handle cases of 24-hour daylight or darkness\n  if (hour_angle_arg <= -1) { daylight_hours <- 24  # Continuous daylight\n  } else if (hour_angle_arg >= 1) { daylight_hours <- 0   # Continuous night\n  }\n  \n  return(daylight_hours)\n}\n\n\n# Calculate daylight duration for each (latitude, longitude, day) combination\ndaylight_data <- location_data %>%  rowwise() %>%\n  mutate(daylight = list(sapply(days, function(day) \n    daylight_duration(latitude, day, altitude)))) %>%\n  unnest_wider(daylight, names_sep = \"_\") %>% ungroup()\n\n# Convert days of the year to actual dates\n# Define the starting date (e.g., January 1, 2024)\nstart_date <- as.Date(\"2024-01-01\")\n\n# Convert days of the year to actual dates\ndaylight_data_long <- daylight_data %>%\n  pivot_longer(cols = starts_with(\"daylight_\"), names_to = \"day\", \n               values_to = \"daylight_hours\") %>%\n  mutate(day = as.numeric(gsub(\"daylight_\", \"\", day)))  # Extract numeric day\n\n\n# daylight_data_long <- daylight_data_long %>%\n#   mutate(date = start_date + (day - 1))  # Convert day number to actual date\n\n# Create a combined label for \"Day X - Date\"\ndaylight_data_long <- daylight_data_long %>%\n  mutate(day_label = paste(\"Day\", day, \"-\", format(date, \"%B %d, %Y\")))  # Combine day number and date\n\n# Define the starting date (e.g., January 1, 2024)\nstart_date <- as.Date(\"2024-01-01\")\n\n# Convert days of the year to actual dates\ndaylight_data_long <- daylight_data_long %>%\n  mutate(date = start_date + (day - 1))  # Convert day number to actual date\n\n# Create a combined label for \"Day X - Date\"\ndaylight_data_long <- daylight_data_long %>%\n  mutate(day_label = paste(\"Day\", day, \"-\", format(date, \"%B %d, %Y\")))  # Combine day number and date\n# Format the date as \"Month Day, Year\" for display in the tooltip\ndaylight_data_long <- daylight_data_long %>%\n  mutate(date_text = format(date, \"%B %d, %Y\"))  # Format as \"Month Day, Year\"\n\n\n# Plotly code with updated frame to display day and date in slider\nfig <- plot_ly(data = daylight_data_long, type = 'scattergeo', mode = 'markers',\n  lat=~latitude, lon=~longitude, frame=~day_label,  # Use combined day and date label for frame\n  marker = list(size = 6, opacity = 0.95), color = ~daylight_hours, colors = \"RdYlBu\",\n  customdata = ~altitude,  # Altitude data for tooltip\n  hovertemplate = paste('<i>Latitude</i>: %{lat:.2f}', '<br><i>Longitude</i>: %{lon:.2f}',\n                        '<br><i>Altitude (m)</i>: %{customdata:.2f}',  \n                        '<br><i>Date</i>: %{text}',  # Display formatted date\n                        '<br><i>Daylight Hours</i>: %{marker.color:.2f}',\n                        '<extra></extra>'),\n  text = ~date_text,  # Assign date_text to the `text` property for hovertemplate\n  showlegend = FALSE) %>%\n  layout(geo = g2,\n    title = list(text = \"Daylight Length Over Earth Throughout the Year\"),  # Set title in list format\n    coloraxis = list(colorbar = list(title = \"Daylight Hours\"))  # Adjust coloraxis for colorbar\n  )\n\nfig  # Show the plot",
      "line_count": 116
    },
    {
      "section": "Daylight Savings Time",
      "code": "# Set up weights for each objective (adjust based on importance)\nweights <- c(economic = 0.4, health = 0.3, environment = 0.2, social = 0.1)\n\n# Hypothetical data (values would ideally come from real data sources)\nset.seed(123)\nT <- 24  # Number of hours in a day\nD <- 365  # Number of days in a year\n\n# Generate random values representing hourly metrics across days\nS <- runif(T, 100, 300)  # Spending per hour\nR <- rnorm(D, mean = 1.2, sd = 0.5)  # Risk factor per day (health impact)\nE <- runif(T, 10, 50)  # Energy saved per hour\nA <- runif(T, 0.2, 1)  # Social activity value per hour\nL <- ifelse(6 <= 1:T & 1:T <= 18, 1, 0)  # Daylight hours (6am-6pm)\n\n# Define the objective functions\nf_economic <- sum(S * L)  # Economic impact\nf_health <- -sum(R)  # Health impact (minimized)\nf_environment <- -sum(E * L)  # Environmental impact\nf_social <- sum(A * L)  # Social impact\n\n# Aggregate objective\nobjective <- weights[\"economic\"] * f_economic +\n             weights[\"health\"] * f_health +\n             weights[\"environment\"] * f_environment +\n             weights[\"social\"] * f_social\nobjective",
      "line_count": 27
    },
    {
      "section": "Daylight Savings Time",
      "code": "# Define a function to compute objective given weights\ncompute_objective <- function(w) {\n  w[\"economic\"] * f_economic +\n    w[\"health\"] * f_health +\n    w[\"environment\"] * f_environment +\n    w[\"social\"] * f_social\n}\n\n# Try different weight configurations\nweights_list <- list(\n  c(economic = 0.5, health = 0.2, environment = 0.2, social = 0.1),\n  c(economic = 0.3, health = 0.4, environment = 0.2, social = 0.1),\n  c(economic = 0.2, health = 0.3, environment = 0.4, social = 0.1)\n)\n\n# Evaluate the objective for each weight configuration\nobjectives <- sapply(weights_list, compute_objective)\nobjectives",
      "line_count": 18
    },
    {
      "section": "Daylight Savings Time",
      "code": "# Simulate Standard Time (6am-6pm daylight)\nL_standard <- ifelse(6 <= 1:T & 1:T <= 18, 1, 0)\n\n# Simulate DST (shift daylight to 7am-7pm)\nL_dst <- ifelse(7 <= 1:T & 1:T <= 19, 1, 0)\n\n# Recalculate objectives\nf_economic_standard <- sum(S * L_standard)\nf_economic_dst <- sum(S * L_dst)\n\nf_environment_standard <- -sum(E * L_standard)\nf_environment_dst <- -sum(E * L_dst)\n\nf_social_standard <- sum(A * L_standard)\nf_social_dst <- sum(A * L_dst)\n\n# Calculate objective values\nobjective_standard <- weights[\"economic\"] * f_economic_standard +\n              weights[\"health\"] * f_health +  # Health is unaffected by DST in this setup\n              weights[\"environment\"] * f_environment_standard +\n              weights[\"social\"] * f_social_standard\n\nobjective_dst <- weights[\"economic\"] * f_economic_dst +\n              weights[\"health\"] * f_health +  # Health is unaffected by DST in this setup\n              weights[\"environment\"] * f_environment_dst +\n              weights[\"social\"] * f_social_dst\n\n# Print results\nobjective_standard\nobjective_dst",
      "line_count": 30
    }
  ]
}