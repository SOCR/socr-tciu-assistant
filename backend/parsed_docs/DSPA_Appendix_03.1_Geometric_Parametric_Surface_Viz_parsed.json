{
  "metadata": {
    "created_at": "2024-11-30T13:46:16.935975",
    "total_sections": 3,
    "total_code_chunks": 10,
    "total_tables": 1,
    "r_libraries": [
      "magrittr",
      "numDeriv",
      "plotly",
      "scales"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"DSPA2: Data Science and Predictive Analytics (UMich HS650)\"\nsubtitle: \"<h2><u>Geometric and Parametric Surface Visualization</u></h2>\"\nauthor: \"<h3>SOCR/MIDAS (Ivo Dinov)</h3>\"\ndate: \"`r format(Sys.time(), '%B %Y')`\"\ntags: [DSPA, SOCR, MIDAS, Big Data, Predictive Analytics] \noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: ../SOCR_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 3\n    toc_float:\n      collapsed: false\n\n\nThis DSPA section Appendix.3.1 (Primitive Surfaces with and without Boundaries) is part of the [DSPA Appendix on visualization of geometric and parametric surfaces](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_03_Geometric_Parametric_Surface_Viz.html). This DSPA Appendix (3) covers the following 3 topics:\n\n - 3.1. Geometric Primitive Surfaces with and without Boundaries (this section)\n    + 1.1 Saddle Point Surface\n    + 1.2 Geometric Shapes: 3D Spherical Parameterization\n    + 1.3 Parametric Torus Surface\n - [3.2. Non-Orientable Surfaces](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_03.2_Geometric_Parametric_Surface_Viz.html)\n    + 2.1 Mobius Band Triangulation\n    + 2.2 Klein Bottle\n - [3.3. Brain Surfaces](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_03.3_Geometric_Parametric_Surface_Viz.html)\n    + 3.1 Human Brain\n    + 3.2 Rodent Brain\n - 3.4 [Time-varying surface embedding of 4D manifolds in 3D](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_03.4_Geometric_Parametric_Surface_Viz.html)",
      "word_count": 146
    },
    {
      "title": "(Section 3.1) Geometric Primitive Surfaces with and without Boundaries",
      "content": "## Saddle Point Surface\n\nA [saddle point](https://en.wikipedia.org/wiki/Saddle_point) is a point on the surface represented by a function $z=z(x,y)$, where the gradient slopes (partial derivatives) of orthogonal function components defining the surface are trivial ($0$), however the point does not represent a local extremum on both axes, as may be expected. We already showed a simple example of a saddle point earlier, which we rendered as a `surface`. Now we will illustrate the parametric definition of a surface with a saddle point and its triangulated representation as a  `mesh3d`.\n\n\n## Geometric Shapes: 3D Spherical Parameterization\n\nBelow, we show three complementary examples of rendering synthetic geometric shapes; convex shapes (*cone*, *sphere*) and a non-convex surface (*complex*). It's worthwhile reviewing the [fundamentals of the spherical coordinate system representation](https://en.wikipedia.org/wiki/Spherical_coordinate_system).\n\n\nThe next example shows a **bumpy** surface parameterized in spherical coordinates. [Complex-time indexed kimesurfaces, which extend time-series data in 5D spacekime](https://spacekime.org/), represent examples of such polar and spherical parameterizations of 2D manifolds. Mind the outer product $\\%o\\%$ operator that takes two vectors and generates their *outer product* as a second order tensor (i.e., a matrix). This example displays the parametric surface modeled by this function:\n$$\\rho=f(\\phi,\\theta) = 1 + \\frac{1}{5}\\left (\\sin(5\\phi)\\ \\%o\\%\\ \n\\sin(7\\theta)\\right ) .$$\n\n\n## Cartesian Parameterization\n\nLet's demonstrate how to visualize as a surface in 3D a 2-parameter (Cartesian parametrization) function:\n\n$$z=f(x,y) = (x-3)^2 +(y+4)^2 + x\\ y .$$\nFirst, we will introduce the Cartesian parametrization of the $(x,y)\\in D=\\{-10\\leq x,y\\leq 10\\} \\subset\\Re^2$ domain. This will be done by steps of size $1$. Next we will express the symbolic definition of the function $z=f(x,y)$. To plot the function using `plotly`, we will need to define the surface density (height, $z$) as an outer product defined on the $(x,y)$ grid, see `outer()` function. In the previous section, we showed how to use polar coordinate parametric grids. Mind that the $z$ array needs to be transformed, as `R` stores matrices in column-wise order (not row-wise). Hence the function we actually plot is $t(z)=z^t$.\n\n\n## Non-Convex Surfaces\n\n### Torus\n\nA horizontal torus revolves around the z axis and is specified by two radii $a$ and $r$. A simple toral surface parameterization is\n\n$$x = (a + r \\cos(\\phi)) \\cos(\\psi),$$\n$$y = (a + r \\cos(\\phi)) \\sin(\\psi),$$\n$$z = r \\sin(\\phi),$$\nwhere $\\phi,\\psi \\in [0, 2\\pi)$ represent the angles about the z axis and about its core.\n\nWhen $a > r$, the torus does not intersect itself and the points on the torus satisfy\n$$\\left ( a - \\sqrt{x^2 + y^2}\\right )^2 + z^2 = r^2.$$\nThe 2D-torus is a 2-manifold (a surface) generated by revolving a circle in 3D about a given axis coplanar with the circle. Torus is the shape of an inner-tube; it is different from a solid torus, such as a doughnut or a bagel. The Torus is the boundary of a solid torus. It is homeomorphic to the Cartesian product of two circles $S^1 \\times S^1$ and represents a compact 2-manifold of genus 1. \n\n\nWe can introduce a checkerboard pattern on a coarser (parametric) surface representation of the torus.\n\n\nLet's go a step further and visualize a parametric curve on the torus.\n\n\n### Objective function optimization\n\n[Non-convex optimization is an NP-hard problem that is very difficult to solve in general](https://socr.umich.edu/DSPA2/DSPA2_notes/21_FunctionOptimization.html). The example below illustrates such non-convex optimization using complex surfaces. The `plot_ly` graph below shows an interactive surface plot of the objective function along with the trajectories of several optimization-solutions. Mind the different optimization trajectories that may either smoothly approach the local minima (surface sulci or valleys) or rapidly switch between neighboring surface slopes or even jump across different crests.\n\n\n### Human face mask surface\n\nThe [(x,y,z) coordinates of a 3D surface representing a face mask are available here (CSV)](https://umich.instructure.com/files/13417342/download?download_frd=1). We can display this (non-convex) surface in 3D using `plot_ly()`.",
      "word_count": 628
    },
    {
      "title": "References",
      "content": "* [Back to the DSPA visualization of geometric and parametric surfaces Appendix](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_03_Geometric_Parametric_Surface_Viz.html).\n* Additional [brain surface data are available online](http://www.freesurfer.net/pub/data/tutorial_data/long-tutorial/).\n* [R plot_ly documentation and details are available here](https://plot.ly/r/).\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number \n\t\t\t\t<img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 124
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "      smooth_scroll: true\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "knitr::opts_chunk$set(echo = TRUE)",
      "line_count": 1
    },
    {
      "section": "(Section 3.1) Geometric Primitive Surfaces with and without Boundaries",
      "code": "library(plotly)\nlibrary (geometry)\n\n# Plotly layout \naxs <- list(\n  backgroundcolor=\"rgb(200,200,200)\", # gray\n  gridcolor=\"rgb(255,255,255)\",       # white\n  showbackground=TRUE,\n  zerolinecolor=\"rgb(255,255,255)\"     # white\n)\n\nn <- 36\nh <- 1/(n-1)\nr = seq(h, 1, length.out=n)\ntheta = seq(0, 2*pi, length.out=100)\n \ngrid.df <- expand.grid(r=r, theta=theta)\n \nx <- c(grid.df$r * cos(grid.df$theta), 0)\ny <- c(grid.df$r * sin(grid.df$theta), 0)\nz <- sin(x*y)\n \nmat <- matrix(\n  c(x,y,z), \n  ncol = 3,\n  dimnames = list(NULL, c(\"x\", \"y\", \"z\"))\n)\n \ntriangulated <- delaunayn(mat[,1:2])\n \n# now figure out the colormap\nzmean <- apply(triangulated, MARGIN=1, function(row){mean(mat[row,3])})\n \nlibrary(scales)\n\nfacecolor = colour_ramp(\n  colorRampPalette(c(\"pink\", \"purple\"))(20)\n)(rescale(x=zmean))\n \nplot_ly(\n  x=x, y=y, z=z,\n  i=triangulated[,1]-1, j=triangulated[,2]-1, k=triangulated[,3]-1,\n  facecolor=facecolor,\n  type=\"mesh3d\",\n  opacity = 0.7,\n  contour=list(show=TRUE, color=\"#000\", width=15)\n) %>%\n  layout(\n    title=\"Triangulated Saddle Point surface\",\n    scene=list(\n      xaxis=axs,\n      yaxis=axs,\n      zaxis=axs,\n      camera=list(\n        eye=list(x=1.75,y=-0.7,z=0.75)\n      )\n    )\n  )\n",
      "line_count": 59
    },
    {
      "section": "(Section 3.1) Geometric Primitive Surfaces with and without Boundaries",
      "code": "# library(plotly)\n\n# sweep or define (u,v) spherical coordinate parameter ranges\nphi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(200 - 1)))\npsi <- seq(from = 0, to = pi, by = ((pi - 0)/(200 - 1)))\n\n#p <- plot_ly(x = ~x, y = ~y, z = ~z, type = 'surface', opacity=1,\n#             contour=list(show=TRUE, color=\"#000\", width=15, lwd=10))  %>%\n#  layout(title = paste(\"Layout \", shape), \n#         scene = list(xaxis=x_label,yaxis=y_label, zaxis=z_label))\n#p\n\n# shape==\"complex\")\n    # rendering (u,v) parametric surfaces requires x,y,z arguments to be 2D arrays\n    # In out case, the three coordinates have to be 200*200 parameterized tensors/arrays\n    r1 = 2 + sin(3 * phi + 5 * psi)    # r = 2 + sin(7phi+5psi)\n    x1 = (r1 * cos(phi)) %o% sin(psi)    # x = r*cos(phi)*sin(psi)\n    y1 = (r1 * sin(phi)) %o% sin(psi)     # y = r*sin(phi)*sin(psi)\n    z1 = r1 %o% cos(psi)  # z = r*cos(psi)\n    \n#shape==\"cone\")\n    h2= 10   # cone height\n    r2 = seq(from = 0, to = h2, by = ((h2 - 0)/(200 - 1)))  # r = radius\n    x2 = 3* ((h2 - r2)/h2 ) %o% rep(1, 200)             # x = 3*r\n    y2 = 3* ((h2 - r2)/h2 ) %o% sin(phi)   # y = r*sin(phi)\n    z2 = 3* ((h2 - r2)/h2 ) %o% cos(phi)   # z = r*cos(phi)\n\n#shape==\"sphere\") \n    r3 = 1                           # r = 1\n    x3 = r3 * cos(phi) %o% sin(psi)   # x = r*cos(phi)*sin(psi)\n    y3 = r3 * sin(phi) %o% sin(psi)   # y = r*sin(phi)*sin(psi)\n    z3 = r3 * rep(1, 200) %o% cos(psi) # still need z to be 200*200 parameterized tensor/array\n\nshape_names <- c(\"complex\", \"cone\", \"sphere\")\n\n# https://plot.ly/r/custom-buttons/\n\n#p <- plot_ly(x = ~x, y = ~y, z = ~z, type = 'surface', opacity=1,\n#             contour=list(show=TRUE, color=\"#000\", width=15, lwd=10),\n#             layout=layout_shapes)\n\n# updatemenus component\nupdatemenus <- list(\n  list(\n    active = -1,\n    type = 'buttons',\n    buttons = list(\n      list(\n        label = shape_names[1],\n        method = \"update\",\n        args = list(list(visible = c(TRUE, FALSE, FALSE)),\n                    list(title = shape_names[1]))),\n      list(\n        label = shape_names[2],\n        method = \"update\",\n        args = list(list(visible = c(FALSE, TRUE, FALSE)),\n                    list(title = shape_names[2]))),\n      list(\n        label = shape_names[3],\n        method = \"update\",\n        args = list(list(visible = c(FALSE, FALSE, TRUE)),\n                    list(title = shape_names[3])))\n    )\n  )\n)\n\np <- plot_ly(hoverinfo=\"none\", legendshow=FALSE, showscale = FALSE) %>%\n  add_trace(x = ~x1, y = ~y1, z = ~z1, type = 'surface', opacity=1, visible=T,\n             contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n                          opacity=1.0, hoverinfo=\"none\", legendshow=F)) %>%\n  add_trace(x = ~x2, y = ~y2, z = ~z2, type='surface', opacity=1,visible=F,\n             contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n                          opacity=1.0, hoverinfo=\"none\", legendshow=F)) %>%\n  add_trace(x = ~x3, y = ~y3, z = ~z3, type = 'surface', opacity=0.7,visible=F,\n             contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n                          opacity=0.7, hoverinfo=\"none\", legendshow=F)) %>%\n  layout(title = \"Choose a Shape\", showlegend = FALSE,\n         updatemenus = updatemenus)\np",
      "line_count": 79
    },
    {
      "section": "(Section 3.1) Geometric Primitive Surfaces with and without Boundaries",
      "code": "library(plotly)\nphi <- seq(from = 0, to = 2*pi, length.out = 200)\ntheta <- seq(from = 0, to = pi/3, length.out = 200)\n\nr1 = 1 + sin(5*phi) %o% (sin(7*theta)/5) # 2 + sin(3 * phi + 5 * theta)\nx1 = r1 * (cos(phi) %o% sin(theta))    # x = r*cos(phi)*sin(theta)\ny1 = r1 * (sin(phi) %o% sin(theta))     # y = r*sin(phi)*sin(theta)\nz1 = r1 * (cos(theta) %o% rep(1,200))  # z = r*cos(theta)\nsurf_color1= phi %o% rep(1,200)\ncolorscale = cbind(seq(0, 1, by=1/(length(phi) - 1)), rainbow(length(phi)))\n\n# Add Angular and Radial (polar-mesh) traces\n# phi <- seq(from = 0, to = 2*pi, length.out = 10)\n# theta <- seq(from = 0, to = pi/3, length.out = 8)\nr = 1 + sin(5*phi) %o% (sin(7*theta)/5) # 2 + sin(3 * phi + 5 * theta)\nx = r * (cos(phi) %o% sin(theta))    # x = r*cos(phi)*sin(theta)\ny = r * (sin(phi) %o% sin(theta))     # y = r*sin(phi)*sin(theta)\nz = r * (cos(theta) %o% rep(1,200))  # z = r*cos(theta)\n\n# Radial (Time) mesh curves\ncount <- 50\nphi <- seq(from = 0, to = 2*pi, length.out = count)\ntheta <- seq(from = 0, to = pi/3, length.out = count)\nx <- array(1, dim=c(count*count))\ny <- array(1, dim=c(count*count))\nz <- array(1, dim=c(count*count))\nr <- array(1, dim=c(count*count))\nopaque <-  array(1, dim=c(count*count))\n\nfor (i in 1:count) {  # phi\n  for (j in 1:count) { # theta\n    r[(i-1)*count+j] <- 1 + sin(5*phi[i]) * (sin(7*theta[j])/5)\n    x[(i-1)*count+j] <- r[(i-1)*count+j] * (cos(phi[i]) * sin(theta[j]))\n    y[(i-1)*count+j] <- r[(i-1)*count+j] * (sin(phi[i]) * sin(theta[j]))\n    z[(i-1)*count+j] <- r[(i-1)*count+j] * cos(theta[j])\n    opaque[(i-1)*count+j] <- ifelse(j==10, 0, 1)\n  }\n}\nlength(x); length(y); length(r); dim(z); dim(opaque)\n\n# Angular (Phase) mesh curves\ncount <- 50 # theta\nphi <- seq(from = 0, to = 2*pi, length.out = count)\ntheta <- seq(from = 0, to = pi/3, length.out = count)\nx2 <- array(1, dim=c(count*count))\ny2 <- array(1, dim=c(count*count))\nz2 <- array(1, dim=c(count*count))\nr2 <- array(1, dim=c(count*count))\nfor (i in 1:count) {  # phi\n  for (j in 1:count) { # theta\n    r2[(i-1)*count+j] <- 1 + sin(5*phi[i]) * (sin(7*theta[j])/5)\n    x2[(i-1)*count+j] <- r2[(i-1)*count+j] * (cos(phi[i]) * sin(theta[j]))\n    y2[(i-1)*count+j] <- r2[(i-1)*count+j] * (sin(phi[i]) * sin(theta[j]))\n    z2[(i-1)*count+j] <- r2[(i-1)*count+j] * cos(theta[j])\n  }\n}\nlength(x2); length(y2); length(r2); dim(z2)\nphase_seq5 <- seq(from=25, to=count^2, by=count)  # phase mesh indexing patterns\nphase_seq15 <- seq(from=40, to=count^2, by=count)\nepsilon=0.03   # slight offset (up shift) of contour meshes\n\np <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(x = ~x1, y = ~y1, z = ~r1,\n              surfacecolor=~surf_color1, colorscale=colorscale, #Phase-based color\n              type = 'surface', opacity=1, visible=T,\n              contour=list(x = list(highlight = FALSE),\n                           y = list(highlight = FALSE),\n                           z = list( highlight = TRUE, highlightcolor = \"blue\"),\n                           color=\"#000\", width=15, lwd=10,\n                           opacity=1.0, hoverinfo=\"none\")) %>%\n    # Add a few Radial Traces\n    add_trace(x = x[(count+1):(2*count)], y = y[(count+1):(2*count)], \n              z = r[(count+1):(2*count)]+epsilon, \n            type = 'scatter3d', mode = 'lines', opacity = 1, # opaque, \n            line = list(color=\"#000\", width=7, lwd=7), name = 'Time') %>%\n    add_trace(x = x[(10*count+1):(11*count)], y = y[(10*count+1):(11*count)], \n              z = r[(10*count+1):(11*count)]+epsilon, \n            type = 'scatter3d', mode = 'lines', opacity = 1, # opaque, \n            line = list(color=\"#000\", width=7, lwd=7), name = 'Time') %>%\n    add_trace(x = x[(32*count+1):(33*count)], y = y[(32*count+1):(33*count)], \n              z = r[(32*count+1):(33*count)]+epsilon, \n            type = 'scatter3d', mode = 'lines', opacity = 1, # opaque, \n            line = list(color=\"#000\", width=7, lwd=7), name = 'Time') %>%\n    \n    # Add a few Phase (Angular) Traces\n    add_trace(x = x2[phase_seq5], y = y2[phase_seq5], z = r2[phase_seq5]+epsilon, \n            type = 'scatter3d', mode = 'lines', opacity = 1, # opaque, \n            line = list(color=\"darkgray\", width=7, lwd=7), name = 'Phase') %>%\n    add_trace(x = x2[phase_seq15], y = y2[phase_seq15], \n              z = r2[phase_seq15]+epsilon, \n            type = 'scatter3d', mode = 'lines', opacity = 1, # opaque, \n            line = list(color=\"darkgray\", width=7, lwd=7), name = 'Phase') %>%\n  \n    # Configure the scene layout\n    layout(title = \"Spherical Surface Parameterization\", showlegend = FALSE,\n           scene = list(aspectmode = \"manual\", \n                        aspectratio = list(x=1, y=1, z=0.3))) # 1:1:1 aspect ratio\np",
      "line_count": 98
    },
    {
      "section": "(Section 3.1) Geometric Primitive Surfaces with and without Boundaries",
      "code": "library(plotly)\nradius <- 10\nx <- seq(from=-radius, to=radius, by=1)\ny <- seq(from=-radius, to=radius, by=1) \nz_fun <- function(x,y) { (x-3)^2 +(y+4)^2 + x*y }\nz    <- outer(x, y, FUN=\"z_fun\")\n\n# check surface function\ndim(z); z[11+7,11-7]\nplot_ly() %>%   add_trace(x=x, y=y, z=t(z), type=\"surface\", opacity=0.7) %>%\n  # add vertical axis at the minimum\n  add_trace(x=7, y=-8, z=c(-24:350), type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 6, color=\"navy blue\"), name=\"Z\",\n              hoverinfo=\"none\") %>%\n  # add a Ball centered at arg_min\n  add_trace(x=7, y=-8, z=-24, type=\"scatter3d\", mode=\"markers\")",
      "line_count": 16
    },
    {
      "section": "(Section 3.1) Geometric Primitive Surfaces with and without Boundaries",
      "code": "# TORUS\na <- 6   # Torus radius (from torus gravitational center)\nr <- 2   # Tube radius (from torus circular core)\n\nphi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(200 - 1)))\npsi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(200 - 1)))\n\nxOuter <- outer(phi, psi, function(phi, psi) { cos(phi)*(a+r*cos(psi)) })\nyOuter <- outer(phi, psi, function(phi, psi) { sin(phi)*(a+r*cos(psi)) })\nzOuter <- outer(phi, psi, function(phi, psi) { r*sin(psi) })\n\nplot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(x=~xOuter, y=~yOuter, z=~zOuter, type='surface', opacity=1, visible=T) %>%\n    layout(title = \"Torus\", showlegend = FALSE,\n          scene = list(aspectmode = \"manual\", aspectratio = list(x=2, y=2, z=1)))",
      "line_count": 15
    },
    {
      "section": "(Section 3.1) Geometric Primitive Surfaces with and without Boundaries",
      "code": "# Checkerboard TORUS\na <- 6   # Torus radius (from torus gravitational center)\nr <- 2   # Tube radius (from torus circular core)\n\nphi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(20 - 1)))\npsi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(20 - 1)))\n\nxOuter <- outer(phi, psi, function(phi, psi) { cos(phi)*(a+r*cos(psi)) })\nyOuter <- outer(phi, psi, function(phi, psi) { sin(phi)*(a+r*cos(psi)) })\nzOuter <- outer(phi, psi, function(phi, psi) { r*sin(psi) })\n\n# checkerboard color pattern\ncolorPair <- c('white','black')\nsurf_colors <- array(\"\", dim = c(length(phi), length(phi)))\nsurf_colors_bin <- array(0, dim = c(length(phi), length(phi)))\n# Check checkerboard pattern\nfor (j in 1:length(phi)) {\n    for (i in 1:length(phi)) {\n        surf_colors[j,i] <- colorPair[1+ (i+j) %% length(colorPair)]\n        # surf_colors[j,i] <- colorPair[1+ ((-1+i+(j)/2) %% 10)]\n        surf_colors_bin[j,i] <- ifelse(surf_colors[j,i]==\"white\", 1, 0)\n    }\n}\n\n# Check checkerboard pattern\nimage(matrix(unclass(as.factor(surf_colors)), nrow=length(phi)))\n\nplot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(x=~xOuter, y=~yOuter, z=~zOuter, type='surface', opacity=1, visible=T,\n              surfacecolor = surf_colors_bin, opacity=0.9) %>%\n    layout(title = \"Torus\", showlegend = FALSE,\n          scene = list(aspectmode = \"manual\", aspectratio = list(x=2, y=2, z=1)))",
      "line_count": 32
    },
    {
      "section": "(Section 3.1) Geometric Primitive Surfaces with and without Boundaries",
      "code": "a <- 6   # Torus radius (from torus gravitational center)\nr <- 2   # Tube radius (from torus circular core)\n\n# phi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(20 - 1)))\n# psi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(20 - 1)))\n\nxOuter <- outer(phi, psi, function(phi, psi) { cos(phi)*(a+r*cos(psi)) })\nyOuter <- outer(phi, psi, function(phi, psi) { sin(phi)*(a+r*cos(psi)) })\nzOuter <- outer(phi, psi, function(phi, psi) { r*sin(psi) })\n\n# checkerboard color pattern\ncolorPair <- c('white','black')\nsurf_colors <- array(\"\", dim = c(length(phi), length(phi)))\n# Check checkerboard pattern\nfor (j in 1:length(phi)) {\n    for (i in 1:length(phi)) {\n        surf_colors[j,i] <- colorPair[1+ (i+j) %% length(colorPair)]\n        # surf_colors[j,i] <- colorPair[1+ ((-1+i+(j)/2) %% 10)]\n    }\n}\n# Check checkerboard pattern\nimage(matrix(unclass(as.factor(surf_colors)), nrow=length(phi)))\n\n### Kime tube on torus\n#### Parametric curve on torus\n# k1 <- phi -pi\n# k2 <- ((phi-1)^3 + 5*(phi-1)^2 + 2*(phi-5) - 8)/10\nxCurveOuter <- outer(phi, psi, function(phi, psi) { \n  cos(phi -pi)*(a+r*cos(((phi -pi-1)^3 + 5*(phi -pi-1)^2 + 2*(phi -pi-5) - 8)/10)) })\nyCurveOuter <- outer(phi, psi, function(phi, psi) { \n  sin(phi -pi)*(a+r*cos(((phi -pi-1)^3 + 5*(phi -pi-1)^2 + 2*(phi -pi-5) - 8)/10)) })\nzCurveOuter <- outer(phi, psi, function(phi, psi) { \n  r*sin(((phi -pi-1)^3 + 5*(phi -pi-1)^2 + 2*(phi -pi-5) - 8)/10) })\n\nplot_ly(x=~as.vector(xCurveOuter), y=~as.vector(yCurveOuter), \n        z=~as.vector(zCurveOuter), type=\"scatter3d\", mode=\"markers+lines\",\n        line=list(color='red', width=15))\n\nplot_ly(hoverinfo=\"none\") %>%\n  add_trace(x=~xOuter, y=~yOuter, z=~zOuter, type='surface', \n            opacity=0.1, visible=TRUE, showlegend= FALSE, showscale = FALSE) %>%\n  add_trace(x=~as.vector(xCurveOuter), y=~as.vector(yCurveOuter), z=~as.vector(zCurveOuter),\n            name=\"Tube\", type='scatter3d', mode='markers+lines', showscale = FALSE,\n            hoverinfo = 'Tube', line=list(color='red', width=15), showlegend = FALSE) %>%\n  # add projection on plane x=8.5\n  add_trace(x = 8.5, y = ~as.vector(yCurveOuter), z=~as.vector(zCurveOuter), \n            type=\"scatter3d\", mode=\"lines\", line = list(width = 2, dash=\"solid\", color = ~c, \n            colorscale = list(c(0,'gray'), c(1,'black'))), name=\"Z\", hoverinfo=\"none\") %>%\n  # add projection on plane y=-8.5\n  add_trace(x = ~as.vector(xCurveOuter), y = -8.5, z = ~as.vector(xCurveOuter), \n            type=\"scatter3d\", mode=\"lines\", line = list(width = 2, dash=\"solid\", color = ~c,\n            colorscale = list(c(0,'gray'), c(1,'black'))), name=\"Z\", hoverinfo=\"none\") %>%\n  # add projection on plane z=-2.5\n  add_trace(x = ~as.vector(xCurveOuter), y = ~as.vector(yCurveOuter), z = ~-2.5, \n            type=\"scatter3d\", mode=\"lines\", line = list(width = 2, dash=\"solid\", color = ~c,\n            colorscale = list(c(0,'gray'), c(1,'black'))), name=\"Z\", hoverinfo=\"none\") %>%\n  layout(title = \"Torus\", showlegend = FALSE,\n          scene = list(aspectmode = \"manual\", aspectratio = list(x=2, y=2, z=1)))",
      "line_count": 58
    },
    {
      "section": "(Section 3.1) Geometric Primitive Surfaces with and without Boundaries",
      "code": "# 1. Initialize the gradient descent optimization process\n# install.packages(\"numDeriv\")\nlibrary(numDeriv)         # to access the gradient calculation function: grad()\n\ngradDescent = function(f, x0, max.iter=500, stepSize=0.01, stoppingCriterion=0.001) {\n  n = length(x0)\n  xmat = matrix(0, nrow=n, ncol=max.iter)\n  xmat[,1] = x0\n  \n  for (k in 2:max.iter) {\n    # Calculate the current gradient\n    currentGrad = grad(f, xmat[,k-1]) \n    \n    # Check Stopping criterion\n    if (all(abs(currentGrad) < stoppingCriterion)) {\n      k = k-1; break\n    }\n    \n    # Move in the opposite direction of the gradient\n    xmat[,k] = xmat[,k-1] - stepSize * currentGrad\n  }\n\n  xmat = xmat[,1:k]     # remove the initial guess (x0)\n  # return the final solution, the solution path, min.value, and the number of iterations\n  return(list(x=xmat[,k], xmat=xmat, min.val=f(xmat[,k]), k=k))\n}\n\n# 2. Define the objective function and use a manual optimization gradient-descent scheme to get solutions\nf1 = function(x) {\n  return((1/2*x[1]^2-1/4*x[2]^2+3)*cos(2*x[1]+1-exp(x[2])))\n}\n\nx0 = c(0.5,0.5)\noptim.f0 = gradDescent(f1,x0,stepSize=0.01)\nx1 = c(-0.1,-1.3)\noptim.f1 = gradDescent(f1,x1,stepSize=0.01,max.iter=400)\nx2 = c(-0.5,-1.3)\noptim.f2 = gradDescent(f1,x2,stepSize=0.01,max.iter=400)\nx3 = c(-0.2,1.4)\noptim.f3 = gradDescent(f1,x3,stepSize=0.01,max.iter=400)\nx4 = c(-0.5,-0.5)\noptim.f4 = gradDescent(f1,x4,stepSize=0.01,max.iter=400)\nx5 = c(-1.7, 1.45)\noptim.f5 = gradDescent(f1,x5,stepSize=0.01,max.iter=400)\n\n# 3. PLot the 3D scene\nlibrary(magrittr)\nlibrary(plotly)\n\nradius <- 2\nx <- seq(from=-2*radius, to=2*radius+1, by=0.05)\ny <- seq(from=-radius, to=radius+1, by=0.05) \nz_fun <- function(x,y) { return((1/2*x^2-1/4*y^2+3)*cos(2*x+1-exp(y))) }\nz <- outer(x, y, FUN=\"z_fun\")\n\nplot_ly() %>%   \n  add_trace(x=x, y=y, z=t(z), type=\"surface\", opacity=0.7, showlegend = FALSE) %>%\n  add_trace(x = optim.f0$xmat[1,], y = optim.f0$xmat[2,], z = apply(optim.f0$xmat,2,f1), \n            type = 'scatter3d', mode = 'lines', opacity = 1, \n            line = list(width = 4, color = \"red\"), name = 'Solution 1') %>%\n  add_trace(x = optim.f1$xmat[1,], y = optim.f1$xmat[2,], z = apply(optim.f1$xmat,2,f1), \n            type = 'scatter3d', mode = 'lines', opacity = 1, \n            line = list(width = 4, color = \"green\"), name = 'Solution 2') %>%\n  add_trace(x = optim.f2$xmat[1,], y = optim.f2$xmat[2,], z = apply(optim.f2$xmat,2,f1), \n            type = 'scatter3d', mode = 'lines', opacity = 1, \n            line = list(width = 4, color = \"blue\"), name = 'Solution 3') %>%\n  add_trace(x = optim.f3$xmat[1,], y = optim.f3$xmat[2,], z = apply(optim.f3$xmat,2,f1), \n            type = 'scatter3d', mode = 'lines', opacity = 1, \n            line = list(width = 4, color = \"purple\"), name = 'Solution 4') %>%\n  add_trace(x = optim.f4$xmat[1,], y = optim.f4$xmat[2,], z = apply(optim.f4$xmat,2,f1), \n            type = 'scatter3d', mode = 'lines', opacity = 1, \n            line = list(width = 4, color = \"orange\"), name = 'Solution 5') %>%\n  add_trace(x = optim.f5$xmat[1,], y = optim.f5$xmat[2,], z = apply(optim.f5$xmat,2,f1), \n            type = 'scatter3d', mode = 'lines', opacity = 1, \n            line = list(width = 4, color = \"gray\"), name = 'Solution 6')",
      "line_count": 75
    },
    {
      "section": "(Section 3.1) Geometric Primitive Surfaces with and without Boundaries",
      "code": "# 1. Load the vertex-based surface data (x,y,z) locations on the surface are obtained by parameterizing \n#    real 3D face scans\nlibrary(plotly)\nvertexMaskDataXYZ <- read.csv(\"https://umich.instructure.com/files/13417342/download?download_frd=1\", header = T)\ndim(vertexMaskDataXYZ) # [1] 7159    3\n\n# 2. Plot the 3D scene\nlibrary(magrittr)\nlibrary(plotly)\n\ny <- 200*sin(seq(0, 2*pi, length.out = 200))*cos(seq(0, 2*pi, length.out = 200))\n\nplot_ly() %>%   \n  add_trace(x=vertexMaskDataXYZ[ , 1], y=vertexMaskDataXYZ[ , 2], \n            z=vertexMaskDataXYZ[ , 3], type=\"mesh3d\", # colors = colorRamp(rainbow(8)), \n            opacity=0.7, name=\"Face Mask\", hoverinfo=\"none\",\n            contour=list(show=TRUE, color=\"#000\", width=15)) %>%\n  # trace the boundary of the saddle point surface\n  add_trace(x=~vertexMaskDataXYZ[ , 1], y=~vertexMaskDataXYZ[ , 2], \n            z=15, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color=\"red\"), name=\"Surface (X,Y) Domain\" # , hoverinfo=\"none\"\n            ) %>%\n  # trace the main Z-axis\n  add_trace(x=-8, y=~y, z= 20, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 20, color=\"navy blue\"), name=\"Z\",\n              name=\"Mask Pole\") %>%\n  layout(title = \"Human Face Surface\", showlegend = FALSE,\n         scene = list(\n          xaxis = list(title = \"X\"),\n          yaxis = list(title = \"Y\"),\n          zaxis = list(title = \"Z\")\n        ))",
      "line_count": 32
    }
  ]
}