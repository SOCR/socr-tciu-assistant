{
  "metadata": {
    "created_at": "2024-11-30T13:46:17.205596",
    "total_sections": 6,
    "total_code_chunks": 15,
    "total_tables": 1,
    "r_libraries": [
      "abind",
      "akima",
      "brokenstick",
      "imager",
      "jpeg",
      "lubridate",
      "plotly"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"DSPA2: Data Science and Predictive Analytics (UMich HS650)\"\nsubtitle: \"<u>Appendix 10: Interpolation of Irregularly Sampled Spatiotemporal Data</u>\"\nauthor: \"SOCR/MIDAS (Ivo Dinov)\"\ndate: \"`r format(Sys.time(), '%B %Y')`\"\ntags: [DSPA, SOCR, MIDAS, Big Data, Predictive Analytics] \noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: SOCR_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 3\n    toc_float:\n      collapsed: false\nThis [DSPA2 appendix](https://www.socr.umich.edu/DSPA2/) demonstrates useful protocols for spatiotemporal interpolation, regularization, and uniform sampling of univariate and multivariate, spatial and temporal (longitudinal) data. The process of *interpolation* used to regularize irregularly sampled data, impute missing values, and facilitate homologies between cases, studies, cohorts, participants, populations, clusters, etc.",
      "word_count": 100
    },
    {
      "title": "Motivation of Interpolation of Irregularly Sampled Data",
      "content": "Let's use the R package [akima](https://cran.r-project.org/web/packages/akima/) to illustrate the regularization of a process, or function $z=f(x,y)$, that is only observed on irregularly sampled points $(x,y)\\in \\mathbb{R}^2$, distributed throughout the 2D $(x,y)\\in \\mathbb{R}^2$ plane. Note that each of the axes can represent space or time, one of the axes can be time and the other one can be space, or alternatively the signal can represent irregularly sampled [kimesurface, $z=f(x,y)$](https://spacekime.org/) over complex time (*kime*), $\\kappa\\equiv z\\in\\mathbb{C}\\cong\\mathbb{R}^2\\ni (x,y)$, where the kime-magnitude $t=|\\kappa|=\\sqrt{x^2+y^2}$ and the kime-phase $\\phi$ are irregularly sampled and $\\kappa=t e^{i\\phi}\\in\\mathbb{C}$.",
      "word_count": 89
    },
    {
      "title": "Univariate Process Interpolation",
      "content": "In general, function interpolation returns a list of points smoothly interpolating the observed (irregularly-sampled) data points.\n\n## Regularly spaced sample\n\n\n\n## Irregularly spaced sample\n\n\n## Another Example - Irregular Sampling\n\n\n## Bicubic Bivariate Interpolation for Data Irregularly smapled on a Rectangular Grid $(x,y)$\n\n\n## Bicubic-grid: Bivariate Interpolation for Data on a Rectangular Grid\n\nInterpolation of a bivariate function, $z=f(x,y)$, on a rectangular grid in the x-y plane, based on the revised Akima method `bicubic.grid(x,y,z,xlim,ylim,dx,dy)`.",
      "word_count": 74
    },
    {
      "title": "Bivariate Case",
      "content": "## Linear Interpolation\n\n### Gridded Bivariate Interpolation of Irregularly-Sampled Data\n\n\n### Pointwise Bivariate Interpolation of Irregularly-Sampled Data:\n\n\n## Nonlinear (Spline) Interpolation \n\n### Bivariate Cubic-Spline Grid Interpolation\n\n\n### Bivariate Cubic-Spline Pointwise Interpolation",
      "word_count": 31
    },
    {
      "title": "Image Super-resolution via Sinc Interpolation",
      "content": "[Sinc interpolation](https://en.wikipedia.org/wiki/Whittaker%E2%80%93Shannon_interpolation_formula) \nis the optimal strategy to increase image resolution by a specified factor without relying on additional information. The examples below utilize the [imager](https://cran.r-project.org/web/packages/imager) and\n[pracma](https://cran.r-project.org/web/packages/pracma/) `R` packages to demonstrate\nresampling 2D images and increasing their resolution by feeding zeo ($0$) rows \nand columns in the Fourier space representation of the input images, which is \nthe core of *sinc interpolation* (aka *Whittakerâ€“Shannon interpolation*).\n\nThis demonstration performs the following steps\n\n - Define the sinc function.\n - Create a new grid for the rescaled image.\n - Initialize a new matrix for the rescaled image.\n - Apply the sinc interpolation formula to calculate the pixel values for the new image.\n - Load an example image and applies the sinc interpolation with a specified scaling factor.\n - Save and plot the rescaled image.\n\nThe zero-padding the Fourier transform of a signal preserves the original signal's \nfrequency components while introducing (empty, information neutral) higher frequency \ncomponents that correspond to the interpolated samples. Adjusting the *scaling factor*\nincreases, or decreases, the image resolution (subsample or super-resolution) the original image.",
      "word_count": 174
    },
    {
      "title": "Longitudinal Data",
      "content": "There are different `R` packages facilitating longitudinal data interpolation and smoothing, e.g., `splines`, `akima`, time-series and spatial interpolation, e.g., `deldir`, `interp`, `spatial`. The nature of interpolation methods relies on pooling information from neighboring observations spatiotemporally co-located in spacetime. The `brokenstick` package is useful for modeling and prediction based on independent irregularly sampled multivariate time series using linear mixed models to increase time-series stability across replicates. \n\n## Univariate Time-Series\n\nLet's demonstrate some of the spatiotemporal interpolation strategies for modeling of geographic and longitudinal data using the [Barcelona air-quality and accidents dataset (2017)](https://umich.instructure.com/courses/38100/files/folder/Case_Studies/other) (.XLSX).\n\n\n\n\n\n## Multi-variate Longitudinal Processes\n...\n\n\n## Longitudinal Processes with Exogeneous-Variables \n...\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number \n\t\t\t\t<img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 198
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "      smooth_scroll: true\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "knitr::opts_chunk$set(echo = TRUE)\nlibrary(akima)\nlibrary(plotly)",
      "line_count": 3
    },
    {
      "section": "Univariate Process Interpolation",
      "code": "x <- 1:10\ny <- c(rnorm(5), c(1,1,1,1,3))\nxnew <- seq(-1, 11, 0.1)\n# plot(x, y, ylim=c(-3, 3), xlim=range(xnew))\n# lines(spline(x, y, xmin=min(xnew), xmax=max(xnew), n=200), col=\"blue\")\nspl <- spline(x, y, xmin=min(xnew), xmax=max(xnew), n=200)\nplot_ly(x=x, y=y, type=\"scatter\", mode=\"markers\", name=\"Raw Obs\") %>%\n  add_trace(x=spl$x, y=spl$y, type=\"scatter\", mode=\"lines\", name=\"Spline Model\") %>%\n  layout(title=\"Spline Modeling of a 1D Process (Uniform Sampling)\",\n         legend = list(orientation = 'h')) %>%\n  hide_colorbar()",
      "line_count": 11
    },
    {
      "section": "Univariate Process Interpolation",
      "code": "x <- sort(runif(10, max=10))\ny <- c(rnorm(5), c(1,1,1,1,3))\n\nspl_1 <- aspline(x, y, xnew)\nspl_2 <- aspline(x, y, xnew, method=\"improved\")\nspl_3 <- aspline(x, y, xnew, method=\"improved\", degree=10)\n\nplot_ly(x=x, y=y, type=\"scatter\", mode=\"markers\", name=\"Raw Obs\") %>%\n  add_trace(x=spl$x, y=spl$y, type=\"scatter\", mode=\"lines\", name=\"Spline Model\") %>%\n  add_trace(x=spl_1$x, y=spl_1$y, type=\"scatter\", mode=\"lines\", name=\"Spline Model 1\") %>%\n  add_trace(x=spl_2$x, y=spl_2$y, type=\"scatter\", mode=\"lines\", name=\"Spline Model 2\") %>%\n  add_trace(x=spl_3$x, y=spl_3$y, type=\"scatter\", mode=\"lines\", name=\"Spline Model 3\") %>%\n  layout(title=\"Four Spline Models of a 1D Process (Uniform Sampling)\",\n         legend = list(orientation = 'h')) %>%\n  hide_colorbar()",
      "line_count": 15
    },
    {
      "section": "Univariate Process Interpolation",
      "code": "x <- c(-3, -2, -1, 0, 1, 2, 2.5, 3)\ny <- c( 0, 0, 0, 0, -1, -1, 0, 2)\n\nspl <- spline(x, y, n=200)\nspl_1 <- aspline(x, y, n=200)\nspl_2 <- aspline(x, y, n=200, method=\"improved\")\nspl_3 <- aspline(x, y, n=200, method=\"improved\", degree=10)\n\nplot_ly(x=x, y=y, type=\"scatter\", mode=\"markers\", name=\"Raw Obs\") %>%\n  add_trace(x=spl$x, y=spl$y, type=\"scatter\", mode=\"lines\", name=\"Spline Model\") %>%\n  add_trace(x=spl_1$x, y=spl_1$y, type=\"scatter\", mode=\"lines\", name=\"Spline Model 1\") %>%\n  add_trace(x=spl_2$x, y=spl_2$y, type=\"scatter\", mode=\"lines\", name=\"Spline Model 2\") %>%\n  add_trace(x=spl_3$x, y=spl_3$y, type=\"scatter\", mode=\"lines\", name=\"Spline Model 3\") %>%\n  layout(title=\"Four Spline Models of a 1D Process (Irregular Sampling)\",\n         legend = list(orientation = 'h')) %>%\n  hide_colorbar()",
      "line_count": 16
    },
    {
      "section": "Univariate Process Interpolation",
      "code": "data(akima760)\n# interpolate at the diagonal of the grid [0,8]x[0,10]\nakima.bic <- bicubic(akima760$x, akima760$y, akima760$z, seq(0,8,length=50), seq(0,10,length=50))\nx <- sqrt(akima.bic$x^2+akima.bic$y^2)\ny <- akima.bic$z\n\nplot_ly(x=x, y=y, type=\"scatter\", mode=\"markers+lines\", name=\"Raw Obs\") %>%\n  layout(title=\"Bicubic Bivariate Interpolation (Irregular Sampling)\",\n         xaxis=list(title=\"Argument Magnitude (||(x,y)||)\"),\n         yaxis=list(title=\"Functional Value (z=f(x,y))\"),\n         legend = list(orientation = 'h')) %>%\n  hide_colorbar()\n\nx <- akima760$x\ny <- akima760$y\nz <- akima760$z\nplot_ly(x=x, y=y, z=z, type=\"surface\", name=\"Raw Obs\") %>%\n  layout(title=\"Bicubic Bivariate Interpolation (Irregular Sampling)\",\n         xaxis=list(title=\"Argument Magnitude (||(x,y)||)\"),\n         yaxis=list(title=\"Functional Value (z=f(x,y))\"),\n         legend = list(orientation = 'h')) %>%\n  hide_colorbar()",
      "line_count": 22
    },
    {
      "section": "Univariate Process Interpolation",
      "code": "data(akima760)\n# interpolate at a grid [0,8]x[0,10]\nakima.bic <- bicubic.grid(akima760$x, akima760$y, akima760$z, c(0,8),c(0,10),0.1,0.1)\n\n# ==================\n# interp:  Gridded Bivariate Interpolation for Irregular Data\n# ==========================\n# implement bivariate interpolation onto a grid for irregularly spaced input data.\n# Bilinear or bicubic spline interpolation is applied using different versions of algorithms from Akima\n\ndata(akima)\n# plot(y ~ x, data = akima, main = \"akima example data\")\n# with(akima, text(x, y, formatC(z,dig=2), adj = -0.1))\nvalues <- formatC(akima$z,dig=2)\nplot_ly(as.data.frame(akima), x=~x, y=~y, type=\"scatter\", mode=\"markers\", name=\"Raw Obs\") %>%\n  add_text(x=~x, y=~y, text=values, name=values, textposition = 'middle top') %>%\n  layout(title=\"Bicubic Bivariate Interpolation (Irregular Sampling)\",\n         xaxis=list(title=\"x\"),\n         yaxis=list(title=\"y\"),\n         legend = list(orientation = 'h')) %>%\n  hide_colorbar()\n\n\n## linear interpolation\nakima_df <- as.data.frame(akima)\nakima_df <- akima_df %>% replace(is.na(.), 0)\n\n# interpolation\nakima_lin_interpol <- \n  interp(akima_df$x, akima_df$y, akima_df$z, \n         xo=seq(min(akima_df$x), max(akima_df$x), length = 200),\n         yo=seq(min(akima_df$y), max(akima_df$y), length = 200))\nakima_lin_interpol$z <- akima_lin_interpol$z %>% replace(is.na(.), 0)\n\ndf <- as.data.frame(akima)\nplot_ly() %>% add_contour(x=~akima_lin_interpol$x, y=~akima_lin_interpol$y,\n                          z=~akima_lin_interpol$z, name=\"Bivariate Linear Model\") %>%\n    add_trace(x=~df$x, y=~df$y, type=\"scatter\", mode=\"markers\", name=\"Raw Obs\") %>%\n    layout(title=\"Linear Bivariate Interpolation (Irregular Sampling)\",\n           xaxis=list(title=\"x\"),yaxis=list(title=\"y\"),\n           legend = list(orientation = 'h')) %>%\n    hide_colorbar()\n\n\n## use finer grid to increase interpolation-model smoothness\nakima.smooth <- \n  with(akima, interp(x, y, z, xo=seq(0,25, length=200), yo=seq(0,20, length=200)))\nakima.smooth$z <- akima.smooth$z %>% replace(is.na(.), 0)\n\nplot_ly() %>% add_contour(x=~akima.smooth$x, y=~akima.smooth$y, \n                          z=~akima.smooth$z, name=\"Smooth Bivariate Model\") %>%\n    add_trace(x=~df$x, y=~df$y, type=\"scatter\", mode=\"markers\", name=\"Raw Obs\") %>%\n    layout(title=\"Bivariate Interpolation (Finer 2D Grid)\",\n           xaxis=list(title=\"x\"),yaxis=list(title=\"y\"),\n           legend = list(orientation = 'h')) %>%\n    hide_colorbar()\n\n# Sparse-data Interpolation using only 10 points (within convex hull)\ndf <- as.data.frame(akima)\nsubset_int <- sample(nrow(df), 10)  \ndf <- df[subset_int, ]\n\nakima.part <- with(df, interp(x, y, z))\nakima.part$z <- akima.part$z %>% replace(is.na(.), 0)\n\ndf$z <- df$z %>% replace(is.na(.), 0)\nplot_ly() %>% add_contour(x=~akima.part$x, y=~akima.part$y, z=~akima.part$z, name=\"Space (10-point-based) Model\") %>%\n    add_trace(x=~df$x, y=~df$y, type=\"scatter\", mode=\"markers\", name=\"Raw Obs\") %>%\n    layout(title=\"Sparce-data (n=10) Bivariate Interpolation\",\n           xaxis=list(title=\"x\"),yaxis=list(title=\"y\"),\n           legend = list(orientation = 'h')) %>%\n    hide_colorbar()",
      "line_count": 72
    },
    {
      "section": "Bivariate Case",
      "code": "# sample of akima\ndata(akima)\ndat <- as.data.frame(akima)\n\n# Display raw data observations\nplot_ly(dat, type=\"scatter3d\", mode=\"markers\", x=~x, y=~y, z=~z) \n  # %>% add_surface(x=~x, y=~y, z=~z)\n\n# interpolation\ndata_grid_interpol <- \n  interp(dat$x, dat$y, dat$z, \n         xo=seq(min(dat$x), max(dat$x), length = 200),\n         yo=seq(min(dat$y), max(dat$y), length = 200))\n\nplot_ly(dat, type=\"scatter3d\", mode=\"markers\", x=~x, y=~y, z=~z, \n        name=\"Observed Sample Data\") %>%\n  add_surface(x=~data_grid_interpol$x, y=~data_grid_interpol$y, \n                z=~data_grid_interpol$z, name=\"Model Manifold\",\n                contours = list(x = list(show = TRUE, start = 0.5, \n                                         end=25, size=5, color='gray'), \n                                z = list(show = TRUE, start = 0.5, \n                                         end = 60, size = 5))) %>%\n  layout(title=\"Linear Modeling & Grid-Interpolation of 2D Processes\",\n         legend = list(orientation = 'h')) %>%\n  hide_colorbar()",
      "line_count": 25
    },
    {
      "section": "Bivariate Case",
      "code": "data_pointwise_interpol <- \n  interpp(dat$x, dat$y, dat$z, runif(20, min(dat$x), max(dat$x)),\n          runif(20, min(dat$y), max(dat$y)))\n\nplot_ly(dat, type=\"scatter3d\", mode=\"markers\", x=~x, y=~y, z=~z, \n        marker = list(color = \"red\", size=3), opacity=0.6,\n        name=\"Observed Sample Data\") %>%\n    add_trace(type=\"scatter3d\", mode=\"markers\",\n              x=~data_pointwise_interpol$x,\n              y=~data_pointwise_interpol$y, \n              z=~data_pointwise_interpol$z, \n              marker = list(color = \"blue\", size=6), opacity=0.6,\n              name=\"Pointwise Interpolation\"\n              ) %>%\n    add_surface(x=~data_grid_interpol$x, y=~data_grid_interpol$y, \n                z=~data_grid_interpol$z, name=\"Model Manifold\",\n                opacity=0.2) %>%\n  layout(title=\n      \"Linear Modeling & Pointwise-Interpolation of 2D Processes\",\n      legend = list(orientation = 'h')) %>%\n  hide_colorbar()",
      "line_count": 21
    },
    {
      "section": "Bivariate Case",
      "code": "data_cubspline_interpol <- \n  interp(dat$x, dat$y, dat$z, \n         xo=seq(min(dat$x), max(dat$x), length = 200),\n         yo=seq(min(dat$y), max(dat$y), length = 200),\n         linear = FALSE, extrap = TRUE)\n\nplot_ly(dat, type=\"scatter3d\", mode=\"markers\", x=~x, y=~y, z=~z, \n        name=\"Observed Sample Data\") %>%\n  add_surface(x=~data_cubspline_interpol$x,\n                y=~data_cubspline_interpol$y, \n                z=~data_cubspline_interpol$z, \n                name=\"Spline Model Manifold\") %>%\n  layout(title=\"Nonlinear Spline Model Interpolation of 2D Processes\",\n         legend = list(orientation = 'h')) %>%\n  hide_colorbar()",
      "line_count": 15
    },
    {
      "section": "Bivariate Case",
      "code": "data_pointwise_interpol <- \n  interpp(dat$x, dat$y, dat$z, runif(20, min(dat$x), max(dat$x)),\n          runif(20, min(dat$y), max(dat$y)), \n          linear = FALSE, extrap = TRUE)\n\nplot_ly(dat, type=\"scatter3d\", mode=\"markers\", x=~x, y=~y, z=~z, \n        marker = list(color = \"red\", size=3), opacity=0.6,\n        name=\"Observed Sample Data\") %>%\n  add_trace(type=\"scatter3d\", mode=\"markers\",\n              x=~data_pointwise_interpol$x,\n              y=~data_pointwise_interpol$y, \n              z=~data_pointwise_interpol$z, \n              marker = list(color = \"blue\", size=6), opacity=0.6,\n              name=\"Pointwise Spline Interpolation\") %>%\n  add_surface(x=~data_grid_interpol$x, y=~data_grid_interpol$y, \n                z=~data_grid_interpol$z, name=\"Model Manifold\",\n                opacity=0.2) %>%\n  layout(title=\n      \"Spline Modeling & Pointwise-Interpolation of 2D Processes\",\n      legend = list(orientation = 'h')) %>%\n  hide_colorbar()",
      "line_count": 21
    },
    {
      "section": "Image Super-resolution via Sinc Interpolation",
      "code": "# Install the necessary packages:\n# install.packages(\"imager\")\n# install.packages(\"pracma\")\nlibrary(imager)\nlibrary(plotly)\nlibrary(jpeg)\n\n# FFT SHIFT\n#' This function is useful for visualizing the Fourier transform with the zero-frequency \n#' component in the middle of the spectrum.\n#' \n#' @param img_ff A Fourier transform of a 1D signal, 2D image, or 3D volume.\n#' @param dim Number of dimensions (-1, 1, 2, 3).\n#' @return A properly shifted FT of the array.\n#' \nfftshift <- function(img_ff, dim = -1) {\n\n  rows <- dim(img_ff)[1]    \n  cols <- dim(img_ff)[2]\n  # planes <- dim(img_ff)[3]\n\n  swap_up_down <- function(img_ff) {\n    rows_half <- ceiling(rows/2)\n    return(rbind(img_ff[((rows_half+1):rows), (1:cols)], img_ff[(1:rows_half), (1:cols)]))\n  }\n\n  swap_left_right <- function(img_ff) {\n    cols_half <- ceiling(cols/2)\n    return(cbind(img_ff[1:rows, ((cols_half+1):cols)], img_ff[1:rows, 1:cols_half]))\n  }\n  \n  #swap_side2side <- function(img_ff) {\n  #  planes_half <- ceiling(planes/2)\n  #  return(cbind(img_ff[1:rows, 1:cols, ((planes_half+1):planes)], img_ff[1:rows, 1:cols, 1:planes_half]))\n  #}\n\n  if (dim == -1) {\n    img_ff <- swap_up_down(img_ff)\n    return(swap_left_right(img_ff))\n  }\n  else if (dim == 1) {\n    return(swap_up_down(img_ff))\n  }\n  else if (dim == 2) {\n    return(swap_left_right(img_ff))\n  }\n  else if (dim == 3) {\n    # Use the `abind` package to bind along any dimension a pair of multi-dimensional arrays\n    # install.packages(\"abind\")\n    library(abind)\n    \n    planes <- dim(img_ff)[3]\n    rows_half <- ceiling(rows/2)\n    cols_half <- ceiling(cols/2)\n    planes_half <- ceiling(planes/2)\n    \n    img_ff <- abind(img_ff[((rows_half+1):rows), (1:cols), (1:planes)], \n                    img_ff[(1:rows_half), (1:cols), (1:planes)], along=1)\n    img_ff <- abind(img_ff[1:rows, ((cols_half+1):cols), (1:planes)], \n                    img_ff[1:rows, 1:cols_half, (1:planes)], along=2)\n    img_ff <- abind(img_ff[1:rows, 1:cols, ((planes_half+1):planes)], \n                    img_ff[1:rows, 1:cols, 1:planes_half], along=3)\n    return(img_ff)\n  }\n  else {\n    stop(\"Invalid dimension parameter\")\n  }\n}\n\n# Define the sinc interpolation function using FFT\nsinc_interp_fft <- function(image, factor) {\n  # Get original image dimensions\n  orig_x <- dim(image)[1]\n  orig_y <- dim(image)[2]\n  \n  # Apply FFT to the original image\n  fft_image <- fft(image)\n  \n  # Zero-padding in the Fourier domain\n  pad_x <- orig_x * factor\n  pad_y <- orig_y * factor\n  pad_fft <- matrix(0, nrow = pad_x, ncol = pad_y)\n  \n  # Calculate the center of the original FFT\n  center_x <- ceiling(orig_x / 2)\n  center_y <- ceiling(orig_y / 2)\n  \n  # Copy the original FFT to the center of the padded FFT matrix\n  pad_fft[1:center_x, 1:center_y] <- fft_image[1:center_x, 1:center_y]\n  pad_fft[(pad_x - center_x + 1):pad_x, 1:center_y] <- \n    fft_image[(center_x + 1):orig_x, 1:center_y]\n  pad_fft[1:center_x, (pad_y - center_y + 1):pad_y] <- \n    fft_image[1:center_x, (center_y + 1):orig_y]\n  pad_fft[(pad_x - center_x + 1):pad_x, (pad_y - center_y + 1):pad_y] <- \n    fft_image[(center_x + 1):orig_x, (center_y + 1):orig_y]\n  \n  # Inter-splice zeros uniformly throughout the k-space \n  # pad_fft[seq(1, pad_x, by = factor), seq(1, pad_y, by = factor)] <- fft_image\n  \n  # Apply inverse FFT to get the interpolated image\n  interp_image <- fft(pad_fft, inverse = TRUE)\n  \n  # Normalize the image\n  interp_image <- Re(interp_image) * (factor^2)/(length(interp_image))\n  \n  return(list(interp_image=as.cimg(interp_image), fft_image=fft_image, pad_fft=pad_fft))\n}\n\n# Load an example image\n# image <- load.image(system.file(\"extdata/parrots.png\", package = \"imager\"))\n# Read Image in and display it\n# Either download the JPG image locally from https://umich.instructure.com/courses/38100/files/1627149/download?download_frd=1 and then read it in\n# mri <- readJPEG(\"C:/Users/user/Desktop/MRI_ImageHematoma.jpg\")\n\n# Or directly load it from the web\npathToMRI <- tempfile(fileext = \".jpg\")\ndownload.file(\"https://umich.instructure.com/courses/38100/files/1627149/download?download_frd=1\", \n              mode = \"wb\", pathToMRI)\nimage <- readJPEG(pathToMRI)\n# load.image(system.file(pathToMRI, package = \"imager\"))\n\n# Convert the image to grayscale for simplicity\n# gray_image <- grayscale(image[,,1])\n\n# Perform sinc interpolation with a scaling factor of 2, and pull the result list of images\nres <- sinc_interp_fft(t(image[,,1]), 2)\nrescaled_image <- res$interp_image\nfft_image <- res$fft_image\npad_fft <- res$pad_fft\n# image(rescaled_image[,,1,1] )\n\n# spacetime domain images\nplt_orig <- plot_ly(z=apply(t(image[,,1]), 1, rev), type=\"heatmap\", name=\"Original Img\") %>%\n  layout(title=\"Original Image\") %>% hide_colorbar()\nplt_SuperResSincInterpol <- plot_ly(z=apply(rescaled_image[,,1,1], 1, rev),\n                                    type=\"heatmap\", name=\"Sinc Interpolated Image\") %>%\n  layout(title=\"Sinc Interpolated Image (Zoom-Factor=2*2)\") %>% hide_colorbar()\n\n# Fourier k-space images\nmag_FFT <- sqrt(Re(fftshift(fft_image))^2 + Im(fftshift(fft_image))^2)\nplt_OrigFFT <- plot_ly(z=log(apply(mag_FFT, 1, rev)), type=\"heatmap\", name=\"FFT\") %>%\n  layout(title=\"FFT Log-Magnitute of Original Image (center-shifted k-space)\") %>%\n  hide_colorbar()\nmag_FFT_padded <- sqrt(Re(fftshift(pad_fft))^2 + Im(fftshift(pad_fft))^2)\nplt_FFTpadded <- plot_ly(z=log(apply(mag_FFT_padded, 1, rev)+0.001),\n                         type=\"heatmap\", name=\"Padded FFT\") %>%\n  layout(title=\"Sinc FFT-padded Log-Magnitute of Image in k-space\") %>%\n  hide_colorbar()\n\nsubplot(plt_orig, plt_SuperResSincInterpol, plt_OrigFFT, plt_FFTpadded, nrows = 2) %>%\n  layout(title = 'Sinc Interpolation: Original and Superresolution Images and their Fourier-space counterparts')",
      "line_count": 151
    },
    {
      "section": "Longitudinal Data",
      "code": "library(lubridate)\n\ntmp = tempfile(fileext = \".xlsx\")\ndownload.file(url = \"https://umich.instructure.com/files/29669631/download?download_frd=1\", destfile = tmp, mode=\"wb\")\nbarcelona_Accidents <- openxlsx::read.xlsx(xlsxFile=tmp, sheet=\"Barcelona_Accidents_2017\", skipEmptyRows=TRUE)\nbarcelona_AirQuality <- openxlsx::read.xlsx(xlsxFile=tmp, sheet=\"air_quality_Nov2017\", skipEmptyRows=TRUE)\ndim(barcelona_Accidents)\ndim(barcelona_AirQuality)\n\n# Reconstruct the Date-Time (new column) from columns Month, Day, Hour\na <- month(as.POSIXct( barcelona_Accidents$Month, format = \"%B\"), label=T)\nbarcelona_Accidents$Year <- 2017\nbarcelona_Accidents$Month <- match(barcelona_Accidents$Month, month.name)\nbarcelona_Accidents$Date <- \n  make_datetime(barcelona_Accidents$Year, barcelona_Accidents$Month, \n                barcelona_Accidents$Day, barcelona_Accidents$Hour)",
      "line_count": 16
    },
    {
      "section": "Longitudinal Data",
      "code": "# install.packages(\"brokenstick\")\nlibrary(brokenstick)\nlibrary(lubridate)\nlibrary(plotly)\n\n# table(as.factor(barcelona_Accidents$Neighborhood.Name))\n\nids <- barcelona_Accidents$Weekday\nbarcelona_Accidents$X_hours <- hour(barcelona_Accidents$Date)\n# knots <- 0:23 # hourly\nknots <- c(0, 5, 11, 17, 23, 24)\n\n# By District Name\nfit <- brokenstick(Victims ~ X_hours | District.Name, boundary = c(0,24),\n                   barcelona_Accidents, knots = knots, method=\"kr\")\nggplotly(plot(fit, barcelona_Accidents, # group = as.factor(Weekday),\n     xlab = \"Time (hours)\", ylab = \"Number of Victims\") +\n    ggtitle(\"Regularized Models of the Data - Blue = observed data, Red = Fitted broken stick curves\"))\n\n# By Neighborhood Name\nfit <- brokenstick(Victims ~ X_hours | Neighborhood.Name, boundary = c(0,24),\n                   barcelona_Accidents, knots = knots, method=\"kr\")\nggplotly(plot(fit, barcelona_Accidents, # group = as.factor(Weekday),\n     xlab = \"Time (hours)\", ylab = \"Number of Victims\") +\n    ggtitle(\"Regularized Models of the Data - Blue = observed data, Red = Fitted broken stick curves\"))\n\n# ctl_lmer <- lmerControl(check.conv.grad = .makeCC(\"warning\", tol = 0.04))\n# f <- Victims ~ X_hours + Neighborhood.Name + Weekday +\n#   (0 + X_hours + Neighborhood.Name + Weekday | District.Name)\n# mod_lmer <- lme4::lmer(f, barcelona_Accidents, control = ctl_lmer)",
      "line_count": 30
    },
    {
      "section": "Longitudinal Data",
      "code": "",
      "line_count": 1
    },
    {
      "section": "Longitudinal Data",
      "code": "",
      "line_count": 1
    }
  ]
}