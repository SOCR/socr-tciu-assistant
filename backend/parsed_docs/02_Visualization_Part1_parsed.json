{
  "metadata": {
    "created_at": "2024-11-30T13:46:16.072705",
    "total_sections": 2,
    "total_code_chunks": 55,
    "total_tables": 1,
    "r_libraries": [
      "Amelia",
      "DT",
      "MASS",
      "Matrix",
      "XML",
      "ada",
      "betareg",
      "crossval",
      "dplyr",
      "foreign",
      "ggplot2",
      "gmodels",
      "gridExtra",
      "knitr",
      "lattice",
      "mi",
      "plotly",
      "psych",
      "rvest",
      "tidyr",
      "unbalanced"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"DSPA2: Data Science and Predictive Analytics (UMich HS650)\"\nsubtitle: \"<h2><u>Basic Visualization and Exploratory Data Analytics (Part 1)</u></h2>\"\nauthor: \"<h3>SOCR/MIDAS (Ivo Dinov)</h3>\"\ndate: \"`r format(Sys.time(), '%B %Y')`\"\ntags: [DSPA, SOCR, MIDAS, Big Data, Predictive Analytics] \noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: SOCR_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n      smooth_scroll: true\n    code_folding: show\n*This is [Part 1](https://socr.umich.edu/DSPA2/DSPA2_notes/02_Visualization_Part1.html) of the larger [DSPA Visualization Chapter](https://socr.umich.edu/DSPA2/DSPA2_notes/02_Visualization.html), which is difficult to render in a single browser window due to extreme memory demands. [Visualization Chapter Part 2](https://socr.umich.edu/DSPA2/DSPA2_notes/02_Visualization_Part2.html) includes exploratory data analytics (EDA), probability distributions, and mixture distribution modeling.*\n\nIn this chapter, we will present a number of complementary strategies for data wrangling, harmonization, manipulation, aggregation, visualization, and graphical exploration.  Specifically, we will discuss alternative methods for loading and saving computable data objects, importing and exporting different data structures, measuring sample statistics for quantitative variables, plotting sample histograms and model distribution functions, and scraping data from websites. In addition, we will cover exploratory data analytical (EDA) techniques, handling of incomplete (missing) data, and cohort-rebalancing of imbalanced groups.",
      "word_count": 176
    },
    {
      "title": "Data Handling",
      "content": "In this section, we will discuss strategies to `import` data and `export` results. Also, we are going to learn the basic tricks we need to know about processing different types of data. Specifically, we will illustrate common `R` data structures and strategies for loading (ingesting) and saving (regurgitating) data. In addition, we will (1) present some basic statistics, e.g., for measuring central tendency (mean, median, mode) or dispersion (variance, quartiles, range), (2) explore simple plots, (3) demonstrate the uniform and normal distributions, (4) contrast numerical and categorical types of variables, (5) present strategies for handling incomplete (missing) data, and (6) show the need for cohort-rebalancing when comparing imbalanced groups of subjects, cases or units.\n\n## Saving and Loading `R` Data Structures\n\nLet's start by extracting Edgar Anderson's Iris Data from the package `datasets`. The [iris dataset](https://en.wikipedia.org/wiki/Iris_flower_data_set) quantifies morphologic shape variations of 50 Iris flowers of three related genera - *Iris setosa*, *Iris virginica* and *Iris versicolor*. Four shape features were measured from each sample - length and the width of the sepals and petals (in centimeters). These data were used by [Ronald Fisher](https://en.wikipedia.org/wiki/Ronald_Fisher) in his [1936 linear discriminant analysis paper](https://doi.org/10.1111%2Fj.1469-1809.1936.tb02137.x).\n\n![](http://www.socr.umich.edu/people/dinov/2017/Spring/DSPA_HS650/images/IrisDataPic_SepalsPetals_LengthWidth.png)\n\nAs an I/O (input/output) demonstration, after we load the `iris` data and examine its class type, we can save it into a file named \"myData.RData\" and then reload it back into `R`.\n\n\n## Importing and Saving Data from CSV Files\n\nImporting the data from `\"CaseStudy07_WorldDrinkingWater_Data.csv\"` from [these case-studies](https://umich.instructure.com/courses/38100/files/folder/Case_Studies) and saving it into the `R` dataset named \"water\". The variables in the dataset are as follows:\n\n - **Time**: Years (1990, 1995, 2000, 2005, 2010, 2012)\n - **Demographic**: Country (across the world)\n - **Residence Area Type**: Urban, rural, or total\n - **WHO Region**\n - **Population using improved drinking-water sources**: The percentage of the population using an improved drinking water source.\n - **Population using improved sanitation facilities**: The percentage of the population using an improved sanitation facility.\n\nGenerally, the separator of a CSV file is comma. By default, we have option`sep=\", \"` in the command `read.csv()`. Also, we can use `colnames()` to rename the column variables. Let's use [CaseStudy07_WorldDrinkingWater_Data.csv](https://umich.instructure.com/files/399172/download?download_frd=1) from out [Canvas Data Archive](https://umich.instructure.com/courses/38100/files/folder/Case_Studies) as an example. This code loads CSV files that already include a header line containing the names of the variables. If we don't have a header in the dataset, we can use the `header = FALSE` option to read the first row in the file as data. In such cases, `R` will assign default names to the column variables of the dataset.\n\n\nTo save a data frame to CSV files, we could use the `write.csv()` function. The option `file = \"a/local/file/path\"` allows us to specify the output file name and location.\n\n\n## Importing Data from ZIP and SAV Files\n\nThis example demonstrates data import from a compressed (ZIP) SPSS (SAV) file. In this case, we utilize DSPA [Case-Study 25: National Ambulatory Medical Care Survey (NAMCS)](https://umich.instructure.com/courses/38100/files/folder/Case_Studies/25_NAMCS_2015).\n\n\n## Exploring the Structure of Data\n\nWe can use the command `str()` and `describe()` to explore the structure of a dataset (in this case the `CaseStudy07_WorldDrinkingWater_Data`).\n\n\nWe can see that this `World Drinking Water` dataset has 3331 observations and 6 variables. The output also includes the class of each variable and first few elements in the variable. The dimension of the other dataset (Case-Study 25: National Ambulatory Medical Care Survey) is much larger, $28,332\\times 1,096$.\n\n## Exploring Numeric Variables\n\nSummary statistics for numeric variables in the dataset could be accessed by using the command `summary()`. \n\n\nThe six summary statistics and `NA`'s (missing data) are reported in the output.\n\n## Measuring Central Tendency - mean, median, mode\n\n**Mean** and **median** are two frequent measurements of the central tendency. Mean is \"the sum of all values divided by the number of values\". Median is the number in the middle of an ordered list of values. In R, `mean()` and `median()` functions can provide us with these two measurements.\n\n\nThe **mode** is the value that occurs most often in the dataset. It is often used in categorical data, where mean and median are inappropriate measurements.\n\nWe can have one or more modes. In the [water dataset](https://umich.instructure.com/files/399172/download?download_frd=1), we have \"Europe\" and \"Urban\" as the modes for region and residence area respectively. These two variables are unimodal, which has a single mode. For the year variable, we have two modes 2000 and 2005. Both of the categories have 570 counts. The *year* represent an example of a multimodal variable that has two, or more, modes.\n\nMode is one of the measures for the central tendency. The best way to use it is to compare the mode to other values in the data. This helps us determine whether one or several categories dominate all others in the data. \nIn numeric datasets, we could think mode as the highest bin in the histogram, since it is unlikely to have many repeated measurements for continuous variables. In this way, we can also examine if the numeric data is multimodal.\n\n[More information about measures of centrality is available here](https://wiki.socr.umich.edu/index.php/AP_Statistics_Curriculum_2007_EDA_Center). \n\n## Measuring Spread - variance, quartiles and the five-number summary\n\nThe five-number summary describes the spread of a dataset. They are:\n\n* Minimum (`Min.`), representing the smallest value in the data\n* First quartile/Q1 (`1st Qu.`), representing the $25^{th}$ percentile, which splits off the lowest 25% of data from the highest 75%\n* Median/Q2 (`Median`), representing the $50^{th}$ percentile, which splits off the lowest 50% of data from the top 50%\n* Third quartile/Q3 (`3rd Qu.`), representing the $75^{th}$ percentile, which splits off the lowest 75% of data from the top 25%\n* Maximum (`Max.`), representing the largest value in the data.\n\n`Min` and `Max` can be obtained by using `min()` and `max()` respectively.\n\nThe difference between maximum and minimum is known as range. In R, `range()` function gives us both the minimum and maximum. A combination of `range()` and `diff()` could do the trick of getting the actual range value. To avoid problems with missing values, we will ignore them using the option `na.rm=TRUE`.\n\n\nQ1 and Q3 are the 25th and 75th percentiles of the data. Median (Q2) is right in the middle of Q1 and Q3. The difference between Q3 and Q1 is called the interquartile range (IQR). Within the IQR lies half of our data that has no extreme values.\n\nIn R, we use the `IQR()` to calculate the interquartile range. If we use `IQR()` for a data with `NA`'s, the `NA`'s are ignored by the function while using the option `na.rm=TRUE`.\n\n\nJust like the command `summary()` that we have talked about earlier in this chapter. A similar function `quantile()` could be used to obtain the five-number summary.\n\n\nWe can also calculate specific percentiles in the data. For example, if we want the 20th and 60th percentiles, we can do the following.\n\n\nWhen we include the `seq()` function, generating percentiles of evenly-spaced values is available.\n\n\nLet's re-examine the five-number summary for the `improved_water` variable. When we ignore the `NA`'s, the difference between minimum and Q1 is 74 while the difference between Q3 and maximum is only 1. The interquartile range is 22%. Combining these facts, the first quarter is more widely spread than the middle 50 percent of values. The last quarter is the most condensed one that has only two percentages 99% and 100%. Also, we can notice that the mean is smaller than the median. The mean is more sensitive to the extreme values than the median. Having some of very small values may spread out the first quartile, skew the distribution to the left and make the mean less than the median. \n\nDistribution models offer a way to characterize data using only a few parameters. For example, the normal distribution can be defined by only two parameters - center and spread, statistically speaking, mean and standard deviation.\n\nThe mean value is obtained by arithmetic averaging of all data points.\n\n$$mean(X)=\\mu=\\frac{1}{n}\\sum_{i=1}^{n} x_i$$\n\nThe standard deviation is the square root of the variance. And the variance is the average sum of square deviation from the mean. \n\n$$Var(X)=\\sigma^2=\\frac{1}{n-1}\\sum^{n}_{i=1} (x_i-\\mu)^2$$\n$$StdDev(X)=\\sigma=\\sqrt{Var(X)}$$\n\nSince the water dataset is not close to normal, in this example, we will use MLB baseball players dataset to illustrate normal distribution properties. The [MLB dataset (01a_data.txt)](https://umich.instructure.com/files/330381/download?download_frd=1) in our [class file data archive](https://umich.instructure.com/courses/38100/files/folder/data) has following variables - *Name*, *Team*, *Position*, *Height*, *Weight*, and *Age*.\n\nWe can use histograms to visually assess approximate normality of baseball players' *Height* and *Weight*.\n\n\nTWe could also report the mean and standard deviation of the weight and height variables.\n\n\nLarger standard deviation, or variance, suggests the data is more spread out from the mean. Therefore, for MLB players, weights appear to be more spread than heights.\n\nGiven the first two moments (mean and standard deviation), we can easily estimate how extreme a specific value is. Assuming we have a normal distribution, the values follow a $68-95-99.7$ rule. This means 68% of the data lies within the interval $[\\mu-\\sigma, \\mu+\\sigma]$;95% of the data lies within the interval $[\\mu-2*\\sigma, \\mu+2*\\sigma]$ and 99.7% of the data lies within the interval $[\\mu-3*\\sigma, \\mu+3*\\sigma]$. The following graph plotted by `R` illustrates the $68-95-99.7$ rule.\n\n\nApplying the 68-95-99.7 rule to our baseball weight variable, we know that 68% of our players weighted between 180.7168 pounds and 222.7164 pounds; 95% of the players weighted between 159.7170 pounds and 243.7162 pounds; And 99.7% of the players weighted between 138.7172 pounds and 264.7160 pounds.\n\n## Visualizing Numeric Variables - boxplots\n\nWe can visualize the five-number summary by a boxplot (box-and-whiskers plot). With the `boxplot()` function we can manage the title (`main=\"\"`) and labels for x (`xlab=\"\"`) and y (`ylab=\"\"`) axis.\n\n\nIn the boxplot we have five horizontal lines each representing the corresponding value in the five-number summary. The box in the middle represents the middle 50 percent of values. The bold line in the box is the median. Mean value is not illustrated on the graph.\n\nBoxplots only allow the two ends to extend to a minimum or maximum of 1.5 times the IQR. Therefore, any value that falls outside of the $3\\times IQR$ range will be represented as circles or dots. They are considered outliers. We can see that there are a lot of outliers with small values on the low ends of the graph.\n\n## Visualizing Numeric Variables - histograms\n\nHistograms offer another way to show the distribution spread of numeric variables. They require a specification of a number of bins, value containers, to divide and stratify the original data. The heights of the bins indicate the observed frequencies within each bin. \n\n\nWe could see that the shape of two graphs are somewhat similar. They both appear to have left skewed patterns ($mean \\lt median$). Other common skew patterns are shown in the following graph.\n\n\nYou can learn more about [Probability Distributions in the SOCR EBook](https://wiki.socr.umich.edu/index.php/EBook#Chapter_IV:_Probability_Distributions) and see the density plots of over 80 different probability distributions using the [SOCR Java Distribution Calculators](https://socr.umich.edu/html/dist/) or the [Distributome HTML5 Distribution Calculators](http://www.distributome.org/V3/calc/index.html).\n\nFor each probability distribution defined in `R`, there are four functions that provide the density (e.g., `dnorm`), the cumulative probability (e.g., `pnorm`), the inverse cumulative distribution (quantile) function (e.g., `qnorm`), and the random sampling (simulation) function (e.g., `rnorm`). The plots below show the *standard normal* density, cumulative probability and the quantile functions. As the density is very small outside of the interval $(-4,4)$, the plots are restricted to this domain.\n\n\n## Understanding Numeric Data - uniform and normal distributions\n\nIf the data follows a *uniform distribution*, then all values are equally likely to occur. The histogram for a uniformly distributed data would have equal heights for each bin like the following graph. \n\n\nOften, but not always, real world processes may appear as normally distributed data. A *normal distribution* would have a higher frequency for middle values and lower frequency for more extreme values. It has a symmetric and bell-curved shape just like the following diagram generated by R. Many parametric-based statistical approaches assume normality of the data. In cases where this parametric assumption is violated, variable transformations or distribution-free tests may be more appropriate.\n\n\n\n## Exploring Categorical Variables\n\nBack to our water dataset, we can treat the year variable as categorical rather than a numeric variable. Since the year variable only has six distinctive values, it is rational to treat it as a categorical variable where each value is a category that could apply to multiple WHO regions. Moreover, region and residence area variables are also categorical.\n\nDifferent from numeric variables, the categorical variables are better examined by tables rather than summary statistics. One-way table represents a single categorical variable. It gives us the counts of different categories. `table()` function can create one-way tables for our water dataset:\n\n\nGiven that we have a total of 3331 observations, the WHO region table tells us that about 27% (910/3331) of the areas examined in the study are in Europe. \n\n`R` can directly give us table proportions when using the `prop.table()` function. The proportion values can be transformed into percentage form and edit number of digits.\n\n\n## Exploring Relationships Between Variables\n\nSo far, the methods and statistics that we have gone through are at univariate level. Sometimes we want to examine the relationship between two or multiple variables. For example, does the percentage of population that uses improved drinking-water sources increase over time? To address these problems we need to look at bivariate or multivariate relationships.\n\n### Visualizing Relationships - scatterplots\n\nLet's look at the bivariate case first. A scatterplot is a good way to visualize bivariate relationships. We have x axis and y axis each representing one of the variables. Each observation is illustrated on the graph by a glyph, e.g., a solid point. If the graph shows a clear pattern, rather than a random scatter of points or a horizontal line, the two variables may be correlated with each other.\n\nIn `R` we can use the `plot()` function to create scatterplots. We have to define the variables for x-axis and y-axis. The labels in the graph are editable.\n\n\nWe can see from the scatterplot that there is an increasing pattern. In later years, the percentages are more centered around one hundred. Especially, in 2012, none of the regions had less than 20% of people using improved water sources while there used to be some regions that had such low percentages in the early years. \n\n### Examining Relationships - two-way cross-tabulations\n\nScatterplot is a useful tool to examine the relationship between two variables where at least one of them is numeric. When both variables are nominal, two-way cross-tabulation would be a better choice (also named as crosstab or contingency table). \n\nThe function `CrossTable()` is available in `R` under the package `gmodels`. Let's install it first.\n\n\nWe are interested in investigating the relationship between WHO region and residence area type in the water study. We might want to know if there is a difference in terms of residence area type between the African WHO region and all other WHO regions.\n\nTo address this problem we need to create an indicator variable for the African WHO region first.\n\n\nLet's revisit the `table()` function to see how many WHO regions are in Africa.\n\n\nNow, let's create a two-way cross-tabulation using `CrossTable()`.\n\n\nEach cell in the table contains five numbers. The first one N gives us the count that falls into its corresponding category. The Chi-square contribution provides us information about the cell's contribution in the Pearson's Chi-squared test for independence between two variables. This number measures the probability that the differences in cell counts are due to chance alone. \n\nThe number of most interest is the `N/ Col Total` or the counts over column total. In this case, these numbers represent the distribution for residence area type among African regions and the regions in the rest of the world. We can see the numbers are very close between African and non-African regions for each type of residence area. Therefore, we can conclude that African WHO regions do not have a difference in terms of residence area types compared to the rest of the world.\n\n## Missing Data\n\nIn the previous sections, we simply ignored the missing observations in our water dataset (`na.rm = TRUE`). Is this an appropriate strategy to handle incomplete data? Could the missingness pattern of those incomplete observations be important? It is possible that the arrangement of the missing observations may reflect an important factor that was not accounted for in our statistics or our models. \n\n**Missing Completely at Random (MCAR)** is an assumption about the probability of missingness being equal for all cases; **Missing at Random (MAR)** assumes the probability of missingness has a known but random mechanism (e.g., different rates for different groups); **Missing not at Random (MNAR)** suggest a missingness mechanism linked to the values of predictors and/or response, e.g., some participants may drop out of a drug trial when they have side-effects.\n\nThere are a number of strategies to impute missing data. The [expectation maximization (EM) algorithm provides one example for handling missing data](https://doi.org/10.1016/0167-9473(93)E0056-A). The [SOCR EM tutorial, activity, and documentations](http://wiki.stat.ucla.edu/socr/index.php/SOCR_EduMaterials_Activities_2D_PointSegmentation_EM_Mixture) provides the theory, applications and practice for effective (multidimensional) EM parameter estimation.\n\nThe simplest way to handle incomplete data is to substitute each missing value with its (feature or column) average. When the missingness proportion is small, the effect of substituting the means for the missing values will have little effect on the mean, variance, or other important statistics of the data. Also, this will preserve those non-missing values of the same observation or row.\n\n![](http://www.socr.umich.edu/people/dinov/2017/Spring/DSPA_HS650/images/CBDA_Cases_by_Features_Schematic.png)\n\n\nA more sophisticated way of resolving missing data is to use a model (e.g., linear regression) to predict the missing feature and impute its missing values. This is called the `predictive mean matching approach`. This method is good for data with multivariate normality. However, a disadvantage of it is that it can only predict one value at a time, which is very time consuming. Also, the multivariate normality assumption might not be satisfied and there may be important multivariate relations that are not accounted for. We are using the `mi` package for the predictive mean matching procedure.\n\nLet's install the `mi` package first.\n\n\nThen we need to get the missing information matrix. We are using the imputation method `pmm`(predictive mean matching approach) for both missing variables. \n\n\n* *Notes*:\n\n - Converting the input `data.frame` to a `missing_data.frame` allows us to include in the DF enhanced metadata about each variable, which is essential for the subsequent modeling, interpretation and imputation of the initial missing data.\n - `show()` displays all missing variables and their class-labels (e.g., continuous), along with meta-data. The `missing_data.frame` constructor suggests the most appropriate classes for each missing variable, however, the user often needs to correct, modify or change these meta-data, using `change()`.\n - Use the `change()` function to change/correct many meta-data in the constructed `missing_data.frame` object which are incorrect when using `show(mfd)`.\n - To get a sense of the raw data, look at the `summary`, `image`, or `hist` of the missing_data.frame.\n - The [mi vignettes](https://cran.r-project.org/web/packages/mi/vignettes/mi_vignette.pdf) provide many useful examples of handling missing data.\n  \nWe can perform the initial imputation. Here we imputed three times, which will create three different (complete) datasets, three *chains*, with slightly different imputed values.\n\n\nNext, we need to extract several multiply imputed `data.frames` from `imputations` object. Finally, we can compare the summary stats between the original dataset and the imputed datasets.\n\n\nThis is just a brief introduction for handling incomplete datasets. In later chapters, we will discuss more about missing data with different imputation methods and how to evaluate the complete imputed results.\n\n### Simulate some real multivariate data \n\nSuppose we would like to generate a synthetic dataset:\n$$sim\\_data=\\{y, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_{10}\\}.$$\n\nThen, we can introduce a method that takes a dataset and a desired proportion of missingness and wipes out the same proportion of the data, i.e., introduces random patterns of missingness. Note that there are already `R` functions that automate the introduction of missingness, e.g., `missForest::prodNA()`, however writing such a method from scratch is also useful.\n\n\nNext, let's synthetically generate (simulate) $1,000$ cases including all 11 features in the data ($\\{y, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10\\}$). \n\n\nIn the missing data plot above, missing values are illustrated as `black` segments in the case-by-feature bivariate chart. The `hot` colormap (17-level) represents the *normalized* values of the corresponding feature-index pairs, see the [mi::image() documentation](https://github.com/cran/mi/blob/master/R/plot_methods.R). Also, test the `order`, `cluster` and `grayscale` options, e.g., `image(mdf, x.order = T, clustered = F, grayscale =T)`.\n\nThe histogram plots display the distributions of:\n\n* The observed data (in blue color), \n* The imputed data (in red color), and\n* The completed values (observed plus imputed, in gray color).\n\n\nLet's check imputation convergence (details provided below).\n\n\nFinally, pool over the $m = 3$ completed datasets when we fit the \"model\".\nPool from across the 3 chains - in order to estimate a linear regression model.\n\n\n\n**Notes**: \n\n - In general, it is recommended to generate multiple imputation chains and then analyze the data (e.g., estimate the model coefficients, obtain inference, compute likelihoods, etc.). *Pooling* the analytics across all chains accounts for between-chain as well as within-chain variability, [Rubin's rule](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2727536/).\n - When deciding on how many chains to compute, a general rule is to compute $m$ chains if the rate of incomplete cases in the dataset is about $m \\%$, i.e., 10-chains when 10% of cases are incomplete, [White et al.,2011](https://www.jstatsoft.org/article/view/v045i04/v45i04.pdf).\n - For categorical features, e.g., binary predictors like $x_3$, the *display()* and *summary()* functions will report coefficient estimates for each (category) level, relative to the base level.\n\n### TBI Data Example\n\nNext, we will see an example using [the traumatic brain injury (TBI) dataset](https://wiki.socr.umich.edu/index.php/SMHS_MissingData#Raw_TBI_data). More information about the [clinical assessment scores (e.g., EGOS, GCS) is available in this publication (DOI: 10.1080/02699050701727460)](https://doi.org/10.1080/02699050701727460).\n\n\n\n### Imputation via Expectation-Maximization\n\nBelow we present the theory and practice of one specific statistical computing strategy for imputing incomplete datasets.\n\n#### Types of missing data\n\n - **MCAR**: Data which is Missing Completely At Random has nothing systematic about which observations are missing. There is no relationship between missingness and either observed or unobserved covariates.\n - **MAR**: Missing At Random is weaker than MCAR. The missingness is still random, but solely due to the observed variables. For example, those from a lower socioeconomic status (SES) may be less willing to provide salary information (but we know their SES). The key is that the missingness is not due to the values which are not observed. MCAR implies MAR, but not vice-versa.\n - **MNAR**: If the data are Missing Not At Random, then the missingness depends on the values of the missing data. Examples include censored data, self-reported data for individuals who are heavier, who are less likely to report their weight, and response-measuring devices that can only measure values above $0.5$, anything below that is missing.\n\n#### General Idea of the EM algorithm\n\n[Expectation-Maximization (EM) is an iterative process](http://repositories.cdlib.org/socr/EM_MM) involving two steps - *expectation* and *maximization*, which are applied in tandem. EM can be employed to find parameter estimates using maximum likelihood and is specifically useful when the equations determining the relations of the data-parameters cannot be directly solved. For example, a Gaussian mixture modeling assumes that each data point ($X$) has a corresponding latent (unobserved) variable or a missing value ($Y$), which may be specified as a mixture of coefficients determining the affinity of the data as a linear combination of Gaussian kernels, determined by a set of parameters ($\\theta$), e.g., means and variance-covariances. Thus, EM estimation relies on:\n\n - An observed data set $X$, \n - A set of missing (or latent) values $Y$, \n - A parameter $\\theta$, which may be a vector of parameters, \n - A likelihood function $L(\\theta | X, Y) =p(X,Y |\\theta)$, and\n - The maximum likelihood estimate (MLE) of the unknown parameter(s) $\\theta$ that is computed using the marginal likelihood of the observed data: \n\n$$L(\\theta | X) = p(X |\\theta) =\\int { p(X, Y |\\theta)dY}.$$\n\nMost of the time, this equation may not be directly solved, e.g., when $Y$ is missing.\n\n - *Expectation step (E step)*: computes the expected value of the *log likelihood function*, with respect to the conditional distribution of $Y$ given $X$ using the parameter estimates at the previous iteration (or at the position of initialization, for the first iteration), $\\theta_t$:\n$$Q ( \\theta | \\theta^{(t)} ) = E_{Y | X, \\theta^{(t)} }[ log \n\\left ( L(\\theta | X , Y ) \\right ];$$\n - *Maximization step (M step)*: Determine the parameter, $\\theta$, that maximizes the expectation above, $$\\theta^{(t+1)}=\\arg\\max_{\\theta}Q(\\theta|\\theta^{(t)}).$$\n\n[This SOCR EM Activity](http://wiki.stat.ucla.edu/socr/index.php/SOCR_EduMaterials_Activities_2D_PointSegmentation_EM_Mixture) shows the practical aspects of applying the EM algorithm. Also, in [DSPA Chapter 3](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/03_DataVisualization.html#61_data_modeler) we will illustrate the EM method for fitting single *distribution models* or (linear) *mixtures of distributions* to data that may represent a blend of heterogeneous observations from multiple different processes.\n\n#### EM-based imputation\n\nThe EM algorithm is an alternative to Newton-Raphson or the method of scoring for computing MLE in cases where there are complications in calculating the MLE. It is applicable for imputing incomplete MAR data, where the missing data mechanism can be ignored and separate parameters may be estimated for each missing feature.\n\n**Complete Data: **\n$$Z = \\left(\\begin{array}{cc} \nX \\\\\nY\n\\end{array}\\right),\nZZ^T = \\left(\\begin{array}{cc} \nXX^T & XY^T \\\\\nYX^T & YY^T\n\\end{array}\\right),$$ \nwhere $X$ is the observed data and $Y$ is the missing data.\n\n - *E-step*: (Expectation) Get the expectations of $Y$ and $YY^T$ based on observed data, $X$.\n - *M-step*: (Maximization) Maximize the conditional expectation in E-step to estimate the parameters.\n\n**Details:** If $o=obs$ and $m=mis$ stand for observed and missing, the mean vector, $(\\mu_{obs}, \\mu_{mis})^T$, and the variance-covariance matrix, $\\Sigma^{(t)} = \\left(\\begin{array}{cc} \\Sigma_{oo} & \\Sigma_{om} \\\\ \\Sigma_{mo}  & \\Sigma_{mm} \\end{array}\\right)$, are represented by:\n\n$$\\mu^{(t)} = \n\\left(\\begin{array}{cc} \n\\mu_{obs} \\\\\n\\mu_{mis}\n\\end{array}\\right),\\;\\;\\;\\;\\;\n\\Sigma^{(t)} = \\left(\\begin{array}{cc} \n\\Sigma_{oo} & \\Sigma_{om} \\\\\n\\Sigma_{mo}  & \\Sigma_{mm} \n\\end{array}\\right)$$ \n**E-step:**\n\n$$E(Z | X) = \n\\left(\\begin{array}{cc} \nX \\\\\nE(Y|X)\n\\end{array}\\right),\\;\\;\\;\\;\\;\nE(ZZ^T|X) = \\left(\\begin{array}{cc} \nXX^T & XE(Y|X)^T \\\\\nE(Y|X)X^T  & E(YY^T|X) \n\\end{array}\\right).$$ \n\n$$E(Y | X) = \\mu_{mis} + \\Sigma_{mo}\\Sigma_{oo}^{-1}(X - \\mu_{obs}).$$\n$$E(YY^T|X) = (\\Sigma_{mm}-\\Sigma_{mo}\\Sigma_{oo}^{-1}\\Sigma_{om})+E(Y|X)E(Y|X)^T.$$ \n\n**M-step:**\n$$\\mu^{(t+1)} = \\frac{1}{n}\\sum_{i=1}^nE(Z|X).$$\n$$\\Sigma^{(t+1)} = \\frac{1}{n}\\sum_{i=1}^nE(ZZ^T|X) - \\mu^{(t+1)}{\\mu^{(t+1)}}^T.$$\n\n#### A simple manual implementation of EM-based imputation\n\n\n\n#### Plotting the complete and imputed data\n\nSmaller points colored in *black* represent observed data, and the circle-shapes colored in *magenta* denote the imputed data.\n\n\n#### Validation of EM-imputation using the `R` Package *Amelia* \n\n - [Paper](https://gking.harvard.edu/files/gking/files/amelia_jss.pdf),\n - [R manual](https://cran.r-project.org/web/packages/Amelia/Amelia.pdf).\n\n\n##### Comparison\n\nLet's use the `amelia` function to impute the original data *sim_data_df* and compare the results to the simpler manual `EM_algorithm` imputation defined above.\n\n\n - **Magenta-color and circle-shape denote manual imputation via `EM_algorithm`**\n - **Orange-color and square-shapes denote Amelia imputation**\n\n\n##### Density plots \n\nFinally, we can compare the densities of the original, manually-imputed and Amelia-imputed datasets. Remember that in this simulation, we had about $500$ observations missing out of the $4,000$ that we synthetically generated.\n\n\n## Parsing web pages and visualizing tabular HTML data\n\nIn this section, we will utilize the Earthquakes dataset on [SOCR website](https://wiki.socr.umich.edu/index.php/SOCR_Data_Dinov_021708_Earthquakes). It records information about earthquakes that happened between 1969 and 2007 with magnitudes larger than 5 on the Richter scale. Here is how we parse the data on the source webpage and ingest the information into R:\n\n\nIn this dataset, `Magt`(magnitude type) may be used as a grouping variable. We will draw a \"Longitude vs Latitude\" line plot from this dataset. The function we are using is called `ggplot()` under `ggplot2`. The input type for this function is mostly data frame. `aes()` specifies axes.\n\n\nThe most important line of code has 2 parts. The first part `ggplot(earthquake, aes(Longitude, Latitude, group=Magt, color=Magt))` specifies the setting of the plot: dataset, group and color. The second part specifies we are going to draw lines between data points. In later chapters we will frequently use the package `ggplot2` and the structure under this great package is always `function1+function2`.\n\nWe can visualize the distribution for different variables using density plots. The following script plots the distribution for Latitude among different Magnitude types, also using the `ggplot()` function combined with `geom_density()`.\n\n\nWe can also compute and display 2D Kernel Density and 3D Surface Plots. Plotting 2D Kernel Density and 3D Surface plots is very important and useful in multivariate exploratory data analytic. \n\nWe will use the `plot_ly()` function under the `plotly` package, which takes value from a data frame.\n\nTo create a surface plot, we use two vectors: *x* and *y* with length *m* and *n* respectively. We also need a matrix: *z* of size $m\\times n$. This *z* matrix is created from matrix multiplication between *x* and *y*. \n\nThe `kde2d()` function is needed for 2D kernel density estimation.\n\n\nHere `z` is an estimate of the kernel density function. Then we apply `plot_ly` to the list `kernal_density` via the `with()` function.\n\n\nNote that we used the option `\"surface\"`, however you can experiment with the `type` option.\n\nAlternatively, one can plot 1D, 2D or 3D plots:\n\n\n## Cohort-Rebalancing (for Imbalanced Groups)\n\nComparing cohorts with imbalanced sample sizes (unbalanced designs) may present hidden biases in the results. Frequently, a cohort-rebalancing protocol is necessary to avoid such unexpected effects. Extremely unequal sample sizes can invalidate various parametric assumptions (e.g., homogeneity of variances). Also, there may be insufficient data representing the patterns belonging to the minority class(es) leading to inadequate capturing of the feature distributions. Although the groups do not have to have equal sizes, a general rule of thumb is that group sizes where one group is more than an order of magnitude larger than the size of another group has the `potential` for bias.\n\n### Example 1: Parkinson's Diseases Study\n\nThis Parkinson's diseases case-study involves neuroimaging, genetics, clinical, and phenotypic data for over 600 volunteers produced multivariate data for 3 cohorts -- *HC=Healthy Controls(166)* , *PD=Parkinson's (434)*, *SWEDD= subjects without evidence for dopaminergic deficit (61)*.\n\n\n**Notes**\n\n - SMOTE oversampling of the minority cohort is via generation of synthetic minority samples within the neighborhoods of observed observations. Thus, new minority instances\nblend observations in the same class and create clusters around each observed minority element.\n - The `percOver` parameter (perc.over/100) represents the number of new instances generated for each rare instance in the minority sample, when $perc.over < 100$, a single instance is generated. For example, `percOver=300` and `percOver=30` would triple (300/100) and leave unchanged (30/100) the size of the *minority sample*, respectively.\n - The $k$ parameter represents the number of neighbors to consider as the aggregate pool that the new examples are generated.\n - The `percUnder` (perc.under/100) represents the number of \"normal\" (majority class) instances that are randomly selected for each *smoted* (synthetically generated) observation. For instance, `percUnder=300` or `percUnder=30` would downsample the *majority sample* by choosing one-out-of-each-three or all of the majority sample points, respectively.\n\nContinue to [Visualization Chapter Part 2](https://socr.umich.edu/DSPA2/DSPA2_notes/02_Visualization_Part2.html) includes exploratory data analytics (EDA), probability distributions, and mixture distribution modeling.\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number \n\t\t\t\t<img class=\"statcounter\"\n\t\t\t\t\t\t\t\tsrc=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" \n\t\t\t\t\t\t\t\talt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 5192
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    self_contained: yes\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Data Handling",
      "code": "data()\ndata(iris)\nclass(iris)",
      "line_count": 3
    },
    {
      "section": "Data Handling",
      "code": "save(iris, file=\"myData.RData\")\nload(\"myData.RData\")",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "water <- read.csv(\n  'https://umich.instructure.com/files/399172/download?download_frd=1',\n  header=TRUE, fileEncoding = \"UTF-8\") #, fileEncoding = \"UTF-8\")\nwater[1:3, ]\ncolnames(water)<-c(\"year\", \"region\", \"country\", \"residence_area\", \"improved_water\", \"sanitation_facilities\")\nwater[1:3, ]\nwhich.max(water$year); \n# rowMeans(water[,5:6])\nmean(water[,6], trim=0.08, na.rm=T)",
      "line_count": 9
    },
    {
      "section": "Data Handling",
      "code": "write.csv(iris, file = \"C:/Users/iris.csv\")",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "# install.packages(\"foreign\")\nlibrary(\"foreign\")\npathToZip <- tempfile() \ndownload.file(\"https://umich.instructure.com/files/8111611/download?download_frd=1\", pathToZip, mode = \"wb\")\ndataset <- read.spss(unzip(pathToZip, files = \"namcs2015-spss.sav\", list = F, overwrite = TRUE), to.data.frame=TRUE)\ndim(dataset)\n## [1] 28332  1096\n# str(dataset)\n# View(dataset)  \nunlink(pathToZip)",
      "line_count": 10
    },
    {
      "section": "Data Handling",
      "code": "str(water)\nHmisc::describe(water)",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "library(plotly)\nsummary(water$year)\nsummary(water[c(\"improved_water\", \"sanitation_facilities\")])\n# plot(density(water$improved_water,na.rm = T))  # no need to be continuous, we can still get intuition about the variable distribution\n\nfit <- density(as.numeric(water$improved_water),na.rm = T)\nplot_ly(x = fit$x, y = fit$y, type = \"scatter\", mode = \"lines\", \n              fill = \"tozeroy\", name = \"Density\") %>% \n    layout(title='Density of (%) Improved Water Quality', \n           xaxis = list (title = 'Percent'), yaxis = list (title = 'Density'))",
      "line_count": 10
    },
    {
      "section": "Data Handling",
      "code": "vec1<-c(40, 56, 99)\nmean(vec1)\nmean(c(40, 56, 99))\nmedian(vec1)\nmedian(c(40, 56, 99))\n# install.packages(\"psych\"); \nlibrary(\"psych\")\ngeometric.mean(vec1, na.rm=TRUE)",
      "line_count": 8
    },
    {
      "section": "Data Handling",
      "code": "range(water$improved_water, na.rm=TRUE)\ndiff(range(water$improved_water, na.rm=TRUE))",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "IQR(water$improved_water, na.rm=TRUE)\nsummary(water$improved_water)",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "quantile(water$improved_water, na.rm = TRUE)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "quantile(water$improved_water, probs = c(0.2, 0.6), na.rm = TRUE)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "quantile(water$improved_water, seq(from=0, to=1, by=0.2), na.rm = TRUE)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "baseball<-read.table(\"https://umich.instructure.com/files/330381/download?download_frd=1\", header=T)\n# hist(baseball$Weight, main = \"Histogram for Baseball Player's Weight\", xlab=\"weight\")\n# hist(baseball$Height, main = \"Histogram for Baseball Player's Height\", xlab=\"height\")\n\nx <- rnorm(10000, mean=mean(baseball$Weight, na.rm=T), sd=sd(baseball$Weight, na.rm=T))\t\nfit <- density(x, bw=10)\t\n\nplot_ly(x=~baseball$Weight, type = \"histogram\", name = \"Weight Histogram\", histnorm = \"probability\") %>% \t\n    add_trace(x =~fit$x, y =~5*fit$y, type = \"scatter\", mode = \"lines\", opacity=0.1,\t\n              fill = \"tozeroy\", name = \"Normal Density\") %>% \t\n    layout(title='Baseball Weight Histogram & Model Normal Distribution', \t\n           xaxis = list(title = \"Weight\"), yaxis = list(title = \"relative frequency/density\"),\t\n           legend = list(orientation = 'h'))\t\n\nx <- rnorm(10000, mean=mean(baseball$Height, na.rm=T), sd=sd(baseball$Height, na.rm=T))\t\nfit <- density(x, bw=1)\t\n\nplot_ly(x=~baseball$Height, type = \"histogram\", name = \"Height Histogram\", histnorm = \"probability\") %>% \t\n    add_trace(x=~fit$x, y=~fit$y, type = \"scatter\", mode = \"lines\", opacity=0.1,\t\n              fill = \"tozeroy\", name = \"Normal Density\") %>% \t\n    layout(title='Baseball Height Histogram & Model Normal Distribution', \t\n           xaxis = list(title = \"Height\"), yaxis = list(title = \"relative frequency/density\"),\t\n           legend = list(orientation = 'h'))\t",
      "line_count": 23
    },
    {
      "section": "Data Handling",
      "code": "mean(baseball$Weight)\nmean(baseball$Height)\nvar(baseball$Weight)\nsd(baseball$Weight)\nvar(baseball$Height)\nsd(baseball$Height)",
      "line_count": 6
    },
    {
      "section": "Data Handling",
      "code": "#  hist(x, probability=T, \n#    col='lightblue', xlab=' ', ylab=' ', axes = F, \n#    main='68-95-99.7 Rule')\n# lines(density(x, bw=0.4), col='red', lwd=3)\n# axis(1, at=c(-3, -2, -1, 0, 1, 2, 3), labels = expression(mu-3*sigma, mu-2*sigma, mu-sigma, mu, mu+sigma, mu+2*sigma, mu+3*sigma))\n# abline(v=-1, lwd=3, lty=2)\n# abline(v=1, lwd=3, lty=2)\n# abline(v=-2, lwd=3, lty=2)\n# abline(v=2, lwd=3, lty=2)\n# abline(v=-3, lwd=3, lty=2)\n# abline(v=3, lwd=3, lty=2)\n# text(0, 0.2, \"68%\")\n# segments(-1, 0.2, -0.3, 0.2, col = 'red', lwd=2)\n# segments(1, 0.2, 0.3, 0.2, col = 'red', lwd=2)\n# text(0, 0.15, \"95%\")\n# segments(-2, 0.15, -0.3, 0.15, col = 'red', lwd=2)\n# segments(2, 0.15, 0.3, 0.15, col = 'red', lwd=2)\n# text(0, 0.1, \"99.7%\")\n# segments(-3, 0.1, -0.3, 0.1, col = 'red', lwd=2)\n# segments(3, 0.1, 0.3, 0.1, col = 'red', lwd=2)\n\nN<- 1000\nnorm <- rnorm(N, 0, 1)\n#  hist(x, probability=T, \n#    col='lightblue', xlab=' ', ylab=' ', axes=F, \n#    main='Normal Distribution')\n# lines(density(x, bw=0.4), col='red', lwd=3)\nnormDensity <- density(norm, bw=0.5)\ndens <- data.frame(x = normDensity$x, y = normDensity$y)\nminy <- 0\nmaxy <- max(dens$y)\n\nxLabels <- c(\"&mu;-3&#963;\",\"&mu;-2&#963;\", \"&mu;-&#963;\", \"&mu;\", \"&mu;+&#963;\", \"&mu;+2&#963;\", \"&mu;+3&#963;\")\nlabelColors <- c(\"green\", \"red\", \"orange\", \"black\", \"orange\", \"red\", \"green\")\nxLocation <- c(-3, -2, -1, 0, 1, 2, 3)\nyLocation <- 0.2\ndata <- data.frame(xLabels, xLocation, yLocation)\n\nplot_ly(dens) %>% \n    add_histogram(x = norm, name=\"Normal Histogram\") %>% \n    add_lines(data = dens, x = ~x, y = ~y+0.05, yaxis = \"y2\", \n              line = list(width = 3), name=\"N(0,1)\") %>% \n    add_annotations(x = ~xLocation, y = ~yLocation, type = 'scatter', ax = 20, ay = 20,\n                    mode = 'text', text = ~xLabels, textposition = 'middle right',\n                    textfont = list(color = labelColors, size = 16)) %>%\n    add_segments(x=-3, xend=-3, y=0, yend=100, name=\"99.7%\", line=list(dash=\"dash\", color=\"green\")) %>%\n    add_segments(x=-2, xend=-2, y=0, yend=90, name=\"95%\", line=list(dash=\"dash\", color=\"red\")) %>%\n    add_segments(x=-1, xend=-1, y=0, yend=80, name=\"68%\", line=list(dash=\"dash\", color=\"orange\")) %>%\n    add_segments(x=1, xend=1, y=0, yend=80, name=\"68%\", line = list(dash = \"dash\", color=\"orange\")) %>%\n    add_segments(x=2, xend=2, y=0, yend=90, name=\"95%\", line=list(dash=\"dash\", color=\"red\")) %>%\n    add_segments(x=3, xend=3, y=0, yend=100, name=\"99.7%\", line=list(dash=\"dash\", color=\"green\")) %>%\n    add_segments(x=-3, xend=3, y=100, yend=100, name=\"99.7%\", line=list(dash=\"dash\", color=\"green\")) %>%\n    add_segments(x=-2, xend=2, y=90, yend=90, name=\"95%\", line=list(dash=\"dash\", color=\"red\")) %>%\n    add_segments(x=-1, xend=1, y=80, yend=80, name=\"68%\", line=list(dash=\"dash\", color=\"orange\")) %>%\n    layout(bargap=0.1, xaxis=list(name=\"\"), yaxis=list(title=\"density/frequency\"),\n           yaxis2 = list(overlaying = \"y\", side = \"right\", # title=\"prob\",\n                         range = c(miny, maxy+0.1), showgrid = F, zeroline = F),\n           legend = list(orientation = 'h'), title=\"Normal 68-95-99.7% Rule\")",
      "line_count": 58
    },
    {
      "section": "Data Handling",
      "code": "# boxplot(water$improved_water, main=\"Boxplot for Percent improved_water\", ylab=\"Percentage\")\nplot_ly(y = ~water$improved_water, type = \"box\", name=\"improved water qual\") %>% \n  add_trace(y = ~water$sanitation_facilities, name =\"sanitation\") %>% \n    layout(title='Boxplots of Improved Water Quality and Sanitation Facilities', \n           yaxis = list (title = 'Percent'))",
      "line_count": 5
    },
    {
      "section": "Data Handling",
      "code": "# hist(water$improved_water, main = \"Histogram of  Percent improved_water\", xlab=\"Percentage\")\n# hist(water$sanitation_facilities, main = \"Histogram of  Percent sanitation_facilities\", xlab = \"Percentage\")\n\nplot_ly(x = ~water$improved_water, type = \"histogram\", name=\"improved_water\") %>% \n  add_trace(x = ~water$sanitation_facilities, type = \"histogram\", name=\"sanitation_facilities\") %>% \n  layout(bargap=0.1, title='Histograms', legend = list(orientation = 'h'),\n         xaxis = list(title = 'Percent'), yaxis = list (title = 'Frequency'))",
      "line_count": 7
    },
    {
      "section": "Data Handling",
      "code": "N <- 10000\nx <- rnbinom(N, 5, 0.1)\n#  hist(x, \n#  xlim=c(min(x), max(x)), probability=T, nclass=max(x)-min(x)+1, \n#    col='lightblue', xlab=' ', ylab=' ', axes=F, \n#    main='Right Skewed')\n# lines(density(x, bw=1), col='red', lwd=3)\nfit <- density(x)\n\nplot_ly(x = x, type = \"histogram\", name = \"Data Histogram\") %>% \n    add_trace(x = fit$x, y = fit$y, type = \"scatter\", mode = \"lines\", opacity=0.3,\n              fill = \"tozeroy\", yaxis = \"y2\", name = \"Density (rnbinom(N, 5, 0.1))\") %>% \n    layout(title='Right Skewed Process', yaxis2 = list(overlaying = \"y\", side = \"right\"),\n           legend = list(orientation = 'h'))\n\nN <- 10000\nx <- rnorm(N, 15, 3.7)\n#  hist(x, \n#  xlim=c(min(x), max(x)), probability=T, nclass=max(x)-min(x)+1, \n#    col='lightblue', xlab=' ', ylab=' ', axes=F, \n#    main='Right Skewed')\n# lines(density(x, bw=1), col='red', lwd=3)\nfit <- density(x)\n\nplot_ly(x = x, type = \"histogram\", name = \"Data Histogram\") %>% \n    add_trace(x = fit$x, y = fit$y, type = \"scatter\", mode = \"lines\", opacity=0.3,\n              fill = \"tozeroy\", yaxis = \"y2\", name = \"Density (rnorm(N, 15, 3.7))\") %>% \n    layout(title='Symmetric Process', yaxis2 = list(overlaying = \"y\", side = \"right\"),\n           legend = list(orientation = 'h'))\n\n# N <- 10000\n# xNu <- extraDistr::rlaplace(N, mu = 0, sigma = 0.4)\n# yNu <- density(xNu, bw=0.2)\n# xMu <- extraDistr::rlaplace(N, mu = 0, sigma = 0.5)\n# yMu <- density(xMu, bw=0.2)\n# # correct second Laplace Density (mu) to ensure absolute continuity, nu << mu\n# yMu$y <- 2*yMu$y\n# plot_ly(x = x, type = \"histogram\", name = \"Data Histogram\") %>% \n#     add_trace(x = yNu$x, y = yNu$y, type = \"scatter\", mode = \"lines\", opacity=0.3,\n#               fill = \"tozeroy\", yaxis = \"y2\", name = \"nu, Laplace(N,0,0.4) Density\") %>% \n#     add_trace(x = yMu$x, y = yMu$y, type=\"scatter\", mode=\"lines\", opacity=0.3,\n#               fill = \"tozeroy\", yaxis = \"y2\", name = \"mu, Laplace(N,0,0.5) Density\") %>% \n#     layout(title=\"Absolutely Continuous Laplace Distributions, nu<<mu\", \n#            yaxis2 = list(overlaying = \"y\", side = \"right\"),\n#            xaxis = list(range = list(-pi, pi)),\n#            legend = list(orientation = 'h'))\n# integrate(approxfun(yNu), -pi, pi)\n# integrate(approxfun(yMu), -pi, pi)",
      "line_count": 48
    },
    {
      "section": "Data Handling",
      "code": "z<-seq(-4, 4, 0.1)  # points from -4 to 4 in 0.1 steps\nq<-seq(0.001, 0.999, 0.001)  # probability quantile values from 0.1% to 99.9% in 0.1% steps\n\ndStandardNormal <- data.frame(Z=z, Density=dnorm(z, mean=0, sd=1), Distribution=pnorm(z, mean=0, sd=1))  \n\nqStandardNormal <- data.frame(Q=q, Quantile=qnorm(q, mean=0, sd=1))  \nhead(dStandardNormal)\n\n# plot(z, dStandardNormal$Density, main=\"Normal Density Curve\", type = \"l\", xlab = \"critical values\", ylab=\"density\", lwd=4, col=\"blue\")\n# polygon(z, dStandardNormal$Density, col=\"red\", border=\"blue\")\n# plot(z, dStandardNormal$Distribution, main=\"Normal Distribution\", type = \"l\", xlab = \"critical values\", ylab=\"Cumulative Distribution\", lwd=4, col=\"blue\")\n# plot(q, qStandardNormal$Quantile, main=\"Normal Quantile Function (Inverse CDF)\", type = \"l\", xlab = \"p-values\", ylab=\"Critical Values\", lwd=4, col=\"blue\")\n\nplot_ly(x = z, y= dStandardNormal$Density, name = \"Normal Density Curve\",\n        mode = 'lines') %>% \n    layout(title='Normal Density Curve', \n           xaxis = list(title = 'critical values'),\n           yaxis = list(title =\"Density\"),\n           legend = list(orientation = 'h'))\n\nplot_ly(x = z, y= dStandardNormal$Distribution,\n        name = \"Normal Density Curve\", mode = 'lines') %>% \n    layout(title='Normal Distribution', \n           xaxis = list(title = 'critical values'),\n           yaxis = list(title =\"Cumulative Distribution\"),\n           legend = list(orientation = 'h'))\n\nplot_ly(x = q, y= qStandardNormal$Quantile,\n        name = \"Normal Quantile Function (Inverse CDF)\", mode = 'lines') %>%\n    layout(title='Normal Distribution', \n           xaxis = list(title = 'probability values'),\n           yaxis = list(title =\"Critical Values\"),\n           legend = list(orientation = 'h'))",
      "line_count": 33
    },
    {
      "section": "Data Handling",
      "code": "x<-runif(1000, 1, 50)\n# hist(x, col='lightblue', main=\"Uniform Distribution\", probability = T, xlab=\"\", ylab=\"Density\", axes=F)\n# abline(h=0.02, col='red', lwd=3)\nplot_ly(x = ~x, type = \"histogram\", histnorm = \"probability\", name=\"proportion\", showlegend = F) %>% \n  add_lines(x=~x, y=~0.038, type = 'scatter', mode = 'lines') %>%\n  layout(bargap=0.1, title='Uniform(0, 50) Histogram', yaxis = list(title =\"probability\"))",
      "line_count": 6
    },
    {
      "section": "Data Handling",
      "code": "N<- 1000\nnorm <- rnorm(N, 0, 1)\n#  hist(x, probability=T, \n#    col='lightblue', xlab=' ', ylab=' ', axes=F, \n#    main='Normal Distribution')\n# lines(density(x, bw=0.4), col='red', lwd=3)\nnormDensity <- density(norm, bw=0.5)\ndens <- data.frame(x = normDensity$x, y = normDensity$y)\nminy <- 0\nmaxy <- max(dens$y)\n\nplot_ly(dens) %>% \n  add_histogram(x = norm, name=\"Normal Histogram\") %>% \n  add_lines(data = dens, x = ~x, y = ~y, yaxis = \"y2\", \n            line = list(width = 3), name=\"N(0,1)\") %>% \n  layout(bargap=0.1, yaxis2 = list(overlaying = \"y\",  side = \"right\", \n            range = c(miny, maxy), showgrid = F, zeroline = F),\n         legend = list(orientation = 'h'), title=\"Normal(0,1)\")",
      "line_count": 18
    },
    {
      "section": "Data Handling",
      "code": "water <- read.csv('https://umich.instructure.com/files/399172/download?download_frd=1', header=T, stringsAsFactors=FALSE, fileEncoding=\"latin1\")\n\ncolnames(water)<-c(\"year\", \"region\", \"country\", \"residence_area\", \"improved_water\", \"sanitation_facilities\")\n\ntable(water$year)\ntable(water$region)\ntable(water$residence_area)",
      "line_count": 7
    },
    {
      "section": "Data Handling",
      "code": "year_table<-table(water$year)\nprop.table(year_table)\nyear_pct<-prop.table(year_table)*100\nround(year_pct, digits=1)",
      "line_count": 4
    },
    {
      "section": "Data Handling",
      "code": "# plot.window(c(400,1000), c(500,1000))\n# plot(x=water$year, y=water$improved_water, \n#      main= \"Scatterplot of Year vs. Improved_water\", \n#      xlab= \"Year\", \n#      ylab= \"Percent of Population Using Improved Water\")\n\nplot_ly(x = ~water$sanitation_facilities, y = ~water$improved_water, type = \"scatter\", \n        mode = \"markers\") %>% \n    layout(title='Scatterplot: Improved Water Quality vs. Sanitation Facilities', \n           xaxis = list (title = 'Water Quality'), yaxis = list (title = 'Sanitation'))\n",
      "line_count": 11
    },
    {
      "section": "Data Handling",
      "code": "#install.packages(\"gmodels\", repos = \"http://cran.us.r-project.org\")\nlibrary(gmodels)",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "water$africa<-water$region==\"Africa\"",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "table(water$africa)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "CrossTable(x=water$residence_area, y=water$africa)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "m1<-mean(water$improved_water, na.rm = T)\nm2<-mean(water$sanitation_facilities, na.rm = T)\nwater_imp<-water\nfor(i in 1:3331){\n  if(is.na(water_imp$improved_water[i])){\n    water_imp$improved_water[i] <- m1\n  }\n  if(is.na(water_imp$sanitation_facilities[i])){\n    water_imp$sanitation_facilities[i] <- m2\n  }\n}\nsummary(water_imp)",
      "line_count": 12
    },
    {
      "section": "Data Handling",
      "code": "# install.packages(\"mi\")\nlibrary(mi)",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "mdf<-missing_data.frame(water)\nhead(mdf)\nshow(mdf)\nmdf<-change(mdf, y=\"improved_water\", what = \"imputation_method\", to=\"pmm\")\nmdf<-change(mdf, y=\"sanitation_facilities\", what = \"imputation_method\", to=\"pmm\")",
      "line_count": 5
    },
    {
      "section": "Data Handling",
      "code": "imputations <- mi(mdf, n.iter=10, n.chains=3, verbose=T)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "library(mi)\ndata.frames <- complete(imputations, 3)\nsummary(water)\nsummary(data.frames[[1]])\nmySummary <- lapply(data.frames, summary)\nmySummary$`chain:1`   # report just the summary of the first chain.",
      "line_count": 6
    },
    {
      "section": "Data Handling",
      "code": "set.seed(123)\n# create MCAR missing-data generator\ncreate.missing <- function (data, pct.mis = 10) \n{\n    n <- nrow(data)\n    J <- ncol(data)\n    if (length(pct.mis) == 1) {\n        if(pct.mis>= 0 & pct.mis <=100) {\n            n.mis <- rep((n * (pct.mis/100)), J)\n        }\n        else {\n          warning(\"Percent missing values should be an integer between 0 and 100! Exiting\"); break\n        }\n      }\n    else {\n        if (length(pct.mis) < J) \n            stop(\"The length of the missing-vector is not equal to the number of columns in the data! Exiting!\")\n            n.mis <- n * (pct.mis/100)\n    }\n    for (i in 1:ncol(data)) {\n        if (n.mis[i] == 0) { # if the column has no missing values, do nothing\n            data[, i] <- data[, i]\n        }\n        else {\n            data[sample(1:n, n.mis[i], replace = FALSE), i] <- NA\n    \t\t  # For each given column (i), sample the row indices (1:n), \n    \t\t  # a number of indices to replace as \"missing\", n.mis[i], \"NA\", \n      \t  # without replacement\n        }\n    }\n    return(as.data.frame(data))\n}",
      "line_count": 32
    },
    {
      "section": "Data Handling",
      "code": "n <- 1000; u1 <- rbinom(n, 1, .5); v1 <- log(rnorm(n, 5, 1)); x1 <- u1*exp(v1)\nu2 <- rbinom(n, 1, .5); v2 <- log(rnorm(n, 5, 1)); x2 <- u2*exp(v2)\nx3 <- rbinom(n, 1, prob=0.45); x4 <- ordered(rep(seq(1, 5), n)[sample(1:n, n)])\nx5 <- rep(letters[1:10], n)[sample(1:n, n)]; x6 <- trunc(runif(n, 1, 10))\nx7 <- rnorm(n); x8 <- factor(rep(seq(1, 10), n)[sample(1:n, n)])\nx9 <- runif(n, 0.1, .99); x10 <- rpois(n, 4)\ny <- x1 + x2 + x7 + x9 + rnorm(n)\n\n# package the simulated data as a data frame object\nsim_data <- cbind.data.frame(y, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)\n\n# randomly create missing values\nsim_data_30pct_missing <- create.missing(sim_data, pct.mis=30); \n# head(sim_data_30pct_missing); summary(sim_data_30pct_missing)\n\n# install.packages(\"DT\")\nlibrary(\"DT\")\nlibrary(dplyr)\ndf_raw <- sim_data %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_raw)\n\ndf_miss <- sim_data_30pct_missing %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_miss)\n\n# install.packages(\"mi\")\n# install.packages(\"betareg\")\nlibrary(\"betareg\"); library(\"mi\")\n\n# get show the missing information matrix\t\t\t\nmdf <- missing_data.frame(sim_data_30pct_missing) \n# show(mdf)\ndf_mdf <- as.data.frame(mdf) %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_mdf)\n\n# mdf@patterns   # to get the textual missing pattern\nimage(mdf)   # remember the visual pattern of this MCAR\n# df_img <- df_mdf %>% mutate_if(is.factor, as.character) %>%  replace(is.character(.), 1)  %>%  replace(is.na(.), 0)\n# # df_img <- df_mdf %>%  replace(is.character(.), 1)  %>%  replace(is.na(.), 0)\n# df_img [1:10,1:10]\n# df_img[is.character(df_img)] <- 1",
      "line_count": 40
    },
    {
      "section": "Data Handling",
      "code": "# Next try to impute the missing values.\n\n# Get the Graph Parameters (plotting canvas/margins)\n# set to plot the histograms for the 3 imputation chains\n# mfcol=c(nr, nc). Subsequent histograms are drawn as nr-by-nc arrays on the graphics device by columns (mfcol), or rows (mfrow)\n# oma\n# oma=c(bottom, left, top, right) giving the size of the outer margins in lines of text\n# mar=c(bottom, left, top, right) gives the number of lines of margin to be specified on the four sides of the plot.\n# tcl=length of tick marks as a fraction of the height of a line of text (default=0.5)\npar(mfcol=c(5, 5), oma=c(1, 1, 0, 0), mar=c(1, 1, 1, 0), tcl=-0.1, mgp=c(0, 0, 0))\n\n# Note to get verbose output-report, parallel must be OFF: parallel=FALSE, verbose=TRUE\nimputations <- mi(sim_data_30pct_missing, n.iter=5, n.chains=3, verbose=TRUE)\nhist(imputations)\n\n# Extracts several multiply imputed data.frames from \"imputations\" object\ndata.frames <- complete(imputations, 3)\n\n# compare the 3 objects, sim_data, sim_data_30pct_missing, and imputed chain1\n# datatable(sim_data, caption = htmltools::tags$caption(\n#      style = 'caption-side: bottom; text-align: center;','Table: Initial sim_data'))\ndf_miss <- sim_data_30pct_missing %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_miss, caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;','Table: Initial sim_data'))\n\n# datatable(sim_data_30pct_missing, caption = htmltools::tags$caption(\n#      style = 'caption-side: bottom; text-align: center;', 'Table: sim_data_30pct_missing'))\ndf_miss30pct <- sim_data_30pct_missing %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_miss30pct, caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: sim_data 30% Missing'))\n          \ndf_chain1 <- data.frames[[1]] %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_chain1, caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', 'Table: Imputed data (chain 1)'))\n\n# Compare the summary stats for the original data (prior to introducing missing\n# values) with missing data and the re-completed data following imputation\n# summary(sim_data)\ndatatable(data.frame(t(as.matrix(unclass(summary(sim_data)))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: summary(sim_data)'))\n\nmySummary <- lapply(data.frames, summary)\ndatatable(data.frame(t(as.matrix(unclass(mySummary$`chain:1`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:1)'))",
      "line_count": 47
    },
    {
      "section": "Data Handling",
      "code": "round(mipply(imputations, mean, to.matrix = TRUE), 3)\nRhats(imputations, statistic = \"moments\") # assess the convergence of MI algorithm\nplot(imputations); hist(imputations); image(imputations); summary(imputations)",
      "line_count": 3
    },
    {
      "section": "Data Handling",
      "code": "model_results <- pool(y ~ x1+x2+x3+x4+x5+x6+x7+x8+x9+x10, data=imputations,  m=3)\ndisplay (model_results); summary (model_results)  \n# Report the summaries of the imputations\ndata.frames <- complete(imputations, 3)  \t# extract the first 3 chains\nmySummary <-lapply(data.frames, summary)\n\ndatatable(data.frame(t(as.matrix(unclass(mySummary$`chain:1`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:1)'))\ndatatable(data.frame(t(as.matrix(unclass(mySummary$`chain:2`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:2)'))\ndatatable(data.frame(t(as.matrix(unclass(mySummary$`chain:3`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:3)'))\n\ncoef(summary(model_results))[, 1:2]  # get the model coefficients and their SE's  \n\nlibrary(\"lattice\")\ndensityplot(y ~ x1 + x2, data=imputations)\n\n# plot_ly(imputations@data$`chain:1`, x=~(x1+x2), y=~density(y))\n# To compare the density of observed data and imputed data --\n# these should be similar (though not identical) under MAR assumption",
      "line_count": 24
    },
    {
      "section": "Data Handling",
      "code": "# Load the (raw) data from the table into a plain text file \"08_EpiBioSData_Incomplete.csv\"\nTBI_Data <- read.csv(\"https://umich.instructure.com/files/720782/download?download_frd=1\", na.strings=c(\"\", \".\", \"NA\"))    ## 1. read in data\nsummary(TBI_Data)\n\n# Get information matrix of the data\n# 2. create an object of class \"missing_data.frame\" from the data.frame TBI_data\n# Convert to a missing_data.frame\n# library(\"betareg\"); library(\"mi\")\t\t\t\nmdf <- missing_data.frame(TBI_Data) # warnings about missingness patterns\ndatatable(mdf)\n# mdf@patterns; \nimage(mdf)\n\n# 3. get description of the \"family\", \"imputation_method\", \"size\", \"transformation\", \"type\", \"link\", or \"model\" of each incomplete variable\n# show(mdf)\n\n# 4. change things: mi::change() method changes the family, imputation method,\n# size, type, and so forth of a missing variable. It's called \n# before calling mi to affect how the conditional expectation of each \n# missing variable is modeled.\n\nmdf <- change(mdf, y = \"spikes.hr\", what = \"transformation\", to = \"identity\")\n# The \"to\" choices include \"identity\" = no transformation, \"standardize\" = standardization, \"log\" = natural logarithm transformation, \"logshift\" = log(y + a) transformation, where a is a small constant, or \"sqrt\" = square-root variable transformation. Changing the transformation will correspondingly change the inverse transformation.",
      "line_count": 23
    },
    {
      "section": "Data Handling",
      "code": "# 5. examine missingness patterns\nsummary(mdf); hist(mdf); \nimage(mdf)\n\n# 6. Perform initial imputation\nimputations1 <- mi(mdf, n.iter=10, n.chains=5, verbose=TRUE)\nhist(imputations1)\n\n# 7. Extracts several multiply imputed data.frames from \"imputations\" object\ndata.frames1 <- complete(imputations1, 5)\n\n# 8. Report a list of \"summaries\" for each element (imputation instance)\nmySummary1 <- lapply(data.frames1, summary)\n\ndatatable(data.frame(t(as.matrix(unclass(mySummary1$`chain:1`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:1)'),\n    extensions = 'Buttons', options = list(dom = 'Bfrtip',\n    buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))\n\ndatatable(data.frame(t(as.matrix(unclass(mySummary1$`chain:5`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:5)'),\n    extensions = 'Buttons', options = list(dom = 'Bfrtip',\n    buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))\n\n# 8.a. To cast the imputed numbers as integers (not necessary, but may be useful)\nindx <- sapply(data.frames1[[5]], is.numeric)  # get the indices of numeric columns\ndata.frames1[[5]][indx] <- lapply(data.frames1[[5]][indx], function(x) as.numeric(as.integer(x))) \t\t    # cast each value as integer\n# data.frames[[5]]$spikes.hr\n\n# 9. Save results out\n# write.csv(data.frames1[[5]], \"C:\\\\Users\\\\IvoD\\\\Desktop\\\\TBI_MIData.csv\")\n\n# 10. Complete Data analytics functions:\n# library(\"mi\")\n#lm.mi(); glm.mi(); polr.mi(); bayesglm.mi(); bayespolr.mi(); lmer.mi(); glmer.mi()\n\n# 10.1 Define Linear Regression for multiply imputed dataset - Also see Step (12)\n##linear regression for each imputed data set - 5 regression models are fit\nfit_lm1 <- glm(ever.sz ~ surgery + worst.gcs + factor(sex) + age, data.frames1$`chain:1`, family = \"binomial\"); summary(fit_lm1); display(fit_lm1)\n\n# Fit the appropriate model and pool the results (estimates over MI chains)\nmodel_results <- pool(ever.sz ~ surgery + worst.gcs + factor(sex) + age, family = \"binomial\", data=imputations1,  m=5)\ndisplay (model_results); summary (model_results)  \n\n# Report the summaries of the imputations\ndata.frames <- complete(imputations1, 3)  \t# extract the first 3 chains\nmySummary2 <-lapply(data.frames1, summary)\n\ndatatable(data.frame(t(as.matrix(unclass(mySummary2$`chain:1`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:1)'))\n\n# 11. Validation: we now verify whether enough iterations were conducted. \n# Validation criteria demands that the mean of each completed variable should\n# be similar for each of the k chains (in this case k=5).\n# mipply is wrapper for sapply invoked on mi-class objects to compute the col means\nround(mipply(imputations1, mean, to.matrix = TRUE), 3)\n\n# Rhat convergence statistics compares the variance between chains to the variance\n# within chains (similar to the ANOVA F-test). \n# Rhat Values ~ 1.0 indicate likely convergence, \n# Rhat Values > 1.1 indicate that the chains should be run longer \n# (use large number of iterations)\nRhats(imputations1, statistic = \"moments\") # assess the convergence of MI algorithm\n\n# When convergence is unstable, we can continue the iterations for all chains, e.g.\nimputations1 <- mi(imputations1, n.iter=20) # add additional 20 iterations\n\n# To plot the produced mi results, for all missing_variables we can generate\n# a histogram of the observed, imputed, and completed data.\n# We can compare of the completed data to the fitted values implied by the model\n# for the completed data, by plotting binned residuals. \n# hist function works similarly as plot. \n# image function gives a sense of the missingness patterns in the data\nplot(imputations1); hist(imputations1); image(imputations1)\nmySummary3 <-lapply(data.frames1, summary)\n\ndatatable(data.frame(t(as.matrix(unclass(mySummary3$`chain:1`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:1)'))\n\n\n# 12. Finally, pool over the m = 5 imputed datasets when we fit the \"model\"\n# Pool from across the 4 chains - in order to estimate a linear regression model\n# and impact of various predictors\n\nmodel_results <- pool(ever.sz ~ surgery + worst.gcs + factor(sex) + age, data =  imputations1,  m =  5 ); display (model_results); summary (model_results)\ncoef(summary(model_results))[, 1:2]  # get the model coefficients and their SE's  ",
      "line_count": 90
    },
    {
      "section": "Data Handling",
      "code": "# install.packages(c(\"gridExtra\", \"MASS\"))\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(MASS)\nlibrary(knitr)",
      "line_count": 5
    },
    {
      "section": "Data Handling",
      "code": "# simulate 20 (feature) vectors  of 200 (cases) Normal Distributed random values (\\mu, \\Sigma)\n# You can choose multiple distribution for testing\n# sim_data <- replicate(20, rpois(50, 10))\nset.seed(202227)\nmu <- as.matrix(rep(2,20) )\nsig <- diag(c(1:20) )\n# Add a noise item. The noise is $ \\epsilon ~ MVN(as.matrix(rep(0,20)), diag(rep(1,20)))$\nsim_data <- mvrnorm(n = 200, mu, sig) + \n  mvrnorm(n=200, as.matrix(rep(0,20)), diag( rep(1,20) ))\n\n# save these in the \"original\" object\nsim_data.orig <- sim_data\n\n# install.packages(\"e1071\")\n\n# introduce 500 random missing indices (in the total of 4000=200*20)\n# discrete distribution where the probability of the elements of values is proportional to probs,\n# which are normalized to add up to 1.\nrand.miss <- e1071::rdiscrete(500, probs = rep(1,length(sim_data)), values = seq(1, length(sim_data)))\nsim_data[rand.miss] <- NA\nsum(is.na(sim_data))  # check now many missing (NA) are there < 500\n\n# cast the data into a data.frame object and report 15*10 elements\nsim_data.df <- data.frame(sim_data)\n# kable( sim_data.df[1:15, 1:10], caption = \"The first 15 rows and first 10 columns of the simulation data\")\n\ndf_mdf <- sim_data.df %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_mdf, caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Simulated Data (sim_data.df)'),\n    extensions = 'Buttons', options = list(dom = 'Bfrtip',\n    buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))\n\n# datatable(sim_data.df, caption = htmltools::tags$caption(\n#      style = 'caption-side: bottom; text-align: center;', \n#      'Table: Simulated Data (sim_data.df)'),\n#     extensions = 'Buttons', options = list(dom = 'Bfrtip',\n#     buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))\n\n# Define the EM imputation method\nEM_algorithm <- function(x, tol = 0.001) {\n  # identify the missing data entries (Boolean indices)\n  missvals <- is.na(x)\n  # instantiate the EM-iteration\n  new.impute <- x\n  old.impute <- x\n  count.iter <- 1\n  reach.tol <- 0\n  \n  # compute \\Sigma on complete data\n  sigma <- as.matrix(var(na.exclude(x)))\n  # compute the vector of feature (column) means\n  mean.vec <- as.matrix(apply(na.exclude(x), 2, mean))\n  \n  while (reach.tol != 1) {\n    for (i in 1:nrow(x)) {\n      pick.miss <- (c(missvals[i, ]))\n      if (sum(pick.miss) != 0) {\n        \n        # compute inverse-Sigma_completeData, variance-covariance matrix\n        inv.S <- solve(sigma[!pick.miss, !pick.miss], tol = 1e-40) \n        \n        # Expectation Step\n        # $$E(Y|X)=\\mu_{mis}+\\Sigma_{mo}\\Sigma_{oo}^{-1}(X-\\mu_{obs})$$\n        new.impute[i, pick.miss] <- mean.vec[pick.miss] +\n          sigma[pick.miss,!pick.miss] %*% inv.S %*%\n          (t(new.impute[i, !pick.miss]) - t(t(mean.vec[!pick.miss])))\n      }\n    }\n    \n    # Maximization Step\n    # Recompute the complete \\Sigma the complete vector of feature (column) means\n    \n    #$$\\Sigma^{(t+1)} = \\frac{1}{n}\\sum_{i=1}^nE(ZZ^T|X) - \\mu^{(t+1)}{\\mu^{(t+1)}}^T$$\n    sigma <- var((new.impute))\n    #$$\\mu^{(t+1)} = \\frac{1}{n}\\sum_{i=1}^nE(Z|X)$$\n    mean.vec <- as.matrix(apply(new.impute, 2, mean))\n    \n    # Inspect for convergence tolerance, start with the 2nd iteration\n    if (count.iter > 1) {\n      for (l in 1:nrow(new.impute)) {\n        for (m in 1:ncol(new.impute)) {\n          if (abs((old.impute[l, m] - new.impute[l, m])) > tol) {\n            reach.tol <- 0\n          } else {\n            reach.tol <- 1\n          }\n        }\n      }\n    }\n    count.iter <- count.iter + 1 \n    old.impute <- new.impute\n  }\n  \n  # return the imputation output of the current iteration that passed the tolerance level\n  return(new.impute)\n} \n\nsim_data.imputed <- EM_algorithm(sim_data.df, tol=0.0001)\ndf_mdf <- sim_data.imputed %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_mdf, caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: EM-Imputed Simulated Data'),\n    extensions = 'Buttons', options = list(dom = 'Bfrtip',\n    buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))",
      "line_count": 105
    },
    {
      "section": "Data Handling",
      "code": "plot.me <- function(index1, index2){\n  plot.imputed <- sim_data.imputed[row.names(\n    subset(sim_data.df, is.na(sim_data.df[, index1]) | is.na(sim_data.df[, index2]))), ]\n  p = ggplot(sim_data.imputed, aes_string( paste0(\"X\",index1)  , paste0(\"X\",index2 ))) + \n  geom_point(alpha = 0.5, size = 0.7)+theme_bw() +\n  stat_ellipse(type = \"norm\", color = \"#000099\", alpha=0.5) +\n  geom_point(data = plot.imputed, aes_string( paste0(\"X\",index1) , paste0(\"X\",(index2))),size = 1.5, color = \"Magenta\", alpha = 0.8)\n} \n\ngridExtra::grid.arrange( plot.me(1,2), plot.me(5,6), plot.me(13,20), plot.me(18,19), nrow = 2)\n\nindex1=1; index2=5\nplot.imputed <- sim_data.imputed[row.names(\n    subset(sim_data.df, is.na(sim_data.df[, index1]) | is.na(sim_data.df[, index2]))), ]\n  p = ggplot(sim_data.imputed, aes_string( paste0(\"X\",index1)  , paste0(\"X\",index2 ))) + \n  geom_point(alpha = 0.5, size = 0.7)+theme_bw() +\n  stat_ellipse(type = \"norm\", color = \"#000099\", alpha=0.5) +\n  geom_point(data = plot.imputed, aes_string( paste0(\"X\",index1) , paste0(\"X\",(index2))),size = 1.5, color = \"Magenta\", alpha = 0.8)\n  \nplot_ly(sim_data.imputed, x = ~X1, y = ~X5, type = \"scatter\", \n        mode = \"markers\") %>% \n    layout(title='Scatterplot: Improved Water Quality vs. Sanitation Facilities', \n           xaxis = list (title = 'Water Quality'), yaxis = list (title = 'Sanitation'))\n  ",
      "line_count": 24
    },
    {
      "section": "Data Handling",
      "code": "# knitr::include_graphics(\"ammelia.png\")",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "# install.packages(\"Amelia\")\nlibrary(Amelia)\ndim(sim_data.df)\namelia.out <- amelia(sim_data.df, m = 5)\namelia.out\namelia.imputed.5 <- amelia.out$imputations[[5]]",
      "line_count": 6
    },
    {
      "section": "Data Handling",
      "code": "plot.ii2 <- function(index, index2){\n  plot.imputed <- sim_data.imputed[row.names(\n    subset(sim_data.df, is.na(sim_data.df[, index]) | is.na(sim_data.df[, index2]))), ]\n  plot.imputed2 <- amelia.imputed.5[row.names(\n  subset(sim_data.df, is.na(sim_data.df[, index]) | is.na(sim_data.df[, index2]))), ]\n  p = ggplot(sim_data.imputed, aes_string( paste0(\"X\",index)  , paste0(\"X\",index2 ))) + \n  geom_point(alpha = 0.8, size = 0.7)+theme_bw() +\n  stat_ellipse(type = \"norm\", color = \"#000099\", alpha=0.5) +\n  geom_point(data = plot.imputed, aes_string( paste0(\"X\",index) , paste0(\"X\",(index2))),size = 2.5, color = \"Magenta\", alpha = 0.9, shape = 16) +  \n    geom_point(data = plot.imputed2, aes( X1 , X2),size = 2.5, color = \"#FF9933\", alpha = 0.8, shape = 18)\n  return(p)\n} \n\nplot.ii2(2, 4)\nplot.ii2(17, 18)",
      "line_count": 15
    },
    {
      "section": "Data Handling",
      "code": "# plot.ii3 <- function(index){\n#   imputed <- sim_data.imputed[is.na(sim_data.df[, index]) , index]\n#   imputed.amelia <- amelia.imputed.5[is.na(sim_data.df[, index]) , index]\n#   observed <- sim_data.df[!is.na(sim_data.df[, index]) , index]\n#   imputed.df <- data.frame(x = c(observed,imputed,imputed.amelia), category = c( rep(\"obs\",length(observed)),rep(\"simpleImplement\",length(imputed)) ,rep(\"amelia\",length(imputed.amelia))   ) )\n#   p = ggplot(imputed.df, aes(x=x, y =..density..)) + \n#     geom_density(aes(fill = category),alpha=0.3)+\n#     theme_bw()\n#   return(p)\n#   }\n# grid.arrange( plot.ii3(1),plot.ii3(2),plot.ii3(3),plot.ii3(4),plot.ii3(5),\n#               plot.ii3(6),plot.ii3(7),plot.ii3(8),plot.ii3(9),plot.ii3(10),\n#               nrow = 5)\n\nlibrary(tidyr)\n\nmyPlotly <- function(index){\n  imputed <- sim_data.imputed[is.na(sim_data.df[, index]) , index]\n  imputed.amelia <- amelia.imputed.5[is.na(sim_data.df[, index]) , index]\n  observed <- sim_data.df[!is.na(sim_data.df[, index]) , index]\n  imputed.df <- data.frame(x = c(observed,imputed,imputed.amelia), \n              category = c( rep(\"obs\",length(observed)),rep(\"simpleImplement\",length(imputed)),\n                            rep(\"amelia\",length(imputed.amelia))   ) )\n  df_long <- as.data.frame(cbind(index=c(1:length(imputed.df$x)), \n                                 category=imputed.df$category, x=imputed.df$x))\n  df_wide <- spread(df_long, category, x)\n  \n  p = plot_ly() %>%\n    add_lines(x = ~density(as.numeric(df_wide$simpleImplement), na.rm = T)$x, \n        y= ~density(as.numeric(df_wide$simpleImplement), na.rm = T)$y, name = \"EM\", mode = 'lines') %>%\n    add_lines(x = density(as.numeric(df_wide$amelia), na.rm = T)$x, \n        y= density(as.numeric(df_wide$amelia), na.rm = T)$y, name = \"Amelia\", mode = 'lines') %>%\n    add_lines(x = ~density(as.numeric(df_wide$obs), na.rm = T)$x, \n        y= ~density(as.numeric(df_wide$obs), na.rm = T)$y, name = \"Observed\", mode = 'lines') %>%\n    layout(title=sprintf(\"Distributions: Feature X.%d\", index),\n           xaxis = list(title = 'Measurements'),\n           yaxis = list(title =\"Densities\"),\n           legend = list(title=\"Distributions\", orientation = 'h'))\n  return(p)\n}\n\n# Plot a few features\nmyPlotly(5)\nmyPlotly(9)\nmyPlotly(10)\n# grid.arrange( myPlotly(1),myPlotly(2),myPlotly(3),myPlotly(4),myPlotly(5),\n#               myPlotly(6),myPlotly(7),myPlotly(8),myPlotly(9),myPlotly(10),\n#               nrow = 5)\n",
      "line_count": 49
    },
    {
      "section": "Data Handling",
      "code": "# install.packages(\"xml2\")\nlibrary(\"XML\"); library(\"xml2\")\nlibrary(\"rvest\")\nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SOCR_Data_Dinov_021708_Earthquakes\")\nhtml_nodes(wiki_url, \"#content\")\nearthquake<- html_table(html_nodes(wiki_url, \"table\")[[2]])",
      "line_count": 6
    },
    {
      "section": "Data Handling",
      "code": "# library(ggplot2)\n# plot4<-ggplot(earthquake, aes(Longitude, Latitude, group=Magt, color=Magt))+ \n#   geom_point(data=earthquake, size=4, mapping=aes(x=Longitude, y=Latitude, shape=Magt))\n# plot4  # or plint(plot4)\n# https://plotly-r.com/working-with-symbols.html \n\nglyphication <- function (name) {\n  glyph= vector()\n  for (i in 1:length(name)){\n    glyph[i]=\"triangle-up\"\n    if (name[i]==\"Md\") { glyph[i]=\"diamond-open\" }\n    else if (name[i]==\"ML\") { glyph[i]=\"circle-open\" }\n    else if (name[i]==\"Mw\") { glyph[i]=\"square-open\" }\n    else if (name[i]==\"Mx\") { glyph[i]=\"x-open\" }\n  }\n  return(glyph)\n}\nearthquake$glyph <- glyphication(earthquake$Magt)\n  \nplot_ly(earthquake) %>%\n  add_markers(x = ~Longitude, y = ~Latitude, type = \"scatter\",  color = ~Magt,\n        mode = \"markers\", marker = list(size = ~Depth, color = ~Magt, symbol = ~glyph,\n                                        line = list(color = \"black\",width = 2))) %>% \n    layout(title=\"California Earthquakes (1969 - 2007)\")",
      "line_count": 24
    },
    {
      "section": "Data Handling",
      "code": "plot5 <- ggplot(earthquake, aes(Latitude, size=1))+geom_density(aes(color=Magt))\nplot5",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "kernal_density <- with(earthquake, MASS::kde2d(Longitude, Latitude, n = 50))",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "library(plotly)\nwith(kernal_density, plot_ly(x=x, y=y, z=z, type=\"surface\"))",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "plot_ly(x = ~ earthquake$Longitude)\nplot_ly(x = ~ earthquake$Longitude, y = ~earthquake$Latitude)\nplot_ly(x = ~ earthquake$Longitude, y = ~earthquake$Latitude, z=~earthquake$Mag)\n\ndf3D <- data.frame(x=earthquake$Longitude, y=earthquake$Latitude, z=earthquake$Mag)\n\n# Convert he Long (X, Y, Z) Earthquake format data into a Matrix Format\n\n#  install.packages(\"Matrix\")\nlibrary(\"Matrix\")\nmatrix_EarthQuakes <- with(df3D, sparseMatrix(i = as.numeric(180-x), j=as.numeric(y), x=z, use.last.ij=T, dimnames=list(levels(x), levels(y))))\ndim(matrix_EarthQuakes)\n\n# colnames(matrix_EarthQuakes) <- seq(from=earthquake$Longitude[1],\n#                                     to=earthquake$Longitude[length(earthquake$Longitude)],\n#                                                              length.out=dim(matrix_EarthQuakes)[2])\n# rownames(matrix_EarthQuakes) <- seq(from=earthquake$Latitude[1],\n#                                     to=earthquake$Latitude[length(earthquake$Latitude)],\n#                                                              length.out=dim(matrix_EarthQuakes)[1])\n# View(as.matrix(matrix_EarthQuakes))\n\n# view matrix is 2D heatmap: \nlibrary(\"ggplot2\"); library(\"gplots\")\n\n# heatmap.2( as.matrix(matrix_EarthQuakes[280:307, 30:44]), Rowv=FALSE, Colv=FALSE, dendrogram='none', cellnote=as.matrix(matrix_EarthQuakes[280:307, 30:44]), notecol=\"black\", trace='none', key=FALSE, lwid = c(.01, .99), lhei = c(.01, .99), margins = c(5, 15 ))\n\nplot_ly(z = ~as.matrix(matrix_EarthQuakes[280:307, 30:44]), type = \"heatmap\") %>% hide_colorbar()\n\n# plot_ly(x=~colnames(matrix_EarthQuakes[280:307, 30:44]), \n#         y=~rownames(matrix_EarthQuakes[280:307, 30:44]),\n#         z = ~as.matrix(matrix_EarthQuakes[280:307, 30:44]), type = \"heatmap\") %>%\n#   layout(title=\"California Earthquakes Heatmap\", \n#          xaxis=list(title=\"Longitude\"), yaxis=list(title=\"Latitude\")) %>% \n#   hide_colorbar()\n\n# Long -180<x<-170, Lat: 30<y<45, Z: 5<Mag<8\nmatrix_EarthQuakes <- with(df3D, sparseMatrix(i = as.numeric(180+x), j=as.numeric(y), x=z, use.last.ij=TRUE, dimnames=list(levels(x), levels(y))))\nmat1 <- as.matrix(matrix_EarthQuakes)\nplot_ly(z = ~mat1, type = \"surface\")\n\n# To plot the Aggregate (Summed) Magnitudes at all Long/Lat:\nmatrix_EarthQuakes <- with(df3D, sparseMatrix(i = as.numeric(180+x), j=as.numeric(y), x=z, dimnames=list(levels(x), levels(y))))\nmat1 <- as.matrix(matrix_EarthQuakes)\nplot_ly(z = ~mat1, type = \"surface\")\n# plot_ly(z = ~mat1[30:60, 20:40], type = \"surface\")",
      "line_count": 45
    },
    {
      "section": "Data Handling",
      "code": "# update packages\n# update.packages()\n\n# load the data: 06_PPMI_ClassificationValidationData_Short.csv\nppmi_data <-read.csv(\"https://umich.instructure.com/files/330400/download?download_frd=1\", header=TRUE)\n\ntable(ppmi_data$ResearchGroup)\n\n# binarize the Dx classes\nppmi_data$ResearchGroup <- ifelse(ppmi_data$ResearchGroup == \"Control\", \"Control\", \"Patient\")\nattach(ppmi_data)\n\nhead(ppmi_data)\n\n# Model-free analysis, classification\n# install.packages(\"crossval\")\n# install.packages(\"ada\")\n# library(\"crossval\")\nlibrary(crossval)\nlibrary(ada)\n#set up adaboosting prediction function\n\n\n# Define a new classification result-reporting function\nmy.ada <- function (train.x, train.y, test.x, test.y, negative, formula){\n  ada.fit <- ada(train.x, train.y)\n  predict.y <- predict(ada.fit, test.x)\n  #count TP, FP, TN, FN, Accuracy, etc.\n  out <- confusionMatrix(test.y, predict.y, negative = negative)\n # negative\t is the label of a negative \"null\" sample (default: \"control\").\n  return (out)\n}\n\n# balance cases\n# SMOTE: Synthetic Minority Oversampling Technique to handle class imbalance in binary classification.\nset.seed(1000)\n# https://cran.r-project.org/src/contrib/Archive/unbalanced/\n# install.packages('mlr', 'FNN', 'RANN', 'unbalanced') to deal with unbalanced group data\nlibrary(unbalanced)\nppmi_data$PD <- ifelse(ppmi_data$ResearchGroup==\"Control\", 1, 0) \nuniqueID <- unique(ppmi_data$FID_IID) \nppmi_data <- ppmi_data[ppmi_data$VisitID==1, ]\nppmi_data$PD <- factor(ppmi_data$PD)\n\ncolnames(ppmi_data)\n# ppmi_data.1<-ppmi_data[, c(3:281, 284, 287, 336:340, 341)]\nn <- ncol(ppmi_data)\noutput.1 <- ppmi_data$PD\n\n# remove Default Real Clinical subject classifications! \nppmi_data$PD <- ifelse(ppmi_data$ResearchGroup==\"Control\", 1, 0) \ninput <- ppmi_data[ , -which(names(ppmi_data) %in% c(\"ResearchGroup\", \"PD\", \"X\", \"FID_IID\"))]\n# output <- as.matrix(ppmi_data[ , which(names(ppmi_data) %in% {\"PD\"})])\noutput <- as.factor(ppmi_data$PD)\nc(dim(input), length(output))\n\n#balance the dataset\ndata.1<-ubBalance(X= input, Y=output, type=\"ubSMOTE\", percOver=300, percUnder=150, verbose=TRUE)\n# percOver = A number that drives the decision of how many extra cases from the minority class are generated (known as over-sampling).\n# k = A number indicating the number of nearest neighbors that are used to generate the new examples of the minority class.\n# percUnder = A number that drives the decision of how many extra cases from the majority classes are selected for each case generated from the minority class (known as under-sampling)  \n\nbalancedData<-cbind(data.1$X, data.1$Y)\ntable(data.1$Y)\n\nnrow(data.1$X); ncol(data.1$X)\nnrow(balancedData); ncol(balancedData)\nnrow(input); ncol(input)\n\ncolnames(balancedData) <- c(colnames(input), \"PD\")\n\n# check visually for differences between the distributions of the raw (input) and rebalanced data (for only one variable, in this case)\nQQ <- qqplot(input[, 5], balancedData [, 5], plot.it=F)\n\nplot_ly(x=~QQ$x, y = ~QQ$y, type=\"scatter\", mode=\"markers\", showlegend=F) %>%\n  add_lines(x=c(0,0.8), y=c(0,0.8), showlegend=F) %>%\n  layout(title=\"QQ-Plot Original vs. Rebalanced Data\", xaxis=list(title=\"original data\"),\n         yaxis=list(title=\"Rebalanced data\"))\n\n###Check balance\n## Wilcoxon test\nalpha.0.05 <- 0.05\ntest.results.bin <- NULL\t\t# binarized/dichotomized p-values\ntest.results.raw <- NULL\t\t# raw p-values\n\nfor (i in 1:(ncol(balancedData)-1)) {\n\ttest.results.raw [i]  <- wilcox.test(input[, i], balancedData [, i])$p.value\n  \ttest.results.bin [i] <- ifelse(test.results.raw [i] > alpha.0.05, 1, 0)\n\tprint(c(\"i=\", i, \"Wilcoxon-test=\", test.results.raw [i]))\n}\nprint(c(\"Wilcoxon test results: \", test.results.bin))\n\ntest.results.corr <- stats::p.adjust(test.results.raw, method = \"fdr\", n = length(test.results.raw)) \n# where methods are \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"BY\", \"fdr\", \"none\")\n# plot(test.results.raw, test.results.corr)\n# zeros (0) are significant independent between-group T-test differences, ones (1) are insignificant\n\nplot_ly(x=~test.results.raw, y = ~test.results.corr, type=\"scatter\", mode=\"markers\", showlegend=F) %>%\n  add_lines(x=c(0,1), y=c(0,1), showlegend=F) %>%\n  layout(title=\"Wilcoxon test results - Original vs. Rebalanced Data\", xaxis=list(title=\"Original\"),\n         yaxis=list(title=\"Rebalanced\"))\n\n# Check the Differences between the rate of significance between the raw and FDR-corrected p-values\ntest.results.bin <- ifelse(test.results.raw > alpha.0.05, 1, 0)\ntable(test.results.bin)\ntest.results.corr.bin <- ifelse(test.results.corr > alpha.0.05, 1, 0)\ntable(test.results.corr.bin)",
      "line_count": 107
    }
  ]
}