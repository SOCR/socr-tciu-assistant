{
  "metadata": {
    "created_at": "2024-11-30T13:46:16.335837",
    "total_sections": 2,
    "total_code_chunks": 44,
    "total_tables": 1,
    "r_libraries": [
      "DiagrammeR",
      "EBImage",
      "XML",
      "calibrate",
      "cluster",
      "data.tree",
      "ggdendro",
      "ggplot2",
      "graphics",
      "imager",
      "jpeg",
      "kernlab",
      "matrixStats",
      "mclust",
      "mixtools",
      "plotly",
      "rvest",
      "stats"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"DSPA2: Data Science and Predictive Analytics (UMich HS650)\"\nsubtitle: \"<h2><u>Unsupervised Clustering</u></h2>\"\nauthor: \"<h3>SOCR/MIDAS (Ivo Dinov)</h3>\"\ndate: \"`r format(Sys.time(), '%B %Y')`\"\ntags: [DSPA, SOCR, MIDAS, Big Data, Predictive Analytics] \noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: SOCR_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 3\n    toc_float:\n      collapsed: false\n      smooth_scroll: true\n    code_folding: show",
      "word_count": 52
    },
    {
      "title": "Unsupervised Clustering",
      "content": "As we learned in [Chapters 3-6](https://dspa2.predictive.space), supervised regression and classification techniques facilitate explicit forecasting and prediction using prospective observations. However, these approaches typically require *a priori* human supervised class labels or predefined outcomes. In many situations, e.g., exploratory data analytics or open-ended study paradigms, such explicit outcomes may not be readily available, may not be desirable, or could require additional time and resources to define, derive, or generate.\n\n*Clustering* can help us conduct complex data-driven studies where automated segregation of participants, grouping of cases, or cohort clustering may be beneficial for capturing similar traits, characterizing common behaviors, or phenotype categorization of heterogeneous phenomena. Each derived group category can be subsequently interpreted in terms of the observed data features. Complementary to various confirmatory analytic methods used in supervised strategies for predicting specific outcomes, clustering may be used for exploratory data analytics and *unsupervised learning*.\n\nIn this chapter, we will (1) present clustering as a machine learning task, (2) review the *silhouette* plots for assessing the reliability of clustering, (3) discuss the *k-Means* clustering algorithm and how to tune it, (4) show examples of several interesting case-studies, including Divorce and Consequences on Young Adults, Pediatric Trauma, and Youth Development, and (5) demonstrate hierarchical, spectral, and Gaussian mixture-model clustering approaches.\n    \n\n## ML Clustering\n\nAs we mentioned earlier, clustering is a machine learning technique that bundles unlabeled cases and outcome-free data into distinct groups. Scatter plots we saw in previous chapters represent a simple visual illustration of the clustering process. Let's start with a simple [hotdogs example](https://wiki.socr.umich.edu/index.php/SOCR_012708_ID_Data_HotDogs). Assume we don't know much about the ingredients of frankfurters (hotdogs) and we look at the following graph.\n\n\nIn terms of their *calories* and *sodium* content, these hotdogs appear to be separated into three different clusters. *Cluster 1* has hotdogs of low calories and medium sodium content; *Cluster 2* has both calorie and sodium at medium levels; *Cluster 3* has both sodium and calories at high levels. We can make a bold guess about the ingredients used in the hotdogs in these three clusters. For cluster 1, it could be mostly *chicken* meat since it has low calories. The second cluster might be *beef* and the third one is likely to be *pork*, because beef hotdogs have considerably less calories and salt than pork hotdogs. However, this is just guessing. Some hotdogs have a mixture of two or three types of meat. The real situation is resembling somewhat our initial guess, however with some random noise, especially in cluster 2.\n\nThe following plot shows a more nuanced scatter of the primary type of meat used for each hotdog designated by color and glyph-symbol for meat-type.\n\n\n## Silhouette plots\n\n[Silhouette plots](https://en.wikipedia.org/wiki/Silhouette_(clustering)) represent graphical depictions of the individual data points and their corresponding cluster-wide silhouette values, which are useful for interpretation of the performance and validation of the consistency of various clustering algorithms. The silhouette value, $sil \\in [-1,1]$, measures the similarity (cohesion) of a data point to its cluster relative to other clusters (separation). Silhouette plots rely on a distance metric, e.g., the [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance), [Manhattan distance](https://en.wikipedia.org/wiki/Manhattan_distance), [Minkowski distance](https://en.wikipedia.org/wiki/Minkowski_distance), etc. The qualitative mapping between silhouette values and their interpretations is summarized below.\n\n - A high silhouette value suggests that the data matches its own cluster well.\n - A clustering algorithm performs well when most Silhouette values are high.\n - A low silhouette value indicates poor matching within the neighboring cluster. \n - Poor clustering may imply that the algorithm configuration may have too many or too few clusters.\n\nSuppose a clustering method groups all data points (objects), $\\{X_i\\}_i$, into $k$ clusters. For each object, we can define the following pair of similarity measures to track its within-cluster and between-cluster similarity.\n\n - $d_i$ as the *average dissimilarity* of $X_i$ with all other data points within its cluster. internal dissimilarity $d_i$ captures the quality of the assignment of $X_i$ to its current class label. Smaller or larger $d_i$ values suggest better or worse overall assignment for $X_i$ to its cluster, respectively.  The average dissimilarity of $X_i$ to a cluster $C$ is the average distance between $X_i$ and all points in the cluster of points labeled $C$.\n - $l_i$ as the *lowest average dissimilarity* of $X_i$ to any other cluster that $X_i$ is not a member of. The cluster corresponding to $l_i$, the lowest average dissimilarity, is called the $X_i$ **neighboring cluster**, as it is the next best fit cluster for $X_i$. \n\nThen, the **silhouette** (value) of each object $X_i$ is defined by:\n\n$$-1 \\leq s_i = \\frac{l_i - d_i}{\\max\\{l_i,  d_i\\}}\n\\equiv \\begin{cases}\n  1-\\frac{d_i}{l_i}, & \\mbox{if } d_i < l_i \\\\\n  0,  & \\mbox{if } d_i = l_i \\\\\n  \\frac{l_i}{d_i}-1, & \\mbox{if } d_i > l_i \\\\\n\\end{cases} \\leq 1 .$$\n\nNote that:\n\n - $-1\\leq s_i \\leq 1$,\n - $s_i \\longrightarrow 1$ when $d_i \\ll l_i$, i.e., the dissimilarity of $X_i$ to its cluster $C$ is much lower relative to its dissimilarity to other clusters, indicating a good (cluster assignment) match. Thus, high Silhouette values imply the data is appropriately clustered.\n - Conversely, $-1 \\longleftarrow s_i$ when $l_i \\ll d_i$, $d_i$ is large, implying a poor match of $X_i$ with its current cluster $C$, relative to neighboring clusters. $X_i$ may be more appropriately clustered in its neighboring cluster. \n - $s_i \\sim 0$ means that the $X_i$ may lie on the border between two natural clusters.\n \nCluster-wide silhouette values represent the overall averages of the corresponding point-based silhouette values for all members of each class.\n\n\n## The k-Means Clustering Algorithm\n\nThe *K-means* algorithm is one of the most commonly used ML clustering algorithms. It has resemblance to the familiar *k-nearest neighbors (kNN)* presented in [Chapter 5](https://socr.umich.edu/DSPA2/DSPA2_notes/05_SupervisedClassification.html). The distinction is that in clustering, we don't have a priori pre-determined labels, and the k-means algorithm is trying to deduce the missing intrinsic groupings in the data.\n\nSimilar to kNN, most of the times, k-means relies on the Euclidean distance ($|\\cdot |_2$ norm), however Manhattan distance ($|\\cdot |_1$ norm), the more general Minkowski distance ($(\\sum_{i=1}^n{|p_i - q_i|^c})^{\\frac{1}{c}}$), Mahalanobis distance (for $x,y\\in \\mathbb{R}$ and a given a nonsingular covariance matrix $S$, $d(x,y)={\\sqrt {(x-y)^t S^{-1}(x-y)}}$), or other distance functions may also be used. For $c=2$, the Minkowski distance represents the classical Euclidean distance, which is commonly used in k-means clustering\n\n$$dist(x, y)=\\sqrt{\\sum_{n=1}^n(x_i-y_i)^2}.$$\n\n### Pseudocode\n\nGiven a specific distance function, we can group neighbors of observations into separate clusters according to their paired distances. Suppose we are trying to use k-means clustering to group a set of observations $\\{x_1, x_2, \\cdots, x_n\\},\\ x_i\\in\\mathbb{R}^d$, into $k\\leq n$ classes $S = \\{S_1, S_2, \\cdots, S_k\\}$. Effectively, the algorithm aims to *minimize* the within-cluster sum of squares, i.e., enforce lower intraclass variance. Let $\\mu_i$ be the mean of all points in the group $S_i$. Then the k-means optimizes the following objective function\n\n$$\\arg\\min_{S} {\\sum_{i=1}^{k} \\sum_{x \\in S_i} {|x - \\mu_i |^2}}=\n\\arg\\min_{S} {\\sum_{i=1}^{k}|S_i| Var(S_i)} \\approx\n\\arg\\min_{S} {\\sum_{i=1}^k {\\frac{1}{|S_{i}|} \\sum_{x,y \\in S_i} { |x-y|^2}}}.$$\n\nSince, $|S_i|\\sum_{x \\in S_i} {|x -\\mu_i|^2 =\\sum_{x \\neq y \\in S_i} |x - y|^2}$, the left and right hand side optimization problems yield equivalent solutions. Also, as the total variance remains unchanged, this *within-group minimization* problem is equivalent to a corresponding *between clusters (dual) maximization* problem involving the sum squared deviations *between* points in different clusters. \n\nThe **k-means protocol** is as follows:\n\n - *Initiation*: First, define *k* points as cluster centers. Often these points are *k* random points from the dataset. For example, if *k=3* we choose 3 random points in the dataset as cluster centers.\n - *Assignment*: Second, determine the maximum extent of the cluster boundaries by computing the distances between each point and the current cluster centers. For each point, we assign the cluster label based on its shortest distance to a cluster center. Now the data are separated into *k* initial clusters.  The assignment of each observation to a cluster is based on computing the least within-cluster sum of squares (i.e., dissimilarities) according to the chosen distance. Mathematically, this is equivalent to [Voronoi tessellation](https://en.wikipedia.org/wiki/Centroidal_Voronoi_tessellation) of the space of the observations according to their mean distances. Voronoi partitioning of the observations can be accomplished by assigning each point $x_p$ to a single class $S^{(t)}$, where at each iteration $i$, $m_i^{(t)}$ denotes the group means of $S_i^{(t)}$.\n\n$$S_i^{(t)}=\\left\\{x_p : \\left \\|x_p-m_i^{(t)}\\right \\|^2\\leq \\left \\|x_p-m_j^{(t)}\\right \\|^2,\\ 1\\leq j\\leq k\\right\\}.$$\n\n - *Update*: Third, update the centers of the current clusters to the new *means* of all points in the current cluster vicinity (based on the shortest distances from current centroid locations). This updating phase is the essence of the *k-means* algorithm. The updating step recomputes the new centroids for each cluster using\n\n$$m_i^{(t+1)} = \\frac{1}{|S_i^{(t)}|}\\sum_{x_j\\in S_i^{(t)}} {x_j}.$$\n\nAlthough there is no guarantee that the *k-means* algorithm converges to a global optimum, in practice, the algorithm tends to converge, i.e., the assignments of objects into groups stabilizes to a local minimum represented by one of only a finite number of such Voronoi partitionings. The following [SOCR 2D Interactive Voronoi Tessellation App](https://socr.umich.edu/HTML5/others/Voronoi_App/) provides an interactive demonstration of this iterative parcellation process where we can use parameters to manually control the dynamics of the iterative process.\n\n### Choosing the appropriate number of clusters\n\nIn principle, neither a large nor a small number of clusters are desirable. If the number of clusters is too large, the induced object grouping may be too specific to be meaningfully interpreted. On the other hand, having too few groups might be overly broad or excessively general to be useful. As we mentioned in [Chapter 5](https://socr.umich.edu/DSPA2/DSPA2_notes/05_SupervisedClassification.html), $k=\\sqrt{\\frac{n}{2}}$ may be a good place to start. However, it might generate too many cluster groups. \n\nAgain, the elbow method may be used to determine the relationship between the number of clusters $k$ and the homogeneity of the observations within each cluster.\n\nGraphing the within-group homogeneity against $k$ identifies if there exists a clearly defined \"elbow point\" suggesting a minimum number $k$ corresponding to relatively large within-group homogeneity.\n\n\nThis graph shows that homogeneity barely increases above the \"elbow point\". There are various ways to measure homogeneity within a cluster. Further details about these choices are provided in this paper [On clustering validation techniques, Journal of Intelligent Information Systems Vol. 17, pp. 107-145, by M. Halkidi, Y. Batistakis, and M. Vazirgiannis (2001)](http://dx.doi.org/10.1023/A:1012801612483).\n\nLet's try to develop a new method `drawElbowGraph()` that automatically identifies an optimal *elbow* point and determines an appropriate value for the number of clusters $k$.\n\n\n**Note**: Recall that the [projection of a point $\\vec{P}$ onto a line $\\vec{l}$](https://en.wikipedia.org/wiki/Vector_projection) is defined as the vector $\\vec{Q}=\\frac{\\langle \\vec{P} | \\vec{l} \\rangle }{\\langle \\vec{l} | \\vec{l} \\rangle }\\vec{l}$. In the graph above the *max-distance* is the length $||\\vec{Q}||$ and $\\vec{Q} \\perp \\vec{l}$. However, since the scales of the horizontal and vertical axes are different, $\\vec{Q}$ *appears* to be a vertical line (it's not!) and it represents the max-distance between the blue curve to the reference orange line.\n\n\n### Case Study 1: Divorce and Consequences on Young Adults\n\n*Step 1 - collecting data*\n\nThis example uses the [Divorce and Consequences on Young Adults dataset](https://umich.instructure.com/files/399121/download?download_frd=1). This is a longitudinal study focused on examining the consequences of recent parental divorce for young adults (initially ages 18-23) whose parents had divorced within 15 months of the study's first wave (1990-91). The sample consisted of 257 White respondents with newly divorced parents. Here we have a subset of this dataset with 47 respondents in [our case-studies folder, CaseStudy01_Divorce_YoungAdults_Data.csv](https://umich.instructure.com/courses/38100/files/folder/Case_Studies).\n\nThe features in the data include:\n\n - **DIVYEAR**: Year in which parents were divorced.  Dichotomous variable with 1989 and 1990 \n - **Child affective relations**: \n    + Momint: Mother intimacy.  Interval level data with 4 possible responses (1-extremely close, 2-quite close, 3-fairly close, 4- not close at all) \n    + Dadint: Father intimacy. Interval level data with 4 possible responses (1-extremely close, 2-quite close, 3-fairly close, 4-not close at all) \n    + Live with mom: Polytomous variable with 3 categories (1- mother only, 2- father only, 3- both parents) \n - **momclose**: measure of how close the child is to the mother (1-extremely close, 2-quite close, 3-fairly close, 4- not close at all).\n - **Depression**: Interval level data regarding feelings of depression in the past 4 weeks.  Possible responses are 1-often, 2-sometimes, 3-hardly ever, 4-never \n - **Gethitched**: Polytomous variable with 4 possible categories indicating respondent's plan for marriage (1-Marry fairly soon, 2-marry sometime, 3-never marry, 8-don't know)\n\n*Step 2 - exploring and preparing the data*\n\nLet's load the dataset and report a summary of all variables.\n\n\nAccording to the summary, DIVYEAR is actually a dummy variable (either 89 or 90). We can re-code (binarize) the DIVYEAR using the `ifelse()` function (mentioned in [Chapter 7](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/07_NaiveBayesianClass.html)). The following line of code generates a new indicator variable for *divorce year=1990*.\n\n\nWe also need another preprocessing step to deal with `livewithmom`, which has missing values, `livewithmom=9`. We can impute these using `momint` and `dadint` variables for each specific participant.\n\n\nFor instance, respondents that feel much closer to their dads may be assigned `divorce$livewithmom==2`, suggesting they most likely live with their fathers. Of course, alternative imputation strategies are also possible.\n\n\n*Step 3 - training a model on the data*\n\nThe function `kmeans()` provides one interface to the *k-means* clustering method using the following invocation syntax.\n\n`myclusters <- kmeans(mydata, k)`\n\n - *mydata*: dataset in a matrix form.\n - *k*: number of clusters we want to create.\n\nThe *output* consists of:\n\n - *myclusters$cluster*: vector indicating the cluster number for every observation.\n - *myclusters$center*: a matrix showing the mean feature values for every center.\n - *mycluster$size*: a table showing how many observations are assigned to each cluster.\n\nBefore we perform clustering, we need to standardize the features to avoid biasing the clustering based on features that use large-scale values. Note that distance calculations are sensitive to measuring units. The method `as.data.frame()` converts the dataset into a data frame allowing us subsequently to use a combination of `lapply()` and `scale()` to standardize the data.\n\n\nThe resulting dataset, `di_z`, is standardized so all features are unitless and follow approximately standardized normal distribution.\n\nNext, we need to think about selecting a proper $k$. We have a relatively small dataset with 47 observations. Obviously we cannot have a $k$ as large as 10. The rule of thumb suggests $k=\\sqrt{47/2}=4.8$. This would be relatively large also because we may expect less than 10 observations for each cluster and it is very likely that some clusters may only have a one observation. A better choice may be 3. Let's see if this will work.\n\n\n*Step 4 - evaluating model performance*\n\nLet's look at the clusters created by the *k-means* model.\n\n\nAt first glance, it seems that 3 worked well for the number of clusters. We don't have any cluster that contains a small number of observations. The three clusters have a relatively equal number of respondents.\n\n*Silhouette* plots represent the most appropriate evaluation strategy to assess the quality of the clustering. Silhouette values are between -1 and 1. In our case, two data points correspond to negative Silhouette values, suggesting these cases may be \"mis-clustered\", or perhaps are ambiguous as the Silhouette value is close to 0. We can observe that the average Silhouette is reasonable, about $0.2$.\n\n\nThe next step would be to interpret the clusters in the context of this social study.\n\n\nThese results facilitate interpretation of the underlying factors associated with the derived 3-cluster labels. For instance, cluster 1 corresponds to divyear=mostly 90, momint=very close, dadint=not close, livewithmom=mostly mother, depression=not often, (gethiched) marry=will likely not get married. Cluster 1 represents mostly adolescents that are closer to mom than dad. These young adults do not often feel depressed and they may avoid getting married. These young adults tend to not be too emotional and do not value family. We can see that these three different clusters appear to contain three complementary types of young adults. Bar plots also provide an alternative strategy to visualize the difference between clusters.\n\n\nFor each of the three clusters, the bars in the plot above represent the following order of features `DIVYEAR, momint, dadint, momclose, depression, livewithmom, gethitched`.\n\n*Step 5 - usage of cluster information*\n\nClustering results could be utilized as new information augmenting the original dataset. For instance, we can add a *cluster* label in our `divorce` dataset:\n\n\nWe can also examine the relationship between living with mom and feel close to mom by displaying a scatter plot of these two variables. If we suspect that young adults' personality might affect this relationship, then we could consider the potential personality (cluster type) in the plot. The cluster labels associated with each participant are printed in different positions relative to each pair of observations, `(livewithmom, momint)`.\n\n\nWe can either use `plot_ly()`, as we showed above, or use the `ggplot2::ggplot()` function to label points with cluster types. In `plot_ly`, we use name and color to stratify the clusters, whereas using `ggplot(divorce, aes(livewithmom, momint))+geom_point()` uses *aesthetics* (`aes`) to draw the scatter plot where the `geom_text()` function helps us label the points with their corresponding cluster identifiers.\n\nThis plot shows that living with mom does not necessarily mean young adults will feel close to mom. For \"emotional\" (cluster 1) young adults, they felt close to their mom whether they live with their mom or not. \"Naive\" (cluster 2) young adults feel closer to mom if they live with mom. However, they tend to be estranged from their mother. \"Independent\" (cluster 3) young adults are opposite to cluster 1. They felt closer to mom if they didn't live with her. \n\n### Model improvement\n\nLet's still use the divorce data to illustrate a model improvement using **k-means++**.\n\n(Appropriate) initialization of the **k-means** algorithm is of paramount importance. The **k-means++** extension provides a practical strategy to obtain an optimal initialization for k-means clustering using a predefined `kpp_init` method.\n\n\nWe can observe some differences.\n\n\nThis improvement is not substantial - the new overall average Silhouette value remains $0.2$ for **k-means++**, compared with the value of $0.2$ reported for the earlier k-means clustering, albeit the 3 groups generated by each method are quite distinct. In addition, the number of \"mis-clustered\" instances remains 2 although their Silhouette values are rather smaller than before and the overall cluster 1 Silhouette average value is low ($0.006$).\n\n\n#### Tuning the hyperparameter $k$\n\nSimilar to what we performed for KNN and SVM, we can tune the **k-means** parameters, including centers initialization and $k$.\n\n\nThis suggests that k=2 or 8 may be appropriate numbers of clusters to use in this case.\nWe can also experiment with other parameter settings, e.g., set the maximal iteration of the algorithm and rerun the model with optimal values of the hyperparameter k=2 or k=8. \n \n\n\n\n### Case study 2: Pediatric Trauma\n\nThe next example demonstrates the use of the *k-means* clustering method on a larger dataset of trauma-exposed children.\n\n*Step 1 - collecting data*\n\nThe dataset we will interrogate now includes [Services Utilization by Trauma-Exposed Children in the US data](https://umich.instructure.com/files/399127/download?download_frd=1), which is located in [our case-studies folder](https://umich.instructure.com/courses/38100/files/folder/Case_Studies). This case study examines associations between post-traumatic psychopathology and service utilization by trauma-exposed children. \n\nThe variables in this dataset include:\n\n - **id**: Case identification number.\n - **sex**: Female or male, dichotomous variable (1= female, 0= male).\n - **age**: Age of child at time of seeking treatment services. Interval-level variable, score range= 0-18.\n - **race**: Race of child seeking treatment services. Polytomous variable with 4 categories (1= black, 2= white, 3= hispanic, 4= other).\n - **cmt**: The child was exposed to child maltreatment trauma - dichotomous variable (1= yes, 0= no).\n - **traumatype**: Type of trauma exposure the child is seeking treatment sore. Polytomous variable with 5 categories (\"sexabuse\"= sexual abuse, \"physabuse\"= physical abuse, \"neglect\"= neglect, \"psychabuse\"= psychological or emotional abuse, \"dvexp\"= exposure to domestic violence or intimate partner violence).\n - **ptsd**: The child has current post-traumatic stress disorder. Dichotomous variable (1= yes, 0= no).\n - **dissoc**: The child currently has a dissociative disorder (PTSD dissociative subtype, DESNOS, DDNOS). Interval-level variable, score range= 0-11.\n - **service**: Number of services the child has utilized in the past 6 months, including primary care, emergency room, outpatient therapy, outpatient psychiatrist, inpatient admission, case management, in-home counseling, group home, foster care, treatment foster care, therapeutic recreation or mentor, department of social services, residential treatment center, school counselor, special classes or school, detention center or jail, probation officer. Interval-level variable, score range= 0-19.\n\n**Note**: These data (`Case_04_ChildTrauma._Data.csv`) are tab-delimited.\n\n*Step 2 - exploring and preparing the data*\n\nFirst, we need to load the dataset into R and report its summary and dimensions.\n\n\nIn the summary we see two factors - `race` and `traumatype`. `Traumatype` codes the real classes we are interested in. If the clusters created by the model are quite similar to the trauma types, our model may have a quite reasonable interpretation. Let's also create a dummy variable for each racial category.\n\n\nThen, we will remove the (outcome-type) class variable, `traumatype`, from the dataset to avoid biasing the clustering algorithm. Thus, we are simulating a real biomedical case-study where we do not necessarily have the actual class information available, i.e., classes are latent features. \n\n\n*Step 3 - training a model on the data*\n\nSimilar to case-study 1, let's standardize the dataset and fit a k-means model.\n\n\nHere we use *k=5* in the hope that we have similar 5 clusters that match the 5 trauma types. In this case study, we have 1,000 observations and *k=5* may be a reasonable option.\n\n*Step 4 - evaluating model performance*\n\nTo assess the clustering model results, we can examine the resulting clusters.\n\n\nOn this barplot, the bars in each cluster represents `sex, age, ses, ptsd, dissoc, service, black, hispanic, other,` and `white`, respectively. It is quite obvious that each cluster has some unique features.\n\nNext, we can compare the *k-means* computed cluster labels to the *original labels*. Let's evaluate the similarities between the automated cluster labels and their real class counterparts using a confusion matrix table, where rows represent the k-means clusters, columns show the actual labels, and the cell values include the frequencies of the corresponding pairings.\n\n\nWe can see that all of the children in cluster 4 belong to `dvexp` (exposure to domestic violence or intimate partner violence). The model groups all `physabuse` and `sexabuse` cases into *cluster1* but can't distinguish between them. Majority (200/250) of all `dvexp` children are grouped in *clusters 4 and 5*. Finally, `neglect` and `psychabuse` types are mixed in *clusters 2 and 3*.\n\nLet's review the output Silhouette value summary. It works well as only a small portion of samples appear mis-clustered.\n\n\nNext, let's try to tune $k$ with **k-means++** and see if $k=5$ appears to be optimal. \n\n\nFinally, let's use **k-means++** with $k=3$ and set the algorithm's maximal iteration before rerunning the experiment:\n\n\nAs we showed earlier, we can interpret the resulting `kmeans` clusters in the context of this pediatric trauma study, by examining `clust_kpp$centers`.\n\n### Feature selection for k-Means clustering\n\nA very active area of research involves feature selection for unsupervised machine-learning clustering, including k-means clustering. We won't go into details here, but we list some of the current strategies to choose salient features in situations where we don't have ground-truth labels.\n\n - For Gaussian model-based clustering, the ['mclust' package](https://cran.r-project.org/web/packages/mclust) provides the functionality to learn and report the clusters, as well as perform variable selection using ['clustvarsel'](https://cran.r-project.org/web/packages/clustvarsel/index.html).\n - a [feature selection for clustering article](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.295.8115&rep=rep1&type=pdf) provides a review of possible strategies.\n - [Unsupervised Feature Selection for k-means Clustering](https://www.researchgate.net/profile/Christos_Boutsidis/publication/221620396_Unsupervised_Feature_Selection_for_the_k-means_Clustering_Problem/links/02e7e52aea2e9b9923000000/Unsupervised-Feature-Selection-for-the-k-means-Clustering-Problem.pdf) provides specifics for variable selection for the k-means algorithm.\n - A [Feature Selection for Clustering](https://link.springer.com/chapter/10.1007/3-540-45571-X_13) paper presents an approach where features are ranked according to their importance on clustering and then a subset of important features are chosen.\n\n\n## Hierarchical Clustering\n\nRecall from [Chapter 5](https://socr.umich.edu/DSPA2/DSPA2_notes/05_SupervisedClassification.htmll) that there are three large classes of unsupervised clustering methods - *Bayesian*, *partitioning-based*, and *hierarchical.* Hierarchical clustering represents a family of techniques that build hierarchies of clusters using one of two complementary strategies:\n\n - *Generative* methods (also known as *agglomerative*) represent bottom-up approaches that are initialized with each individual observation being its own cluster, and the iterative protocol aggregates observations (i.e., merges clusters) by pairing similar clusters, which results in higher hierarchy levels.\n - *Discriminative* methods (also known as *divisive*) represent reversed top-down techniques that are initialized by all observations belonging to a single cluster, which is recursively split into higher hierarchical levels.\n\nIn both situations, cluster splits and merges are determined by minimizing some objective function using a greedy algorithm (e.g., gradient descent). It's common to illustrate hierarchical clustering results as dendrograms. One example of genomics data hierarchical clustering using probability distributions is available [here (DOI: 10.1016/j.jtbi.2016.07.032)](https://doi.org/10.1016/j.jtbi.2016.07.032).\n\nDecisions about merging or splitting nodes in the hierarchy heavily depend on the specific distance metric used to measure the dissimilarity between sets of observations in the original cluster and the candidate children (sub)clusters. It's common to employ standard metrics ($d$) for measuring distances between pairs of observations (e.g., Euclidean, Manhattan, Mahalanobis) and a linkage criterion connecting cluster-dissimilarity of sets to the paired distances of observations in the cluster sets (e.g., maximum/complete linkage clustering \t$\\max \\{ d ( a , b ) : a \\in A , b \\in B \\}$, minimum/single linkage clustering \t$\\min \\{ d ( a , b ) : a \\in A , b \\in B \\}$, mean linkage clustering $\\frac {1}{|A|.|B|} \\sum_{a\\in A} {\\sum _{b\\in B}d(a,b)}$).\n\nThere are a number of `R` **hierarchical clustering** packages, including:\n\n - `hclust` in base R.\n - `agnes` in the `cluster` package.\n\nAlternative distance measures (or linkages) can be used in all Hierarchical Clustering, e.g., *single*, *complete* and *ward*.\n\nWe will demonstrate hierarchical clustering using case-study 1 ([Divorce and Consequences on Young Adults](https://umich.instructure.com/files/399121/download?download_frd=1)). Preset $k=3$ and recall that we have to use normalized data for hierarchical clustering.\n\n\nYou can generate the hierarchical plot by `ggdendrogram` in the package `ggdendro`.\n\n\nGenerally speaking, the best result should come from **wald** linkage, but you should also try complete linkage (method='complete'). We can see that the hierarchical clustering result (average silhouette value $\\sim 0.24$) mostly agrees with the prior *k-means* ($0.2$) and *k-means++* ($0.2$) results.\n\n\n## Spectral Clustering\n\nSpectral clustering relies on decomposition of the similarity-matrix   in terms of its spectrum of eigenvalues. The similarity matrix of the data is computed using some pairwise distances between all observations in the dataset. This spectral decomposition is used to reduce the data dimensionality prior to clustering. Typically, one precomputes the distance matrix first and feeds it as an input to the clustering method.\n\nFor a dataset of records, the similarity matrix is a symmetric matrix $A=\\{a_{ij}\\geq 0\\}_{ij}$ encoding the similarity measures between pairs of data points indexed by $1\\leq i,j \\leq n$. Most spectral clustering methods employ a traditional *cluster method* like $k$-means clustering applied on the eigenvectors of the *Laplacian* similarity matrix. There are alternative approaches to define a Laplacian that lead to different mathematical interpretations of the spectral clustering protocol. The *relevant eigenvectors* correspond to the few *smallest eigenvalues* of the Laplacian, excluding the smallest eigenvalue, which is typically $0$. This process (finding the smallest eigenvalues) is analogous to computing the *largest* few eigenvalues of an operator representing a *function* of the original Laplacian.\n\nThe underlying philosophy of spectral clustering has roots in physics, e.g., partitioning of a mass-spring system. The analytical concept corresponding to physical mass is data point and mass-characteristics (e.g., stiffness parameter) relates to weights of edges describing pairwise similarity of related data points. The eigenvalue problem in spectral clustering analytics maps to physical transversal vibration modes of mass-spring systems. Mathematically, the eigenvalue problem for the Laplacian matrix is $L=D-A$, where \n$D=\\{ d_{i,i} = \\sum_j a_{i,j};\\ d_{i\\not= j}=0 \\}$ is a diagonal matrix.\n\nTightly coupled spring masses in the physical system jointly move in space from the equilibrium state in low-frequency vibration modes. Eigenvector components that correspond to the smallest eigenvalues of the Laplacian can be used to derive clustering of the masses (data points). \n\nFor instance, the *normalized cuts* spectral clustering algorithm partitions points in $B$ into two sets $B_1$ and $B_2$ based on the eigenvector $v$ corresponding to the *second-smallest* Laplacian eigenvalue, where the *symmetrized-and-normalized* Laplacian matrix is defined by:\n\n$$L^\\text{norm} = I-\\left (D^{-1/2} A D^{-1/2}\\right ).$$\n\nSimilarly, we can take the eigenvector corresponding to the *largest eigenvalue* of the adjacency matrix \n\n$$P = D^{-1}A.$$ \n\nThe key is to obtain the spectrum of the Laplacian. Then using the eigenvectors, we can cluster the observations in many alternative ways. For instance, the cases can be partitioned by computing the median $m$ of the components of the *second smallest eigenvector* $v$ and mapping all points whose component in $v$ is greater than $m$ in $B_1$ and the remaining cases in its complement, $B_2$. Repeated partitioning of the data into the subsets using this protocol will induce a classification scheme (spectral clustering) of the data.\n\nThe unnormalized spectral clustering pseudo algorithm is listed below.\n\n - *Input*:  *Similarity matrix*, $A\\in \\mathbb{R}^n\\times \\mathbb{R}^n$, $k=$ number of clusters\n - Construct a *similarity graph* modeling the local neighborhood relationships, where the similarity function encodes mainly local neighborhoods. For instance, a Gaussian similarity function $a(x_i,x_j)=\\exp{\\left (-\\frac{||x_i-x_j||^2}{2\\sigma^2}\\right )}$, where $\\sigma$ controls the width of the neighborhoods.\n - Let $W$ be its *weighted adjacency matrix*, corresponding to the similarity graph, $W= (w_{i,j})_{i,j}$, where $w_{i,j}=w_{j,i}$ and $w_{i,j}= 0$ implies that the vertices $x_i$ and $x_j$ are not connected. \n - Compute the unnormalized Laplacian $L$.\n - Compute the first $k$ eigenvectors of $L$ and let $V\\in R^{n\\times k}$ be the matrix containing these $k$ vectors as columns.\n - For $1\\leq i\\leq n$, let $y_i\\in \\mathbb{R}^k$ be the vector corresponding to the $i^{th}$ row of $V$.\n - In $\\mathbb{R}^k$, Cluster the points $\\{y_i \\}_{1\\leq i\\leq n}$ in $k$-clusters, $\\{C_i\\}_{i=1}^k$, using $k$-means clustering.\n - *Output*:  Clusters $\\{A_i\\}_{i=1}^k$, where $A_i=\\{j | y_i \\in C_i\\}$.\n\n### Image segmentation using spectral clustering\n\nLet's look at one specific implementation of spectral clustering for segmenting/classifying a region of interest (ROI) representing [brain hematoma](https://en.wikipedia.org/wiki/Subdural_hematoma) in a 2D MRI image ([MRI_ImageHematoma.jpg](https://umich.instructure.com/files/1627149/download?download_frd=1)).\n\n\n### Point cloud segmentation using spectral clustering\n\nLet's try spectral clustering on the [Knee Pain Dataset](https://wiki.socr.umich.edu/index.php/SOCR_Data_KneePainData_041409) using the `kernlab::specc()` method.\n\n\n## Gaussian mixture models\n\nRecall the general univariate distribution mixture modeling we showed using the [crystallography data in Chapter 2](https://socr.umich.edu/DSPA2/DSPA2_notes/02_Visualization.html#26_Distributions). Gaussian mixture modeling is a special case of distribution mixture modeling using normal distribution components.\n\n\nWhen modeling a process using a mixture of $k$ Gaussian distributions, the probability of observing an outcome $x_n$ is given by the weighted averaging (linear mixture) of the corresponding $k$ Gaussian probabilities:\n\n$$p(x_n)=\\sum_k {\\left ( \\underbrace{p(x_n | z_n=k)}_{k^{th}\\ Gaussian\\ Probability} \\times \n\\underbrace{p(z_n=k)}_{prior} \\right )}.$$\n\nThe *probability* represents the specific Gaussian mixture component, $N(x_n |\\mu_k, \\Sigma_k)$, and the *prior* represents the mixture proportion. The probability $p(x_n)$ describes how each data point $x_n$ can be generated from the prior distribution on the $k$ model components, $\\pi_k=p(z_n=k)$, choosing a cluster first, and then how to generate values of the data point from the corresponding model distribution, $N(\\mu_k, \\Sigma_k)$.\n\nFor a mixture of $k$ Gaussians, the GMM distribution has $\\theta=\\{\\mu_l, \\Sigma_l, \\pi_l, 1\\leq, l\\leq k \\}$ parameters. We want to obtain the maximum likelihood estimate (MLE) of the unknown parameter vector $\\theta$.\n\nWhen all data and classes $(x_i, z_i)$ are observed, we can maximize the data log-likelihood function for $(x_i, z_i)$ using $p(x_i, z_i)$. However, when only a fraction of $x_i$’s is observed, the situation is much more difficult, as we can only maximize the data log-likelihood for $(x_i)$ based on $p(x_i)$. Using the expectation maximization (EM) algorithm, we can maximize the expected data log-likelihood for $(x_i, z_i)$ based on $p(x_i, z_i)$.\n\nTo learn the mixture models when the data and classes are fully observed, we assume\nthat the data are IID, which helps simplify the joint probability distribution. The log-likelihood \ndecomposes into a sum of local terms. The MLE exists since the two optimization problems, for $(\\mu_k, \\Sigma_k)$ (each Gaussian component) and for $\\pi_k$ (weights), are decoupled, and there exists a closed-form MLE solution.\n\n$$I_c(\\theta | Data)=\\sum_k {\\log(p(x_n,z_n | \\theta)}\\equiv \n\\underbrace{\\sum_k {\\log(p(z_n | \\theta)}}_{{\\text{depends on }} \\pi_k} + \n\\underbrace{\\sum_k {\\log(p(x_n | z_n, \\theta)}}_{{\\text{depends on }} (\\mu_k,\\Sigma_k)}.$$\n\nMore explicitly,\n\n$$I(\\theta | Data) = \\log\\prod_n {p(x_n,z_n | \\theta)} =\n\\log\\prod_n{(p(z_n | \\pi) p(x_n | z_n, \\mu, \\sigma))}=$$\n$$\\sum_n {\\log\\prod_k \\pi_k^{z_n^k}} + \\sum_n {\\log\\prod_k (N(x_n | \\mu_k, \\sigma))^{z_n^k}}=$$\n$$\\sum_n {\\sum_k {z_n^k \\log \\pi_k}} - \n\\sum_n {\\sum_k {\\left (z_n^k\\frac{1}{2\\sigma^2} (x_n-\\mu_k)^2\\right ) + \\text{const}}}\\ .$$\n\nThe corresponding MLE estimates are:\n\n - $\\hat{\\pi}_k^{MLE}=\\arg\\max_{\\pi} {I(\\theta | Data)}$,\n - $\\hat{\\mu}_k^{MLE}=\\arg\\max_{\\mu} {I(\\theta | Data)}\\equiv \\frac{\\sum{z_n^k x_n}}{\\sum{z_n^k}}$,\n - $\\hat{\\sigma}_k^{MLE}=\\arg\\max_{\\sigma} {I(\\theta | Data)}$\n\n\nMore [details about Gaussian mixture models (GMM) are provided here](http://escholarship.org/uc/item/1rb70972). Also see the [SOCR 2D Gaussian Mixture Model (Java) interactive activity](http://wiki.stat.ucla.edu/socr/index.php/SOCR_EduMaterials_Activities_2D_PointSegmentation_EM_Mixture). Below is a brief introduction to GMM using the `Mclust` function in the `R` package `mclust`.\n\nFor multivariate mixture, there are totally 14 possible models:\n\n - \"EII\"    =    spherical, equal volume\n - \"VII\"    =    spherical, unequal volume\n - \"EEI\"    =    diagonal, equal volume and shape\n - \"VEI\"    =    diagonal, varying volume, equal shape\n - \"EVI\"    =    diagonal, equal volume, varying shape\n - \"VVI\"    =    diagonal, varying volume and shape\n - \"EEE\"    =    ellipsoidal, equal volume, shape, and orientation\n - \"EVE\"    =    ellipsoidal, equal volume and orientation (*)\n - \"VEE\"    =    ellipsoidal, equal shape and orientation (*)\n - \"VVE\"    =    ellipsoidal, equal orientation (*)\n - \"EEV\"    =    ellipsoidal, equal volume and equal shape\n - \"VEV\"    =    ellipsoidal, equal shape\n - \"EVV\"    =    ellipsoidal, equal volume (*)\n - \"VVV\"    =    ellipsoidal, varying volume, shape, and orientation\n\nFor more practical details, you may refer to [`Mclust`](https://cran.r-project.org/web/packages/mclust/mclust.pdf) and its [vignettes](https://cran.r-project.org/web/packages/mclust/vignettes/mclust.html).  Additional theoretical details are available in [C. Fraley and A. E. Raftery (2002). Model-based clustering, discriminant analysis, and density estimation. Journal of the American Statistical Association 97:611:631](http://dx.doi.org/10.1198/016214502760047131).\n\nLet's use the [Divorce and Consequences on Young Adults dataset](https://umich.instructure.com/files/399121/download?download_frd=1) for a demonstration.\n\n\nThus, the optimal model, `VEI`, has 3 components.\n\n\nTo assess the model, we can print the confusion matrix comparing, say, the `Mclust` clustering labels and `divorce$depression` categories:\n\n\n## Summary\n\n - K-means, spectral, hierarchical, and Gaussian mixture-modeling clustering may be most appropriate for exploratory data analytics. These techniques are highly flexible and fairly efficient in terms of tessellating data into groups.\n - Clustering approaches may be be used for data that has no *a priori* classes (labels), i.e., for unsupervised AI/ML.\n - Generated clusters may lead to phenotype stratification and/or be compared against known clinical traits.\n\n\n## Practice Problems\n\n### Youth Development\n\nUse [Boys Town Study of Youth Development data](https://umich.instructure.com/courses/38100/files/folder/Case_Studies),  second case study, CaseStudy02_Boystown_Data.csv, we used in [Chapter 6](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/06_LazyLearning_kNN.html), to find clusters using variables about GPA, alcohol abuse, attitudes on drinking, social status, parent closeness and delinquency for clustering(all variables other than gender and ID).\n\nFirst, load the data and transfer `sex`, `dadjob` and `momjob` into dummy variables.\n\n\nThen, extract all the variables, except the first two columns (subject identifiers and genders).\n\n\nNext, we need to standardize and cluster the data with `k=3`. You may have the following centers (numbers could be a little different).\n\n\nAdd *k-means* cluster labels as a new (last) column back in the original dataset.\n\n\nTo investigate the gender distribution within different clusters we may use `aggregate()`.\n\n\nHere `clusters` represents the new vector indicating cluster labels. The gender distribution does not vary much between different cluster labels.\n\nTry to apply these clustering methods to [other data from the list of our Case-Studies](https://umich.instructure.com/courses/38100/files/).\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number \n\t\t\t\t<img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 5907
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    self_contained: yes\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Unsupervised Clustering",
      "code": "# install.packages(\"rvest\")\nlibrary(plotly)\nlibrary(rvest)\nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SOCR_012708_ID_Data_HotDogs\")\n# html_nodes(wiki_url, \"#content\")\nhotdog <- html_table(html_nodes(wiki_url, \"table\")[[1]])\n# plot(hotdog$Calories, hotdog$Sodium, main = \"Hotdogs\", xlab=\"Calories\", ylab=\"Sodium\")\n# segments(120, 280, 120, 570, lty=2)\n# segments(120, 280, 30, 280, lty=2)\n# segments(120, 570, 30, 570, lty=2)\n# segments(125, 250, 125, 600, lty=2)\n# segments(125, 250, 165, 250, lty=2)\n# segments(165, 250, 165, 600, lty=2)\n# segments(125, 600, 165, 600, lty=2)\n# segments(170, 400, 170, 700, lty=2)\n# segments(170, 400, 250, 400, lty=2)\n# text(100, 220, \"cluster 1\")\n# text(140, 200, \"cluster 2\")\n# text(185, 350, \"cluster 3\")\n# # install.packages(\"calibrate\")\n# # library(calibrate)\n\nmodelLabels <- c('cluster 1', 'cluster 2', 'cluster 3')\nmodelLabels.x <- c(100, 145, 185)\nmodelLabels.y <- c(220, 200, 350)\nmodelLabels.col <- c(\"blue\", \"red\", \"green\")\nrect.x <- c(120, 80, 165, 125, 200, 170)\nrect.y <- c(130, 570, 250, 600, 400, 700)\n\nplot_ly(hotdog, x = ~Calories, y = ~Sodium,  type=\"scatter\",\n        mode=\"markers\", symbol = \"na\", symbols = \"circle-open\") %>%\n  layout(title=\"2D Hotdogs Scatterplot (Calories vs. Sodium)\",\n         xaxis=list(title=\"Calories\"),     # , scaleanchor=\"y\"),  # control the y:x axes aspect ratio\n         yaxis = list(title=\"Sodium\"),     # , scaleanchor  = \"x\"), \n         legend = list(title=list(text='<b> Meat Type</b>'), orientation = 'h'),\n         annotations = list(text=modelLabels,  x=modelLabels.x, y=modelLabels.y, textangle=c(90,90,90),\n                            font=list(size=15, color=modelLabels.col), showarrow=FALSE),\n         shapes = list(   # draw the rectangular boxes\n               list(type=\"rect\", fillcolor=\"lightblue\", line=list(color=\"blue\"), opacity=0.2,\n                    x0=rect.x[1], x1=rect.x[2], xref=\"x\", y0=rect.y[1], y1=rect.y[2], yref=\"y\"),\n               list(type=\"rect\", fillcolor= \"lightgreen\", line=list(color=\"green\"), opacity=0.2,\n                 x0=rect.x[3], x1=rect.x[4], xref=\"x\", y0=rect.y[3], y1=rect.y[4], yref = \"y\"),\n               list(type=\"rect\", fillcolor= \"lightgray\", line=list(color=\"orange\"), opacity=0.2,\n                 x0=rect.x[5], x1=rect.x[6], xref=\"x\", y0=rect.y[5], y1=rect.y[6], yref = \"y\"))\n         )",
      "line_count": 45
    },
    {
      "section": "Unsupervised Clustering",
      "code": "# plot(hotdog$Calories, hotdog$Sodium)\n# text(hotdog$Calories, hotdog$Sodium, labels=hotdog$Type, pos=3)\n# \n# library(ggplot2)\n# gg1_plot = ggplot(hotdog, aes(x=Calories, y=Sodium)) + geom_point(aes(color=Type, shape = Type, stroke = 5),alpha=1) + theme_bw(base_size=15) +\n# guides(colour = guide_legend(override.aes = list(size=5))) +\n# theme(legend.position=\"top\")\n# gg1_plot\n\nplot_ly(hotdog, x = ~Calories, y = ~Sodium, color=~Type, type=\"scatter\",\n        mode=\"markers\", name=~Type, symbol=~Type, marker = list(size = 15)) %>%\n  layout(title=\"2D Hotdogs Scatterplot (Calories vs. Sodium)\",\n         xaxis=list(title=\"Calories\"),     # , scaleanchor=\"y\"),  # control the y:x axes aspect ratio\n         yaxis = list(title=\"Sodium\"),     # , scaleanchor  = \"x\"), \n         legend = list(title=list(text='<b> Meat Type</b>'), orientation = 'h'),\n         annotations = list(text=modelLabels,  x=modelLabels.x, y=modelLabels.y, textangle=c(90,90,90),\n                            font=list(size=15, color=modelLabels.col), showarrow=FALSE),\n         shapes = list(   # draw the rectangular boxes\n               list(type=\"rect\", fillcolor=\"lightblue\", line=list(color=\"blue\"), opacity=0.2,\n                    x0=rect.x[1], x1=rect.x[2], xref=\"x\", y0=rect.y[1], y1=rect.y[2], yref=\"y\"),\n               list(type=\"rect\", fillcolor= \"lightgreen\", line=list(color=\"green\"), opacity=0.2,\n                 x0=rect.x[3], x1=rect.x[4], xref=\"x\", y0=rect.y[3], y1=rect.y[4], yref = \"y\"),\n               list(type=\"rect\", fillcolor= \"lightgray\", line=list(color=\"orange\"), opacity=0.2,\n                 x0=rect.x[5], x1=rect.x[6], xref=\"x\", y0=rect.y[5], y1=rect.y[6], yref = \"y\"))\n         )",
      "line_count": 25
    },
    {
      "section": "Unsupervised Clustering",
      "code": "library(graphics)\nx <- c(30, 200, 500, 1096.663, 3000, 5000, 7000, 10000)\ny <- function(x){\n  y=log(x)\n}\n# curve(log(x), 30, 10000, xlab=\"k\", ylab=\"Within-group Homogeneity\", axes=F, main=\"Elbow Method\")\n# Axis(side=1, at=c(0, 2000, 4000, 6000, 8000, 10000), labels = c(rep(\"\", 6)))\n# Axis(side=2, at=4:9, labels = c(rep(\"\", 6)))\n# points(x, y(x))\n# text(1000, 8, \"elbow point\")\n# segments(1096.663, 7.3, 1000, 7.7)\n\nelbowAnnot <- list(x = x[4], y = y(x[4]), text = \"Elbow Point\", xref = \"x\", yref = \"y\",\n                   showarrow = TRUE, arrowhead = 1)\nplot_ly(x = ~x, y = ~y(x), type = 'scatter', mode = 'markers+lines', marker=list(size=15)) %>%\n    # add_annotation(x=1, y=7, text=\"Elbow Point\", showarrow=True, arrowhead=1) %>%\n    layout(title=\"Elbow Method\", annotations = elbowAnnot,\n           xaxis=list(title=\"Number of clusters (k)\"),\n           yaxis = list(title=\"Within-group Homogeneity\"))",
      "line_count": 19
    },
    {
      "section": "Unsupervised Clustering",
      "code": "# Estimate Elbow point\nestimateElbowPoint <- function(xValues, yValues) {\n  # Determine the extreme values to create line\n  max_x_x <- max(xValues)\n  max_x_y <- yValues[which.max(xValues)]\n  max_y_y <- min(yValues)\n  max_y_x <- xValues[which.min(yValues)]\n  max_df  <- data.frame(x = c(max_y_x, max_x_x), y = c(max_y_y, max_x_y))\n  \n  # Create a straight line between the extreme values\n  fit <- lm(max_df$y ~ max_df$x)\n  \n  # compute Euclidean Distance from point to line\n  distances <- c()\n  for(i in 1:length(xValues)) {\n    distances <- c(distances, \n                   abs(coef(fit)[2]*xValues[i] - yValues[i] + coef(fit)[1]) / sqrt(coef(fit)[2]^2 + 1^2))\n  }\n  \n  # Determine the Max distance point\n  x_max_dist <- xValues[which.max(distances)]\n  y_max_dist <- yValues[which.max(distances)]\n  \n  return(c(x_max_dist, y_max_dist, max(distances)))\n}\n\n# Define elbow-drawing function\n# https://en.wikibooks.org/wiki/Linear_Algebra/Orthogonal_Projection_Onto_a_Line \n# https://en.wikipedia.org/wiki/Vector_projection\ndrawElbowGraph <- function(x_K_clusters, y_WGH_values) {\n  nbValues = length(y_WGH_values)\n  extremes_lineSlope = (y_WGH_values[nbValues] - y_WGH_values[1]) / (x_K_clusters[nbValues] - x_K_clusters[1])\n  extremes_orth_lineSlope = -1 / extremes_lineSlope\n  elbowPoint_orth_proj = c(elbowPoint[1] + elbowPoint[3]/2, \n                           elbowPoint[2] + extremes_orth_lineSlope * (elbowPoint[3]/2))\n  e1 = c(x_K_clusters[nbValues]-x_K_clusters[1], y_WGH_values[nbValues]-y_WGH_values[1])  # bottom-left (origin) point\n  e2 = c(elbowPoint[1]-x_K_clusters[1], elbowPoint[2]-y_WGH_values[1]) # elbow point, e2\n  p = ((e1 %*% e2)[1,1]/(e1 %*% e1)[1,1]) * e1 + c(x_K_clusters[1], y_WGH_values[1]); p  # Projection point\n  distP <- e2-p\n  dist <- sqrt((distP %*% distP)[1,1])\n  distLabel <- (e2+p)/2 + c(100, 2)\n    \n  # plot(x_K_clusters, y_WGH_values, type=\"b\", main='Within-Group Homogeneity (WGH) vs. number of clusters (k)', \n  #      xlab = 'k', ylab = 'WGH Value')\n  # lines(x=c(x_K_clusters[1], x_K_clusters[nbValues]), y=c(y_WGH_values[1], y_WGH_values[nbValues]), \n  #       type=\"b\", col='green')\n  # lines(x=c(elbowPoint[1], p[1]), y=c(elbowPoint[2], p[2]), type=\"b\", col='red')\n\n  plot_ly(x = ~x_K_clusters, y = ~y_WGH_values, type=\"scatter\", mode = \"markers+lines\", name=\"Data\") %>%\n    add_lines(x = c(x_K_clusters[1], x_K_clusters[nbValues]), name=\"reference\", \n              y = c(y_WGH_values[1], y_WGH_values[nbValues]), type = 'scatter', mode = 'lines') %>%\n    add_lines(x = c(elbowPoint[1], p[1]), y = c(elbowPoint[2], p[2]), type = 'scatter', \n              name=\"Max Distance (Elbow)\", mode = 'lines') %>%\n    layout(title='Within-Group Homogeneity (WGH) vs. number of clusters (k)',\n           xaxis = list(title=\"k\"), # scaleanchor=\"y\"),\n           yaxis = list(title=\"WGH Value\"), #, scaleanchor=\"x\"))\n           legend = list(orientation = 'h'),\n           annotations = list(text=paste0(\"MaxDist=\", round(dist, 3)),  \n                   x=distLabel[1], y=distLabel[2], textangle=0, showarrow=T,\n                   xref = \"x\", yref = \"y\", ax = 80, ay = -40))\n}\n\n# Test the function: drawElbowGraph()\nx <- c(30, 200, 500, 1096.663, 3000, 5000, 7000, 10000)\ny <- function(x){\n  return (log(x))\n}\n\nelbowPoint = estimateElbowPoint(xValues = x, yValues = y(x))\n \ndrawElbowGraph(x_K_clusters=x, y_WGH_values=y(x))",
      "line_count": 71
    },
    {
      "section": "Unsupervised Clustering",
      "code": "divorce<-read.csv(\"https://umich.instructure.com/files/399118/download?download_frd=1\")\nsummary(divorce)",
      "line_count": 2
    },
    {
      "section": "Unsupervised Clustering",
      "code": "divorce$DIVYEAR<-ifelse(divorce$DIVYEAR==89, 0, 1)",
      "line_count": 1
    },
    {
      "section": "Unsupervised Clustering",
      "code": "table(divorce$livewithmom)\ndivorce[divorce$livewithmom==9, ]",
      "line_count": 2
    },
    {
      "section": "Unsupervised Clustering",
      "code": "divorce[45, 6]<-2\ndivorce[45, ]",
      "line_count": 2
    },
    {
      "section": "Unsupervised Clustering",
      "code": "di_z <- as.data.frame(lapply(divorce, scale))\nstr(di_z)",
      "line_count": 2
    },
    {
      "section": "Unsupervised Clustering",
      "code": "library(stats)\nset.seed(12345)\ndiz_clussters<-kmeans(di_z, 3)",
      "line_count": 3
    },
    {
      "section": "Unsupervised Clustering",
      "code": "diz_clussters$size",
      "line_count": 1
    },
    {
      "section": "Unsupervised Clustering",
      "code": "library(cluster)\nlibrary(plotly)\ndis = dist(di_z)\nsil = silhouette(diz_clussters$cluster, dis)\nsummary(sil)\nplot(sil, col=c(1:length(diz_clussters$size)))\nggplotly(factoextra::fviz_silhouette(sil, label=T, palette = \"jco\"))",
      "line_count": 7
    },
    {
      "section": "Unsupervised Clustering",
      "code": "diz_clussters$centers",
      "line_count": 1
    },
    {
      "section": "Unsupervised Clustering",
      "code": "# par(mfrow=c(1, 1), mar=c(4, 4, 4, 2))\n# myColors <- c(\"darkblue\", \"red\", \"green\", \"brown\", \"pink\", \"purple\", \"yellow\")\n# barplot(t(diz_clussters$centers), beside = TRUE, xlab=\"cluster\", \n# ylab=\"value\", col = myColors)\n# legend(\"top\", ncol=2, legend = c(\"DIVYEAR\", \"momint\", \"dadint\", \"momclose\", \"depression\", \"livewithmom\", \"gethitched\"), fill = myColors)\n\ndf <- as.data.frame(t(diz_clussters$centers))\nrowNames <- rownames(df)\ncolnames(df) <- paste0(\"Cluster\",c(1:3))\nplot_ly(df, x = rownames(df), y = ~Cluster1, type = 'bar', name = 'Cluster1') %>% \n  add_trace(y = ~Cluster2, name = 'Cluster2') %>% \n  add_trace(y = ~Cluster3, name = 'Cluster3') %>% \n  layout(title=\"Explicating Derived Cluster Labels\",\n         yaxis = list(title = 'Cluster Centers'), barmode = 'group')",
      "line_count": 14
    },
    {
      "section": "Unsupervised Clustering",
      "code": "divorce$clusters<-diz_clussters$cluster\ndivorce[1:5, ]",
      "line_count": 2
    },
    {
      "section": "Unsupervised Clustering",
      "code": "# require(ggplot2)\n# ggplot(divorce, aes(livewithmom, momint), main=\"Scatterplot Live with mom vs feel close to mom\") +\n#   geom_point(aes(colour = factor(clusters), shape=factor(clusters), stroke = 8), alpha=1) + \n#   theme_bw(base_size=25) +\n#   geom_text(aes(label=ifelse(clusters%in%1, as.character(clusters), ''), hjust=2, vjust=2, colour = factor(clusters)))+\n#   geom_text(aes(label=ifelse(clusters%in%2, as.character(clusters), ''), hjust=-2, vjust=2, colour = factor(clusters)))+\n#   geom_text(aes(label=ifelse(clusters%in%3, as.character(clusters), ''), hjust=2, vjust=-1, colour = factor(clusters))) + \n#   guides(colour = guide_legend(override.aes = list(size=8))) +\n# theme(legend.position=\"top\")\n\nclusterNames <- paste0(\"Cluster \", divorce$clusters)\nplot_ly(data = divorce, x = ~livewithmom, y = ~momint, type=\"scatter\", mode=\"markers\",\n        color = ~clusters, marker = list(size = 30), name=clusterNames) %>%\n  hide_colorbar()",
      "line_count": 14
    },
    {
      "section": "Unsupervised Clustering",
      "code": "# install.packages(\"matrixStats\")\nlibrary(matrixStats)\nkpp_init = function(dat, K) {\n  x = as.matrix(dat)\n  n = nrow(x)\n  # Randomly choose a first center\n  centers = matrix(NA, nrow=K, ncol=ncol(x))\n  # set.seed(123)\n  centers[1,] = as.matrix(x[sample(1:n, 1),])\n  for (k in 2:K) {\n    # Calculate dist^2 to closest center for each point\n    dists = matrix(NA, nrow=n, ncol=k-1)\n    for (j in 1:(k-1)) {\n      temp = sweep(x, 2, centers[j,], '-')\n      dists[,j] = rowSums(temp^2)\n    }\n    dists = rowMins(dists)\n    # Draw next center with probability proportional to dist^2\n    cumdists = cumsum(dists)\n    prop = runif(1, min=0, max=cumdists[n])\n    centers[k,] = as.matrix(x[min(which(cumdists > prop)),])\n  }\n  return(centers)\n}\nset.seed(12345)\nclust_kpp = kmeans(di_z, kpp_init(di_z, 3), iter.max=200, algorithm='Hartigan-Wong')",
      "line_count": 26
    },
    {
      "section": "Unsupervised Clustering",
      "code": "clust_kpp$centers",
      "line_count": 1
    },
    {
      "section": "Unsupervised Clustering",
      "code": "sil2 = silhouette(clust_kpp$cluster, dis)\nsummary(sil2)\nplot(sil2, col=1:length(diz_clussters$size), border=NA)\nggplotly(factoextra::fviz_silhouette(sil2, label=T, palette = \"jco\"))",
      "line_count": 4
    },
    {
      "section": "Unsupervised Clustering",
      "code": "n_rows <- 21\nmat = matrix(0,nrow = n_rows)\nfor (i in 2:n_rows){\n  set.seed(321)\n  clust_kpp = kmeans(di_z, kpp_init(di_z, i), iter.max=100, algorithm='Lloyd')\n  sil = silhouette(clust_kpp$cluster, dis)\n  mat[i] = mean(as.matrix(sil)[,3])\n}\ncolnames(mat) <- c(\"Avg_Silhouette_Value\")\nmat\n# ggplot(data.frame(k=2:n_rows,sil=mat[2:n_rows]),aes(x=k,y=sil))+\n#   geom_line()+\n#   scale_x_continuous(breaks = 2:n_rows)\n\ndf <- data.frame(k=2:n_rows,sil=mat[2:n_rows])\nplot_ly(df, x = ~k, y = ~sil, type = 'scatter', mode = 'lines', name='Silhouette') %>%\n  layout(title=\"Average Silhouette Graph\")",
      "line_count": 17
    },
    {
      "section": "Unsupervised Clustering",
      "code": "k <- 8\nset.seed(31)\nclust_kpp = kmeans(di_z, kpp_init(di_z, k), iter.max=200, algorithm=\"MacQueen\")\nsil3 = silhouette(clust_kpp$cluster, dis)\nsummary(sil3)\nplot(sil3, col=1:length(clust_kpp$size))",
      "line_count": 6
    },
    {
      "section": "Unsupervised Clustering",
      "code": "trauma<-read.csv(\"https://umich.instructure.com/files/399129/download?download_frd=1\", sep = \" \")\nsummary(trauma); dim(trauma)",
      "line_count": 2
    },
    {
      "section": "Unsupervised Clustering",
      "code": "trauma$black<-ifelse(trauma$race==\"black\", 1, 0)\ntrauma$hispanic<-ifelse(trauma$race==\"hispanic\", 1, 0)\ntrauma$other<-ifelse(trauma$race==\"other\", 1, 0)\ntrauma$white<-ifelse(trauma$race==\"white\", 1, 0)",
      "line_count": 4
    },
    {
      "section": "Unsupervised Clustering",
      "code": "trauma_notype<-trauma[, -c(1, 5, 6)]",
      "line_count": 1
    },
    {
      "section": "Unsupervised Clustering",
      "code": "tr_z <- as.data.frame(lapply(trauma_notype, scale))\nstr(tr_z)\nset.seed(1234)\ntrauma_clusters <- kmeans(tr_z, 5)",
      "line_count": 4
    },
    {
      "section": "Unsupervised Clustering",
      "code": "trauma_clusters$centers\n\nmyColors <- c(\"darkblue\", \"red\", \"green\", \"brown\", \"pink\", \"purple\", \"lightblue\", \"orange\", \"gray\", \"yellow\")\n\n# barplot(t(trauma_clusters$centers), beside = TRUE, xlab=\"cluster\", \n# ylab=\"value\", col = myColors)\n# legend(\"topleft\", ncol=4, legend = c(\"sex\", \"age\", \"ses\", \"ptsd\", \"dissoc\", \"service\", \"black\", \"hispanic\", \"other\", \"white\"), fill = myColors)\n\ndf <- as.data.frame(t(trauma_clusters$centers))\nrowNames <- rownames(df)\ncolnames(df) <- paste0(\"Cluster\",c(1:dim(trauma_clusters$centers)[1]))\nplot_ly(df, x = rownames(df), y = ~Cluster1, type = 'bar', name = 'Cluster1') %>% \n  add_trace(y = ~Cluster2, name = 'Cluster2') %>% \n  add_trace(y = ~Cluster3, name = 'Cluster3') %>% \n  add_trace(y = ~Cluster4, name = 'Cluster4') %>% \n  add_trace(y = ~Cluster5, name = 'Cluster5') %>% \n  layout(title=\"Explicating Derived Cluster Labels\",\n         yaxis = list(title = 'Cluster Centers'), barmode = 'group')",
      "line_count": 18
    },
    {
      "section": "Unsupervised Clustering",
      "code": "trauma$clusters<-trauma_clusters$cluster\ntable(trauma$clusters, trauma$traumatype)",
      "line_count": 2
    },
    {
      "section": "Unsupervised Clustering",
      "code": "dis_tra = dist(tr_z)\nsil_tra = silhouette(trauma_clusters$cluster, dis_tra)\nsummary(sil_tra)\n\nwindows(width=7, height=7)\nplot(sil_tra, col=1:length(trauma_clusters$centers[ ,1]), border=NA)\n# report the overall mean silhouette value\nmean(sil_tra[,\"sil_width\"])\n# The sil object colnames  are (\"cluster\", \"neighbor\", \"sil_width\")",
      "line_count": 9
    },
    {
      "section": "Unsupervised Clustering",
      "code": "mat = matrix(0,nrow = 11)\nfor (i in 2:11){\n  set.seed(321)\n  clust_kpp = kmeans(tr_z, kpp_init(tr_z, i), iter.max=100, algorithm='Lloyd')\n  sil = silhouette(clust_kpp$cluster, dis_tra)\n  mat[i] = mean(as.matrix(sil)[,3])\n}\nmat\n# ggplot(data.frame(k=2:11,sil=mat[2:11]),aes(x=k,y=sil))+geom_line()+scale_x_continuous(breaks = 2:11)\n\ndf <- data.frame(data.frame(k=2:11, sil=mat[2:11]))\nplot_ly(df, x = ~k, y = ~sil, type = 'scatter', mode = 'lines', name='Silhouette') %>%\n  layout(title=\"Average Silhouette Graph\")",
      "line_count": 13
    },
    {
      "section": "Unsupervised Clustering",
      "code": "set.seed(1234)\nclust_kpp = kmeans(tr_z, kpp_init(tr_z, 3), iter.max=100, algorithm='Lloyd')\nsil = silhouette(clust_kpp$cluster, dis_tra)\nsummary(sil)\n# plot(sil)\n# report the overall mean silhouette value\nmean(sil[,\"sil_width\"])",
      "line_count": 7
    },
    {
      "section": "Unsupervised Clustering",
      "code": "library(cluster)\ndivorce_sing = agnes(di_z, diss=FALSE, method='single')\ndivorce_comp = agnes(di_z, diss=FALSE, method='complete')\ndivorce_ward = agnes(di_z, diss=FALSE, method='ward')\nsil_sing = silhouette(cutree(divorce_sing, k=3), dis)\nsil_comp = silhouette(cutree(divorce_comp, k=3), dis)\n# try 10 clusters, see plot above\nsil_ward = silhouette(cutree(divorce_ward, k=10), dis)",
      "line_count": 8
    },
    {
      "section": "Unsupervised Clustering",
      "code": "# install.packages(\"ggdendro\")\nlibrary(ggdendro)\nggdendrogram(as.dendrogram(divorce_ward), leaf_labels=FALSE, labels=FALSE)\n\nmean(sil_ward[,\"sil_width\"])\nggdendrogram(as.dendrogram(divorce_ward), leaf_labels=TRUE, labels=T, size=10)\n\nlibrary(data.tree)\nDD_hcclust <- as.hclust(divorce_ward)\nDD <- as.dendrogram(divorce_ward)\n\n# Dendrogram --> Graph(Nodes)\nDD_Node <- data.tree::as.Node(DD)\n\n# install.packages(\"DiagrammeR\")\n# library(\"DiagrammeR\")\n\nDD_Node$attributesAll\nDD_Node$totalCount\nDD_Node$leafCount\n# DD_Node$height\n\n# Get nodes, labels, values, IDs\nIDs <- DD_Node$Get(\"name\")\nlabels = DD_Node$Get(\"name\")\nparents = DD_Node$Get(function(x) x$parent$name)\nvalues = as.numeric(DD_Node$Get(\"name\"))\n\ndf <- as.data.frame(cbind(labels=labels, parents=parents, values=values))\n\n# remove node self-loops\ndf1 <- subset(df, as.character(labels) != as.character(parents))\n\n# remove duplicates\ndf2 <- distinct(df1, labels, .keep_all= TRUE)\n\nplot_ly(df2, labels=~labels, parents=~parents, values=~values, type='sunburst')\n\nplot_ly(df2, labels=~labels, parents=~parents, values=~values, type='treemap')",
      "line_count": 39
    },
    {
      "section": "Unsupervised Clustering",
      "code": "summary(sil_ward)\nplot(sil_ward, col=1:length(unique(sil_ward[,1])))",
      "line_count": 2
    },
    {
      "section": "Unsupervised Clustering",
      "code": "# Import the Brain 2D image MRI_ImageHematoma.jpg\nlibrary(jpeg)\nimg_url <- \"https://umich.instructure.com/files/1627149/download?download_frd=1\"\t\nimg_file <- tempfile(); download.file(img_url, img_file, mode=\"wb\")\t\nimg <- readJPEG(img_file)\t\n\n# To expedite the calculations, reduce the size of 2D image\n# install.packages(\"BiocManager\")\n# BiocManager::install(\"EBImage\")\n# library(\"EBImage\")\n\nlibrary(imager)   # for image resizing\n\n# take the first RGB-color channel; transpose to get it anatomically correct Viz\nimg1 <- t(apply(img[ , , 1], 2, rev)) \n# width and height of the original image\ndim(img1)[1:2]\nolddim <- c(dim(img1)[1], dim(img1)[2])\nnewdim <- c(64, 64)  # new smaller image dimensions\n# img1 <- resize(img, w = newdim[1], h = newdim[2])\nimg2 <- array(img1, dim=c(dim(img1)[1], dim(img1)[2], 1, 1))  # 2D img --> 4D hyper-volume\nimg3 <- resize(img2, size_x = newdim[1], size_y = newdim[2])\n# dim(img1)  # [1] 64 64  1  1\nimg <- array(img3, dim=c(dim(img3)[1], dim(img3)[2]))  # 4D hyper-volume --> 2D img\n\n# image(img, main=\"Original (high) resolution\", xaxt = \"n\", yaxt = \"n\", asp=1)\n# image(img1, main=\"Downsample (low) resolution)\", xaxt = \"n\", yaxt = \"n\", asp=1)\n\nplot_ly(z = ~img, type=\"surface\")\n\n# Convert image matrix to long vector (i,j, value)\nimgvec <- matrix(NA, prod(dim(img)),3)\ncounter <- 1\nfor (r in 1:nrow(img)) {\n  for (c in 1:ncol(img)) {\n    imgvec[counter,1] <- r\n    imgvec[counter,2] <- c\n    imgvec[counter,3] <- img[r,c]\n    counter <- counter+1\n  }\n}\n\n# Compute the Similarity Matrix A\npixdiff <- 2\nsigma2 <- 0.01 \nsimmatrix <- matrix(0, counter-1, counter-1)\n\nfor(r in 1:nrow(imgvec)) {\n  # Verbose\n  # cat(r, \"out of\", nrow(imgvec), \"\\n\")\n  simmatrix[r,] <- ifelse(abs(imgvec[r,1]-imgvec[,1])<=pixdiff & abs(imgvec[r,2]-imgvec[,2])<=pixdiff,exp(-(imgvec[r,3]-imgvec[,3])^2/sigma2),0)\n}\n \n# Compute the graph Laplacians\n# U: unnormalized graph Laplacian (U=D-A) \n# L: normalized graph Laplacian, which can be computed in different ways:\n## L1:   Simple Laplacian: I - D^{-1} A, which can be seen as a random walk, where D^{-1} A is the transition matrix, which yields spectral clustering with groups of nodes such that the random walk seldom transitions from one group to another.\n## L2:   Normalized Laplacian D^{-1/2} A D^{-1/2}, or\n## L3:   Generalized Laplacian: D^{-1} A.\n\nD <- diag(rowSums(simmatrix))\nDinv <- diag(1/rowSums(simmatrix))\nL <- diag(rep(1,nrow(simmatrix)))-Dinv %*% simmatrix\nU <- D-simmatrix\n\n# Compute the eigen-spectra for the normalized and unnormalized Laplacians \nevL <- eigen(L, symmetric=TRUE)\nevU <- eigen(U, symmetric=TRUE)\n\n# Apply k-means clustering on the eigenspectra of both Laplacians\nkmL <- kmeans(evL$vectors[,(ncol(simmatrix)-1):(ncol(simmatrix)-0)],\n              centers=2,nstart=5)\nsegmatL <- matrix(kmL$cluster-1, newdim[1], newdim[2], byrow=T)\n\nkmU <- kmeans(evU$vectors[,(ncol(simmatrix)-1):(ncol(simmatrix)-0)],\n              centers=2,nstart=5)\nsegmatU <- matrix(kmU$cluster-1, newdim[1], newdim[2], byrow=T)\n\ncolorL <- rep(1, length(img))\ndim(colorL) <- dim(img)\n\nplot_ly(x=~seq(0, 4, length.out=olddim[1]), \n            y=~seq(0, 4, length.out=olddim[2]), z=~segmatL, \n        surfacecolor=colorL, cauto=F, cmax=1, cmin=0,\n        name=\"L = Normalized graph Laplacian\", type=\"surface\") %>%\n  add_trace(x=~seq(0, 4, length.out=olddim[1]), \n            y=~seq(0, 4, length.out=olddim[2]), z=~segmatU*(1), \n            colorscale = list(c(0, 1), c(\"tan\", \"red\")),\n            name=\"U = Unnormalized graph Laplacian\", type=\"surface\")  %>%\n  add_trace(x = ~seq(0, 4, length.out=olddim[1]), \n            y = ~seq(0, 4, length.out=olddim[2]),\n            z = ~img, type=\"surface\", name=\"Original Image\", opacity=0.5) %>%\n  layout(scene=list(xaxis=list(name=\"X\"), yaxis=list(name=\"Y\"), zaxis=list(title=\"\")),\n         title=\"Spectral Laplacian Classification\")  %>% hide_colorbar()\n\n# Plot the pair of spectral clusters (hematoma and normal brain areas)\n# image(1-segmatL, col=grey((0:15)/15), main=\"Normalized Laplacian\", xaxt = \"n\", yaxt = \"n\", asp=1)\n# image(segmatU, col=grey((0:15)/15), main=\"Unnormalized Laplacian\", xaxt = \"n\", yaxt = \"n\", asp=1)\nplot_ly(z=t(img), type=\"heatmap\", name=\"Original Image\", opacity=0.8) %>%\n    add_trace(z=t(segmatU), type=\"heatmap\", name=\"Unnormalized Laplacian\", opacity=0.5) %>%\n    add_trace(z=t((1-segmatL)), name=\"Normalized Laplacian\", opacity=0.3)  %>% \n    layout(title=\"Overlay of Unnormalized and Normalized Laplacians\") %>% hide_colorbar()\n\n\n# Overlay the outline of the ROI-segmentation region on top of original image\nimage(seq(0, 1, length.out=olddim[1]), seq(0, 1, length.out=olddim[2]),\n      img1, col = grey((0:15)/15), xlab=\"\",ylab=\"\", asp=1, xaxt = \"n\", yaxt = \"n\",\n      main=\"Original MRI with Overlay of the Boundaries of the \\n Unnormalized (red) and Normalized (green) Laplacian Labels\")\n\n# Compute the outline of the spectral segmentation and plot it as piecewise polygon - line segments\nsegmat <- segmatU\nlinecol <- \"red\"\nlinew <- 3\nfor(r in 2:newdim[1]) {\n  for (c in 2:newdim[2]) {\n    if(abs(segmat[r-1,c]-segmat[r,c])>0) {\n      xloc <- (r-1)/(newdim[1])\n      ymin <- (c-1)/(newdim[2])\n      ymax <- (c-0)/(newdim[2])\n      segments(xloc, ymin, xloc, ymax, col=linecol,lwd=linew)\n    }\n    if(abs(segmat[r,c-1]-segmat[r,c])>0) {\n      yloc <- (c-1)/(newdim[2])\n      xmin <- (r-1)/(newdim[1])\n      xmax <- (r-0)/(newdim[1])\n      segments(xmin, yloc, xmax, yloc, col=linecol,lwd=linew)\n    }\n  }\n}\n\n# Add the normalized Laplacian contour\nsegmat <- segmatL\nlinecol <- \"green\"\nlinew <- 3\nfor(r in 2:newdim[1]) {\n  for (c in 2:newdim[2]) {\n    if(abs(segmat[r-1,c]-segmat[r,c])>0) {\n      xloc <- (r-1)/(newdim[1])\n      ymin <- (c-1)/(newdim[2])\n      ymax <- (c-0)/(newdim[2])\n      segments(xloc, ymin, xloc, ymax, col=linecol,lwd=linew)\n    }\n    if(abs(segmat[r,c-1]-segmat[r,c])>0) {\n      yloc <- (c-1)/(newdim[2])\n      xmin <- (r-1)/(newdim[1])\n      xmax <- (r-0)/(newdim[1])\n      segments(xmin, yloc, xmax, yloc, col=linecol,lwd=linew)\n    }\n  }\n}",
      "line_count": 150
    },
    {
      "section": "Unsupervised Clustering",
      "code": "#Get the data first\nlibrary(\"XML\"); library(\"xml2\"); library(\"rvest\")\n\nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SOCR_Data_KneePainData_041409\")\nhtml_nodes(wiki_url, \"#content\")\n\nkneeRawData <- html_table(html_nodes(wiki_url, \"table\")[[2]])\nnormalize<-function(x){\n  return((x-min(x))/(max(x)-min(x)))\n}\nkneeRawData_df <- as.data.frame(cbind(normalize(kneeRawData$x), normalize(kneeRawData$Y), as.factor(kneeRawData$View)))\ncolnames(kneeRawData_df) <- c(\"X\", \"Y\", \"Label\")\n\n# randomize the rows of the DF as RF, RB, LF and LB labels of classes\n# which are by default sequentially ordered\nset.seed(1234)\nkneeRawData_df <- kneeRawData_df[sample(nrow(kneeRawData_df)), ]\n# summary(kneeRawData_df)\n# View(kneeRawData_df)\n\n# Artificially reduce the size of the data from 8K to 1K to get results faster \nkneeDF <- data.frame(x=kneeRawData_df[1:1000, 1], \n                     y=kneeRawData_df[1:1000, 2], \n                     class=as.factor(kneeRawData_df[1:1000, 3]))\nhead(kneeDF)  \n\n# Do the spectral clustering\nlibrary(kernlab)\nknee_data <- cbind(kneeDF$x, kneeDF$y); dim(knee_data)\nspectral_knee <- specc(knee_data, iterations=10, centers=4)\n\n# plot(knee_data, col=spectral_knee, pch=1)    # estimated clusters\n# points(knee_data, col=kneeDF$class, pch=0)\n\nplot_ly(x = ~knee_data[,1], y = ~knee_data[,2], type = 'scatter',\n  mode = 'markers', symbol = ~unlist(spectral_knee@.Data), \n  symbols = c('circle','x','o', 'diamond'),\n  color = ~unlist(spectral_knee@.Data), marker = list(size = 10)) %>%\n  layout(\"Knee-pain data (L+R & F+B) with derived Spectral Color/Symbol Clustering Labels\", \n         xaxis=list(title=\"X\"), yaxis=list(title=\"Y\")) %>%\n  hide_colorbar()",
      "line_count": 41
    },
    {
      "section": "Unsupervised Clustering",
      "code": "# crystallography_data <- read.csv(file = \"https://umich.instructure.com/files/13375767/download?download_frd=1\",\n#                          header=TRUE)\ncrystallography_data <- read.csv(file = \"https://umich.instructure.com/files/11653615/download?download_frd=1\",\n                         header=TRUE)\n# install.packages(\"mixtools\")\nlibrary(mixtools)\ncol_num <- dim(crystallography_data)[2] \n#  col_num\n\nfit_Gauss <- list()\n\ncapture.output(\n  for(i in 1:col_num) {   # remove all non-numeric elements (if any)\n    # data_no_NA <- unlist(Filter(is.numeric, crystallography_data[complete.cases(crystallography_data[, i]), i]))\n    data_no_NA <- crystallography_data[complete.cases(crystallography_data[, i]), i]\n    length(data_no_NA)\n    fit_Gauss[[i]] <- normalmixEM(data_no_NA, k=3, verb=F)\n    # summary(fit_LN[i])\n  }, \n  file='NUL'\n)\n\n#plot(fit_Gauss[[1]], which=2)\nlibrary(plotly)\n\n# Custom design of Normal-Mixture Model plot\nnormalMM.plot <- function(mix.object, dataSet, k = 3, main = \"\") { \n  data_no_NA <- dataSet\n  d3 <- function(x) { # construct the mixture using the estimated parameters\n    mix.object$lambda[1]*dnorm(x, mean=mix.object$mu[1], sd=mix.object$sigma[1]) + \n    mix.object$lambda[2]*dnorm(x, mean=mix.object$mu[2], sd=mix.object$sigma[2]) +\n    mix.object$lambda[3]*dnorm(x, mean=mix.object$mu[3], sd=mix.object$sigma[3])\n  }\n\n  x <- seq(min(data_no_NA), max(data_no_NA), 0.1)\n  # hist(data_no_NA, col=\"pink\", freq=F, breaks=20, main = main, xlab=\"Intensities\", xlim = c(4,23), ylim = c(0.0, 0.25))\n  # lines(x, d3(x), lwd=3, col=\"black\")\n  # mixColors <- colorRampPalette(c(\"blue\", \"red\"))(k)\n  # for (i in 1:k) {\n  #   d = function(x) { # construct each of the Weibull components using the estimated parameters\n  #     mix.object$lambda[i]*dnorm(x, mean=mix.object$mu[i], sd=mix.object$sigma[i])\n  #   }\n  #   lines(x, d(x), lwd=3, col=mixColors[i])\n  # }\n  \n  d_list <- list()\n  for (i in 1:3) {\n    # construct each of the Gaussian components using the estimated parameters\n    d_list[[i]] =  mix.object$lambda[i]*dnorm(x, mean=mix.object$mu[i], sd=mix.object$sigma[i])\n  }\n\n  pl <- plot_ly() %>% \n    add_trace(x=~x, y=~(10*d3(x)), type=\"scatter\", mode=\"lines\", name=\"Mixture of 3 Gaussian Models\") %>%\n    add_trace(x=~x, y=~(10*d_list[[1]]), type=\"scatter\", mode=\"lines\", name=paste0(\"Gaussian Mixture Component \", 1)) %>%\n    add_trace(x=~x, y=~(10*d_list[[2]]), type=\"scatter\", mode=\"lines\", name=paste0(\"Gaussian Mixture Component \", 2)) %>%\n    add_trace(x=~x, y=~(10*d_list[[3]]), type=\"scatter\", mode=\"lines\", name=paste0(\"Gaussian Mixture Component \", 3)) %>% \n    add_trace(x = ~data_no_NA, type=\"histogram\", histnorm = \"probability\", name = \"Data histogram\") %>%\n    layout(title = \"Gaussian Mixture Modeling (1D)\", xaxis = list(title = \"data values\"), \n         yaxis = list(title = \"frequency\"), legend = list(orientation='h'), bargap=0.2)\n  return (pl)\n}\n\ni=1; data_no_NA <- crystallography_data[complete.cases(crystallography_data[, i]), i]\n\nnormalMM.plot(mix.object=fit_Gauss[[i]], dataSet=data_no_NA, k=3, main=paste0(\"Mixture of \", 3, \" Normal Models\"))",
      "line_count": 65
    },
    {
      "section": "Unsupervised Clustering",
      "code": "library(mclust)\nset.seed(1234)\ngmm_clust <- Mclust(di_z)\nsummary(gmm_clust, parameters = TRUE)\ngmm_clust$modelName",
      "line_count": 5
    },
    {
      "section": "Unsupervised Clustering",
      "code": "plot(gmm_clust$BIC, legendArgs = list(x = \"bottom\", ncol = 2, cex = 1))\nplot(gmm_clust, what = \"density\")\nplot(gmm_clust, what = \"classification\")\nplot(gmm_clust, what = \"uncertainty\", dimens = c(6,7), main = \"livewithmom vs. gethitched\")\n\n# Mclust Dimension Reduction clustering\ngmm_clustDR <- MclustDR(gmm_clust, lambda=1)\nsummary(gmm_clustDR)\n\nplot(gmm_clustDR, what = \"boundaries\", ngrid = 200)\nplot(gmm_clustDR, what = \"pairs\")\nplot(gmm_clustDR, what = \"scatterplot\")\n\n# Plot the Silhouette plot to assess the quality of\n# the clustering based on the Mixture of 3 Gaussians\nsilGauss = silhouette(as.numeric(gmm_clustDR$classification), dis)\nplot(silGauss, col=1:length(gmm_clustDR$class2mixcomp), border=NA)",
      "line_count": 17
    },
    {
      "section": "Unsupervised Clustering",
      "code": "table(divorce$depression, gmm_clust$classification)",
      "line_count": 1
    },
    {
      "section": "Unsupervised Clustering",
      "code": "boystown<-read.csv(\"https://umich.instructure.com/files/399119/download?download_frd=1\", sep=\" \")\nboystown$sex<-boystown$sex-1\nboystown$dadjob <- (-1)*(boystown$dadjob-2)\nboystown$momjob <- (-1)*(boystown$momjob-2)\nstr(boystown)",
      "line_count": 5
    },
    {
      "section": "Unsupervised Clustering",
      "code": "boystown_sub<-boystown[, -c(1, 2)]",
      "line_count": 1
    },
    {
      "section": "Unsupervised Clustering",
      "code": "boystown_z<-as.data.frame(lapply(boystown_sub, scale))\nset.seed(1234)\nbt_cluster <- kmeans(boystown_z, 3)\nbt_cluster$centers\n\n# myColors <- c(\"darkblue\", \"red\", \"green\", \"brown\", \"pink\", \"purple\", \"lightblue\", \"orange\", \"gray\")\n# barplot(t(bt_cluster$centers), beside = TRUE, xlab=\"cluster\", \n# ylab=\"value\", col = myColors)\n# legend(\"topleft\", ncol=4, legend = c(\"gpa\",\"Alcoholuse\",\"alcatt\",  \"dadjob\",\"momjob\",\"dadclose\", \"momclose\", \"larceny\",\"vandalism\"), fill = myColors)\n\ndf <- as.data.frame(t(bt_cluster$centers))\nrowNames <- rownames(df)\ncolnames(df) <- paste0(\"Cluster\",c(1:dim(bt_cluster$centers)[1]))\nplot_ly(df, x = rownames(df), y = ~Cluster1, type = 'bar', name = 'Cluster1') %>% \n  add_trace(y = ~Cluster2, name = 'Cluster2') %>% \n  add_trace(y = ~Cluster3, name = 'Cluster3') %>% \n  layout(title=\"Explicating Derived Cluster Labels\",\n         yaxis = list(title = 'Cluster Centers'), barmode = 'group')",
      "line_count": 18
    },
    {
      "section": "Unsupervised Clustering",
      "code": "boystown$clusters<-bt_cluster$cluster",
      "line_count": 1
    },
    {
      "section": "Unsupervised Clustering",
      "code": "# Compute the averages for the variable 'sex', grouped by cluster\naggregate(data=boystown, sex~clusters, mean)",
      "line_count": 2
    }
  ]
}