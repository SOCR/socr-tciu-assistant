{
  "metadata": {
    "created_at": "2024-11-30T13:46:16.010847",
    "total_sections": 4,
    "total_code_chunks": 120,
    "total_tables": 1,
    "r_libraries": [
      "Amelia",
      "DT",
      "GGally",
      "MASS",
      "Matrix",
      "RODBC",
      "XML",
      "ada",
      "betareg",
      "brainR",
      "corrplot",
      "crossval",
      "d3heatmap",
      "dendextend",
      "devtools",
      "dplyr",
      "fitdistrplus",
      "foreign",
      "ggdendro",
      "ggplot2",
      "gmodels",
      "gplots",
      "grDevices",
      "graphics",
      "gridExtra",
      "jpeg",
      "knitr",
      "lattice",
      "mi",
      "mixtools",
      "oro.nifti",
      "plotly",
      "plyr",
      "psych",
      "reshape",
      "reshape2",
      "rvest",
      "scales",
      "spatstat",
      "tidyr",
      "tidyverse",
      "unbalanced",
      "xml2"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"DSPA2: Data Science and Predictive Analytics (UMich HS650)\"\nsubtitle: \"<h2><u>Basic Visualization and Exploratory Data Analytics</u></h2>\"\nauthor: \"<h3>SOCR/MIDAS (Ivo Dinov)</h3>\"\ndate: \"`r format(Sys.time(), '%B %Y')`\"\ntags: [DSPA, SOCR, MIDAS, Big Data, Predictive Analytics] \noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: SOCR_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n      smooth_scroll: true\n    code_folding: show\nIn this chapter, we will present a number of complementary strategies for data wrangling, harmonization, manipulation, aggregation, visualization, and graphical exploration.  Specifically, we will discuss alternative methods for loading and saving computable data objects, importing and exporting different data structures, measuring sample statistics for quantitative variables, plotting sample histograms and model distribution functions, and scraping data from websites. In addition, we will cover exploratory data analytical (EDA) techniques, handling of incomplete (missing) data, and cohort-rebalancing of imbalanced groups.",
      "word_count": 134
    },
    {
      "title": "Data Handling",
      "content": "In this section, we will discuss strategies to `import` data and `export` results. Also, we are going to learn the basic tricks we need to know about processing different types of data. Specifically, we will illustrate common `R` data structures and strategies for loading (ingesting) and saving (regurgitating) data. In addition, we will (1) present some basic statistics, e.g., for measuring central tendency (mean, median, mode) or dispersion (variance, quartiles, range), (2) explore simple plots, (3) demonstrate the uniform and normal distributions, (4) contrast numerical and categorical types of variables, (5) present strategies for handling incomplete (missing) data, and (6) show the need for cohort-rebalancing when comparing imbalanced groups of subjects, cases or units.\n\n## Saving and Loading `R` Data Structures\n\nLet's start by extracting Edgar Anderson's Iris Data from the package `datasets`. The [iris dataset](https://en.wikipedia.org/wiki/Iris_flower_data_set) quantifies morphologic shape variations of 50 Iris flowers of three related genera - *Iris setosa*, *Iris virginica* and *Iris versicolor*. Four shape features were measured from each sample - length and the width of the sepals and petals (in centimeters). These data were used by [Ronald Fisher](https://en.wikipedia.org/wiki/Ronald_Fisher) in his [1936 linear discriminant analysis paper](https://doi.org/10.1111%2Fj.1469-1809.1936.tb02137.x).\n\n![](http://www.socr.umich.edu/people/dinov/2017/Spring/DSPA_HS650/images/IrisDataPic_SepalsPetals_LengthWidth.png)\n\nAs an I/O (input/output) demonstration, after we load the `iris` data and examine its class type, we can save it into a file named \"myData.RData\" and then reload it back into `R`.\n\n\n## Importing and Saving Data from CSV Files\n\nImporting the data from `\"CaseStudy07_WorldDrinkingWater_Data.csv\"` from [these case-studies](https://umich.instructure.com/courses/38100/files/folder/Case_Studies) and saving it into the `R` dataset named \"water\". The variables in the dataset are as follows:\n\n - **Time**: Years (1990, 1995, 2000, 2005, 2010, 2012)\n - **Demographic**: Country (across the world)\n - **Residence Area Type**: Urban, rural, or total\n - **WHO Region**\n - **Population using improved drinking-water sources**: The percentage of the population using an improved drinking water source.\n - **Population using improved sanitation facilities**: The percentage of the population using an improved sanitation facility.\n\nGenerally, the separator of a CSV file is comma. By default, we have option`sep=\", \"` in the command `read.csv()`. Also, we can use `colnames()` to rename the column variables. Let's use [CaseStudy07_WorldDrinkingWater_Data.csv](https://umich.instructure.com/files/399172/download?download_frd=1) from out [Canvas Data Archive](https://umich.instructure.com/courses/38100/files/folder/Case_Studies) as an example. This code loads CSV files that already include a header line containing the names of the variables. If we don't have a header in the dataset, we can use the `header = FALSE` option to read the first row in the file as data. In such cases, `R` will assign default names to the column variables of the dataset.\n\n\nTo save a data frame to CSV files, we could use the `write.csv()` function. The option `file = \"a/local/file/path\"` allows us to specify the output file name and location.\n\n\n## Importing Data from ZIP and SAV Files\n\nThis example demonstrates data import from a compressed (ZIP) SPSS (SAV) file. In this case, we utilize DSPA [Case-Study 25: National Ambulatory Medical Care Survey (NAMCS)](https://umich.instructure.com/courses/38100/files/folder/Case_Studies/25_NAMCS_2015).\n\n\n## Exploring the Structure of Data\n\nWe can use the command `str()` and `describe()` to explore the structure of a dataset (in this case the `CaseStudy07_WorldDrinkingWater_Data`).\n\n\nWe can see that this `World Drinking Water` dataset has 3331 observations and 6 variables. The output also includes the class of each variable and first few elements in the variable. The dimension of the other dataset (Case-Study 25: National Ambulatory Medical Care Survey) is much larger, $28,332\\times 1,096$.\n\n## Exploring Numeric Variables\n\nSummary statistics for numeric variables in the dataset could be accessed by using the command `summary()`. \n\n\nThe six summary statistics and `NA`'s (missing data) are reported in the output.\n\n## Measuring Central Tendency - mean, median, mode\n\n**Mean** and **median** are two frequent measurements of the central tendency. Mean is \"the sum of all values divided by the number of values\". Median is the number in the middle of an ordered list of values. In R, `mean()` and `median()` functions can provide us with these two measurements.\n\n\nThe **mode** is the value that occurs most often in the dataset. It is often used in categorical data, where mean and median are inappropriate measurements.\n\nWe can have one or more modes. In the [water dataset](https://umich.instructure.com/files/399172/download?download_frd=1), we have \"Europe\" and \"Urban\" as the modes for region and residence area respectively. These two variables are unimodal, which has a single mode. For the year variable, we have two modes 2000 and 2005. Both of the categories have 570 counts. The *year* represent an example of a multimodal variable that has two, or more, modes.\n\nMode is one of the measures for the central tendency. The best way to use it is to compare the mode to other values in the data. This helps us determine whether one or several categories dominate all others in the data. \nIn numeric datasets, we could think mode as the highest bin in the histogram, since it is unlikely to have many repeated measurements for continuous variables. In this way, we can also examine if the numeric data is multimodal.\n\n[More information about measures of centrality is available here](https://wiki.socr.umich.edu/index.php/AP_Statistics_Curriculum_2007_EDA_Center). \n\n## Measuring Spread - variance, quartiles and the five-number summary\n\nThe five-number summary describes the spread of a dataset. They are:\n\n* Minimum (`Min.`), representing the smallest value in the data\n* First quartile/Q1 (`1st Qu.`), representing the $25^{th}$ percentile, which splits off the lowest 25% of data from the highest 75%\n* Median/Q2 (`Median`), representing the $50^{th}$ percentile, which splits off the lowest 50% of data from the top 50%\n* Third quartile/Q3 (`3rd Qu.`), representing the $75^{th}$ percentile, which splits off the lowest 75% of data from the top 25%\n* Maximum (`Max.`), representing the largest value in the data.\n\n`Min` and `Max` can be obtained by using `min()` and `max()` respectively.\n\nThe difference between maximum and minimum is known as range. In R, `range()` function gives us both the minimum and maximum. A combination of `range()` and `diff()` could do the trick of getting the actual range value. To avoid problems with missing values, we will ignore them using the option `na.rm=TRUE`.\n\n\nQ1 and Q3 are the 25th and 75th percentiles of the data. Median (Q2) is right in the middle of Q1 and Q3. The difference between Q3 and Q1 is called the interquartile range (IQR). Within the IQR lies half of our data that has no extreme values.\n\nIn R, we use the `IQR()` to calculate the interquartile range. If we use `IQR()` for a data with `NA`'s, the `NA`'s are ignored by the function while using the option `na.rm=TRUE`.\n\n\nJust like the command `summary()` that we have talked about earlier in this chapter. A similar function `quantile()` could be used to obtain the five-number summary.\n\n\nWe can also calculate specific percentiles in the data. For example, if we want the 20th and 60th percentiles, we can do the following.\n\n\nWhen we include the `seq()` function, generating percentiles of evenly-spaced values is available.\n\n\nLet's re-examine the five-number summary for the `improved_water` variable. When we ignore the `NA`'s, the difference between minimum and Q1 is 74 while the difference between Q3 and maximum is only 1. The interquartile range is 22%. Combining these facts, the first quarter is more widely spread than the middle 50 percent of values. The last quarter is the most condensed one that has only two percentages 99% and 100%. Also, we can notice that the mean is smaller than the median. The mean is more sensitive to the extreme values than the median. Having some of very small values may spread out the first quartile, skew the distribution to the left and make the mean less than the median. \n\nDistribution models offer a way to characterize data using only a few parameters. For example, the normal distribution can be defined by only two parameters - center and spread, statistically speaking, mean and standard deviation.\n\nThe mean value is obtained by arithmetic averaging of all data points.\n\n$$mean(X)=\\mu=\\frac{1}{n}\\sum_{i=1}^{n} x_i$$\n\nThe standard deviation is the square root of the variance. And the variance is the average sum of square deviation from the mean. \n\n$$Var(X)=\\sigma^2=\\frac{1}{n-1}\\sum^{n}_{i=1} (x_i-\\mu)^2$$\n$$StdDev(X)=\\sigma=\\sqrt{Var(X)}$$\n\nSince the water dataset is not close to normal, in this example, we will use MLB baseball players dataset to illustrate normal distribution properties. The [MLB dataset (01a_data.txt)](https://umich.instructure.com/files/330381/download?download_frd=1) in our [class file data archive](https://umich.instructure.com/courses/38100/files/folder/data) has following variables - *Name*, *Team*, *Position*, *Height*, *Weight*, and *Age*.\n\nWe can use histograms to visually assess approximate normality of baseball players' *Height* and *Weight*.\n\n\nTWe could also report the mean and standard deviation of the weight and height variables.\n\n\nLarger standard deviation, or variance, suggests the data is more spread out from the mean. Therefore, for MLB players, weights appear to be more spread than heights.\n\nGiven the first two moments (mean and standard deviation), we can easily estimate how extreme a specific value is. Assuming we have a normal distribution, the values follow a $68-95-99.7$ rule. This means 68% of the data lies within the interval $[\\mu-\\sigma, \\mu+\\sigma]$;95% of the data lies within the interval $[\\mu-2*\\sigma, \\mu+2*\\sigma]$ and 99.7% of the data lies within the interval $[\\mu-3*\\sigma, \\mu+3*\\sigma]$. The following graph plotted by `R` illustrates the $68-95-99.7$ rule.\n\n\nApplying the 68-95-99.7 rule to our baseball weight variable, we know that 68% of our players weighted between 180.7168 pounds and 222.7164 pounds; 95% of the players weighted between 159.7170 pounds and 243.7162 pounds; And 99.7% of the players weighted between 138.7172 pounds and 264.7160 pounds.\n\n## Visualizing Numeric Variables - boxplots\n\nWe can visualize the five-number summary by a boxplot (box-and-whiskers plot). With the `boxplot()` function we can manage the title (`main=\"\"`) and labels for x (`xlab=\"\"`) and y (`ylab=\"\"`) axis.\n\n\nIn the boxplot we have five horizontal lines each representing the corresponding value in the five-number summary. The box in the middle represents the middle 50 percent of values. The bold line in the box is the median. Mean value is not illustrated on the graph.\n\nBoxplots only allow the two ends to extend to a minimum or maximum of 1.5 times the IQR. Therefore, any value that falls outside of the $3\\times IQR$ range will be represented as circles or dots. They are considered outliers. We can see that there are a lot of outliers with small values on the low ends of the graph.\n\n## Visualizing Numeric Variables - histograms\n\nHistograms offer another way to show the distribution spread of numeric variables. They require a specification of a number of bins, value containers, to divide and stratify the original data. The heights of the bins indicate the observed frequencies within each bin. \n\n\nWe could see that the shape of two graphs are somewhat similar. They both appear to have left skewed patterns ($mean \\lt median$). Other common skew patterns are shown in the following graph.\n\n\nYou can learn more about [Probability Distributions in the SOCR EBook](https://wiki.socr.umich.edu/index.php/EBook#Chapter_IV:_Probability_Distributions) and see the density plots of over 80 different probability distributions using the [SOCR Java Distribution Calculators](https://socr.umich.edu/html/dist/) or the [Distributome HTML5 Distribution Calculators](http://www.distributome.org/V3/calc/index.html).\n\nFor each probability distribution defined in `R`, there are four functions that provide the density (e.g., `dnorm`), the cumulative probability (e.g., `pnorm`), the inverse cumulative distribution (quantile) function (e.g., `qnorm`), and the random sampling (simulation) function (e.g., `rnorm`). The plots below show the *standard normal* density, cumulative probability and the quantile functions. As the density is very small outside of the interval $(-4,4)$, the plots are restricted to this domain.\n\n\n## Understanding Numeric Data - uniform and normal distributions\n\nIf the data follows a *uniform distribution*, then all values are equally likely to occur. The histogram for a uniformly distributed data would have equal heights for each bin like the following graph. \n\n\nOften, but not always, real world processes may appear as normally distributed data. A *normal distribution* would have a higher frequency for middle values and lower frequency for more extreme values. It has a symmetric and bell-curved shape just like the following diagram generated by R. Many parametric-based statistical approaches assume normality of the data. In cases where this parametric assumption is violated, variable transformations or distribution-free tests may be more appropriate.\n\n\n\n## Exploring Categorical Variables\n\nBack to our water dataset, we can treat the year variable as categorical rather than a numeric variable. Since the year variable only has six distinctive values, it is rational to treat it as a categorical variable where each value is a category that could apply to multiple WHO regions. Moreover, region and residence area variables are also categorical.\n\nDifferent from numeric variables, the categorical variables are better examined by tables rather than summary statistics. One-way table represents a single categorical variable. It gives us the counts of different categories. `table()` function can create one-way tables for our water dataset:\n\n\nGiven that we have a total of 3331 observations, the WHO region table tells us that about 27% (910/3331) of the areas examined in the study are in Europe. \n\n`R` can directly give us table proportions when using the `prop.table()` function. The proportion values can be transformed into percentage form and edit number of digits.\n\n\n## Exploring Relationships Between Variables\n\nSo far, the methods and statistics that we have gone through are at univariate level. Sometimes we want to examine the relationship between two or multiple variables. For example, does the percentage of population that uses improved drinking-water sources increase over time? To address these problems we need to look at bivariate or multivariate relationships.\n\n### Visualizing Relationships - scatterplots\n\nLet's look at the bivariate case first. A scatterplot is a good way to visualize bivariate relationships. We have x axis and y axis each representing one of the variables. Each observation is illustrated on the graph by a glyph, e.g., a solid point. If the graph shows a clear pattern, rather than a random scatter of points or a horizontal line, the two variables may be correlated with each other.\n\nIn `R` we can use the `plot()` function to create scatterplots. We have to define the variables for x-axis and y-axis. The labels in the graph are editable.\n\n\nWe can see from the scatterplot that there is an increasing pattern. In later years, the percentages are more centered around one hundred. Especially, in 2012, none of the regions had less than 20% of people using improved water sources while there used to be some regions that had such low percentages in the early years. \n\n### Examining Relationships - two-way cross-tabulations\n\nScatterplot is a useful tool to examine the relationship between two variables where at least one of them is numeric. When both variables are nominal, two-way cross-tabulation would be a better choice (also named as crosstab or contingency table). \n\nThe function `CrossTable()` is available in `R` under the package `gmodels`. Let's install it first.\n\n\nWe are interested in investigating the relationship between WHO region and residence area type in the water study. We might want to know if there is a difference in terms of residence area type between the African WHO region and all other WHO regions.\n\nTo address this problem we need to create an indicator variable for the African WHO region first.\n\n\nLet's revisit the `table()` function to see how many WHO regions are in Africa.\n\n\nNow, let's create a two-way cross-tabulation using `CrossTable()`.\n\n\nEach cell in the table contains five numbers. The first one N gives us the count that falls into its corresponding category. The Chi-square contribution provides us information about the cell's contribution in the Pearson's Chi-squared test for independence between two variables. This number measures the probability that the differences in cell counts are due to chance alone. \n\nThe number of most interest is the `N/ Col Total` or the counts over column total. In this case, these numbers represent the distribution for residence area type among African regions and the regions in the rest of the world. We can see the numbers are very close between African and non-African regions for each type of residence area. Therefore, we can conclude that African WHO regions do not have a difference in terms of residence area types compared to the rest of the world.\n\n## Missing Data\n\nIn the previous sections, we simply ignored the missing observations in our water dataset (`na.rm = TRUE`). Is this an appropriate strategy to handle incomplete data? Could the missingness pattern of those incomplete observations be important? It is possible that the arrangement of the missing observations may reflect an important factor that was not accounted for in our statistics or our models. \n\n**Missing Completely at Random (MCAR)** is an assumption about the probability of missingness being equal for all cases; **Missing at Random (MAR)** assumes the probability of missingness has a known but random mechanism (e.g., different rates for different groups); **Missing not at Random (MNAR)** suggest a missingness mechanism linked to the values of predictors and/or response, e.g., some participants may drop out of a drug trial when they have side-effects.\n\nThere are a number of strategies to impute missing data. The [expectation maximization (EM) algorithm provides one example for handling missing data](https://doi.org/10.1016/0167-9473(93)E0056-A). The [SOCR EM tutorial, activity, and documentations](http://wiki.stat.ucla.edu/socr/index.php/SOCR_EduMaterials_Activities_2D_PointSegmentation_EM_Mixture) provides the theory, applications and practice for effective (multidimensional) EM parameter estimation.\n\nThe simplest way to handle incomplete data is to substitute each missing value with its (feature or column) average. When the missingness proportion is small, the effect of substituting the means for the missing values will have little effect on the mean, variance, or other important statistics of the data. Also, this will preserve those non-missing values of the same observation or row.\n\n![](http://www.socr.umich.edu/people/dinov/2017/Spring/DSPA_HS650/images/CBDA_Cases_by_Features_Schematic.png)\n\n\nA more sophisticated way of resolving missing data is to use a model (e.g., linear regression) to predict the missing feature and impute its missing values. This is called the `predictive mean matching approach`. This method is good for data with multivariate normality. However, a disadvantage of it is that it can only predict one value at a time, which is very time consuming. Also, the multivariate normality assumption might not be satisfied and there may be important multivariate relations that are not accounted for. We are using the `mi` package for the predictive mean matching procedure.\n\nLet's install the `mi` package first.\n\n\nThen we need to get the missing information matrix. We are using the imputation method `pmm`(predictive mean matching approach) for both missing variables. \n\n\n* *Notes*:\n\n - Converting the input `data.frame` to a `missing_data.frame` allows us to include in the DF enhanced metadata about each variable, which is essential for the subsequent modeling, interpretation and imputation of the initial missing data.\n - `show()` displays all missing variables and their class-labels (e.g., continuous), along with meta-data. The `missing_data.frame` constructor suggests the most appropriate classes for each missing variable, however, the user often needs to correct, modify or change these meta-data, using `change()`.\n - Use the `change()` function to change/correct many meta-data in the constructed `missing_data.frame` object which are incorrect when using `show(mfd)`.\n - To get a sense of the raw data, look at the `summary`, `image`, or `hist` of the missing_data.frame.\n - The [mi vignettes](https://cran.r-project.org/web/packages/mi/vignettes/mi_vignette.pdf) provide many useful examples of handling missing data.\n  \nWe can perform the initial imputation. Here we imputed three times, which will create three different (complete) datasets, three *chains*, with slightly different imputed values.\n\n\nNext, we need to extract several multiply imputed `data.frames` from `imputations` object. Finally, we can compare the summary stats between the original dataset and the imputed datasets.\n\n\nThis is just a brief introduction for handling incomplete datasets. In later chapters, we will discuss more about missing data with different imputation methods and how to evaluate the complete imputed results.\n\n### Simulate some real multivariate data \n\nSuppose we would like to generate a synthetic dataset:\n$$sim\\_data=\\{y, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_{10}\\}.$$\n\nThen, we can introduce a method that takes a dataset and a desired proportion of missingness and wipes out the same proportion of the data, i.e., introduces random patterns of missingness. Note that there are already `R` functions that automate the introduction of missingness, e.g., `missForest::prodNA()`, however writing such a method from scratch is also useful.\n\n\nNext, let's synthetically generate (simulate) $1,000$ cases including all 11 features in the data ($\\{y, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10\\}$). \n\n\nIn the missing data plot above, missing values are illustrated as `black` segments in the case-by-feature bivariate chart. The `hot` colormap (17-level) represents the *normalized* values of the corresponding feature-index pairs, see the [mi::image() documentation](https://github.com/cran/mi/blob/master/R/plot_methods.R). Also, test the `order`, `cluster` and `grayscale` options, e.g., `image(mdf, x.order = T, clustered = F, grayscale =T)`.\n\nThe histogram plots display the distributions of:\n\n* The observed data (in blue color), \n* The imputed data (in red color), and\n* The completed values (observed plus imputed, in gray color).\n\n\nLet's check imputation convergence (details provided below).\n\n\nFinally, pool over the $m = 3$ completed datasets when we fit the \"model\".\nPool from across the 3 chains - in order to estimate a linear regression model.\n\n\n\n**Notes**: \n\n - In general, it is recommended to generate multiple imputation chains and then analyze the data (e.g., estimate the model coefficients, obtain inference, compute likelihoods, etc.). *Pooling* the analytics across all chains accounts for between-chain as well as within-chain variability, [Rubin's rule](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2727536/).\n - When deciding on how many chains to compute, a general rule is to compute $m$ chains if the rate of incomplete cases in the dataset is about $m \\%$, i.e., 10-chains when 10% of cases are incomplete, [White et al.,2011](https://www.jstatsoft.org/article/view/v045i04/v45i04.pdf).\n - For categorical features, e.g., binary predictors like $x_3$, the *display()* and *summary()* functions will report coefficient estimates for each (category) level, relative to the base level.\n\n### TBI Data Example\n\nNext, we will see an example using [the traumatic brain injury (TBI) dataset](https://wiki.socr.umich.edu/index.php/SMHS_MissingData#Raw_TBI_data). More information about the [clinical assessment scores (e.g., EGOS, GCS) is available in this publication (DOI: 10.1080/02699050701727460)](https://doi.org/10.1080/02699050701727460).\n\n\n\n### Imputation via Expectation-Maximization\n\nBelow we present the theory and practice of one specific statistical computing strategy for imputing incomplete datasets.\n\n#### Types of missing data\n\n - **MCAR**: Data which is Missing Completely At Random has nothing systematic about which observations are missing. There is no relationship between missingness and either observed or unobserved covariates.\n - **MAR**: Missing At Random is weaker than MCAR. The missingness is still random, but solely due to the observed variables. For example, those from a lower socioeconomic status (SES) may be less willing to provide salary information (but we know their SES). The key is that the missingness is not due to the values which are not observed. MCAR implies MAR, but not vice-versa.\n - **MNAR**: If the data are Missing Not At Random, then the missingness depends on the values of the missing data. Examples include censored data, self-reported data for individuals who are heavier, who are less likely to report their weight, and response-measuring devices that can only measure values above $0.5$, anything below that is missing.\n\n#### General Idea of the EM algorithm\n\n[Expectation-Maximization (EM) is an iterative process](http://repositories.cdlib.org/socr/EM_MM) involving two steps - *expectation* and *maximization*, which are applied in tandem. EM can be employed to find parameter estimates using maximum likelihood and is specifically useful when the equations determining the relations of the data-parameters cannot be directly solved. For example, a Gaussian mixture modeling assumes that each data point ($X$) has a corresponding latent (unobserved) variable or a missing value ($Y$), which may be specified as a mixture of coefficients determining the affinity of the data as a linear combination of Gaussian kernels, determined by a set of parameters ($\\theta$), e.g., means and variance-covariances. Thus, EM estimation relies on:\n\n - An observed data set $X$, \n - A set of missing (or latent) values $Y$, \n - A parameter $\\theta$, which may be a vector of parameters, \n - A likelihood function $L(\\theta | X, Y) =p(X,Y |\\theta)$, and\n - The maximum likelihood estimate (MLE) of the unknown parameter(s) $\\theta$ that is computed using the marginal likelihood of the observed data: \n\n$$L(\\theta | X) = p(X |\\theta) =\\int { p(X, Y |\\theta)dY}.$$\n\nMost of the time, this equation may not be directly solved, e.g., when $Y$ is missing.\n\n - *Expectation step (E step)*: computes the expected value of the *log likelihood function*, with respect to the conditional distribution of $Y$ given $X$ using the parameter estimates at the previous iteration (or at the position of initialization, for the first iteration), $\\theta_t$:\n$$Q ( \\theta | \\theta^{(t)} ) = E_{Y | X, \\theta^{(t)} }[ log \n\\left ( L(\\theta | X , Y ) \\right ];$$\n - *Maximization step (M step)*: Determine the parameter, $\\theta$, that maximizes the expectation above, $$\\theta^{(t+1)}=\\arg\\max_{\\theta}Q(\\theta|\\theta^{(t)}).$$\n\n[This SOCR EM Activity](http://wiki.stat.ucla.edu/socr/index.php/SOCR_EduMaterials_Activities_2D_PointSegmentation_EM_Mixture) shows the practical aspects of applying the EM algorithm. Also, in [DSPA Chapter 3](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/03_DataVisualization.html#61_data_modeler) we will illustrate the EM method for fitting single *distribution models* or (linear) *mixtures of distributions* to data that may represent a blend of heterogeneous observations from multiple different processes.\n\n#### EM-based imputation\n\nThe EM algorithm is an alternative to Newton-Raphson or the method of scoring for computing MLE in cases where there are complications in calculating the MLE. It is applicable for imputing incomplete MAR data, where the missing data mechanism can be ignored and separate parameters may be estimated for each missing feature.\n\n**Complete Data: **\n$$Z = \\left(\\begin{array}{cc} \nX \\\\\nY\n\\end{array}\\right),\nZZ^T = \\left(\\begin{array}{cc} \nXX^T & XY^T \\\\\nYX^T & YY^T\n\\end{array}\\right),$$ \nwhere $X$ is the observed data and $Y$ is the missing data.\n\n - *E-step*: (Expectation) Get the expectations of $Y$ and $YY^T$ based on observed data, $X$.\n - *M-step*: (Maximization) Maximize the conditional expectation in E-step to estimate the parameters.\n\n**Details:** If $o=obs$ and $m=mis$ stand for observed and missing, the mean vector, $(\\mu_{obs}, \\mu_{mis})^T$, and the variance-covariance matrix, $\\Sigma^{(t)} = \\left(\\begin{array}{cc} \\Sigma_{oo} & \\Sigma_{om} \\\\ \\Sigma_{mo}  & \\Sigma_{mm} \\end{array}\\right)$, are represented by:\n\n$$\\mu^{(t)} = \n\\left(\\begin{array}{cc} \n\\mu_{obs} \\\\\n\\mu_{mis}\n\\end{array}\\right),\\;\\;\\;\\;\\;\n\\Sigma^{(t)} = \\left(\\begin{array}{cc} \n\\Sigma_{oo} & \\Sigma_{om} \\\\\n\\Sigma_{mo}  & \\Sigma_{mm} \n\\end{array}\\right)$$ \n**E-step:**\n\n$$E(Z | X) = \n\\left(\\begin{array}{cc} \nX \\\\\nE(Y|X)\n\\end{array}\\right),\\;\\;\\;\\;\\;\nE(ZZ^T|X) = \\left(\\begin{array}{cc} \nXX^T & XE(Y|X)^T \\\\\nE(Y|X)X^T  & E(YY^T|X) \n\\end{array}\\right).$$ \n\n$$E(Y | X) = \\mu_{mis} + \\Sigma_{mo}\\Sigma_{oo}^{-1}(X - \\mu_{obs}).$$\n$$E(YY^T|X) = (\\Sigma_{mm}-\\Sigma_{mo}\\Sigma_{oo}^{-1}\\Sigma_{om})+E(Y|X)E(Y|X)^T.$$ \n\n**M-step:**\n$$\\mu^{(t+1)} = \\frac{1}{n}\\sum_{i=1}^nE(Z|X).$$\n$$\\Sigma^{(t+1)} = \\frac{1}{n}\\sum_{i=1}^nE(ZZ^T|X) - \\mu^{(t+1)}{\\mu^{(t+1)}}^T.$$\n\n#### A simple manual implementation of EM-based imputation\n\n\n\n#### Plotting the complete and imputed data\n\nSmaller points colored in *black* represent observed data, and the circle-shapes colored in *magenta* denote the imputed data.\n\n\n#### Validation of EM-imputation using the `R` Package *Amelia* \n\n - [Paper](https://gking.harvard.edu/files/gking/files/amelia_jss.pdf),\n - [R manual](https://cran.r-project.org/web/packages/Amelia/Amelia.pdf).\n\n\n##### Comparison\n\nLet's use the `amelia` function to impute the original data *sim_data_df* and compare the results to the simpler manual `EM_algorithm` imputation defined above.\n\n\n - **Magenta-color and circle-shape denote manual imputation via `EM_algorithm`**\n - **Orange-color and square-shapes denote Amelia imputation**\n\n\n##### Density plots \n\nFinally, we can compare the densities of the original, manually-imputed and Amelia-imputed datasets. Remember that in this simulation, we had about $500$ observations missing out of the $4,000$ that we synthetically generated.\n\n\n## Parsing web pages and visualizing tabular HTML data\n\nIn this section, we will utilize the Earthquakes dataset on [SOCR website](https://wiki.socr.umich.edu/index.php/SOCR_Data_Dinov_021708_Earthquakes). It records information about earthquakes that happened between 1969 and 2007 with magnitudes larger than 5 on the Richter scale. Here is how we parse the data on the source webpage and ingest the information into R:\n\n\nIn this dataset, `Magt`(magnitude type) may be used as a grouping variable. We will draw a \"Longitude vs Latitude\" line plot from this dataset. The function we are using is called `ggplot()` under `ggplot2`. The input type for this function is mostly data frame. `aes()` specifies axes.\n\n\nThe most important line of code has 2 parts. The first part `ggplot(earthquake, aes(Longitude, Latitude, group=Magt, color=Magt))` specifies the setting of the plot: dataset, group and color. The second part specifies we are going to draw lines between data points. In later chapters we will frequently use the package `ggplot2` and the structure under this great package is always `function1+function2`.\n\nWe can visualize the distribution for different variables using density plots. The following script plots the distribution for Latitude among different Magnitude types, also using the `ggplot()` function combined with `geom_density()`.\n\n\nWe can also compute and display 2D Kernel Density and 3D Surface Plots. Plotting 2D Kernel Density and 3D Surface plots is very important and useful in multivariate exploratory data analytic. \n\nWe will use the `plot_ly()` function under the `plotly` package, which takes value from a data frame.\n\nTo create a surface plot, we use two vectors: *x* and *y* with length *m* and *n* respectively. We also need a matrix: *z* of size $m\\times n$. This *z* matrix is created from matrix multiplication between *x* and *y*. \n\nThe `kde2d()` function is needed for 2D kernel density estimation.\n\n\nHere `z` is an estimate of the kernel density function. Then we apply `plot_ly` to the list `kernal_density` via the `with()` function.\n\n\nNote that we used the option `\"surface\"`, however you can experiment with the `type` option.\n\nAlternatively, one can plot 1D, 2D or 3D plots:\n\n\n## Cohort-Rebalancing (for Imbalanced Groups)\n\nComparing cohorts with imbalanced sample sizes (unbalanced designs) may present hidden biases in the results. Frequently, a cohort-rebalancing protocol is necessary to avoid such unexpected effects. Extremely unequal sample sizes can invalidate various parametric assumptions (e.g., homogeneity of variances). Also, there may be insufficient data representing the patterns belonging to the minority class(es) leading to inadequate capturing of the feature distributions. Although the groups do not have to have equal sizes, a general rule of thumb is that group sizes where one group is more than an order of magnitude larger than the size of another group has the `potential` for bias.\n\n### Example 1: Parkinson's Diseases Study\n\nThis Parkinson's diseases case-study involves neuroimaging, genetics, clinical, and phenotypic data for over 600 volunteers produced multivariate data for 3 cohorts -- *HC=Healthy Controls(166)* , *PD=Parkinson's (434)*, *SWEDD= subjects without evidence for dopaminergic deficit (61)*.\n\n\n**Notes**\n\n - SMOTE oversampling of the minority cohort is via generation of synthetic minority samples within the neighborhoods of observed observations. Thus, new minority instances\nblend observations in the same class and create clusters around each observed minority element.\n - The `percOver` parameter (perc.over/100) represents the number of new instances generated for each rare instance in the minority sample, when $perc.over < 100$, a single instance is generated. For example, `percOver=300` and `percOver=30` would triple (300/100) and leave unchanged (30/100) the size of the *minority sample*, respectively.\n - The $k$ parameter represents the number of neighbors to consider as the aggregate pool that the new examples are generated.\n - The `percUnder` (perc.under/100) represents the number of \"normal\" (majority class) instances that are randomly selected for each *smoted* (synthetically generated) observation. For instance, `percUnder=300` or `percUnder=30` would downsample the *majority sample* by choosing one-out-of-each-three or all of the majority sample points, respectively.",
      "word_count": 5083
    },
    {
      "title": "Exploratory Data Analytics (EDA)",
      "content": "In this section, we will see a broad range of simulations and hands-on activities to highlight some of the basic data visualization techniques using R. A brief discussion of alternative visualization methods is followed by demonstrations of histograms, density, pie, jitter, bar, line and scatter plots, as well as strategies for displaying trees and graphs and 3D surface plots. Many of these are also used throughout the textbook in the context of addressing the graphical needs of specific case-studies.     \n\nIt is practically impossible to cover all options of every different visualization routine. Readers are encouraged to experiment with each visualization type, change input data and parameters, explore the function documentation using R-help (e.g., `?plot`), and search for new R visualization packages and new functionality, which are continuously being developed.\n\n## General Questions Driving Visualization \n\n - What exploratory visualization techniques are available to visually interrogate my specific data? \n - How to examine paired associations and correlations in a multivariate dataset?\n\n## Classification of visualization methods\n\nScientific data-driven or simulation-driven visualization methods are hard to classify. The following list of criteria can be used for classification:\n\n - **Data Type**: structured/unstructured, small/large, complete/incomplete, time/space, ASCII/binary, Euclidean/non-Euclidean, etc.\n - **Task type**: Task  type  is  one  of  the  aspects  considered  in classification  of  visualization  techniques,  which provides means of interaction between the researcher, the data and the display software/platform\n - **Scalability**:  Visualization techniques are subject to some limitations, such as the amount of data that a particular technique can exhibit  \n - **Dimensionality**: Visualization techniques can also be classified according to the number of attributes\n - **Positioning and Attributes**: the distribution of attributes on the chart may affect the interpretation of the display representation, e.g., correlation analysis, where the relative distance among the plotted attributes is relevant for observation\n - **Investigative Need**: the specific scientific question or exploratory interest may also determine the type of visualization:\n  + Examining the composition of the data\n  + Exploring the distribution of the data\n  + Contrasting or comparing several data elements, relations, association\n  + Unsupervised exploratory data mining.\n\nAlso, we have the following table for common data visualization methods according to task types:\n\n![Task Type Visualization Methods](https://wiki.socr.umich.edu/images/7/79/DSPA_Chap03_VizTypes_Fig1.png)\n\nWe chose to introduce common data visualization methods according to this classification criterion, albeit this is not a unique or even broadly agreed upon ontological characterization of exploratory data visualization. \n\n## Composition\n\nIn this section, we will see composition plots for different types of variables and data structures.\n\n### Histograms and density plots\n\nOne of the first few graphs we learned in high school would be Histogram. In R, the functions `hist()` or `plot_ly()` represent two methods that can be applied to a vector of values for plotting histograms. The famous 19-th century statistician [Karl Pearson](https://en.wikipedia.org/wiki/Karl_Pearson) introduced histograms as graphical representations of the distribution of a sample of numeric data. The histogram plot uses the data to infer and display the probability distribution of the underlying population that the data is sampled from. Histograms are constructed by selecting a certain number of bins covering the range of values of the observed process. Typically, the number of bins for a data array of size $N$ should be equal to $\\sqrt{N}$. These bins form a partition (disjoint and covering sets) of the range. Finally, we compute the relative frequency representing the number of observations that fall within each bin interval. The histogram just plots a piecewise step-function defined over the union of the bin interfaces whose height equals the observed relative frequencies.\n\n\nThe shape of the last histogram we draw is very close to a Normal distribution (because we sampled from this distribution by `rnorm`). Note the superposition of the corresponding Normal density curve.\n\n\n### Pie Chart\t\n\nWe are all very familiar with pie charts that show us the components of a big \"cake\". Although pie charts provide effective simple visualization in certain situations, it may also be difficult to compare segments within a pie chart or across different pie charts. Other plots like bar chart, box or dot plots may be attractive alternatives.\n\nWe will use the Letter Frequency Data on [SOCR website](https://wiki.socr.umich.edu/index.php/SOCR_LetterFrequencyData) to illustrate the use of pie charts.\n\n\nWe can try to plot the frequency proportion of the 26 English letters using pie and donut charts.\n\n\n\nThe input type for `pie()` is a vector of non-negative numerical quantities. In the `pie` function we list the data that we are going to use (positive and numeric), the labels for each of them, and the colors we want to use for each sector. In the `legend` function, we put the location in the first slot and `legend` are the labels for colors. `cex`, `bty`, `pch`, and `pt.cex` are all graphic parameters that we have talked about in [Chapter 1](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/01_Foundation.html).\n\nMore elaborate pie charts, using the Latin letter data, will be demonstrated using `ggplot` later, ([Section 7.2](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/03_DataVisualization.html#72_some_additional_ggplot_examples).\n\n### Heat map\n\nAnother common data visualization method is the `heat map`. Heat maps can help us visualize the individual values in a matrix intuitively. It is widely used in genetics research and financial applications.\n\nWe will illustrate the use of heat maps, based on a [neuroimaging genetics case-study data](https://dx.doi.org/10.4306/pi.2015.12.1.125) about the association (p-values) of different brain regions of interest (ROIs) and genetic traits (SNPs) for Alzheimer's disease (AD) patients, subjects with mild cognitive impairment (MCI), and normal controls (NC). First, let's import the data into R. The data are 2D arrays where the rows represent different genetic SNPs, columns represent brain ROIs, and the cell values represent the strength of the SNP-ROI association as probability values (smaller p-values indicate stronger neuroimaging-genetic associations).\n\n\nThen we load the R packages we need for heat maps (use `install.packages(\"package name\")` first if you did not install them into your computer). \n\n\nThen we convert the datasets into matrices.\n\n\nWe may also want to set up the row (rc) and column (cc) colors for each cohort.\n\n\nFinally, we got to the point where we can plot heat maps. As we can see, the input type of `heatmap()` is a numeric matrix.\n\n\nIn the `heatmap()` function the first argument is for matrices we want to use. `col` is the color scheme; `scale` is a character indicating if the values should be centered and scaled in either the row direction or the column direction, or none (\"row\", \"column\", and \"none\"); `RowSideColors` and `ColSideColors` creates the color names for horizontal side bars.\n\nThe differences between the AD, MCI and NC heat maps are suggestive of variations of genetic traits or alternative brain regions that may be affected in the three clinically different cohorts.\n\n## Comparison\n\nPlots used for comparing different individuals, groups of subjects, or multiple units represent another set of popular exploratory visualization tools.\n\n### Paired Scatter Plots\n\nScatter plots use the 2D Cartesian plane to display a graph indexed by a pair of variables. 2D points in the graph represent values associated with the two variables corresponding to the two coordinate axes. The position of each 2D point is determined by the values of the first and second variables, tracked on the horizontal and vertical axes. If no clear dependent variable exists, either variable can be plotted on the X axis and the corresponding scatter plot will illustrate the degree of correlation (not necessarily causation) between two variables. Although we will mostly demonstrate the use of `plot_ly()`, which provides dynamic and interactive charts, many basic graphs, including scatter plots, can be rendered using the R function `plot(x, y)`.\n\n\nNow let's draw a paired scatter plot with 5 variables. \n\n\nThis is an interactive scatter plot where you can select/subset some observations in any of the plots and see their associations with other variables across all pairs plots.\n\nLet's see a real word data example. First, we can import the Mental Health Services Survey Data into R, which is on the [class website](https://umich.instructure.com/courses/38100/files/folder/Case_Studies). This survey data covers $10,374$ mental health facilities across the US, the District of Columbia, and US Territories with 237 variables about various facility characteristics. A subset of 10 variables is included in this dataset with all 10,374 cases. Two of the facilitate characteristics involve (1) *supp*, representing the number of specialty and support services available at the mental health facility; and (2) *qual*, which is the number of quality indicators present at the mental health facility. \n\n\nWe can see from `head()` that there are a lot of *NA*'s in the dataset and the pairs plot (`splom`) automatically ignores these (and posts a warning message).\n\n\nThe first plot shows the relation between *supp* (support services) and *qual* (quality indicators). The more elaborate pairs plot illustrates multiple bivariate relations that can be interactively explored by selecting points in any of the plots, where points are color-coded by the *quality indicator* variable.\n\nTo see this trend model (`loess(supp ~ qual`) exposing the trajectory of the support-services to quality relationship. This *locally estimated scatterplot smoothing* (LOESS) model represents a nonlinear smoothing regression.\n\n\nYou can also use the [human height and weight dataset](http://wiki.stat.ucla.edu/socr/index.php/SOCR_Data_Dinov_020108_HeightsWeights) or the [knee pain dataset](https://wiki.socr.umich.edu/index.php/SOCR_Data_KneePainData_041409) to illustrate some interesting scatter plots. \n\n### Jitter plot\n\nJitter plot can help us deal with the overplot issue when we have many points in the data. The function we will be using is still in the package `ggplot2` called `position_jitter()`.\n\nStill we use the earthquake data for example. We will compare the differences with and without the `position_jitter()` function.\n\n\n### Bar Plots\n\nBar plots, or bar charts, represent group data with rectangular bars. There are many variants of bar charts for comparison among categories. Typically, either horizontal or vertical bars are used where one of the axes shows the compared categories and the other axis represents a discrete value. It's possible, and sometimes desirable, to plot bar graphs including bars clustered by groups.\n\nIn R we can use `plotly` or `barplot()` for barplots with inputs either vectors or matrices.\nThe `ggplot2::diamonds` dataset is comprised of $53,940$ diamond records (rows) with 10 observed characteristics: price (\\$326–\\$18,823); carat (diamond weight); cut (quality of the cut); color (D (best) to J (worst)); clarity \n(I1 (worst), ..., IF (best)); x, and z length in mm; depth (total depth percentage = z/mean(x, y) = 2*z/(x + y)); and table (diamond width of top).\n\n\nWe can add error-bars to each bar to indicate a statistical variability. T\n\n\nLet's look at a more complex example. We utilize the dataset [Case_04_ChildTrauma](https://umich.instructure.com/courses/38100/files/folder/Case_Studies) for illustration. This case study examines associations between post-traumatic psychopathology and service utilization by trauma-exposed children.  \n\n\nWe have two character variables. Our goal is to draw a bar plot comparing the means of `age` and `service` among different races in this study and we want to add standard deviation for each bar. The first thing to do is delete the two character columns. Remember the input for `barplot()` is numerical vector or matrix. However, we will need race information for classification. Thus, we store it in a different dataset.\n\n\nThen, we are ready to separate groups and get group means.\n\n\nUntil now, we had a numerical matrix for the means available for plotting. Now, we can compute a second order statistics - standard deviation, and plot it along with the means, to illustrate the amount of dispersion for each variable.\n\n\nAnother way to plot bar plots is to use `ggplot()` in the ggplot package. This kind of bar plots are quite different from the one we introduced previously. It plots the counts of character variables rather than the means of numerical variables. It takes the values from a `data.frame`. Unlike `barplot()`, drawing bar plots using `ggplot2` requires remaining character variables in the original data frame.\n\n\nThis plot helps us to compare the occurrence of different types of child-trauma among different races.\n\n### Trees and Graphs\n\nIn general, a [graph](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)) is an ordered pair $G = (V, E)$ of vertices ($V$). i.e., nodes or points, and a set edges ($E$), arcs or lines connecting pairs of nodes in $V$. A [tree](https://en.wikipedia.org/wiki/Tree_(graph_theory)) is a special type of acyclic graph that does not include looping paths. Visualization of graphs is critical in many biosocial and health studies and we will see examples throughout this textbook.\n\nIn [Chapter 3](https://socr.umich.edu/DSPA2/DSPA2_notes/03_LinearAlgebraMatrixComputingRegression.html) and [Chapter 8](https://socr.umich.edu/DSPA2/DSPA2_notes/08_Unsupervised_Clustering.html) we will learn more about how to build tree models and other clustering methods, and in [Chapter 22](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/22_DeepLearning.html), we will discuss deep learning and neural networks, which intrinsically represent AI decision graphs.\n\nThis section will be focused on displaying tree graphs. We will use [02_Nof1_Data.csv](https://umich.instructure.com/courses/38100/files/folder/data) for this demonstration.\n\n\nWe use `hclust` to build the hierarchical cluster model. `hclust` takes only inputs that have dissimilarity structure as produced by `dist()`. Also, we use the `ave()` method for agglomeration and plot our first tree graph.\n\n\nWhen we have no limit for maximum cluster groups, we will get the above graph, which is miserable to look at. Luckily, `cutree` will help us to set limitations to the number of clusters. `cutree()` takes a `hclust` object and returns a vector of group indicators for all observations.  \n\n\nThen, we can get the mean of each variable within groups by the following for loop.\n\n\nNow we can plot the new tree graph with 10 groups. With `members=table(mem)` option, the matrix is taken to be a dissimilarity matrix between clusters instead of dissimilarities between singletons and members giving the number of observations per cluster.\n\n\n### Correlation Plots\n\nThe `corrplot` package enables the graphical display of a correlation matrix, and confidence intervals, along with some tools for matrix reordering. There are seven visualization methods (parameter method) in the `corrplot` package, named \"circle\", \"square\", \"ellipse\", \"number\", \"shade\", \"color\", \"pie\".\n\nLet's use [03_NC_SNP_ROI_Assoc_P_values.csv](https://umich.instructure.com/courses/38100/files/folder/data?) again to investigate the associations among SNPs using correlation plots.\n\nThe `corrplot()` function we will be using takes correlation matrix only. So we need to get the correlation matrix of our data first via the `cor()` function.\n\n\nWe will discover the difference among different methods under `corrplot`.\n\n\nThe shades are different and darker dots represent high correlation of the two variables corresponding to the x and y axes.\n\n## Relationships\n\n### Line plots using `ggplot`\n\n[Line charts](https://en.wikipedia.org/wiki/Line_chart) display a series of data points, e.g., observed intensities ($Y$) over time ($X$), by connecting them with straight-line segments. These can be used to either track temporal changes of a process or compare the trajectories of multiple cases, time series or subjects over time, space, or state.\n\nIn this section, we will utilize the Earthquakes dataset on [SOCR website](https://wiki.socr.umich.edu/index.php/SOCR_Data_Dinov_021708_Earthquakes). It records information about earthquakes that occurred between 1969 and 2007 with magnitudes larger than 5 on the [Richter scale](https://simple.wikipedia.org/wiki/Richter_scale).\n\n\nIn this dataset, we set `Magt`(magnitude type) as groups. We will draw a \"Depth vs Latitude\" line plot from this dataset. The function we are using is called `ggplot()` under `ggplot2`. The input type for this function is mostly data frame and `aes()` specifies aesthetic mappings of how variables in the data are mapped to visual properties (aesthetics) of the `geom` objects, e.g., lines.\n\n\nThe first part `ggplot(earthquake, aes(Depth, Latitude, group=Magt, color=Magt))` in the code specifies the setting of the plot: dataset, group and color. The second part specifies we are going to draw (points or) lines between data points. In later chapters, we will frequently use the package `ggplot2` and the structure under this great package is always `function1+function2`.\n\n### Density Plots\n\nWe can visualize the distribution for different variables using density plots. \n\nThe following segment of R code plots the distribution for latitude among different [earthquake magnitude types](https://wiki.socr.umich.edu/index.php/SOCR_Data_Dinov_021708_Earthquakes#Data_Description). Also, it is using the `ggplot()` function but combined with `geom_density()`.\n\n\nNote how the green `magt` type (Local (ML) earthquakes) has a peak at latitude $37.5$, which represents [37-38 degrees North](https://en.wikipedia.org/wiki/37th_parallel_north).\n\n## Distributions\n\nRecall that there is a duality between *theoretical* and *empirical* mass, density, and distribution functions. Earlier, we saw the relations between these using the (continuous) Normal distribution, let's now look at the (discrete) Poisson distribution. The graph below plots (1) the histogram of a sample of 1,000 Poisson(1) random observations (light blue color), (2) the theoretical density/mass function (magenta color), and (3) a smooth continuous (Gaussian) kernel density estimation based on the random sample (blue color). More interactive plots of [univariate distributions](http://www.distributome.org/V3/calc/index.html) and [multivariate distributions](https://socr.umich.edu/HTML5/BivariateNormal/BVN2/) are available online.\n\n\n### Data Modeler\n\nA common task in data-driven inference involves the *fitting* of appropriate distribution models to specific observed data elements (features). In general, as there are uncountably many possible distributions that can be used as models for various types of processes, this is a difficult task. The [Probability Distributome Project (see Distributome Navigator)](http://distributome.org/) provides a deeper understanding of the notion of a probability distribution and the relations between various distributions.\n\nWe will demonstrate the concept of a **data modeler** by using [crystallographic data](https://doi.org/10.1038/nature15368) from the [Ivanova Lab at the University of Michigan](https://www.umich.edu/~mivanova), which includes the crystal spectra of [9 length samples](https://umich.instructure.com/files/11653615/download?download_frd=1) and [9 width samples](https://umich.instructure.com/files/11653614/download?download_frd=1). For both, the length and width spectra, the 9 features include \"AC1338\", \"AC1432\", \"AC1593\", \"AC1679\", \"AC1860\", \"AC1874\", \"AC1881\", \"AC1903\", and \"Rec\" (these represent different samples). Notice that the nine spectra are not congruent, different features have different sampling rates. We will employ the [`fitdistrplus` R-package](https://cran.r-project.org/web/packages/fitdistrplus) to estimate the parameters of 3 complementary distributions, however, there are many alternative packages that can also be used.\n\n#### Loading the spectral crystallography data\n\nThe data include two separate signals capturing the spectral *length* and the *width* of the crystallographic sample.\n\n - [Dec 2019 crystallography spectral data](https://umich.instructure.com/files/13375767/download?download_frd=1)\n - [crystallography Length data are here](https://umich.instructure.com/files/11653615/download?download_frd=1)\n - [crystallography Width data are here](https://umich.instructure.com/files/11653614/download?download_frd=1)\n                         \n\n#### Feature distributions\n\nLet's plot the histograms of each of the nine features.\n\n\n#### Fitting single-feature univariate distribution models\n\nWe will fit [Weibull](https://en.wikipedia.org/wiki/Weibull_distribution), [Gamma](https://en.wikipedia.org/wiki/Gamma_distribution), and [Log-Normal](https://en.wikipedia.org/wiki/Log-normal_distribution) distribution models to each feature in the data.\n\n\n####  Visual inspection \n\nLet's examine graphically the quality of the fitted distribution models. We'll plot the histograms of the features, the fitted probability densities, and the corresponding cumulative distribution functions (CDF) and compare them to their sample counterparts.\n\n\nBelow is the `plot_ly()` version of the model fit for one case.\n\n\n\n#### Quantitative summaries\n\nOften, it's useful to export the numerical results of the models. This may include various distribution characteristics like measure of centrality (e.g., mean, median, mode), measures of dispersion, and metrics of the model performance (e.g., [Kolmogorov-Smirnov test](https://wiki.socr.umich.edu/index.php/SMHS_ModelFitting)).\n\n\n#### Mixture distribution data modeling\n\nEarlier, we discussed the *expectations maximization* (EM) algorithm for parameter estimation. Now, we will illustrate the use of EM to estimate the mixture weights and the distribution parameters needed to obtain mixture-distribution data models.\n\nFor each sample, we fit a mixture distribution of $k=3$ (different number of distribution models, which is predefined). The specific types of mixtures for each of the 9 samples are indicated below.\n\n\n#### Mixture-distribution model fitting and parameter estimation\n\nWe will use the [R package mixtools](https://cran.r-project.org/web/packages/mixtools/index.html) to obtain the EM estimates of the mixture distribution weights and the corresponding distribution parameters.\n\n\n#### Plotting the mixture distribution models\n\nWe will define custom plots for the mixtures of *Gamma*, *Weibull*, and *Normal* distributions. Alternatively, we can also use some of the `mixtools::plot()` function to display mixture distribution models.\n\n\nNext, we will display the three alternative mixture distribution models overlaid on the sample histograms of each of the nine samples.\n\n\n#### Reporting model parameter estimates\n\nFor each of the [9 samples in this dataset](https://umich.instructure.com/files/13375767/download?download_frd=1)) and each of the 3 types of mixture distribution models ([Weibull](https://en.wikipedia.org/wiki/Weibull_distribution), [Gamma](https://en.wikipedia.org/wiki/Gamma_distribution), and [Normal](https://en.wikipedia.org/wiki/Normal_distribution)) we will summarize:\n\n - **lambda**: The weights (impacts) of each of the 3 mixture components to the overall mixture model,\n - **parameters**: of each mixture distribution component, *mean* and *sd*,\n - **loglik**: the overall mixture distribution [log-likelihood value](https://en.wikipedia.org/wiki/Likelihood_function).\n\n\nBelow we summarize the mixture-distribution models just for the first two crystallographic features.\n\n##### *AC1338* Report (Case 1)\n\n\n##### *AC1432* Report (Case 2)\n\n\n\n### 2D Kernel Density and 3D Surface Plots\n\n[Density estimation](https://en.wikipedia.org/wiki/Density_estimation) is the process of using observed data to compute an estimate of the underlying process' probability density function. There are several approaches to obtain density estimation, but the most basic technique is to use a rescaled histogram.\n\nPlotting 2D Kernel Density and 3D Surface plots is very important and useful in multivariate exploratory data analytics. \n\nWe will use the `plot_ly()` function in the `plotly` package, which works with data frame objects.\n\nTo create a surface plot, we use two vectors: *x* and *y* with length *m* and *n* respectively. We also need a matrix: *z* of size $m\\times n$. This *z* matrix is created from matrix multiplication between *x* and *y*. \n\nTo plot the 2D Kernel Density estimation plot we will use the eruptions data from the \"Old Faithful\" geyser in Yellowstone National Park, Wyoming stored under `geyser`. Also, `kde2d()` function is needed for 2D kernel density estimation.\n\n\nHere `z=t(x)%*%y`. Then we apply `plot_ly` to the list `kd` using the `with()` function.\n\n\n![](https://wiki.socr.umich.edu/images/1/18/DSPA_Figs_2d_kernel_visual.png)\n\nNote we used the option `\"surface\"`.\n\nFor 3D surfaces, we have a built-in dataset in R called `volcano`. It records the volcano height at location x, y (longitude, latitude). Because *z* is always made from *x* and *y*, we can simply specify *z* to get the complete surface plot.\n\n![](https://wiki.socr.umich.edu/images/c/c4/DSPA_Figs_3dsurface_visual.png)\n\n### Multiple 2D image surface plots\n\n\n![](http://wiki.stat.ucla.edu/socr/uploads/f/f6/DSPA_Figs_2d_kernel_ImageVisual.png.png)\n\n### 3D and 4D Visualizations\n\nMany datasets have intrinsic multi-dimensional characteristics. For instance, the human body is a 3D solid of matter (3 spatial dimensions can be used to describe the position of every component, e.g., [sMRI volume](https://en.wikipedia.org/wiki/Magnetic_resonance_imaging)) that changes over time (the fourth dimension, e.g., [fMRI hypervolumes](https://en.wikipedia.org/wiki/Functional_magnetic_resonance_imaging)).\n\nThe [SOCR BrainViewer](https://socr.umich.edu/HTML5/BrainViewer/) shows how to use a web-browser to visualize 2D cross-sections of 3D volumes, display volume-rendering, and show 1D (e.g., 1-manifold curves embedded in 3D) and 2D (e.g., surfaces, shapes) models jointly into the same 3D scene.\n\nWe will now illustrate an example of 3D/4D visualization in `R` using the packages [brainR](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4911196/) and [rgl](https://cran.r-project.org/web/packages/rgl). This code is included as it runs well in interactive `R` sessions. However, it is suppressed during HTML knitting (`eval=FALSE`), as `rgl` causes some browser-OS combinations to fail while loading the resulting HTML file.\n\n\nBelow we provide some additional 3D/4D PET, sMRI, and fMRI volumes in [*.nii.gz format](https://nifti.nimh.nih.gov/nifti-1/data):\n\n - [sMRI](https://socr.umich.edu/HTML5/BrainViewer/data/ABIDE_MRI_MPRAGE_peds_defaced.nii.gz) (3D real-valued structural MRI volume)\n - [fMRI](https://socr.umich.edu/HTML5/BrainViewer/data/fMRI_FilteredData_4D.nii.gz) (4D real-valued functional MRI hyper-volume)\n - [PET](https://socr.umich.edu/HTML5/BrainViewer/data/PET_FDG_3D_vol.nii.gz) (3D perfusion Positron Emission Tomography volume).\n\nFor 4D fMRI time-series, we can load the hypervolumes similarly and then display some lower dimensional projections.\n\n\n[Chapter 12](https://socr.umich.edu/DSPA2/DSPA2_notes/12_LongitudinalDataAnalysis.html) provides more details about longitudinal and time-series data analysis.\n\nFinally, [DSPA Appendix 3](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_03_Geometric_Parametric_Surface_Viz.html) includes details about classification, representation, modeling, and visualization of parametric and implicit, open and closed manifolds.",
      "word_count": 3705
    },
    {
      "title": "Appendix",
      "content": "## Importing Data from SQL Databases\n\nWe can also import SQL databases into `R`. First, we need to install and load the RODBC (R Open Database Connectivity) package.  \n\n\nThen, we could open a connection to the SQL server database with Data Source Name (DSN), via Microsoft Access. More details are provided [here](https://technet.microsoft.com/en-us/library/cc879308%28v=sql.105%29.aspx) and [here](https://cran.r-project.org/web/packages/RODBC/vignettes/RODBC.pdf).\n\n## Additional `R` scripts\n\nThe code below was used to generate some of the graphs shown in this chapter.\n\n\n## Case-Study 11 - Traumatic Brain Injury (TBI)\n\nThe data is available in the [Canvas case-studies folder](https://umich.instructure.com/courses/38100/files/folder/Case_Studies).\n\n\nPreprocess the data and plot the clustering dendrogram.\n\n\nTo identify the number of cases for varying number of clusters\n\n\nInspect which *SubjectIDs* are in which clusters:\n\n\nLet's see which *Age* and which *Surgery* cohorts fall within each of the derived cluster labels. Remember that all variables are scaled, so they represent standardized variable values!\n\n\nTo characterize the clusters, we can look at cluster summary statistics, like the median, of the variables that were used to perform the cluster analysis. These can be broken down by the groups identified by the cluster analysis. The aggregate function will compute stats (e.g., median) on many variables simultaneously. To look at the median values for the variables we've used in the cluster analysis, broken up by the cluster groups:\n\n\n## Some additional `ggplot` examples\n\n###  Housing Price Data\nThis example uses the [SOCR Home Price Index data of 19 major city in US from 1991-2009](https://wiki.socr.umich.edu/index.php/SOCR_Data_Dinov_091609_SnP_HomePriceIndex).\n\n\n### Modeling the home price index data\n\n\nLet's examine some popular `ggplot` graphs.\n\n\n### Map of the neighborhoods of Los Angeles (LA)\n\nThis example interrogates data of [110 LA neighborhoods](https://wiki.socr.umich.edu/index.php/SOCR_Data_LA_Neighborhoods_Data), which includes measures of education, income and population demographics.\n\nHere, we select the **Longitude** and *Latitude* as the axes, mark these 110 Neighborhoods according to their population, fill out those points according to the income of each area, and label each neighborhood.\n\n\nObserve that some areas (e.g., Beverly Hills) have disproportionately higher incomes and notice that the resulting plot resembles this plot\n\n![SOCR plot of the same data](https://wiki.socr.umich.edu/images/4/49/SOCR_Data_LA_County_Neighborhoods_Dinov_100109_Fig1.png). \n\n### Latin letter frequency in different languages\n\nThis example uses `ggplot` to interrogate the [SOCR Latin letter frequency data](https://wiki.socr.umich.edu/index.php/SOCR_LetterFrequencyData).\n\n\nYou can see [some additional Latin Letters plots here](http://wiki.stat.ucla.edu/socr/index.php/SOCR_LetterFrequencyData#Graphs).\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number \n\t\t\t\t<img class=\"statcounter\"\n\t\t\t\t\t\t\t\tsrc=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" \n\t\t\t\t\t\t\t\talt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 459
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    self_contained: yes\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Data Handling",
      "code": "data()\ndata(iris)\nclass(iris)",
      "line_count": 3
    },
    {
      "section": "Data Handling",
      "code": "save(iris, file=\"myData.RData\")\nload(\"myData.RData\")",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "water <- read.csv(\n  'https://umich.instructure.com/files/399172/download?download_frd=1',\n  header=TRUE, fileEncoding = \"UTF-8\") #, fileEncoding = \"UTF-8\")\nwater[1:3, ]\ncolnames(water)<-c(\"year\", \"region\", \"country\", \"residence_area\", \"improved_water\", \"sanitation_facilities\")\nwater[1:3, ]\nwhich.max(water$year); \n# rowMeans(water[,5:6])\nmean(water[,6], trim=0.08, na.rm=T)",
      "line_count": 9
    },
    {
      "section": "Data Handling",
      "code": "write.csv(iris, file = \"C:/Users/iris.csv\")",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "# install.packages(\"foreign\")\nlibrary(\"foreign\")\npathToZip <- tempfile() \ndownload.file(\"https://umich.instructure.com/files/8111611/download?download_frd=1\", pathToZip, mode = \"wb\")\ndataset <- read.spss(unzip(pathToZip, files = \"namcs2015-spss.sav\", list = F, overwrite = TRUE), to.data.frame=TRUE)\ndim(dataset)\n## [1] 28332  1096\n# str(dataset)\n# View(dataset)  \nunlink(pathToZip)",
      "line_count": 10
    },
    {
      "section": "Data Handling",
      "code": "str(water)\nHmisc::describe(water)",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "library(plotly)\nsummary(water$year)\nsummary(water[c(\"improved_water\", \"sanitation_facilities\")])\n# plot(density(water$improved_water,na.rm = T))  # no need to be continuous, we can still get intuition about the variable distribution\n\nfit <- density(as.numeric(water$improved_water),na.rm = T)\nplot_ly(x = fit$x, y = fit$y, type = \"scatter\", mode = \"lines\", \n              fill = \"tozeroy\", name = \"Density\") %>% \n    layout(title='Density of (%) Improved Water Quality', \n           xaxis = list (title = 'Percent'), yaxis = list (title = 'Density'))",
      "line_count": 10
    },
    {
      "section": "Data Handling",
      "code": "vec1<-c(40, 56, 99)\nmean(vec1)\nmean(c(40, 56, 99))\nmedian(vec1)\nmedian(c(40, 56, 99))\n# install.packages(\"psych\"); \nlibrary(\"psych\")\ngeometric.mean(vec1, na.rm=TRUE)",
      "line_count": 8
    },
    {
      "section": "Data Handling",
      "code": "range(water$improved_water, na.rm=TRUE)\ndiff(range(water$improved_water, na.rm=TRUE))",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "IQR(water$improved_water, na.rm=TRUE)\nsummary(water$improved_water)",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "quantile(water$improved_water, na.rm = TRUE)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "quantile(water$improved_water, probs = c(0.2, 0.6), na.rm = TRUE)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "quantile(water$improved_water, seq(from=0, to=1, by=0.2), na.rm = TRUE)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "baseball<-read.table(\"https://umich.instructure.com/files/330381/download?download_frd=1\", header=T)\n# hist(baseball$Weight, main = \"Histogram for Baseball Player's Weight\", xlab=\"weight\")\n# hist(baseball$Height, main = \"Histogram for Baseball Player's Height\", xlab=\"height\")\n\nx <- rnorm(10000, mean=mean(baseball$Weight, na.rm=T), sd=sd(baseball$Weight, na.rm=T))\t\nfit <- density(x, bw=10)\t\n\nplot_ly(x=~baseball$Weight, type = \"histogram\", name = \"Weight Histogram\", histnorm = \"probability\") %>% \t\n    add_trace(x =~fit$x, y =~5*fit$y, type = \"scatter\", mode = \"lines\", opacity=0.1,\t\n              fill = \"tozeroy\", name = \"Normal Density\") %>% \t\n    layout(title='Baseball Weight Histogram & Model Normal Distribution', \t\n           xaxis = list(title = \"Weight\"), yaxis = list(title = \"relative frequency/density\"),\t\n           legend = list(orientation = 'h'))\t\n\nx <- rnorm(10000, mean=mean(baseball$Height, na.rm=T), sd=sd(baseball$Height, na.rm=T))\t\nfit <- density(x, bw=1)\t\n\nplot_ly(x=~baseball$Height, type = \"histogram\", name = \"Height Histogram\", histnorm = \"probability\") %>% \t\n    add_trace(x=~fit$x, y=~fit$y, type = \"scatter\", mode = \"lines\", opacity=0.1,\t\n              fill = \"tozeroy\", name = \"Normal Density\") %>% \t\n    layout(title='Baseball Height Histogram & Model Normal Distribution', \t\n           xaxis = list(title = \"Height\"), yaxis = list(title = \"relative frequency/density\"),\t\n           legend = list(orientation = 'h'))\t",
      "line_count": 23
    },
    {
      "section": "Data Handling",
      "code": "mean(baseball$Weight)\nmean(baseball$Height)\nvar(baseball$Weight)\nsd(baseball$Weight)\nvar(baseball$Height)\nsd(baseball$Height)",
      "line_count": 6
    },
    {
      "section": "Data Handling",
      "code": "#  hist(x, probability=T, \n#    col='lightblue', xlab=' ', ylab=' ', axes = F, \n#    main='68-95-99.7 Rule')\n# lines(density(x, bw=0.4), col='red', lwd=3)\n# axis(1, at=c(-3, -2, -1, 0, 1, 2, 3), labels = expression(mu-3*sigma, mu-2*sigma, mu-sigma, mu, mu+sigma, mu+2*sigma, mu+3*sigma))\n# abline(v=-1, lwd=3, lty=2)\n# abline(v=1, lwd=3, lty=2)\n# abline(v=-2, lwd=3, lty=2)\n# abline(v=2, lwd=3, lty=2)\n# abline(v=-3, lwd=3, lty=2)\n# abline(v=3, lwd=3, lty=2)\n# text(0, 0.2, \"68%\")\n# segments(-1, 0.2, -0.3, 0.2, col = 'red', lwd=2)\n# segments(1, 0.2, 0.3, 0.2, col = 'red', lwd=2)\n# text(0, 0.15, \"95%\")\n# segments(-2, 0.15, -0.3, 0.15, col = 'red', lwd=2)\n# segments(2, 0.15, 0.3, 0.15, col = 'red', lwd=2)\n# text(0, 0.1, \"99.7%\")\n# segments(-3, 0.1, -0.3, 0.1, col = 'red', lwd=2)\n# segments(3, 0.1, 0.3, 0.1, col = 'red', lwd=2)\n\nN<- 1000\nnorm <- rnorm(N, 0, 1)\n#  hist(x, probability=T, \n#    col='lightblue', xlab=' ', ylab=' ', axes=F, \n#    main='Normal Distribution')\n# lines(density(x, bw=0.4), col='red', lwd=3)\nnormDensity <- density(norm, bw=0.5)\ndens <- data.frame(x = normDensity$x, y = normDensity$y)\nminy <- 0\nmaxy <- max(dens$y)\n\nxLabels <- c(\"&mu;-3&#963;\",\"&mu;-2&#963;\", \"&mu;-&#963;\", \"&mu;\", \"&mu;+&#963;\", \"&mu;+2&#963;\", \"&mu;+3&#963;\")\nlabelColors <- c(\"green\", \"red\", \"orange\", \"black\", \"orange\", \"red\", \"green\")\nxLocation <- c(-3, -2, -1, 0, 1, 2, 3)\nyLocation <- 0.2\ndata <- data.frame(xLabels, xLocation, yLocation)\n\nplot_ly(dens) %>% \n    add_histogram(x = norm, name=\"Normal Histogram\") %>% \n    add_lines(data = dens, x = ~x, y = ~y+0.05, yaxis = \"y2\", \n              line = list(width = 3), name=\"N(0,1)\") %>% \n    add_annotations(x = ~xLocation, y = ~yLocation, type = 'scatter', ax = 20, ay = 20,\n                    mode = 'text', text = ~xLabels, textposition = 'middle right',\n                    textfont = list(color = labelColors, size = 16)) %>%\n    add_segments(x=-3, xend=-3, y=0, yend=100, name=\"99.7%\", line=list(dash=\"dash\", color=\"green\")) %>%\n    add_segments(x=-2, xend=-2, y=0, yend=90, name=\"95%\", line=list(dash=\"dash\", color=\"red\")) %>%\n    add_segments(x=-1, xend=-1, y=0, yend=80, name=\"68%\", line=list(dash=\"dash\", color=\"orange\")) %>%\n    add_segments(x=1, xend=1, y=0, yend=80, name=\"68%\", line = list(dash = \"dash\", color=\"orange\")) %>%\n    add_segments(x=2, xend=2, y=0, yend=90, name=\"95%\", line=list(dash=\"dash\", color=\"red\")) %>%\n    add_segments(x=3, xend=3, y=0, yend=100, name=\"99.7%\", line=list(dash=\"dash\", color=\"green\")) %>%\n    add_segments(x=-3, xend=3, y=100, yend=100, name=\"99.7%\", line=list(dash=\"dash\", color=\"green\")) %>%\n    add_segments(x=-2, xend=2, y=90, yend=90, name=\"95%\", line=list(dash=\"dash\", color=\"red\")) %>%\n    add_segments(x=-1, xend=1, y=80, yend=80, name=\"68%\", line=list(dash=\"dash\", color=\"orange\")) %>%\n    layout(bargap=0.1, xaxis=list(name=\"\"), yaxis=list(title=\"density/frequency\"),\n           yaxis2 = list(overlaying = \"y\", side = \"right\", # title=\"prob\",\n                         range = c(miny, maxy+0.1), showgrid = F, zeroline = F),\n           legend = list(orientation = 'h'), title=\"Normal 68-95-99.7% Rule\")",
      "line_count": 58
    },
    {
      "section": "Data Handling",
      "code": "# boxplot(water$improved_water, main=\"Boxplot for Percent improved_water\", ylab=\"Percentage\")\nplot_ly(y = ~water$improved_water, type = \"box\", name=\"improved water qual\") %>% \n  add_trace(y = ~water$sanitation_facilities, name =\"sanitation\") %>% \n    layout(title='Boxplots of Improved Water Quality and Sanitation Facilities', \n           yaxis = list (title = 'Percent'))",
      "line_count": 5
    },
    {
      "section": "Data Handling",
      "code": "# hist(water$improved_water, main = \"Histogram of  Percent improved_water\", xlab=\"Percentage\")\n# hist(water$sanitation_facilities, main = \"Histogram of  Percent sanitation_facilities\", xlab = \"Percentage\")\n\nplot_ly(x = ~water$improved_water, type = \"histogram\", name=\"improved_water\") %>% \n  add_trace(x = ~water$sanitation_facilities, type = \"histogram\", name=\"sanitation_facilities\") %>% \n  layout(bargap=0.1, title='Histograms', legend = list(orientation = 'h'),\n         xaxis = list(title = 'Percent'), yaxis = list (title = 'Frequency'))",
      "line_count": 7
    },
    {
      "section": "Data Handling",
      "code": "N <- 10000\nx <- rnbinom(N, 5, 0.1)\n#  hist(x, \n#  xlim=c(min(x), max(x)), probability=T, nclass=max(x)-min(x)+1, \n#    col='lightblue', xlab=' ', ylab=' ', axes=F, \n#    main='Right Skewed')\n# lines(density(x, bw=1), col='red', lwd=3)\nfit <- density(x)\n\nplot_ly(x = x, type = \"histogram\", name = \"Data Histogram\") %>% \n    add_trace(x = fit$x, y = fit$y, type = \"scatter\", mode = \"lines\", opacity=0.3,\n              fill = \"tozeroy\", yaxis = \"y2\", name = \"Density (rnbinom(N, 5, 0.1))\") %>% \n    layout(title='Right Skewed Process', yaxis2 = list(overlaying = \"y\", side = \"right\"),\n           legend = list(orientation = 'h'))\n\nN <- 10000\nx <- rnorm(N, 15, 3.7)\n#  hist(x, \n#  xlim=c(min(x), max(x)), probability=T, nclass=max(x)-min(x)+1, \n#    col='lightblue', xlab=' ', ylab=' ', axes=F, \n#    main='Right Skewed')\n# lines(density(x, bw=1), col='red', lwd=3)\nfit <- density(x)\n\nplot_ly(x = x, type = \"histogram\", name = \"Data Histogram\") %>% \n    add_trace(x = fit$x, y = fit$y, type = \"scatter\", mode = \"lines\", opacity=0.3,\n              fill = \"tozeroy\", yaxis = \"y2\", name = \"Density (rnorm(N, 15, 3.7))\") %>% \n    layout(title='Symmetric Process', yaxis2 = list(overlaying = \"y\", side = \"right\"),\n           legend = list(orientation = 'h'))\n\n# N <- 10000\n# xNu <- extraDistr::rlaplace(N, mu = 0, sigma = 0.4)\n# yNu <- density(xNu, bw=0.2)\n# xMu <- extraDistr::rlaplace(N, mu = 0, sigma = 0.5)\n# yMu <- density(xMu, bw=0.2)\n# # correct second Laplace Density (mu) to ensure absolute continuity, nu << mu\n# yMu$y <- 2*yMu$y\n# plot_ly(x = x, type = \"histogram\", name = \"Data Histogram\") %>% \n#     add_trace(x = yNu$x, y = yNu$y, type = \"scatter\", mode = \"lines\", opacity=0.3,\n#               fill = \"tozeroy\", yaxis = \"y2\", name = \"nu, Laplace(N,0,0.4) Density\") %>% \n#     add_trace(x = yMu$x, y = yMu$y, type=\"scatter\", mode=\"lines\", opacity=0.3,\n#               fill = \"tozeroy\", yaxis = \"y2\", name = \"mu, Laplace(N,0,0.5) Density\") %>% \n#     layout(title=\"Absolutely Continuous Laplace Distributions, nu<<mu\", \n#            yaxis2 = list(overlaying = \"y\", side = \"right\"),\n#            xaxis = list(range = list(-pi, pi)),\n#            legend = list(orientation = 'h'))\n# integrate(approxfun(yNu), -pi, pi)\n# integrate(approxfun(yMu), -pi, pi)",
      "line_count": 48
    },
    {
      "section": "Data Handling",
      "code": "z<-seq(-4, 4, 0.1)  # points from -4 to 4 in 0.1 steps\nq<-seq(0.001, 0.999, 0.001)  # probability quantile values from 0.1% to 99.9% in 0.1% steps\n\ndStandardNormal <- data.frame(Z=z, Density=dnorm(z, mean=0, sd=1), Distribution=pnorm(z, mean=0, sd=1))  \n\nqStandardNormal <- data.frame(Q=q, Quantile=qnorm(q, mean=0, sd=1))  \nhead(dStandardNormal)\n\n# plot(z, dStandardNormal$Density, main=\"Normal Density Curve\", type = \"l\", xlab = \"critical values\", ylab=\"density\", lwd=4, col=\"blue\")\n# polygon(z, dStandardNormal$Density, col=\"red\", border=\"blue\")\n# plot(z, dStandardNormal$Distribution, main=\"Normal Distribution\", type = \"l\", xlab = \"critical values\", ylab=\"Cumulative Distribution\", lwd=4, col=\"blue\")\n# plot(q, qStandardNormal$Quantile, main=\"Normal Quantile Function (Inverse CDF)\", type = \"l\", xlab = \"p-values\", ylab=\"Critical Values\", lwd=4, col=\"blue\")\n\nplot_ly(x = z, y= dStandardNormal$Density, name = \"Normal Density Curve\",\n        mode = 'lines') %>% \n    layout(title='Normal Density Curve', \n           xaxis = list(title = 'critical values'),\n           yaxis = list(title =\"Density\"),\n           legend = list(orientation = 'h'))\n\nplot_ly(x = z, y= dStandardNormal$Distribution,\n        name = \"Normal Density Curve\", mode = 'lines') %>% \n    layout(title='Normal Distribution', \n           xaxis = list(title = 'critical values'),\n           yaxis = list(title =\"Cumulative Distribution\"),\n           legend = list(orientation = 'h'))\n\nplot_ly(x = q, y= qStandardNormal$Quantile,\n        name = \"Normal Quantile Function (Inverse CDF)\", mode = 'lines') %>%\n    layout(title='Normal Distribution', \n           xaxis = list(title = 'probability values'),\n           yaxis = list(title =\"Critical Values\"),\n           legend = list(orientation = 'h'))",
      "line_count": 33
    },
    {
      "section": "Data Handling",
      "code": "x<-runif(1000, 1, 50)\n# hist(x, col='lightblue', main=\"Uniform Distribution\", probability = T, xlab=\"\", ylab=\"Density\", axes=F)\n# abline(h=0.02, col='red', lwd=3)\nplot_ly(x = ~x, type = \"histogram\", histnorm = \"probability\", name=\"proportion\", showlegend = F) %>% \n  add_lines(x=~x, y=~0.038, type = 'scatter', mode = 'lines') %>%\n  layout(bargap=0.1, title='Uniform(0, 50) Histogram', yaxis = list(title =\"probability\"))",
      "line_count": 6
    },
    {
      "section": "Data Handling",
      "code": "N<- 1000\nnorm <- rnorm(N, 0, 1)\n#  hist(x, probability=T, \n#    col='lightblue', xlab=' ', ylab=' ', axes=F, \n#    main='Normal Distribution')\n# lines(density(x, bw=0.4), col='red', lwd=3)\nnormDensity <- density(norm, bw=0.5)\ndens <- data.frame(x = normDensity$x, y = normDensity$y)\nminy <- 0\nmaxy <- max(dens$y)\n\nplot_ly(dens) %>% \n  add_histogram(x = norm, name=\"Normal Histogram\") %>% \n  add_lines(data = dens, x = ~x, y = ~y, yaxis = \"y2\", \n            line = list(width = 3), name=\"N(0,1)\") %>% \n  layout(bargap=0.1, yaxis2 = list(overlaying = \"y\",  side = \"right\", \n            range = c(miny, maxy), showgrid = F, zeroline = F),\n         legend = list(orientation = 'h'), title=\"Normal(0,1)\")",
      "line_count": 18
    },
    {
      "section": "Data Handling",
      "code": "water <- read.csv('https://umich.instructure.com/files/399172/download?download_frd=1', header=T, stringsAsFactors=FALSE, fileEncoding=\"latin1\")\n\ncolnames(water)<-c(\"year\", \"region\", \"country\", \"residence_area\", \"improved_water\", \"sanitation_facilities\")\n\ntable(water$year)\ntable(water$region)\ntable(water$residence_area)",
      "line_count": 7
    },
    {
      "section": "Data Handling",
      "code": "year_table<-table(water$year)\nprop.table(year_table)\nyear_pct<-prop.table(year_table)*100\nround(year_pct, digits=1)",
      "line_count": 4
    },
    {
      "section": "Data Handling",
      "code": "# plot.window(c(400,1000), c(500,1000))\n# plot(x=water$year, y=water$improved_water, \n#      main= \"Scatterplot of Year vs. Improved_water\", \n#      xlab= \"Year\", \n#      ylab= \"Percent of Population Using Improved Water\")\n\nplot_ly(x = ~water$sanitation_facilities, y = ~water$improved_water, type = \"scatter\", \n        mode = \"markers\") %>% \n    layout(title='Scatterplot: Improved Water Quality vs. Sanitation Facilities', \n           xaxis = list (title = 'Water Quality'), yaxis = list (title = 'Sanitation'))\n",
      "line_count": 11
    },
    {
      "section": "Data Handling",
      "code": "#install.packages(\"gmodels\", repos = \"http://cran.us.r-project.org\")\nlibrary(gmodels)",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "water$africa<-water$region==\"Africa\"",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "table(water$africa)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "CrossTable(x=water$residence_area, y=water$africa)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "m1<-mean(water$improved_water, na.rm = T)\nm2<-mean(water$sanitation_facilities, na.rm = T)\nwater_imp<-water\nfor(i in 1:3331){\n  if(is.na(water_imp$improved_water[i])){\n    water_imp$improved_water[i] <- m1\n  }\n  if(is.na(water_imp$sanitation_facilities[i])){\n    water_imp$sanitation_facilities[i] <- m2\n  }\n}\nsummary(water_imp)",
      "line_count": 12
    },
    {
      "section": "Data Handling",
      "code": "# install.packages(\"mi\")\nlibrary(mi)",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "mdf<-missing_data.frame(water)\nhead(mdf)\nshow(mdf)\nmdf<-change(mdf, y=\"improved_water\", what = \"imputation_method\", to=\"pmm\")\nmdf<-change(mdf, y=\"sanitation_facilities\", what = \"imputation_method\", to=\"pmm\")",
      "line_count": 5
    },
    {
      "section": "Data Handling",
      "code": "imputations <- mi(mdf, n.iter=10, n.chains=3, verbose=T)",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "library(mi)\ndata.frames <- complete(imputations, 3)\nsummary(water)\nsummary(data.frames[[1]])\nmySummary <- lapply(data.frames, summary)\nmySummary$`chain:1`   # report just the summary of the first chain.",
      "line_count": 6
    },
    {
      "section": "Data Handling",
      "code": "set.seed(123)\n# create MCAR missing-data generator\ncreate.missing <- function (data, pct.mis = 10) \n{\n    n <- nrow(data)\n    J <- ncol(data)\n    if (length(pct.mis) == 1) {\n        if(pct.mis>= 0 & pct.mis <=100) {\n            n.mis <- rep((n * (pct.mis/100)), J)\n        }\n        else {\n          warning(\"Percent missing values should be an integer between 0 and 100! Exiting\"); break\n        }\n      }\n    else {\n        if (length(pct.mis) < J) \n            stop(\"The length of the missing-vector is not equal to the number of columns in the data! Exiting!\")\n            n.mis <- n * (pct.mis/100)\n    }\n    for (i in 1:ncol(data)) {\n        if (n.mis[i] == 0) { # if the column has no missing values, do nothing\n            data[, i] <- data[, i]\n        }\n        else {\n            data[sample(1:n, n.mis[i], replace = FALSE), i] <- NA\n    \t\t  # For each given column (i), sample the row indices (1:n), \n    \t\t  # a number of indices to replace as \"missing\", n.mis[i], \"NA\", \n      \t  # without replacement\n        }\n    }\n    return(as.data.frame(data))\n}",
      "line_count": 32
    },
    {
      "section": "Data Handling",
      "code": "n <- 1000; u1 <- rbinom(n, 1, .5); v1 <- log(rnorm(n, 5, 1)); x1 <- u1*exp(v1)\nu2 <- rbinom(n, 1, .5); v2 <- log(rnorm(n, 5, 1)); x2 <- u2*exp(v2)\nx3 <- rbinom(n, 1, prob=0.45); x4 <- ordered(rep(seq(1, 5), n)[sample(1:n, n)])\nx5 <- rep(letters[1:10], n)[sample(1:n, n)]; x6 <- trunc(runif(n, 1, 10))\nx7 <- rnorm(n); x8 <- factor(rep(seq(1, 10), n)[sample(1:n, n)])\nx9 <- runif(n, 0.1, .99); x10 <- rpois(n, 4)\ny <- x1 + x2 + x7 + x9 + rnorm(n)\n\n# package the simulated data as a data frame object\nsim_data <- cbind.data.frame(y, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)\n\n# randomly create missing values\nsim_data_30pct_missing <- create.missing(sim_data, pct.mis=30); \n# head(sim_data_30pct_missing); summary(sim_data_30pct_missing)\n\n# install.packages(\"DT\")\nlibrary(\"DT\")\nlibrary(dplyr)\ndf_raw <- sim_data %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_raw)\n\ndf_miss <- sim_data_30pct_missing %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_miss)\n\n# install.packages(\"mi\")\n# install.packages(\"betareg\")\nlibrary(\"betareg\"); library(\"mi\")\n\n# get show the missing information matrix\t\t\t\nmdf <- missing_data.frame(sim_data_30pct_missing) \n# show(mdf)\ndf_mdf <- as.data.frame(mdf) %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_mdf)\n\n# mdf@patterns   # to get the textual missing pattern\nimage(mdf)   # remember the visual pattern of this MCAR\n# df_img <- df_mdf %>% mutate_if(is.factor, as.character) %>%  replace(is.character(.), 1)  %>%  replace(is.na(.), 0)\n# # df_img <- df_mdf %>%  replace(is.character(.), 1)  %>%  replace(is.na(.), 0)\n# df_img [1:10,1:10]\n# df_img[is.character(df_img)] <- 1",
      "line_count": 40
    },
    {
      "section": "Data Handling",
      "code": "# Next try to impute the missing values.\n\n# Get the Graph Parameters (plotting canvas/margins)\n# set to plot the histograms for the 3 imputation chains\n# mfcol=c(nr, nc). Subsequent histograms are drawn as nr-by-nc arrays on the graphics device by columns (mfcol), or rows (mfrow)\n# oma\n# oma=c(bottom, left, top, right) giving the size of the outer margins in lines of text\n# mar=c(bottom, left, top, right) gives the number of lines of margin to be specified on the four sides of the plot.\n# tcl=length of tick marks as a fraction of the height of a line of text (default=0.5)\npar(mfcol=c(5, 5), oma=c(1, 1, 0, 0), mar=c(1, 1, 1, 0), tcl=-0.1, mgp=c(0, 0, 0))\n\n# Note to get verbose output-report, parallel must be OFF: parallel=FALSE, verbose=TRUE\nimputations <- mi(sim_data_30pct_missing, n.iter=5, n.chains=3, verbose=TRUE)\nhist(imputations)\n\n# Extracts several multiply imputed data.frames from \"imputations\" object\ndata.frames <- complete(imputations, 3)\n\n# compare the 3 objects, sim_data, sim_data_30pct_missing, and imputed chain1\n# datatable(sim_data, caption = htmltools::tags$caption(\n#      style = 'caption-side: bottom; text-align: center;','Table: Initial sim_data'))\ndf_miss <- sim_data_30pct_missing %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_miss, caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;','Table: Initial sim_data'))\n\n# datatable(sim_data_30pct_missing, caption = htmltools::tags$caption(\n#      style = 'caption-side: bottom; text-align: center;', 'Table: sim_data_30pct_missing'))\ndf_miss30pct <- sim_data_30pct_missing %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_miss30pct, caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: sim_data 30% Missing'))\n          \ndf_chain1 <- data.frames[[1]] %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_chain1, caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', 'Table: Imputed data (chain 1)'))\n\n# Compare the summary stats for the original data (prior to introducing missing\n# values) with missing data and the re-completed data following imputation\n# summary(sim_data)\ndatatable(data.frame(t(as.matrix(unclass(summary(sim_data)))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: summary(sim_data)'))\n\nmySummary <- lapply(data.frames, summary)\ndatatable(data.frame(t(as.matrix(unclass(mySummary$`chain:1`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:1)'))",
      "line_count": 47
    },
    {
      "section": "Data Handling",
      "code": "round(mipply(imputations, mean, to.matrix = TRUE), 3)\nRhats(imputations, statistic = \"moments\") # assess the convergence of MI algorithm\nplot(imputations); hist(imputations); image(imputations); summary(imputations)",
      "line_count": 3
    },
    {
      "section": "Data Handling",
      "code": "model_results <- pool(y ~ x1+x2+x3+x4+x5+x6+x7+x8+x9+x10, data=imputations,  m=3)\ndisplay (model_results); summary (model_results)  \n# Report the summaries of the imputations\ndata.frames <- complete(imputations, 3)  \t# extract the first 3 chains\nmySummary <-lapply(data.frames, summary)\n\ndatatable(data.frame(t(as.matrix(unclass(mySummary$`chain:1`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:1)'))\ndatatable(data.frame(t(as.matrix(unclass(mySummary$`chain:2`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:2)'))\ndatatable(data.frame(t(as.matrix(unclass(mySummary$`chain:3`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:3)'))\n\ncoef(summary(model_results))[, 1:2]  # get the model coefficients and their SE's  \n\nlibrary(\"lattice\")\ndensityplot(y ~ x1 + x2, data=imputations)\n\n# plot_ly(imputations@data$`chain:1`, x=~(x1+x2), y=~density(y))\n# To compare the density of observed data and imputed data --\n# these should be similar (though not identical) under MAR assumption",
      "line_count": 24
    },
    {
      "section": "Data Handling",
      "code": "# Load the (raw) data from the table into a plain text file \"08_EpiBioSData_Incomplete.csv\"\nTBI_Data <- read.csv(\"https://umich.instructure.com/files/720782/download?download_frd=1\", na.strings=c(\"\", \".\", \"NA\"))    ## 1. read in data\nsummary(TBI_Data)\n\n# Get information matrix of the data\n# 2. create an object of class \"missing_data.frame\" from the data.frame TBI_data\n# Convert to a missing_data.frame\n# library(\"betareg\"); library(\"mi\")\t\t\t\nmdf <- missing_data.frame(TBI_Data) # warnings about missingness patterns\ndatatable(mdf)\n# mdf@patterns; \nimage(mdf)\n\n# 3. get description of the \"family\", \"imputation_method\", \"size\", \"transformation\", \"type\", \"link\", or \"model\" of each incomplete variable\n# show(mdf)\n\n# 4. change things: mi::change() method changes the family, imputation method,\n# size, type, and so forth of a missing variable. It's called \n# before calling mi to affect how the conditional expectation of each \n# missing variable is modeled.\n\nmdf <- change(mdf, y = \"spikes.hr\", what = \"transformation\", to = \"identity\")\n# The \"to\" choices include \"identity\" = no transformation, \"standardize\" = standardization, \"log\" = natural logarithm transformation, \"logshift\" = log(y + a) transformation, where a is a small constant, or \"sqrt\" = square-root variable transformation. Changing the transformation will correspondingly change the inverse transformation.",
      "line_count": 23
    },
    {
      "section": "Data Handling",
      "code": "# 5. examine missingness patterns\nsummary(mdf); hist(mdf); \nimage(mdf)\n\n# 6. Perform initial imputation\nimputations1 <- mi(mdf, n.iter=10, n.chains=5, verbose=TRUE)\nhist(imputations1)\n\n# 7. Extracts several multiply imputed data.frames from \"imputations\" object\ndata.frames1 <- complete(imputations1, 5)\n\n# 8. Report a list of \"summaries\" for each element (imputation instance)\nmySummary1 <- lapply(data.frames1, summary)\n\ndatatable(data.frame(t(as.matrix(unclass(mySummary1$`chain:1`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:1)'),\n    extensions = 'Buttons', options = list(dom = 'Bfrtip',\n    buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))\n\ndatatable(data.frame(t(as.matrix(unclass(mySummary1$`chain:5`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:5)'),\n    extensions = 'Buttons', options = list(dom = 'Bfrtip',\n    buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))\n\n# 8.a. To cast the imputed numbers as integers (not necessary, but may be useful)\nindx <- sapply(data.frames1[[5]], is.numeric)  # get the indices of numeric columns\ndata.frames1[[5]][indx] <- lapply(data.frames1[[5]][indx], function(x) as.numeric(as.integer(x))) \t\t    # cast each value as integer\n# data.frames[[5]]$spikes.hr\n\n# 9. Save results out\nwrite.csv(data.frames1[[5]], \"C:\\\\Users\\\\Dinov\\\\Desktop\\\\TBI_MIData.csv\")\n\n# 10. Complete Data analytics functions:\n# library(\"mi\")\n#lm.mi(); glm.mi(); polr.mi(); bayesglm.mi(); bayespolr.mi(); lmer.mi(); glmer.mi()\n\n# 10.1 Define Linear Regression for multiply imputed dataset - Also see Step (12)\n##linear regression for each imputed data set - 5 regression models are fit\nfit_lm1 <- glm(ever.sz ~ surgery + worst.gcs + factor(sex) + age, data.frames1$`chain:1`, family = \"binomial\"); summary(fit_lm1); display(fit_lm1)\n\n# Fit the appropriate model and pool the results (estimates over MI chains)\nmodel_results <- pool(ever.sz ~ surgery + worst.gcs + factor(sex) + age, family = \"binomial\", data=imputations1,  m=5)\ndisplay (model_results); summary (model_results)  \n\n# Report the summaries of the imputations\ndata.frames <- complete(imputations1, 3)  \t# extract the first 3 chains\nmySummary2 <-lapply(data.frames1, summary)\n\ndatatable(data.frame(t(as.matrix(unclass(mySummary2$`chain:1`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:1)'))\n\n# 11. Validation: we now verify whether enough iterations were conducted. \n# Validation criteria demands that the mean of each completed variable should\n# be similar for each of the k chains (in this case k=5).\n# mipply is wrapper for sapply invoked on mi-class objects to compute the col means\nround(mipply(imputations1, mean, to.matrix = TRUE), 3)\n\n# Rhat convergence statistics compares the variance between chains to the variance\n# within chains (similar to the ANOVA F-test). \n# Rhat Values ~ 1.0 indicate likely convergence, \n# Rhat Values > 1.1 indicate that the chains should be run longer \n# (use large number of iterations)\nRhats(imputations1, statistic = \"moments\") # assess the convergence of MI algorithm\n\n# When convergence is unstable, we can continue the iterations for all chains, e.g.\nimputations1 <- mi(imputations1, n.iter=20) # add additional 20 iterations\n\n# To plot the produced mi results, for all missing_variables we can generate\n# a histogram of the observed, imputed, and completed data.\n# We can compare of the completed data to the fitted values implied by the model\n# for the completed data, by plotting binned residuals. \n# hist function works similarly as plot. \n# image function gives a sense of the missingness patterns in the data\nplot(imputations1); hist(imputations1); image(imputations1)\nmySummary3 <-lapply(data.frames1, summary)\n\ndatatable(data.frame(t(as.matrix(unclass(mySummary3$`chain:1`))), check.names = FALSE, stringsAsFactors = FALSE), caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Imputed data: summary(chain:1)'))\n\n\n# 12. Finally, pool over the m = 5 imputed datasets when we fit the \"model\"\n# Pool from across the 4 chains - in order to estimate a linear regression model\n# and impact of various predictors\n\nmodel_results <- pool(ever.sz ~ surgery + worst.gcs + factor(sex) + age, data =  imputations1,  m =  5 ); display (model_results); summary (model_results)\ncoef(summary(model_results))[, 1:2]  # get the model coefficients and their SE's  ",
      "line_count": 90
    },
    {
      "section": "Data Handling",
      "code": "# install.packages(c(\"gridExtra\", \"MASS\"))\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(MASS)\nlibrary(knitr)",
      "line_count": 5
    },
    {
      "section": "Data Handling",
      "code": "# simulate 20 (feature) vectors  of 200 (cases) Normal Distributed random values (\\mu, \\Sigma)\n# You can choose multiple distribution for testing\n# sim_data <- replicate(20, rpois(50, 10))\nset.seed(202227)\nmu <- as.matrix(rep(2,20) )\nsig <- diag(c(1:20) )\n# Add a noise item. The noise is $ \\epsilon ~ MVN(as.matrix(rep(0,20)), diag(rep(1,20)))$\nsim_data <- mvrnorm(n = 200, mu, sig) + \n  mvrnorm(n=200, as.matrix(rep(0,20)), diag( rep(1,20) ))\n\n# save these in the \"original\" object\nsim_data.orig <- sim_data\n\n# install.packages(\"e1071\")\n\n# introduce 500 random missing indices (in the total of 4000=200*20)\n# discrete distribution where the probability of the elements of values is proportional to probs,\n# which are normalized to add up to 1.\nrand.miss <- e1071::rdiscrete(500, probs = rep(1,length(sim_data)), values = seq(1, length(sim_data)))\nsim_data[rand.miss] <- NA\nsum(is.na(sim_data))  # check now many missing (NA) are there < 500\n\n# cast the data into a data.frame object and report 15*10 elements\nsim_data.df <- data.frame(sim_data)\n# kable( sim_data.df[1:15, 1:10], caption = \"The first 15 rows and first 10 columns of the simulation data\")\n\ndf_mdf <- sim_data.df %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_mdf, caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: Simulated Data (sim_data.df)'),\n    extensions = 'Buttons', options = list(dom = 'Bfrtip',\n    buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))\n\n# datatable(sim_data.df, caption = htmltools::tags$caption(\n#      style = 'caption-side: bottom; text-align: center;', \n#      'Table: Simulated Data (sim_data.df)'),\n#     extensions = 'Buttons', options = list(dom = 'Bfrtip',\n#     buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))\n\n# Define the EM imputation method\nEM_algorithm <- function(x, tol = 0.001) {\n  # identify the missing data entries (Boolean indices)\n  missvals <- is.na(x)\n  # instantiate the EM-iteration\n  new.impute <- x\n  old.impute <- x\n  count.iter <- 1\n  reach.tol <- 0\n  \n  # compute \\Sigma on complete data\n  sigma <- as.matrix(var(na.exclude(x)))\n  # compute the vector of feature (column) means\n  mean.vec <- as.matrix(apply(na.exclude(x), 2, mean))\n  \n  while (reach.tol != 1) {\n    for (i in 1:nrow(x)) {\n      pick.miss <- (c(missvals[i, ]))\n      if (sum(pick.miss) != 0) {\n        \n        # compute inverse-Sigma_completeData, variance-covariance matrix\n        inv.S <- solve(sigma[!pick.miss, !pick.miss], tol = 1e-40) \n        \n        # Expectation Step\n        # $$E(Y|X)=\\mu_{mis}+\\Sigma_{mo}\\Sigma_{oo}^{-1}(X-\\mu_{obs})$$\n        new.impute[i, pick.miss] <- mean.vec[pick.miss] +\n          sigma[pick.miss,!pick.miss] %*% inv.S %*%\n          (t(new.impute[i, !pick.miss]) - t(t(mean.vec[!pick.miss])))\n      }\n    }\n    \n    # Maximization Step\n    # Recompute the complete \\Sigma the complete vector of feature (column) means\n    \n    #$$\\Sigma^{(t+1)} = \\frac{1}{n}\\sum_{i=1}^nE(ZZ^T|X) - \\mu^{(t+1)}{\\mu^{(t+1)}}^T$$\n    sigma <- var((new.impute))\n    #$$\\mu^{(t+1)} = \\frac{1}{n}\\sum_{i=1}^nE(Z|X)$$\n    mean.vec <- as.matrix(apply(new.impute, 2, mean))\n    \n    # Inspect for convergence tolerance, start with the 2nd iteration\n    if (count.iter > 1) {\n      for (l in 1:nrow(new.impute)) {\n        for (m in 1:ncol(new.impute)) {\n          if (abs((old.impute[l, m] - new.impute[l, m])) > tol) {\n            reach.tol <- 0\n          } else {\n            reach.tol <- 1\n          }\n        }\n      }\n    }\n    count.iter <- count.iter + 1 \n    old.impute <- new.impute\n  }\n  \n  # return the imputation output of the current iteration that passed the tolerance level\n  return(new.impute)\n} \n\nsim_data.imputed <- EM_algorithm(sim_data.df, tol=0.0001)\ndf_mdf <- sim_data.imputed %>%  mutate_if(is.numeric, round, digits = 2)\ndatatable(df_mdf, caption = htmltools::tags$caption(\n     style = 'caption-side: bottom; text-align: center;', \n     'Table: EM-Imputed Simulated Data'),\n    extensions = 'Buttons', options = list(dom = 'Bfrtip',\n    buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))",
      "line_count": 105
    },
    {
      "section": "Data Handling",
      "code": "plot.me <- function(index1, index2){\n  plot.imputed <- sim_data.imputed[row.names(\n    subset(sim_data.df, is.na(sim_data.df[, index1]) | is.na(sim_data.df[, index2]))), ]\n  p = ggplot(sim_data.imputed, aes_string( paste0(\"X\",index1)  , paste0(\"X\",index2 ))) + \n  geom_point(alpha = 0.5, size = 0.7)+theme_bw() +\n  stat_ellipse(type = \"norm\", color = \"#000099\", alpha=0.5) +\n  geom_point(data = plot.imputed, aes_string( paste0(\"X\",index1) , paste0(\"X\",(index2))),size = 1.5, color = \"Magenta\", alpha = 0.8)\n} \n\ngridExtra::grid.arrange( plot.me(1,2), plot.me(5,6), plot.me(13,20), plot.me(18,19), nrow = 2)\n\nindex1=1; index2=5\nplot.imputed <- sim_data.imputed[row.names(\n    subset(sim_data.df, is.na(sim_data.df[, index1]) | is.na(sim_data.df[, index2]))), ]\n  p = ggplot(sim_data.imputed, aes_string( paste0(\"X\",index1)  , paste0(\"X\",index2 ))) + \n  geom_point(alpha = 0.5, size = 0.7)+theme_bw() +\n  stat_ellipse(type = \"norm\", color = \"#000099\", alpha=0.5) +\n  geom_point(data = plot.imputed, aes_string( paste0(\"X\",index1) , paste0(\"X\",(index2))),size = 1.5, color = \"Magenta\", alpha = 0.8)\n  \nplot_ly(sim_data.imputed, x = ~X1, y = ~X5, type = \"scatter\", \n        mode = \"markers\") %>% \n    layout(title='Scatterplot: Improved Water Quality vs. Sanitation Facilities', \n           xaxis = list (title = 'Water Quality'), yaxis = list (title = 'Sanitation'))\n  ",
      "line_count": 24
    },
    {
      "section": "Data Handling",
      "code": "# knitr::include_graphics(\"ammelia.png\")",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "# install.packages(\"Amelia\")\nlibrary(Amelia)\ndim(sim_data.df)\namelia.out <- amelia(sim_data.df, m = 5)\namelia.out\namelia.imputed.5 <- amelia.out$imputations[[5]]",
      "line_count": 6
    },
    {
      "section": "Data Handling",
      "code": "plot.ii2 <- function(index, index2){\n  plot.imputed <- sim_data.imputed[row.names(\n    subset(sim_data.df, is.na(sim_data.df[, index]) | is.na(sim_data.df[, index2]))), ]\n  plot.imputed2 <- amelia.imputed.5[row.names(\n  subset(sim_data.df, is.na(sim_data.df[, index]) | is.na(sim_data.df[, index2]))), ]\n  p = ggplot(sim_data.imputed, aes_string( paste0(\"X\",index)  , paste0(\"X\",index2 ))) + \n  geom_point(alpha = 0.8, size = 0.7)+theme_bw() +\n  stat_ellipse(type = \"norm\", color = \"#000099\", alpha=0.5) +\n  geom_point(data = plot.imputed, aes_string( paste0(\"X\",index) , paste0(\"X\",(index2))),size = 2.5, color = \"Magenta\", alpha = 0.9, shape = 16) +  \n    geom_point(data = plot.imputed2, aes( X1 , X2),size = 2.5, color = \"#FF9933\", alpha = 0.8, shape = 18)\n  return(p)\n} \n\nplot.ii2(2, 4)\nplot.ii2(17, 18)",
      "line_count": 15
    },
    {
      "section": "Data Handling",
      "code": "# plot.ii3 <- function(index){\n#   imputed <- sim_data.imputed[is.na(sim_data.df[, index]) , index]\n#   imputed.amelia <- amelia.imputed.5[is.na(sim_data.df[, index]) , index]\n#   observed <- sim_data.df[!is.na(sim_data.df[, index]) , index]\n#   imputed.df <- data.frame(x = c(observed,imputed,imputed.amelia), category = c( rep(\"obs\",length(observed)),rep(\"simpleImplement\",length(imputed)) ,rep(\"amelia\",length(imputed.amelia))   ) )\n#   p = ggplot(imputed.df, aes(x=x, y =..density..)) + \n#     geom_density(aes(fill = category),alpha=0.3)+\n#     theme_bw()\n#   return(p)\n#   }\n# grid.arrange( plot.ii3(1),plot.ii3(2),plot.ii3(3),plot.ii3(4),plot.ii3(5),\n#               plot.ii3(6),plot.ii3(7),plot.ii3(8),plot.ii3(9),plot.ii3(10),\n#               nrow = 5)\n\nlibrary(tidyr)\n\nmyPlotly <- function(index){\n  imputed <- sim_data.imputed[is.na(sim_data.df[, index]) , index]\n  imputed.amelia <- amelia.imputed.5[is.na(sim_data.df[, index]) , index]\n  observed <- sim_data.df[!is.na(sim_data.df[, index]) , index]\n  imputed.df <- data.frame(x = c(observed,imputed,imputed.amelia), \n              category = c( rep(\"obs\",length(observed)),rep(\"simpleImplement\",length(imputed)),\n                            rep(\"amelia\",length(imputed.amelia))   ) )\n  df_long <- as.data.frame(cbind(index=c(1:length(imputed.df$x)), \n                                 category=imputed.df$category, x=imputed.df$x))\n  df_wide <- spread(df_long, category, x)\n  \n  p = plot_ly() %>%\n    add_lines(x = ~density(as.numeric(df_wide$simpleImplement), na.rm = T)$x, \n        y= ~density(as.numeric(df_wide$simpleImplement), na.rm = T)$y, name = \"EM\", mode = 'lines') %>%\n    add_lines(x = density(as.numeric(df_wide$amelia), na.rm = T)$x, \n        y= density(as.numeric(df_wide$amelia), na.rm = T)$y, name = \"Amelia\", mode = 'lines') %>%\n    add_lines(x = ~density(as.numeric(df_wide$obs), na.rm = T)$x, \n        y= ~density(as.numeric(df_wide$obs), na.rm = T)$y, name = \"Observed\", mode = 'lines') %>%\n    layout(title=sprintf(\"Distributions: Feature X.%d\", index),\n           xaxis = list(title = 'Measurements'),\n           yaxis = list(title =\"Densities\"),\n           legend = list(title=\"Distributions\", orientation = 'h'))\n  return(p)\n}\n\n# Plot a few features\nmyPlotly(5)\nmyPlotly(9)\nmyPlotly(10)\n# grid.arrange( myPlotly(1),myPlotly(2),myPlotly(3),myPlotly(4),myPlotly(5),\n#               myPlotly(6),myPlotly(7),myPlotly(8),myPlotly(9),myPlotly(10),\n#               nrow = 5)\n",
      "line_count": 49
    },
    {
      "section": "Data Handling",
      "code": "# install.packages(\"xml2\")\nlibrary(\"XML\"); library(\"xml2\")\nlibrary(\"rvest\")\nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SOCR_Data_Dinov_021708_Earthquakes\")\nhtml_nodes(wiki_url, \"#content\")\nearthquake<- html_table(html_nodes(wiki_url, \"table\")[[2]])",
      "line_count": 6
    },
    {
      "section": "Data Handling",
      "code": "# library(ggplot2)\n# plot4<-ggplot(earthquake, aes(Longitude, Latitude, group=Magt, color=Magt))+ \n#   geom_point(data=earthquake, size=4, mapping=aes(x=Longitude, y=Latitude, shape=Magt))\n# plot4  # or plint(plot4)\n# https://plotly-r.com/working-with-symbols.html \n\nglyphication <- function (name) {\n  glyph= vector()\n  for (i in 1:length(name)){\n    glyph[i]=\"triangle-up\"\n    if (name[i]==\"Md\") { glyph[i]=\"diamond-open\" }\n    else if (name[i]==\"ML\") { glyph[i]=\"circle-open\" }\n    else if (name[i]==\"Mw\") { glyph[i]=\"square-open\" }\n    else if (name[i]==\"Mx\") { glyph[i]=\"x-open\" }\n  }\n  return(glyph)\n}\nearthquake$glyph <- glyphication(earthquake$Magt)\n  \nplot_ly(earthquake) %>%\n  add_markers(x = ~Longitude, y = ~Latitude, type = \"scatter\",  color = ~Magt,\n        mode = \"markers\", marker = list(size = ~Depth, color = ~Magt, symbol = ~glyph,\n                                        line = list(color = \"black\",width = 2))) %>% \n    layout(title=\"California Earthquakes (1969 - 2007)\")",
      "line_count": 24
    },
    {
      "section": "Data Handling",
      "code": "plot5 <- ggplot(earthquake, aes(Latitude, size=1))+geom_density(aes(color=Magt))\nplot5",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "kernal_density <- with(earthquake, MASS::kde2d(Longitude, Latitude, n = 50))",
      "line_count": 1
    },
    {
      "section": "Data Handling",
      "code": "library(plotly)\nwith(kernal_density, plot_ly(x=x, y=y, z=z, type=\"surface\"))",
      "line_count": 2
    },
    {
      "section": "Data Handling",
      "code": "plot_ly(x = ~ earthquake$Longitude)\nplot_ly(x = ~ earthquake$Longitude, y = ~earthquake$Latitude)\nplot_ly(x = ~ earthquake$Longitude, y = ~earthquake$Latitude, z=~earthquake$Mag)\n\ndf3D <- data.frame(x=earthquake$Longitude, y=earthquake$Latitude, z=earthquake$Mag)\n\n# Convert he Long (X, Y, Z) Earthquake format data into a Matrix Format\n\n#  install.packages(\"Matrix\")\nlibrary(\"Matrix\")\nmatrix_EarthQuakes <- with(df3D, sparseMatrix(i = as.numeric(180-x), j=as.numeric(y), x=z, use.last.ij=T, dimnames=list(levels(x), levels(y))))\ndim(matrix_EarthQuakes)\n\n# colnames(matrix_EarthQuakes) <- seq(from=earthquake$Longitude[1],\n#                                     to=earthquake$Longitude[length(earthquake$Longitude)],\n#                                                              length.out=dim(matrix_EarthQuakes)[2])\n# rownames(matrix_EarthQuakes) <- seq(from=earthquake$Latitude[1],\n#                                     to=earthquake$Latitude[length(earthquake$Latitude)],\n#                                                              length.out=dim(matrix_EarthQuakes)[1])\n# View(as.matrix(matrix_EarthQuakes))\n\n# view matrix is 2D heatmap: \nlibrary(\"ggplot2\"); library(\"gplots\")\n\n# heatmap.2( as.matrix(matrix_EarthQuakes[280:307, 30:44]), Rowv=FALSE, Colv=FALSE, dendrogram='none', cellnote=as.matrix(matrix_EarthQuakes[280:307, 30:44]), notecol=\"black\", trace='none', key=FALSE, lwid = c(.01, .99), lhei = c(.01, .99), margins = c(5, 15 ))\n\nplot_ly(z = ~as.matrix(matrix_EarthQuakes[280:307, 30:44]), type = \"heatmap\") %>% hide_colorbar()\n\n# plot_ly(x=~colnames(matrix_EarthQuakes[280:307, 30:44]), \n#         y=~rownames(matrix_EarthQuakes[280:307, 30:44]),\n#         z = ~as.matrix(matrix_EarthQuakes[280:307, 30:44]), type = \"heatmap\") %>%\n#   layout(title=\"California Earthquakes Heatmap\", \n#          xaxis=list(title=\"Longitude\"), yaxis=list(title=\"Latitude\")) %>% \n#   hide_colorbar()\n\n# Long -180<x<-170, Lat: 30<y<45, Z: 5<Mag<8\nmatrix_EarthQuakes <- with(df3D, sparseMatrix(i = as.numeric(180+x), j=as.numeric(y), x=z, use.last.ij=TRUE, dimnames=list(levels(x), levels(y))))\nmat1 <- as.matrix(matrix_EarthQuakes)\nplot_ly(z = ~mat1, type = \"surface\")\n\n# To plot the Aggregate (Summed) Magnitudes at all Long/Lat:\nmatrix_EarthQuakes <- with(df3D, sparseMatrix(i = as.numeric(180+x), j=as.numeric(y), x=z, dimnames=list(levels(x), levels(y))))\nmat1 <- as.matrix(matrix_EarthQuakes)\nplot_ly(z = ~mat1, type = \"surface\")\n# plot_ly(z = ~mat1[30:60, 20:40], type = \"surface\")",
      "line_count": 45
    },
    {
      "section": "Data Handling",
      "code": "# update packages\n# update.packages()\n\n# load the data: 06_PPMI_ClassificationValidationData_Short.csv\nppmi_data <-read.csv(\"https://umich.instructure.com/files/330400/download?download_frd=1\", header=TRUE)\n\ntable(ppmi_data$ResearchGroup)\n\n# binarize the Dx classes\nppmi_data$ResearchGroup <- ifelse(ppmi_data$ResearchGroup == \"Control\", \"Control\", \"Patient\")\nattach(ppmi_data)\n\nhead(ppmi_data)\n\n# Model-free analysis, classification\n# install.packages(\"crossval\")\n# install.packages(\"ada\")\n# library(\"crossval\")\nlibrary(crossval)\nlibrary(ada)\n#set up adaboosting prediction function\n\n\n# Define a new classification result-reporting function\nmy.ada <- function (train.x, train.y, test.x, test.y, negative, formula){\n  ada.fit <- ada(train.x, train.y)\n  predict.y <- predict(ada.fit, test.x)\n  #count TP, FP, TN, FN, Accuracy, etc.\n  out <- confusionMatrix(test.y, predict.y, negative = negative)\n # negative\t is the label of a negative \"null\" sample (default: \"control\").\n  return (out)\n}\n\n# balance cases\n# SMOTE: Synthetic Minority Oversampling Technique to handle class imbalance in binary classification.\nset.seed(1000)\n# https://cran.r-project.org/src/contrib/Archive/unbalanced/\n# install.packages('mlr', 'FNN', 'RANN', 'unbalanced') to deal with unbalanced group data\nlibrary(unbalanced)\nppmi_data$PD <- ifelse(ppmi_data$ResearchGroup==\"Control\", 1, 0) \nuniqueID <- unique(ppmi_data$FID_IID) \nppmi_data <- ppmi_data[ppmi_data$VisitID==1, ]\nppmi_data$PD <- factor(ppmi_data$PD)\n\ncolnames(ppmi_data)\n# ppmi_data.1<-ppmi_data[, c(3:281, 284, 287, 336:340, 341)]\nn <- ncol(ppmi_data)\noutput.1 <- ppmi_data$PD\n\n# remove Default Real Clinical subject classifications! \nppmi_data$PD <- ifelse(ppmi_data$ResearchGroup==\"Control\", 1, 0) \ninput <- ppmi_data[ , -which(names(ppmi_data) %in% c(\"ResearchGroup\", \"PD\", \"X\", \"FID_IID\"))]\n# output <- as.matrix(ppmi_data[ , which(names(ppmi_data) %in% {\"PD\"})])\noutput <- as.factor(ppmi_data$PD)\nc(dim(input), length(output))\n\n#balance the dataset\ndata.1<-ubBalance(X= input, Y=output, type=\"ubSMOTE\", percOver=300, percUnder=150, verbose=TRUE)\n# percOver = A number that drives the decision of how many extra cases from the minority class are generated (known as over-sampling).\n# k = A number indicating the number of nearest neighbors that are used to generate the new examples of the minority class.\n# percUnder = A number that drives the decision of how many extra cases from the majority classes are selected for each case generated from the minority class (known as under-sampling)  \n\nbalancedData<-cbind(data.1$X, data.1$Y)\ntable(data.1$Y)\n\nnrow(data.1$X); ncol(data.1$X)\nnrow(balancedData); ncol(balancedData)\nnrow(input); ncol(input)\n\ncolnames(balancedData) <- c(colnames(input), \"PD\")\n\n# check visually for differences between the distributions of the raw (input) and rebalanced data (for only one variable, in this case)\nQQ <- qqplot(input[, 5], balancedData [, 5], plot.it=F)\n\nplot_ly(x=~QQ$x, y = ~QQ$y, type=\"scatter\", mode=\"markers\", showlegend=F) %>%\n  add_lines(x=c(0,0.8), y=c(0,0.8), showlegend=F) %>%\n  layout(title=\"QQ-Plot Original vs. Rebalanced Data\", xaxis=list(title=\"original data\"),\n         yaxis=list(title=\"Rebalanced data\"))\n\n###Check balance\n## Wilcoxon test\nalpha.0.05 <- 0.05\ntest.results.bin <- NULL\t\t# binarized/dichotomized p-values\ntest.results.raw <- NULL\t\t# raw p-values\n\nfor (i in 1:(ncol(balancedData)-1)) {\n\ttest.results.raw [i]  <- wilcox.test(input[, i], balancedData [, i])$p.value\n  \ttest.results.bin [i] <- ifelse(test.results.raw [i] > alpha.0.05, 1, 0)\n\tprint(c(\"i=\", i, \"Wilcoxon-test=\", test.results.raw [i]))\n}\nprint(c(\"Wilcoxon test results: \", test.results.bin))\n\ntest.results.corr <- stats::p.adjust(test.results.raw, method = \"fdr\", n = length(test.results.raw)) \n# where methods are \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"BY\", \"fdr\", \"none\")\n# plot(test.results.raw, test.results.corr)\n# zeros (0) are significant independent between-group T-test differences, ones (1) are insignificant\n\nplot_ly(x=~test.results.raw, y = ~test.results.corr, type=\"scatter\", mode=\"markers\", showlegend=F) %>%\n  add_lines(x=c(0,1), y=c(0,1), showlegend=F) %>%\n  layout(title=\"Wilcoxon test results - Original vs. Rebalanced Data\", xaxis=list(title=\"Original\"),\n         yaxis=list(title=\"Rebalanced\"))\n\n# Check the Differences between the rate of significance between the raw and FDR-corrected p-values\ntest.results.bin <- ifelse(test.results.raw > alpha.0.05, 1, 0)\ntable(test.results.bin)\ntest.results.corr.bin <- ifelse(test.results.corr > alpha.0.05, 1, 0)\ntable(test.results.corr.bin)",
      "line_count": 107
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# Here `freq=T` shows the frequency for each *x* value and `breaks` controls for the number of bars in our histogram.\n# mu <- 15; sd <- 3.7\n# set.seed(1234)\n# x<-rnorm(100, mean = mu, sd=sd)\n# hist(x, freq=F, breaks = 10)\n# lines(density(x), lwd=2, col=\"blue\") \n# t <- seq(mu-3*sd, mu+3*sd, by=0.01)\n# lines(t, dnorm(t,mu,sd), col=\"magenta\") # add the theoretical density line\n\nlibrary(plotly)\n\nN <- 10000\nmu <- 15; sd <- 3.7\nset.seed(1234)\nx <- rnorm(N, mean = mu, sd=sd)\nfit <- density(x)\nz<-seq(mu-4*sd, mu+4*sd, 0.1)  # points from -4 to 4 in 0.1 steps\nq<-seq(0.001, 0.999, 0.001)  # probability quantile values from 0.1% to 99.9% in 0.1% steps\n\nnormDensity <- dnorm(z, mean=15, sd= 3.7)\n\nplot_ly(x = x, type = \"histogram\", name = \"Data Histogram\", histnorm = \"probability\") %>% \n    add_trace(x = fit$x, y = fit$y, type = \"scatter\", mode = \"lines\", opacity=0.1,\n              fill = \"tozeroy\", yaxis = \"y2\", name = \"Density (rnorm(100, 15, 3.7))\") %>% \n    add_trace(x = z, y = normDensity, type = \"scatter\", mode = \"lines\", opacity=0.1,\n              fill = \"tozeroy\", yaxis = \"y2\", name = \"Normal(15, 3.7)\") %>% \n    layout(title='Data Histogram, Density Estimate & Theoretical Model Distribution', \n           yaxis2 = list(overlaying = \"y\", side = \"right\"),\n           legend = list(orientation = 'h'))",
      "line_count": 29
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# hist(x, freq=F, breaks = 10)\n# lines(density(x), lwd=2, col=\"blue\")\n# Here we used the option `freq=F` to make the *y* axis represent the \"relative frequency\", or \"density\". We can also use `plot(density(x))` to draw the density plot by itself.\n# plot(density(x))",
      "line_count": 4
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "library(rvest)\nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SOCR_LetterFrequencyData\")\nhtml_nodes(wiki_url, \"#content\")\nletter<- html_table(html_nodes(wiki_url, \"table\")[[1]])\nsummary(letter)",
      "line_count": 5
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# The left hand side plot is the one without reference table and the right one has the table made by function `legend`.\n# par(mfrow=c(1, 2))\n# pie(letter$English[1:10], labels=letter$Letter[1:10], col=rainbow(10, start=0.1, end=0.8), clockwise=TRUE, main=\"First 10 Letters Pie Chart\")\n# pie(letter$English[1:10], labels=letter$Letter[1:10], col=rainbow(10, start=0.1, end=0.8), clockwise=TRUE, main=\"First 10 Letters Pie Chart\")\n# legend(\"topleft\", legend=letter$Letter[1:10], cex=1.3, bty=\"n\", pch=15, pt.cex=1.8, col=rainbow(10, start=0.1, end=0.8), ncol=1)\n\nplot_ly(letter, labels = ~Letter, values = ~English, type = 'pie', name=\"English\",\n        textposition = 'inside', textinfo = 'label+percent', showlegend = FALSE,\n        domain = list(row = 0, column = 0)) %>% \n  add_pie(labels = ~Letter, values = ~Spanish,  name = \"Spanish\", \n        textposition = 'inside', textinfo = 'label+percent', showlegend = FALSE,\n        domain = list(row = 0, column = 1)) %>% \n  add_pie(labels = ~Letter, values = ~Swedish,  name = \"Swedish\", \n        textposition = 'inside', textinfo = 'label+percent', showlegend = FALSE,\n        domain = list(row = 1, column = 0)) %>% \n  add_pie(labels = ~Letter, values = ~Polish,  name = \"Polish\", \n        textposition = 'inside', textinfo = 'label+percent', showlegend = FALSE,\n        domain = list(row = 1, column = 1)) %>% \n  add_annotations(x=0.01,  y=0.99,text = \"English\",showarrow = F, ax = 20, ay = -40) %>% \n  add_annotations(x=0.58,  y=0.99,text = \"Spanish\",showarrow = F, ax = 20, ay = -40) %>% \n  add_annotations(x=0.01,  y=0.01,text = \"Swedish\",showarrow = F, ax = 20, ay = -40) %>% \n  add_annotations(x=0.58,  y=0.01,text = \"Polish\",showarrow = F, ax = 20, ay = -40) %>%\n  layout(title = 'Pie Charts of English, Spanish, Swedish & Polish Letters',\n         grid=list(rows=2, columns=2),\n         xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),\n         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))\n\nplot_ly(letter, labels = ~Letter, values = ~German, type = 'pie', name=\"German\",\n        textposition = 'inside', textinfo = 'label+percent', showlegend = FALSE,\n        domain = list(row = 0, column = 0), hole = 0.5) %>% \n  add_pie(labels = ~Letter, values = ~Italian,  name = \"Italian\", \n        textposition = 'inside', textinfo = 'label+percent', showlegend = FALSE,\n        domain = list(row = 0, column = 1)) %>% \n  add_pie(labels = ~Letter, values = ~Dutch,  name = \"Dutch\", \n        textposition = 'inside', textinfo = 'label+percent', showlegend = FALSE,\n        domain = list(row = 1, column = 0)) %>% \n  add_pie(labels = ~Letter, values = ~Esperanto,  name = \"Esperanto\", \n        textposition = 'inside', textinfo = 'label+percent', showlegend = FALSE,\n        domain = list(row = 1, column = 1)) %>% \n  add_annotations(x=0.2,  y=0.78,text = \"German\",showarrow = F, ax = 20, ay = -40) %>% \n  add_annotations(x=0.8,  y=0.78,text = \"Italian\",showarrow = F, ax = 20, ay = -40) %>% \n  add_annotations(x=0.2,  y=0.21,text = \"Dutch\",showarrow = F, ax = 20, ay = -40) %>% \n  add_annotations(x=0.82,  y=0.21,text = \"Esperanto\",showarrow = F, ax = 20, ay = -40) %>%\n  layout(title = 'Pie Charts of German, Italian, Dutch & Esperanto Letters',\n         grid=list(rows=2, columns=2),\n         xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),\n         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))",
      "line_count": 47
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "AD_Data <- read.table(\"https://umich.instructure.com/files/330387/download?download_frd=1\", header=TRUE, row.names=1,  sep=\",\", dec=\".\")\t \nMCI_Data <- read.table(\"https://umich.instructure.com/files/330390/download?download_frd=1\", header=TRUE, row.names=1,  sep=\",\", dec=\".\")\t \t \nNC_Data <- read.table(\"https://umich.instructure.com/files/330391/download?download_frd=1\", header=TRUE, row.names=1,  sep=\",\", dec=\".\")\t \t ",
      "line_count": 3
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "library(graphics)\nlibrary(grDevices)\nlibrary(gplots)",
      "line_count": 3
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "AD_mat  <- as.matrix(AD_Data); class(AD_mat) <- \"numeric\"\nMCI_mat  <- as.matrix(MCI_Data); class(MCI_mat) <- \"numeric\"\nNC_mat  <- as.matrix(NC_Data); class(NC_mat) <- \"numeric\"",
      "line_count": 3
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "rcAD <- rainbow(nrow(AD_mat), start = 0, end = 1.0); ccAD<-rainbow(ncol(AD_mat), start = 0, end = 1.0)\nrcMCI <- rainbow(nrow(MCI_mat), start = 0, end=1.0); ccMCI<-rainbow(ncol(MCI_mat), start=0, end=1.0)\nrcNC <- rainbow(nrow(NC_mat), start = 0, end = 1.0); ccNC<-rainbow(ncol(NC_mat), start = 0, end = 1.0)",
      "line_count": 3
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# hvAD <- heatmap(AD_mat, col = cm.colors(256), scale = \"column\", RowSideColors = rcAD, ColSideColors = ccAD, margins = c(2, 2), main=\"AD Cohort\")\n# hvMCI <- heatmap(MCI_mat, col = cm.colors(256), scale = \"column\", RowSideColors = rcMCI, ColSideColors = ccMCI, margins = c(2, 2), main=\"MCI Cohort\")\n# hvNC <- heatmap(NC_mat, col = cm.colors(256), scale = \"column\", RowSideColors = rcNC, ColSideColors = ccNC, margins = c(2, 2), main=\"NC Cohort\")\n\n# if (!require(\"devtools\")) install.packages(\"devtools\")\n# devtools::install_github(\"talgalili/d3heatmap\")\n\n# library(d3heatmap)\n# d3heatmap(AD_mat, dendrogram = 'both', key = TRUE, col = 'Blues', scale = 'column', key.title = \"Legend\",\n#           print.values = T, notecol = 'white') %>% \n#     hmAxis(\"x\", title = \"Imaging Phenotype\", location = 'bottom') %>% \n#     hmAxis(\"y\", title = \"Genotype\", location = 'left') %>% \n#     hmCells(font.size = 9, color = 'blue') %>% \n#     hmLegend(show = T, title = \"AD Cohort\", location = \"tl\")\n\nplot_ly(x =~colnames(AD_mat), y = ~rownames(AD_mat), z = ~AD_mat, type = \"heatmap\") %>%\n  layout(title=\"AD Neuroimaging-Genomic Associations (p-values)\", \n         xaxis=list(title=\"ROI Imaging Biomarkers\"), yaxis=list(title=\"SNPs\"))\n\n# d3heatmap(MCI_mat, dendrogram = 'both', key = TRUE, col = 'Blues', scale = 'column', key.title = \"Legend\",\n#           print.values = T, notecol = 'white') %>% \n#     hmAxis(\"x\", title = \"Imaging Phenotype\", location = 'bottom') %>% \n#     hmAxis(\"y\", title = \"Genotype\", location = 'left') %>% \n#     hmCells(font.size = 9, color = 'blue') %>% \n#     hmLegend(show = T, title = \"MCI Cohort\", location = \"tl\")\n\nplot_ly(x =~colnames(MCI_mat), y = ~rownames(MCI_mat), z = ~MCI_mat, type = \"heatmap\") %>%\n  layout(title=\"MCI Neuroimaging-Genomic Associations (p-values)\", \n         xaxis=list(title=\"ROI Imaging Biomarkers\"), yaxis=list(title=\"SNPs\"))\n\n# d3heatmap(NC_mat, dendrogram = 'both', key = TRUE, col = 'Blues', scale = 'column', key.title = \"Legend\",\n#           print.values = T, notecol = 'white') %>% \n#     hmAxis(\"x\", title = \"Imaging Phenotype\", location = 'bottom') %>% \n#     hmAxis(\"y\", title = \"Genotype\", location = 'left') %>% \n#     hmCells(font.size = 9, color = 'blue') %>% \n#     hmLegend(show = T, title = \"Normal Cohort\", location = \"tl\")\n\nplot_ly(x =~colnames(NC_mat), y = ~rownames(NC_mat), z = ~NC_mat, type = \"heatmap\") %>%\n  layout(title=\"(Normal) HC Neuroimaging-Genomic Associations (p-values)\", \n         xaxis=list(title=\"ROI Imaging Biomarkers\"), yaxis=list(title=\"SNPs\"))",
      "line_count": 40
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "N <- 50\nind <- c(1:N)\nx<-runif(N)\ny<-runif(N)\nz<-runif(N)\nhoverText <- paste0(\"Point \", ind, \": (\", round(x, 3), \",\", round(y, 3), \")\")\n# plot(x, y, main=\"Scatter Plot\")\nplot_ly(x=~x[1:20], y=~y[1:20], type=\"scatter\",  size=2, name=ind[1:20], \n        color=~z[1:20],  mode=\"markers\", text = hoverText[1:20]) %>% \n    layout(title=\"Random Scatterplot\", xaxis=list(title=\"X\"), yaxis=list(title=\"Y\")) %>%\n    hide_colorbar()\n\n# `qplot()` is another way to plot fancy scatter plots. We can manage the colors and sizes of dots. The input type for `qplot()` is a data frame. In the following example, larger *x* will have larger dot sizes. We also grouped the data as 10 points per group. \n# \n# library(ggplot2)\n# cat <- rep(c(\"A\", \"B\", \"C\", \"D\", \"E\"), 10)  \n# plot.1 <- qplot(x, y, geom=\"point\", size=5*x, color=cat, main=\"GGplot with Relative Dot Size and Color\")\n# print(plot.1)",
      "line_count": 18
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# The input type for `pairs()` function is a matrix or data frame.\n# pairs(data.frame(x, y, z))\n\nN=1000\nw<-rnorm(N)\nu<-rpois(N, lambda = 1.7)\n# generate some random categorical labels for all N observations\nclass <- sample( LETTERS[1:3], N, replace=TRUE, prob=c(0.2, 0.5, 0.3))\ndf <- as.data.frame(cbind(x=x,y=y,z=z,w=w,u=u, class=class))\n\npl_colorscale=list(c(0.0, '#19d3f3'), c(0.333, '#19d3f3'), c(0.333, '#e763fa'), c(0.666, '#e763fa'),\n                   c(0.666, '#636efa'), c(1, '#636efa'))\n\naxis = list(showline=FALSE, zeroline=FALSE, gridcolor='#ffff', ticklen=4)\n\nplot_ly(df) %>%\n    add_trace(type = 'splom', dimensions = list( list(label='X', values=~x), list(label='Y', values=~y),\n            list(label='Z', values=~z), list(label='w', values=~w), list(label='U', values=~u)),\n        text=~class,\n        marker = list(color = as.integer(df$class), colorscale = pl_colorscale,\n            size = 7, line = list(width = 1, color = 'rgb(230,230,230)')\n        )\n    ) %>%\n    layout(\n        title= 'Random Data Pairs Plot', hovermode='closest', dragmode= 'select',\n        plot_bgcolor='rgba(240,240,240, 0.95)',\n        xaxis=list(domain=NULL, showline=F, zeroline=F, gridcolor='#ffff', ticklen=4),\n        yaxis=list(domain=NULL, showline=F, zeroline=F, gridcolor='#ffff', ticklen=4),\n        xaxis2=axis, xaxis3=axis, xaxis4=axis,yaxis2=axis, yaxis3=axis, yaxis4=axis)",
      "line_count": 29
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "data1 <- read.table('https://umich.instructure.com/files/399128/download?download_frd=1', header=T)\t\nhead(data1)\nattach(data1)",
      "line_count": 3
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# plot(data1[, 9], data1[, 10], pch=20, col=\"red\", main=\"qual vs supp\")\n# pairs(data1[, 5:10])\n\nplot_ly(data1, x=~qual, y=~supp, type=\"scatter\",  size=2, name=STFIPS, \n        color=~num,  mode=\"markers\", text = STFIPS) %>% \n    layout(title=\"2010 National Mental Health Services Survey: Support Services vs. Quality Indicators Scatterplot\",\n           xaxis=list(title=\"Support Services\"), yaxis=list(title=\"Quality Indicators\")) %>%\n    hide_colorbar()\n\nplot_ly(data1) %>%\n    add_trace(type = 'splom', dimensions = list( list(label='FacilityType', values=~FacilityType ), \n            list(label='Ownership', values=~Ownership), list(label='Focus', values=~Focus), \n            list(label='PostTraum', values=~PostTraum), list(label='num', values=~num)),\n        text=~STFIPS,\n        marker = list(color = as.integer(qual), colorscale = pl_colorscale,\n            size = 7, line = list(width = 1, color = qual)\n        )\n    ) %>%\n    layout(\n        title= '2010 National Mental Health Services Survey Pairs Plot (color=qual)', hovermode='closest', dragmode= 'select',\n        plot_bgcolor='rgba(240,240,240, 0.95)',\n        xaxis=list(domain=NULL, showline=F, zeroline=F, gridcolor='#ffff', ticklen=4),\n        yaxis=list(domain=NULL, showline=F, zeroline=F, gridcolor='#ffff', ticklen=4),\n        xaxis2=axis, xaxis3=axis, xaxis4=axis,yaxis2=axis, yaxis3=axis, yaxis4=axis)",
      "line_count": 24
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# plot.2 <- qplot(qual, supp, data = data1, geom = c(\"point\", \"smooth\"))\n# print(plot.2)\n\n# extract only the complete cases\nlibrary(dplyr)\ndf1 <- data1 %>% filter_at(vars(qual,supp), all_vars(!is.na(.)))\n\nll.smooth = loess(df1$supp ~ df1$qual, span=0.7)\nll.pred = predict(ll.smooth, se = TRUE)\nll.df = data.frame(x=ll.smooth$x, fit=ll.pred$fit, lb=ll.pred$fit-(1.96*ll.pred$se),\n                   ub=ll.pred$fit+(1.96*ll.pred$se))\nll.df = ll.df[order(ll.df$df1.qual),]\n\nplot_ly(x=df1$qual, y=df1$supp, type=\"scatter\", mode=\"markers\", name=\"Data\") %>%\n  add_lines(x=df1$qual, y=ll.pred$fit, name=\"Mean\", line=list(color=\"gray\", width=4)) %>%\n  add_ribbons(x=ll.df$df1.qual, ymin=ll.df$lb, ymax=ll.df$ub, name=\"95% CI\", \n              line=list(opacity=0.4, width=1, color=\"lightgray\")) %>%\n  layout(title = \"LOESS Model (Supp ~ Qual) with Confidence Band\",\n         xaxis=list(title=\"Quality Indicator\"), yaxis=list(title=\"Supporting Services\"))",
      "line_count": 19
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# library(\"xml2\"); library(\"rvest\") \nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SOCR_Data_Dinov_021708_Earthquakes\")\nhtml_nodes(wiki_url, \"#content\")\nearthquake <- html_table(html_nodes(wiki_url, \"table\")[[2]])\n# plot6.1<-ggplot(earthquake, aes(Depth, Latitude, group=Magt, color=Magt))+geom_point()\n# plot6.2<-ggplot(earthquake, aes(Depth, Latitude, group=Magt, color=Magt))+geom_point(position = position_jitter(w = 0.3, h = 0.3), alpha=0.5)\n# print(plot6.1)\n# print(plot6.2)\n# Note that with option `alpha=0.5` the \"crowded\" places are darker than the places with only one data point. \n# Sometimes, we need to add text to these points, i.e., add label in `aes` or add `geom_text`. It looks messy. \n# ggplot(earthquake, aes(Depth, Latitude, group=Magt, color=Magt,label=rownames(earthquake)))+\n#  geom_point(position = position_jitter(w = 0.3, h = 0.3), alpha=0.5)+geom_text()\n# Let's try to fix the overlap of points and labels. We need to add `check_overlap` in `geom_text` and adjust the positions of the text labels with respect to the points.\n# \n# ```{r warning=FALSE, message=FALSE, error=FALSE}\n# ggplot(earthquake, aes(Depth, Latitude, group=Magt, color=Magt,label=rownames(earthquake)))+\n#   geom_point(position = position_jitter(w = 0.3, h = 0.3), alpha=0.5)+\n#   geom_text(check_overlap = T,vjust = 0, nudge_y = 0.5, size = 2,angle = 45)\n# \n# # Or you can simply use the text to denote the positions of points.\n# ggplot(earthquake, aes(Depth, Latitude, group=Magt, color=Magt,label=rownames(earthquake)))+\n#   geom_text(check_overlap = T,vjust = 0, nudge_y = 0, size = 3,angle = 45)\n# # Warning: check_overlap will not show those overlapped points. Thus, if you need an analysis at the level of every instance, do not use it.\n\nglyphication <- function (name) {\n  glyph= vector()\n  for (i in 1:length(name)){\n    glyph[i]=\"triangle-up\"\n    if (name[i]==\"Md\") { glyph[i]=\"diamond-open\" }\n    else if (name[i]==\"ML\") { glyph[i]=\"circle-open\" }\n    else if (name[i]==\"Mw\") { glyph[i]=\"square-open\" }\n    else if (name[i]==\"Mx\") { glyph[i]=\"x-open\" }\n  }\n  return(glyph)\n}\nearthquake$glyph <- glyphication(earthquake$Magt)\n  \nplot_ly(earthquake) %>%\n  add_markers(x = ~Longitude, y = ~Latitude, type = \"scatter\",  color = ~Magt,\n        mode = \"markers\", marker = list(size = ~Depth, color = ~Magt, symbol = ~glyph,\n                                        line = list(color = ~Magt, width = 3))) %>% \n    layout(title=\"California Earthquakes (1969 - 2007)\")",
      "line_count": 42
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "plot_ly(ggplot2::diamonds, x = ~cut, y = ~price, type = 'bar', color = ~clarity, text= ~clarity)",
      "line_count": 1
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# bar <- barplot(m <- rowMeans(x) * 10, ylim=c(0, 10))\n# stdev <- sd(t(x[1:4, ]))\n# arrows(bar, m, bar, m + stdev, length=0.15, angle = 90)\n\nplot_ly(ggplot2::diamonds, y = ~log(price), color=~cut, type = \"box\") %>%\n  layout(title = \"Boxplot of Diamond (log) Price by Cut\",\n         xaxis=list(title=\"Diamond Cut\"))\n\nplot_ly(ggplot2::diamonds, x= ~clarity, y = ~log(price), color=~color, type = \"box\") %>%\n  layout(boxmode = \"group\", title = \"Grouped Boxplot of Diamond (log) Price by Clarity and Color\",\n         legend=list(title=list(text='<b> Diamond Color </b>')),\n         xaxis=list(title=\"Diamond Clarity\"))\n\n# for jitter plots, use    boxpoints = \"all\", jitter = 0.3, pointpos = -1.8, color=~cut)",
      "line_count": 14
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "data2 <- read.table('https://umich.instructure.com/files/399129/download?download_frd=1', header=T)\t\nattach(data2)\nhead(data2)",
      "line_count": 3
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "data2.sub <- data2[, c(-5, -6)] \ndata2<-data2[, -6]",
      "line_count": 2
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "data2.df <- as.data.frame(data2)\nBlacks <- data2[which(data2$race==\"black\"), ]\nOther <- data2[which(data2$race==\"other\"), ]\nHispanic <- data2[which(data2$race==\"hispanic\"), ]\nWhite <- data2[which(data2$race==\"white\"), ]\n\nB <- c(mean(Blacks$age), mean(Blacks$service))\nO <- c(mean(Other$age), mean(Other$service))\nH <- c(mean(Hispanic$age), mean(Hispanic$service))\nW <- c(mean(White$age), mean(White$service))\n\nx <- cbind(B, O, H, W)\nx",
      "line_count": 13
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# bar <- barplot(x, ylim=c(0, max(x)+2.0), beside=TRUE, \n# legend.text = c(\"age\", \"service\") ,  args.legend = list(x = \"right\"))\n# text(labels=round(as.vector(as.matrix(x)), 2), x=seq(1.4, 21, by=1.5), #y=as.vector(as.matrix(x[1:2, ]))+0.3)\n# \ty=11.5)\n# \n# m <- x; stdev <- sd(t(x))\n# arrows(bar, m, bar, m + stdev, length=0.15, angle = 90)\n# Here, we want the y margin to be little higher than the greatest value (`ylim=c(0, max(x)+2.0)`) because we need to leave space for value labels. Now we can easily notice that Hispanic trauma-exposed children are the youngest in terms of average age and they are less likely to utilize services like primary care, emergency room, outpatient therapy, outpatient psychiatrist, etc.\n\n# Diamonds Dataset example\n# data_mean <- ddply(diamonds, c(\"clarity\", \"cut\"), summarize, price = mean(price))\n# data_sd <- ddply(diamonds, c(\"clarity\", \"cut\"), summarize, price = sd(price))\n# data2 <- data.frame(data_mean, sd=data_sd$price)\n# \n# plot_ly(data = data2[which(data2$cut == 'Ideal'), ], x = ~clarity, y = ~price, type = 'bar',\n#                name = 'Cut=Ideal', error_y = ~list(array = sd, color = '#000000')) %>% \n#   add_trace(data = data2[which(data2$cut == 'Premium'), ], name = 'Cut=Premium')  %>% \n#   add_trace(data = data2[which(data2$cut == 'Very Good'), ], name = 'Cut=Very Good') %>% \n#   add_trace(data = data2[which(data2$cut == 'Good'), ], name = 'Cut=Good') %>% \n#   add_trace(data = data2[which(data2$cut == 'Fair'), ], name = 'Cut=Fair') %>%\n#   layout(title=\"Statistical Barplots (Diamonds Dataset)\",\n#          legend=list(title=list(text='<b> Diamond Cuts </b>')))\n \nlibrary(plyr)                        \ndata_mean <- ddply(data2, c(\"traumatype\", \"race\"), summarise, service = mean(service))\ndata_sd <- ddply(diamonds, c(\"traumatype\", \"race\"), summarise, service = sd(service))\ndata2 <- data.frame(data_mean, sd=data_sd$service)\n\nplot_ly(data = data2[which(data2$race == 'black'), ], x = ~traumatype, y = ~service, type = 'bar',\n               name = 'Black', error_y = ~list(array = sd, color = '#000000')) %>% \n  add_trace(data = data2[which(data2$race == 'hispanic'), ], name = 'Hispanic')  %>% \n  add_trace(data = data2[which(data2$race == 'other'), ], name = 'Other') %>% \n  add_trace(data = data2[which(data2$race == 'white'), ], name = 'White') %>%\n  layout(title=\"Statistical Barplots (Child Trauma Dataset)\",\n         legend=list(title=list(text='<b> Race </b>')))",
      "line_count": 35
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "library(ggplot2)\n#data2 <- read.table('https://umich.instructure.com/files/399129/download?download_frd=1', header=T)\t\nggplot(data2, aes(race, fill=race)) + geom_bar()+facet_grid(. ~ traumatype) ",
      "line_count": 3
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "data3<- read.table(\"https://umich.instructure.com/files/330385/download?download_frd=1\", sep=\",\", header = TRUE)\nhead(data3)",
      "line_count": 2
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "hc<-hclust(dist(data3), method='ave') \npar (mfrow=c(1, 1))\nplot(hc)",
      "line_count": 3
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "require(graphics)\nmem <- cutree(hc, k = 10)\n\n# mem; # to print the hierarchical tree labels for each case\n# which(mem==5)  # to identify which cases belong to class/cluster 5\n# To see the number of Subjects in which cluster:\n# table(cutree(hc, k=5))",
      "line_count": 7
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "cent <- NULL\nfor(k in 1:10){\n  \t\tcent <- rbind(cent, colMeans(data3[mem == k, , drop = FALSE]))\n}",
      "line_count": 4
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "hc1 <- hclust(dist(cent), method = \"ave\", members = table(mem))\nplot(hc1, hang = -1, main = \"Re-start from 10 clusters\")\n# via plot_ly()\nlibrary(plotly)\nlibrary(ggplot2)\nlibrary(ggdendro)\np <- ggdendrogram(hc, rotate = FALSE, size = 2)\nggplotly(p)",
      "line_count": 8
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# install.packages(\"corrplot\")\nlibrary(corrplot)\nNC_Associations_Data <- read.table(\"https://umich.instructure.com/files/330391/download?download_frd=1\", header=TRUE, row.names=1,  sep=\",\", dec=\".\")\t \nM <- cor(NC_Associations_Data)\nM[1:10, 1:10]",
      "line_count": 5
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "corrplot(M, method = \"circle\", title = \"circle\", tl.cex = 0.5, tl.col = 'black', mar=c(1, 1, 1, 1))\n# par specs c(bottom, left, top, right) which gives the margin size specified in inches\ncorrplot(M, method = \"square\", title = \"square\", tl.cex = 0.5, tl.col = 'black', mar=c(1, 1, 1, 1))\ncorrplot(M, method = \"ellipse\", title = \"ellipse\", tl.cex = 0.5, tl.col = 'black', mar=c(1, 1, 1, 1))\ncorrplot(M, method = \"pie\", title = \"pie\", tl.cex = 0.5, tl.col = 'black', mar=c(1, 1, 1, 1))\ncorrplot(M, type = \"upper\", tl.pos = \"td\",\n         method = \"circle\", tl.cex = 0.5, tl.col = 'black',\n         order = \"hclust\", diag = FALSE, mar=c(1, 1, 0, 1))\ncorrplot.mixed(M, number.cex = 0.4, tl.cex = 0.4)",
      "line_count": 9
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# library(\"xml2\"); library(\"rvest\") \nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SOCR_Data_Dinov_021708_Earthquakes\")\nhtml_nodes(wiki_url, \"#content\")\nearthquake<- html_table(html_nodes(wiki_url, \"table\")[[2]])",
      "line_count": 4
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "library(ggplot2)\nplot4 <- ggplot(earthquake, aes(Longitude, Latitude, group=Magt, color=Magt))+\n  # Either draw lines\n  # geom_line()\n  # or, alternatively, we can draw glyphs/points\n  geom_point(data=earthquake, size=4, mapping=aes(x=Longitude, y=Latitude, shape=Magt))\nplot4  # or print(plot4)",
      "line_count": 7
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# library(\"ggplot2\")\nggplot(earthquake, aes(Latitude, group=Magt, newsize=2))+geom_density(aes(color=Magt), size = 2) +\n  theme(legend.position = 'right', \n      legend.text = element_text(color= 'black', size = 12, face = 'bold'),\n      legend.key = element_rect(size = 0.5, linetype='solid'),\n      legend.key.size = unit(1.5, 'lines'))\n# table(earthquake$Magt) # to see the distribution of magnitude types",
      "line_count": 7
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "set.seed(1234)\npoisson_sample <- rpois(1000, 1)\n# slightly offset the histogram bins to align with mass function\nhist_breakes <- c(-0.5, 0.5, 1.5, 2.5, 3.5, 6.5)\n# hist(poisson_sample, freq=F, breaks = hist_breakes, col=\"light blue\", lwd=2, ylim = c(0, 0.45))\n# lines(density(poisson_sample, kernel = \"gaussian\"), lwd=2, col=\"blue\") \n# t <- seq(0, 6, by=0.01)\n# lines(t, dpois(t,1), type=\"h\", col=\"magenta\", lwd=6) # add the theoretical density line\n# legend(3,0.3, legend=c(\"Sample histogram (n=1,000)\", \"Theoretical mass function\", \n#                             \"Gaussian kernel density estimate\"), \n#        bty = \"n\", box.lty=0, col=c(\"light blue\", \"magenta\", \"blue\"), lty=1, lwd=3)\n\nh <-hist(poisson_sample, breaks = hist_breakes, plot = F)\nt <- seq(0, 6, by=0.01)\nPois <- density(poisson_sample, kernel = \"gaussian\")\n\nplot_ly(x = h$mids, y = h$density, type = \"bar\", name=\"Sample Histogram\") %>%\n  add_lines(x=t, y=dpois(t,1), type=\"scatter\", mode=\"lines\", \n            name=\"(Theoretical) Poisson Mass Function\") %>%\n  add_lines(x=Pois$x, y=Pois$y, \n        type=\"scatter\", mode=\"lines\", \n        name=\"Gaussian kernel density estimate (sample)\") %>%\n  layout(bargap=0.1, title=\"Histogram (Simulated Poisson Data)\",\n         legend = list(orientation = 'h'))\n",
      "line_count": 25
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# You may choose which of the 2 CSV files (width or length) to work with\ncrystallography_Length_data <- read.csv(file = \"https://umich.instructure.com/files/11653615/download?download_frd=1\",\n                         header=TRUE)\n\ncrystallography_Width_data <- read.csv(file = \"https://umich.instructure.com/files/11653614/download?download_frd=1\",\n                         header=TRUE)\n\ncrystallography_data <- crystallography_Length_data\n# crystallography_data <- crystallography_Width_data\n\n# Get the feature names (IDs)\ncolNames <- colnames(crystallography_data); colNames",
      "line_count": 12
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# plot all histograms\nlibrary(tidyr)\n# library(ggplot2)\n# # or `library(tidyverse)`\n# \n# crystallography_data %>% gather() %>% head()\n# #     key   value\n# #1 AC1338  70.547\n# #2 AC1338  40.448\n# #3 AC1338  47.212\n# #4 AC1338  91.468\n# #5 AC1338  79.088\n# #6 AC1338 132.319\n# #...\n# crystallography_data %>% gather() %>% tail()\n# #      key  value\n# #5872 Rec 68.479\n# #5873 Rec 41.047\n# #5874 Rec 47.546\n# #5875 Rec 98.558\n# #5876 Rec 52.956\n# #5877 Rec 82.470\n# \n# ggplot(gather(crystallography_data), aes(value)) + \n#     geom_histogram(bins = 20) + \n#     facet_wrap(~key, scales = 'free_x')\n\n\ncrystalCompleteData <- crystallography_data[complete.cases(crystallography_data), ]\n\ndf_crystal <- apply(crystalCompleteData,  2,  density, kernel=\"gaussian\", bw=15)\n\ndf <- data.frame(x = unlist(lapply(df_crystal, \"[[\", \"x\")),\n                 y = unlist(lapply(df_crystal, \"[[\", \"y\")),\n                 sample = rep(names(df_crystal), each = length(df_crystal[[1]]$x)))\n\nplot_ly(df, x = ~x, y = ~y, color = ~sample, type = \"scatter\", mode = \"lines\") %>% \n    layout(title='Crystallography Sample Densities', \n           legend=list(title=list(text='<b> Samples </b>')), \n           xaxis=list(title='X'), yaxis=list(title='Density'))",
      "line_count": 40
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# install.packages(\"fitdistrplus\")\nlibrary(fitdistrplus)\ncol_num <- dim(crystallography_data)[2]; col_num\n\n# Store the Weibull, Gamma, and Log-Normal Distribution models for the 9 features\nfit_W <- vector(mode = \"list\", length = col_num)\nfit_G <- vector(mode = \"list\", length = col_num)\nfit_LN <- vector(mode = \"list\", length = col_num)\n  \nfor(i in 1:col_num) {\n  data_no_NA <- crystallography_data[complete.cases(crystallography_data[, i]), i]\n  length(data_no_NA)\n  fit_W[[i]]  <- fitdist(data_no_NA, \"weibull\"); summary(fit_W[i])\n  fit_G[[i]]  <- fitdist(data_no_NA, \"gamma\"); summary(fit_G[i])\n  fit_LN[[i]] <- fitdist(data_no_NA, \"lnorm\"); summary(fit_LN[i])\n}\n\n# extract the model parameters\nW_mod_p1_name = array(dim=c(col_num,2)); dim(W_mod_p1_name)  # param name\nW_mod_p1_val = array(dim=c(col_num,2)); dim(W_mod_p1_val)    # parameter-estimate value\nG_mod_p1_name = array(dim=c(col_num,2)); dim(G_mod_p1_name)  # param name\nG_mod_p1_val = array(dim=c(col_num,2)); dim(G_mod_p1_val)    # parameter-estimate value\nLN_mod_p1_name = array(dim=c(col_num,2)); dim(LN_mod_p1_name)  # param name\nLN_mod_p1_val = array(dim=c(col_num,2)); dim(LN_mod_p1_val)    # parameter-estimate value\n\n# Compute the mean (m) and standard deviation (sd) for each model distribution\nW_mod_mean = array(dim=c(col_num,1)); length(W_mod_mean)  # Weibull mean or mode\nW_mod_sd = array(dim=c(col_num,1)); length(W_mod_sd)      # Weibull SD\nG_mod_mean = array(dim=c(col_num,1)); length(G_mod_mean)  # Gamma mean or mode\nG_mod_sd = array(dim=c(col_num,1)); length(G_mod_sd)      # Gamma SD\nLN_mod_mean = array(dim=c(col_num,1)); length(LN_mod_mean)  # Log-normal mean or mode\nLN_mod_sd = array(dim=c(col_num,1)); length(LN_mod_sd)      # Log-normal SD\n\nfor(i in 1:col_num) {\n  W_mod_p1_name[i, 1] <- names(fit_W[[i]]$estimate[1])  # Weibull \"shape\"\n  W_mod_p1_val[i, 1] <- fit_W[[i]]$estimate[[1]]\n  W_mod_p1_name[i, 2] <- names(fit_W[[i]]$estimate[2])  # Weibull \"scale\"\n  W_mod_p1_val[i, 2] <- fit_W[[i]]$estimate[[2]]\n  W_mod_mean[i] = W_mod_p1_val[i, 2] * gamma(1+1/W_mod_p1_val[i, 1])  # Weibull mean\n  W_mod_mean[i] = W_mod_p1_val[i, 2] * \n          ((W_mod_p1_val[i, 1]-1)/W_mod_p1_val[i, 1])^(1/W_mod_p1_val[i, 1])  # Weibull mode\n  W_mod_sd[i] = W_mod_p1_val[i, 2]*sqrt(gamma(1+2/W_mod_p1_val[i, 1])-\n                                        (gamma(1+1/W_mod_p1_val[i, 1]))^2)  # Weibull SD\n\n  G_mod_p1_name[i, 1] <- names(fit_G[[i]]$estimate[1])  # Gamma \"shape\"\n  G_mod_p1_val[i, 1] <- fit_G[[i]]$estimate[[1]]\n  G_mod_p1_name[i, 2] <- names(fit_G[[i]]$estimate[2])  # Gamma \"scale\"\n  G_mod_p1_val[i, 2] <- fit_G[[i]]$estimate[[2]]\n  G_mod_mean[i] = G_mod_p1_val[i, 1] / G_mod_p1_val[i, 2]  # Gamma mean\n  G_mod_mean[i] = (G_mod_p1_val[i, 1]-1) / G_mod_p1_val[i, 2]  # Gamma mode\n  G_mod_sd[i] = sqrt(G_mod_p1_val[i, 1]) / G_mod_p1_val[i, 2]  # Gamma SD\n  \n  LN_mod_p1_name[i, 1] <- names(fit_LN[[i]]$estimate[1])  # Log-normal \"shape\"\n  LN_mod_p1_val[i, 1] <- fit_LN[[i]]$estimate[[1]]\n  LN_mod_p1_name[i, 2] <- names(fit_LN[[i]]$estimate[2])  # Log-normal \"scale\"\n  LN_mod_p1_val[i, 2] <- fit_LN[[i]]$estimate[[2]]\n  LN_mod_mean[i] = exp(LN_mod_p1_val[i, 1]+ (LN_mod_p1_val[i, 2])^2/2)  # Log-normal mean\n  LN_mod_mean[i] = exp(LN_mod_p1_val[i, 1] - LN_mod_p1_val[i, 2]^2)  # Log-normal mean\n  LN_mod_sd[i] = sqrt((exp(LN_mod_p1_val[i, 2]^2)-1)*\n                  exp(2*LN_mod_p1_val[i, 1]+LN_mod_p1_val[i, 2]^2))  # Log-normal SD\n}\n\n# Check results, just for one model\nstr(fit_W[[1]])",
      "line_count": 64
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "windows(width=20, height=8)\npar(mfrow=c(3,3))\n\nfor(i in 1:col_num) {\n  # W_mod_p1_name[i] <- names(fit_W[[i]]$estimate[1])\n  # W_mod_p1_val[i] <- fit_W[[1]]$estimate[[1]]\n  plot.legend <- c(sprintf(\"Weibull(%s=%s,%s=%s) (m=%s,sd=%s)\", \n                           W_mod_p1_name[i, 1], format(W_mod_p1_val[i, 1], digits=2),\n                           W_mod_p1_name[i, 2], format(W_mod_p1_val[i, 2], digits=2),\n                           format(W_mod_mean[i], digits=2),\n                           format(W_mod_sd[i], digits=2)), \n                   sprintf(\"Gamma(%s=%s,%s=%s) (m=%s,sd=%s)\", \n                           G_mod_p1_name[i, 1], format(G_mod_p1_val[i, 1], digits=2),\n                           G_mod_p1_name[i, 2], format(G_mod_p1_val[i, 2], digits=2),\n                           format(G_mod_mean[i], digits=2),\n                           format(G_mod_sd[i], digits=2)), \n                   sprintf(\"Log-normal(%s=%s,%s=%s) (m=%s,sd=%s)\", \n                           LN_mod_p1_name[i, 1], format(LN_mod_p1_val[i, 1], digits=2),\n                           LN_mod_p1_name[i, 2], format(LN_mod_p1_val[i, 2], digits=2),\n                           format(LN_mod_mean[i], digits=2),\n                           format(LN_mod_sd[i], digits=2)))\n  denscomp(list(fit_W[[i]], fit_G[[i]], fit_LN[[i]]), legendtext = plot.legend, \n           xlegend = \"topright\", ylegend =\"right\",\n           main=sprintf(\"Width: Feature: %s: Histogram & Model Densities\", colnames(crystallography_data)[i]))\n  abline(v = format(W_mod_mean[i], digits=2), col = \"red\", lty=1)\n  abline(v = format(G_mod_mean[i], digits=2), col = \"green\", lty=2)\n  abline(v = format(LN_mod_mean[i], digits=2), col = \"blue\", lty=3)\n  # cdfcomp (list(fit_w, fit_g, fit_ln), legendtext = plot.legend)\n  # qqcomp  (list(fit_w, fit_g, fit_ln), legendtext = plot.legend)\n  # ppcomp  (list(fit_w, fit_g, fit_ln), legendtext = plot.legend)\n}\n\n# Plot histograms and CDF (cumulative distribution function) models\nwindows(width=20, height=12)\npar(mfrow=c(3,3))\nfor(i in 1:col_num) {\n  plot.legend <- c(sprintf(\"Weibull(%s=%s,%s=%s) (m=%s,sd=%s)\", \n                           W_mod_p1_name[i, 1], format(W_mod_p1_val[i, 1], digits=2),\n                           W_mod_p1_name[i, 2], format(W_mod_p1_val[i, 2], digits=2),\n                           format(W_mod_mean[i], digits=2),\n                           format(W_mod_sd[i], digits=2)), \n                   sprintf(\"Gamma(%s=%s,%s=%s) (m=%s,sd=%s)\", \n                           G_mod_p1_name[i, 1], format(G_mod_p1_val[i, 1], digits=2),\n                           G_mod_p1_name[i, 2], format(G_mod_p1_val[i, 2], digits=2),\n                           format(G_mod_mean[i], digits=2),\n                           format(G_mod_sd[i], digits=2)), \n                   sprintf(\"Log-normal(%s=%s,%s=%s) (m=%s,sd=%s)\", \n                           LN_mod_p1_name[i, 1], format(LN_mod_p1_val[i, 1], digits=2),\n                           LN_mod_p1_name[i, 2], format(LN_mod_p1_val[i, 2], digits=2),\n                           format(LN_mod_mean[i], digits=2),\n                           format(LN_mod_sd[i], digits=2)))\n  cdfcomp(list(fit_W[[i]], fit_G[[i]], fit_LN[[i]]), legendtext = plot.legend, \n           xlegend = \"bottomright\", ylegend =\"right\",\n           main=sprintf(\"Width: Feature: %s: Aggregate Hist & Model CDFs\", colnames(crystallography_data)[i]))\n}",
      "line_count": 55
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "pl_list <- list()\n\nfor(i in 1:col_num) {\n  # W_mod_p1_name[i] <- names(fit_W[[i]]$estimate[1])\n  # W_mod_p1_val[i] <- fit_W[[1]]$estimate[[1]]\n  plot.legend <- c(sprintf(\"Weibull(%s=%s,%s=%s) (m=%s,sd=%s)\", \n                           W_mod_p1_name[i, 1], format(W_mod_p1_val[i, 1], digits=2),\n                           W_mod_p1_name[i, 2], format(W_mod_p1_val[i, 2], digits=2),\n                           format(W_mod_mean[i], digits=2),\n                           format(W_mod_sd[i], digits=2)), \n                   sprintf(\"Gamma(%s=%s,%s=%s) (m=%s,sd=%s)\", \n                           G_mod_p1_name[i, 1], format(G_mod_p1_val[i, 1], digits=2),\n                           G_mod_p1_name[i, 2], format(G_mod_p1_val[i, 2], digits=2),\n                           format(G_mod_mean[i], digits=2),\n                           format(G_mod_sd[i], digits=2)), \n                   sprintf(\"Log-normal(%s=%s,%s=%s) (m=%s,sd=%s)\", \n                           LN_mod_p1_name[i, 1], format(LN_mod_p1_val[i, 1], digits=2),\n                           LN_mod_p1_name[i, 2], format(LN_mod_p1_val[i, 2], digits=2),\n                           format(LN_mod_mean[i], digits=2),\n                           format(LN_mod_sd[i], digits=2)))\n  # x <- dweibull(10000, shape=fit_W[[i]]$estimate[1], scale =fit_W[[i]]$estimate[2])\n  # fit <- density(x)\n  z <- seq(from=min(fit_W[[i]]$data), max(fit_W[[i]]$data), 0.1)  # points from -4 to 4 in 0.1 steps\n  weibullDens   <- dweibull(z, shape=fit_W[[i]]$estimate[1], scale =fit_W[[i]]$estimate[2])\n  gammaDens     <- dgamma(z, shape=fit_G[[i]]$estimate[1], rate =fit_G[[i]]$estimate[2])\n  logNormalDens <- dlnorm(z, meanlog=fit_LN[[i]]$estimate[1], sdlog =fit_LN[[i]]$estimate[2])\n  \n  # z<-seq(from=min(fit_W[[i]]$data), to=max(fit_W[[i]]$data), 0.1)  # Range points in 0.1 steps\n\n  pl_list[[i]] <- \n    plot_ly(x=~fit_W[[i]]$data, name=~colnames(crystallography_data)[i], showlegend = FALSE,\n            marker = list(color = \"transparent\", line = list(color = \"darkgray\", width = 2)),\n            type=\"histogram\", mode=\"markers\", opacity=0.9, nbinsx=20, histnorm=\"probability\") %>%\n      # add models\n      add_trace(x=z, y=15*weibullDens, type=\"scatter\", mode=\"lines\", opacity=0.5, name=plot.legend[1],\n                line = list(color = \"red\", width = 2)) %>%  \n      add_trace(x=z, y=15*gammaDens, type=\"scatter\", mode=\"lines\", opacity=0.5, name=plot.legend[2],\n                line = list(color = \"green\", width = 2)) %>%  \n      add_trace(x=z, y=15*logNormalDens, type=\"scatter\", mode=\"lines\", opacity=0.5, name=plot.legend[3],\n                line = list(color = \"blue\", width = 2)) %>%\n      # add vertical mean lines\n      add_segments(x=W_mod_mean[i], y=0, xend=W_mod_mean[i], yend=0.2, name=\"Weibull mean\", color=\"red\") %>%\n      add_segments(x=G_mod_mean[i], y=0, xend=G_mod_mean[i], yend=0.2, name=\"Gamma mean\", color=\"green\") %>%\n      add_segments(x=LN_mod_mean[i], y=0, xend=LN_mod_mean[i], yend=0.2, name=\"LogNormal mean\", color=\"blue\") %>%\n      layout(title = sprintf(\"Width: Feature: %s: Histogram & Model Densities\", colnames(crystallography_data)[i]),\n              xaxis = list(title = colnames(crystallography_data)[i]), yaxis = list(title = \"Density\"),\n             bargap=0.1) %>% hide_colorbar()\n}\n\npl_list %>% plotly::subplot(nrows = 3) %>% layout(title=\"Mixture Modeling of Crystallography Data (Interactive Plot)\")  ",
      "line_count": 50
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# Save the summary outputs (mode & SD) across 9 samples, 3 models and 2 measures into a dataframe\n\ndf_matrix = array(dim=c(col_num,3*2*2)); dim(df_matrix) \n\nfor(i in 1:col_num) {\n  data1 <- crystallography_data[complete.cases(crystallography_data[, i]), i]\n  \n  df_matrix[i, 1] = format(W_mod_mean[i], digits=2)  # Weibull mode\n  df_matrix[i, 2] = format(W_mod_sd[i], digits=2)    # Weibull SD\n  ks_W <- ks.test(data1, \"pweibull\", scale=W_mod_p1_val[i, 2], shape=W_mod_p1_val[i, 1])\n  df_matrix[i, 3] = format(ks_W$statistic[[1]], digits=4)  # KS-test-stat Weibull\n  df_matrix[i, 4] = format(ks_W$p.value, digits=5)    # KS-test-p-value Weibull\n  \n  df_matrix[i, 5] = format(G_mod_mean[i], digits=2)  # Gamma mode\n  df_matrix[i, 6] = format(G_mod_sd[i], digits=2)    # Gamma SD\n  ks_G <- ks.test(data1, \"pgamma\", rate=G_mod_p1_val[i, 2], shape=G_mod_p1_val[i, 1])\n  df_matrix[i, 7] = format(ks_G$statistic[[1]], digits=4)  # KS-test-stat Gamma\n  df_matrix[i, 8] = format(ks_G$p.value, digits=5)    # KS-test-p-value Gamma\n  \n  df_matrix[i, 9] = format(LN_mod_mean[i], digits=2)  # Log-normal mode\n  df_matrix[i, 10] = format(LN_mod_sd[i], digits=2)    # Log-normal SD\n  ks_LN <- ks.test(data1, \"plnorm\", sdlog=LN_mod_p1_val[i, 2], meanlog=LN_mod_p1_val[i, 1])\n  df_matrix[i, 11] = format(ks_LN$statistic[[1]], digits=4)  # KS-test-stat Log-normal\n  df_matrix[i, 12] = format(ks_G$p.value, digits=5)    # KS-test-p-value Log-normal\n}\n\ndf_summary <- as.data.frame(df_matrix, row.names=colNames)\ncolnames(df_summary) <- c(\"Weibull_mode\", \"Weibull_sd\",\"Weibull_KS.test.stat\", \"Weibull_KS.p.val\",\n                  \"Gamma_mode\", \"Gamma_sd\",\"Gamma_KS.test.stat\", \"Gamma_KS.p.val\",\n                  \"Lognormal_mode\", \"Lognormal_sd\",\"Lognormal_KS.test.stat\", \"Lognormal_KS.p.val\")\ndf_summary\n\nlibrary(\"DT\")\ndatatable(t(df_summary))\n#write.csv(df_summary, file = \"/Desktop/SummaryResults_Width_Models.csv\", \n#          row.names=T, col.names=T)",
      "line_count": 36
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "sampleColNames <- c(\"AC1338\",\"AC1432\",\"AC1593\", \"AC1679\", \"AC1860\", \"AC1874\", \"AC1881\", \"AC1903\", \"Rec\")\nsampleMixtureParam <- c(3, 3, 3, 3, 3, 3, 3, 3, 3)\ndf_sampleMixtureParam <- data.frame(t(sampleMixtureParam))\ncolnames(df_sampleMixtureParam) <- sampleColNames; # df_sampleMixtureParam",
      "line_count": 4
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# crystallography_data <- read.csv(file = \"https://umich.instructure.com/files/13375767/download?download_frd=1\",\n#                          header=TRUE)\n# crystallography_data <- read.csv(file = \"https://umich.instructure.com/files/11653615/download?download_frd=1\",\n#                          header=TRUE)\n\n# install.packages(\"mixtools\")\nlibrary(mixtools)\n\ncol_num <- dim(crystallography_data)[2]; col_num\n\n# Fit mixture models\ncapture.output(\n  for(i in 1:col_num) {   # remove all non-numeric elements (if any)\n    # data_no_NA <- unlist(Filter(is.numeric, crystallography_data[complete.cases(crystallography_data[, i]), i]))\n    data_no_NA <- crystallography_data[complete.cases(crystallography_data[, i]), i]\n    length(data_no_NA)\n    fit_W[[i]]  <- weibullRMM_SEM(data_no_NA, k=df_sampleMixtureParam[1,i], verb=F)\n    # summary(fit_W[i])\n    fit_G[[i]]  <- gammamixEM(data_no_NA, k=df_sampleMixtureParam[1,i], verb=F)\n    # summary(fit_G[i])\n    fit_LN[[i]] <- normalmixEM(data_no_NA, k=df_sampleMixtureParam[1,i], verb=F)\n    # summary(fit_LN[i])\n  }, \n  file='NUL'\n)\n\n# plot(fit_LN[[1]], which=2)\n# lines(density(crystallography_data[complete.cases(crystallography_data[, 1]), 1]), lty=2, lwd=2)",
      "line_count": 28
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# Custom design of Gamma-Mixture Model plot\ngammaMM.plot <- function(mix.object, k = 2, main = \"\") {  # mix.object <- fit_G[[i]]\n  data_no_NA <- crystallography_data[complete.cases(crystallography_data[, i]), i]\n  d3 <- function(x) { # construct the mixture using the estimated parameters\n    mix.object$lambda[1]*dgamma(x, shape=mix.object$gamma.pars[1,1], 1/mix.object$gamma.pars[2,1]) + \n      mix.object$lambda[2]*dgamma(x, shape=mix.object$gamma.pars[1,2], 1/mix.object$gamma.pars[2,2]) + \n      mix.object$lambda[3]*dgamma(x, shape=mix.object$gamma.pars[1,3], 1/mix.object$gamma.pars[2,3])\n  }\n\n  x <- seq(min(data_no_NA), max(data_no_NA), 0.001)\n  hist(data_no_NA, col=\"pink\", freq=F, breaks=10, main = main, xlab=\"Intensities\")\n  lines(x, d3(x), lwd=3, col=\"black\", xlim=c(4,23), ylim=c(0, 0.25))\n  mixColors <- colorRampPalette(c(\"blue\", \"red\"))(k)\n  \n  for (i in 1:k) {\n    d = function(x) { # construct each of the Gamma components using the estimated parameters\n      mix.object$lambda[i]*dgamma(x, shape=mix.object$gamma.pars[1, i], 1/mix.object$gamma.pars[2,i])\n    }\n    lines(x, d(x), lwd=3, col=mixColors[i])\n  }\n}\n\n# Custom design of Weibull-Mixture Model plot\nweibullMM.plot <- function(mix.object, k = 2, main = \"\") {  # mix.object <- fit_W[[i]]\n  data_no_NA <- crystallography_data[complete.cases(crystallography_data[, i]), i]\n  d3 <- function(x) { # construct the mixture using the estimated parameters\n    mix.object$lambda[1]*dweibull(x, shape=mix.object$shape[1], scale=mix.object$scale[1]) + \n      mix.object$lambda[2]*dweibull(x, shape=mix.object$shape[2], scale=mix.object$scale[2]) +\n      mix.object$lambda[3]*dweibull(x, shape=mix.object$shape[3], scale=mix.object$scale[3])\n  }\n\n  x <- seq(min(data_no_NA), max(data_no_NA), 0.001)\n  hist(data_no_NA, col=\"pink\", freq=F, breaks=15, main = main, xlab=\"Intensities\")\n  lines(x, d3(x), lwd=3, col=\"black\", xlim=c(4,23), ylim=c(0, 0.25))\n  mixColors <- colorRampPalette(c(\"blue\", \"red\"))(k)\n  \n  for (i in 1:k) {\n    d = function(x) { # construct each of the Weibull components using the estimated parameters\n      mix.object$lambda[i]*dweibull(x, shape=mix.object$shape[i], scale=mix.object$scale[i])\n    }\n    lines(x, d(x), lwd=3, col=mixColors[i])\n  }\n}\n\n# Custom design of Normal-Mixture Model plot\nnormalMM.plot <- function(mix.object, k = 2, main = \"\") {  # mix.object <- fit_LN[[i]]\n  data_no_NA <- crystallography_data[complete.cases(crystallography_data[, i]), i]\n  d3 <- function(x) { # construct the mixture using the estimated parameters\n    mix.object$lambda[1]*dnorm(x, mean=mix.object$mu[1], sd=mix.object$sigma[1]) + \n      mix.object$lambda[2]*dnorm(x, mean=mix.object$mu[2], sd=mix.object$sigma[2]) +\n      mix.object$lambda[3]*dnorm(x, mean=mix.object$mu[3], sd=mix.object$sigma[3])\n  }\n\n  x <- seq(min(data_no_NA), max(data_no_NA), 0.001)\n  hist(data_no_NA, col=\"pink\", freq=F, breaks=20, main = main, xlab=\"Intensities\", xlim = c(4,180), ylim = c(0.0, 0.02))\n  lines(x, d3(x), lwd=3, col=\"black\")\n  mixColors <- colorRampPalette(c(\"blue\", \"red\"))(k)\n  \n  for (i in 1:k) {\n    d = function(x) { # construct each of the Normal components using the estimated parameters\n      mix.object$lambda[i]*dnorm(x, mean=mix.object$mu[i], sd=mix.object$sigma[i])\n    }\n    lines(x, d(x), lwd=3, col=mixColors[i])\n  }\n}",
      "line_count": 65
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# Plot Mixture Models and Report model parameter estimates\n# for(i in 1:col_num) {  # uncomment this to plot all 9 samples\nfor(i in 1:2) {    # this only plots the first 2 samples to save space\n  weibullMM.plot(fit_W[[i]], df_sampleMixtureParam[1,i], \n               paste0(\"Mixture of \", df_sampleMixtureParam[1, sampleColNames[i]], \n                  \" Weibull Models of \", sampleColNames[i]))\n  #plot(fit_W[[i]], density=TRUE, whichplots = 2,\n  #   main2=paste0(\"Mixture of \", df_sampleMixtureParam[1, sampleColNames[i]], \n  #                \" Weibull Models of \", sampleColNames[i]), xlab2=\"Intensities\")\n  gammaMM.plot(fit_G[[i]], df_sampleMixtureParam[1,i], \n               paste0(\"Mixture of \", df_sampleMixtureParam[1, sampleColNames[i]], \n                  \" Gamma Models of \", sampleColNames[i]))\n  normalMM.plot(fit_LN[[i]], df_sampleMixtureParam[1,i], \n               paste0(\"Mixture of \", df_sampleMixtureParam[1, sampleColNames[i]], \n                  \" Normal Models of \", sampleColNames[i]))\n}",
      "line_count": 16
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# Generate the summary DF\ngetSummaryTable <- function (crystalSampleIndex) {\n  mat <- matrix(0, nrow = 3, ncol = 10)\n  \n  # Weibull estimates for all 3 model components \n  # For Weibull Dist mean and SD see: https://en.wikipedia.org/wiki/Weibull_distribution\n  mat[1,1] <- round(fit_W[[crystalSampleIndex]]$lambda[1],3) # lambda\n  mat[1,2] <- round(fit_W[[crystalSampleIndex]]$scale[1] * \n                      gamma(1+1/fit_W[[crystalSampleIndex]]$shape[1]),3)  # mean\n  mat[1,3] <- round(fit_W[[crystalSampleIndex]]$scale[1] *\n                      sqrt(gamma(1+2/fit_W[[crystalSampleIndex]]$shape[1])-\n                          (gamma(1+1/fit_W[[crystalSampleIndex]]$shape[1]))^2),3)  #  sd\n  \n  mat[1,4] <- round(fit_W[[crystalSampleIndex]]$lambda[2],3) # lambda\n  mat[1,5] <- round(fit_W[[crystalSampleIndex]]$scale[2] * \n                      gamma(1+1/fit_W[[crystalSampleIndex]]$shape[2]),3)  # mean\n  mat[1,6] <- round(fit_W[[crystalSampleIndex]]$scale[2] *\n                      sqrt(gamma(1+2/fit_W[[crystalSampleIndex]]$shape[2])-\n                          (gamma(1+1/fit_W[[crystalSampleIndex]]$shape[2]))^2),3)  #  sd\n  \n  mat[1,7]  <- round(fit_W[[crystalSampleIndex]]$lambda[3],3) # lambda\n  mat[1,8] <- round(fit_W[[crystalSampleIndex]]$scale[3] * \n                      gamma(1+1/fit_W[[crystalSampleIndex]]$shape[3]),3)  # mean\n  mat[1,9] <- round(fit_W[[crystalSampleIndex]]$scale[3] *\n                      sqrt(gamma(1+2/fit_W[[crystalSampleIndex]]$shape[3])-\n                          (gamma(1+1/fit_W[[crystalSampleIndex]]$shape[3]))^2),3)  #  sd\n  mat[1,10] <- round(fit_W[[crystalSampleIndex]]$loglik,3)    # Log-lik\n  \n  # Gamma estimates for all 3 model components \n  # For Gamma dist mean & SD see: https://en.wikipedia.org/wiki/Gamma_distribution\n  mat[2,1] <- round(fit_G[[crystalSampleIndex]]$lambda[1],3)        # lambda\n  mat[2,2] <- round(fit_G[[crystalSampleIndex]]$gamma.pars[1,1]*\n                      fit_G[[crystalSampleIndex]]$gamma.pars[2,1],3)  # mean\n  mat[2,3] <- round(sqrt(fit_G[[crystalSampleIndex]]$gamma.pars[1,1])*\n                      fit_G[[crystalSampleIndex]]$gamma.pars[2,1],3)  # SD\n  \n  mat[2,4] <- round(fit_G[[crystalSampleIndex]]$lambda[2],3)        # lambda\n  mat[2,5] <- round(fit_G[[crystalSampleIndex]]$gamma.pars[1,2]*\n                      fit_G[[crystalSampleIndex]]$gamma.pars[2,2],3)  # mean\n  mat[2,6] <- round(sqrt(fit_G[[crystalSampleIndex]]$gamma.pars[1,2])*\n                      fit_G[[crystalSampleIndex]]$gamma.pars[2,2],3)  # sd\n  \n  mat[2,7]  <- round(fit_G[[crystalSampleIndex]]$lambda[3],3)        # lambda\n  mat[2,8] <- round(fit_G[[crystalSampleIndex]]$gamma.pars[1,3]*\n                       fit_G[[crystalSampleIndex]]$gamma.pars[2,3],3)  # mean\n  mat[2,9] <- round(sqrt(fit_G[[crystalSampleIndex]]$gamma.pars[1,3])*\n                       fit_G[[crystalSampleIndex]]$gamma.pars[2,3],3)  # sd\n  mat[2,10] <- round(fit_G[[crystalSampleIndex]]$loglik,3)    # Log-lik\n  \n  # Normal estimates for all 3 model components \n  mat[3,1] <- round(fit_LN[[crystalSampleIndex]]$lambda[1],3)        # lambda\n  mat[3,2] <- round(fit_LN[[crystalSampleIndex]]$mu[1],3)  # shape\n  mat[3,3] <- round(fit_LN[[crystalSampleIndex]]$sigma[1],3)  # scale\n  \n  mat[3,4] <- round(fit_LN[[crystalSampleIndex]]$lambda[2],3)        # lambda\n  mat[3,5] <- round(fit_LN[[crystalSampleIndex]]$mu[2],3)  # shape\n  mat[3,6] <- round(fit_LN[[crystalSampleIndex]]$sigma[2],3)  # scale\n  \n  mat[3,7]  <- round(fit_LN[[crystalSampleIndex]]$lambda[3],3)        # lambda\n  mat[3,8] <- round(fit_LN[[crystalSampleIndex]]$mu[3],3)  # shape\n  mat[3,9] <- round(fit_LN[[crystalSampleIndex]]$sigma[3],3)  # scale\n  mat[3,10] <- round(fit_LN[[crystalSampleIndex]]$loglik,3)    # Log-lik\n  \n  return(as.data.frame(mat))\n}\n\n# render the summary DT tables\nlibrary(\"DT\")",
      "line_count": 68
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "df_summary <- getSummaryTable(1)\nrownames(df_summary) <- c(\"Weibull\", \"Gamma\", \"Normal\")\ncolnames(df_summary) <- c(\"MC 1 Weight\", \"MC 1 Mean\", \"MC 1 SD\", \n                            \"MC 2 Weight\", \"MC 2 Mean\", \"MC 2 SD\", \n                            \"MC 3 Weight\", \"MC 3 Mean\", \"MC 3 SD\", \"MixMod LogLik\")\ndatatable(df_summary, rownames = TRUE)",
      "line_count": 6
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "ddf_summary <- getSummaryTable(2)\nrownames(df_summary) <- c(\"Weibull\", \"Gamma\", \"Normal\")\ncolnames(df_summary) <- c(\"MC 1 Weight\", \"MC 1 Mean\", \"MC 1 SD\", \n                            \"MC 2 Weight\", \"MC 2 Mean\", \"MC 2 SD\", \n                            \"MC 3 Weight\", \"MC 3 Mean\", \"MC 3 SD\", \"MixMod LogLik\")\ndatatable(df_summary, rownames = TRUE)",
      "line_count": 6
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "kd <- with(MASS::geyser, MASS::kde2d(duration, waiting, n = 50))\nkd$x[1:5]\nkd$y[1:5]\nkd$z[1:5, 1:5]",
      "line_count": 4
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "library(plotly)\nwith(kd, plot_ly(x=x, y=y, z=z, type=\"surface\"))",
      "line_count": 2
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "volcano[1:10, 1:10]\nplot_ly(z=volcano, type=\"surface\")",
      "line_count": 2
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "#install.packages(\"jpeg\") ## if necessary\nlibrary(jpeg)\n\n# Get an image file downloaded (default: MRI_ImageHematoma.jpg)\nimg_url <- \"https://umich.instructure.com/files/1627149/download?download_frd=1\"\nimg_file <- tempfile(); download.file(img_url, img_file, mode=\"wb\")\nimg <- readJPEG(img_file)\nfile.info(img_file)\nfile.remove(img_file) # cleanup\nimg <- img[, , 1] # extract the first channel (from RGB intensity spectrum) as a univariate 2D array\n\n# install.packages(\"spatstat\")\n# package spatstat has a function blur() that applies a Gaussian blur\nlibrary(spatstat) \nimg_s <- as.matrix(blur(as.im(img), sigma=10)) # the smoothed version of the image\n\nz2 <- img_s + 1   # abs(rnorm(1, 1, 1)) # Upper confidence surface\nz3 <- img_s - 1   # abs(rnorm(1, 1, 1)) # Lower confidence limit\n\n# Plot the image surfaces\np <- plot_ly(z=img, type=\"surface\", showscale=FALSE) %>%\n add_trace(z=z2, type=\"surface\", showscale=FALSE, opacity=0.98) %>%\n add_trace(z=z3, type=\"surface\", showscale=FALSE, opacity=0.98)\np # Plot the mean-surface along with lower and upper confidence services.",
      "line_count": 24
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# install.packages(\"brainR\") ## if necessary\nlibrary(brainR)\n# Test data: https://socr.umich.edu/HTML5/BrainViewer/data/TestBrain.nii.gz\n\nbrainURL <- \"https://socr.umich.edu/HTML5/BrainViewer/data/TestBrain.nii.gz\"\nbrainFile <- file.path(tempdir(), \"TestBrain.nii.gz\")\ndownload.file(brainURL, dest=brainFile, quiet=TRUE)\nbrainVolume <- readNIfTI(brainFile, reorient=FALSE)\n\nbrainVolDims <- dim(brainVolume); brainVolDims\n# try different levels at which to construct contour surfaces (10 fast)\n# lower values yield smoother surfaces # see ?contour3d\ncontour3d(brainVolume, level = 20, alpha = 0.1, draw = TRUE)\n\n# multiple levels may be used to show multiple shells\n# \"activations\" or surfaces like hyper-intense white matter\n# This will take 1-2 minutes to rend!\ncontour3d(brainVolume, level = c(10, 120), alpha = c(0.3, 0.5),\n        add = TRUE, color=c(\"yellow\", \"red\"))\n\n# create text for orientation of right/left\ntext3d(x=brainVolDims[1]/2, y=brainVolDims[2]/2, z = brainVolDims[3]*0.98, text=\"Top\")\ntext3d(x=brainVolDims[1]*0.98, y=brainVolDims[2]/2, z = brainVolDims[3]/2, text=\"Right\")\n\n### render this on a webpage and view it!\n#browseURL(paste(\"file://\",\n#        writeWebGL_split(dir= file.path(tempdir(),\"webGL\"),\n#        template = system.file(\"my_template.html\", package=\"brainR\"),\n#        width=500), sep=\"\"))",
      "line_count": 29
    },
    {
      "section": "Exploratory Data Analytics (EDA)",
      "code": "# See examples here: https://cran.r-project.org/web/packages/oro.nifti/vignettes/nifti.pdf\n# and here: http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0089470\nlibrary(oro.nifti)\nfMRIURL <- \"https://socr.umich.edu/HTML5/BrainViewer/data/fMRI_FilteredData_4D.nii.gz\"\nfMRIFile <- file.path(tempdir(), \"fMRI_FilteredData_4D.nii.gz\")\ndownload.file(fMRIURL, dest=fMRIFile, quiet=TRUE)\n(fMRIVolume <- readNIfTI(fMRIFile, reorient=FALSE))\n# dimensions: 64 x 64 x 21 x 180 ; 4mm x 4mm x 6mm x 3 sec \n\nfMRIVolDims <- dim(fMRIVolume); fMRIVolDims\ntime_dim <- fMRIVolDims[4]; time_dim\n\n# Plot the 4D array of imaging data in a 5x5 grid of images \n# The first three dimensions are spatial locations of the voxel (volume element) and the fourth dimension is time for this functional MRI (fMRI) acquisition. \nimage(fMRIVolume, zlim=range(fMRIVolume)*0.95)\nh <- hist(fMRIVolume, plot = F)\n\nplot_ly(x = h$mids, y = h$density, type = \"bar\") %>%\n   layout(bargap=0.1, title=\"fMRI Histogram\")\n\n# Plot an orthographic display of the fMRI data using the axial plane containing the left-and-right thalamus to approximately center the crosshair vertically\n\northographic(fMRIVolume, xyz=c(34,29,10), zlim=range(fMRIVolume)*0.9)\n\nstat_fmri_test <- ifelse(fMRIVolume > 15000, fMRIVolume, NA)\n\nh <- hist(stat_fmri_test, plot = F)\n\nplot_ly(x = h$mids, y = h$density, type = \"bar\") %>%\n   layout(bargap=0.1, title=\"fMRI Histogram (high intensities)\")\n\ndim(stat_fmri_test)\n\noverlay(fMRIVolume, fMRIVolume[,,,5], zlim.x=range(fMRIVolume)*0.95)\n\n# overlay(fMRIVolume, stat_fmri_test[,,,5], zlim.x=range(fMRIVolume)*0.95)\n\n# To examine the time course of a specific 3D voxel (say the one at x=30, y=30, z=10):\n# plot(fMRIVolume[30, 30, 10,], type='l', main=\"Time Series of 3D Voxel \\n (x=30, y=30, z=10)\", col=\"blue\")\nx1 <- c(1:180)\ny1 <- loess(fMRIVolume[30, 30, 10,]~ x1, family = \"gaussian\")\n# lines(x1, smooth(fMRIVolume[30, 30, 10,]), col = \"red\", lwd = 2)\n# lines(ksmooth(x1, fMRIVolume[30, 30, 10,], kernel = \"normal\", bandwidth = 5), col = \"green\", lwd = 3)\n# legend(\"bottomright\", legend=c(\"(raw) fMRI\", \"smooth(fMRI)\", \"ksmooth(fMRI\"),\n#        col=c(\"blue\", \"red\", \"green\"), lty=1, cex=0.8,\n#        y.intersp=0.8)\n\nplot_ly(x = x1, y = fMRIVolume[30, 30, 10,], \n        name=\"Raw fMRI\", type = 'scatter', mode = 'lines') %>%\n  add_trace(y = smooth(fMRIVolume[30, 30, 10,]), name = 'loess fMRI')  %>%\n  add_trace(y = ksmooth(x1, fMRIVolume[30, 30, 10,], kernel=\"normal\", bandwidth = 5)$y, name='kSmooth fMRI')  %>%\n  layout(title=\"Time Series of 3D Voxel (x=30, y=30, z=10)\", legend = list(orientation = 'h'))\n",
      "line_count": 53
    },
    {
      "section": "Appendix",
      "code": "# install.packages(\"RODBC\", repos = \"http://cran.us.r-project.org\")\nlibrary(RODBC)",
      "line_count": 2
    },
    {
      "section": "Appendix",
      "code": "# Right Skewed\nN <- 10000\n x <- rnbinom(N, 10, .5)\n hist(x, \n xlim=c(min(x), max(x)), probability=T, nclass=max(x)-min(x)+1, \n   col='lightblue', xlab=' ', ylab=' ', axes=F, \n   main='Right Skewed')\nlines(density(x, bw=1), col='red', lwd=3)\n\n#No Skew\nN <- 10000\n x <- rnorm(N, 0, 1)\n hist(x, probability=T, \n   col='lightblue', xlab=' ', ylab=' ', axes=F, \n   main='No Skew')\nlines(density(x, bw=0.4), col='red', lwd=3)\n\n#Uniform density\nx<-runif(1000, 1, 50)\nhist(x, col='lightblue', main=\"Uniform Distribution\", probability = T, xlab=\"\", ylab=\"Density\", axes=F)\nabline(h=0.02, col='red', lwd=3)\n\n#68-95-99.7 rule\nx <- rnorm(N, 0, 1)\n hist(x, probability=T, \n   col='lightblue', xlab=' ', ylab=' ', axes = F, \n   main='68-95-99.7 Rule')\nlines(density(x, bw=0.4), col='red', lwd=3)\naxis(1, at=c(-3, -2, -1, 0, 1, 2, 3), labels = expression(mu-3*sigma, mu-2*sigma, mu-sigma, mu, mu+sigma, mu+2*sigma, mu+3*sigma))\nabline(v=-1, lwd=3, lty=2)\nabline(v=1, lwd=3, lty=2)\nabline(v=-2, lwd=3, lty=2)\nabline(v=2, lwd=3, lty=2)\nabline(v=-3, lwd=3, lty=2)\nabline(v=3, lwd=3, lty=2)\ntext(0, 0.2, \"68%\")\nsegments(-1, 0.2, -0.3, 0.2, col = 'red', lwd=2)\nsegments(1, 0.2, 0.3, 0.2, col = 'red', lwd=2)\ntext(0, 0.15, \"95%\")\nsegments(-2, 0.15, -0.3, 0.15, col = 'red', lwd=2)\nsegments(2, 0.15, 0.3, 0.15, col = 'red', lwd=2)\ntext(0, 0.1, \"99.7%\")\nsegments(-3, 0.1, -0.3, 0.1, col = 'red', lwd=2)\nsegments(3, 0.1, 0.3, 0.1, col = 'red', lwd=2)",
      "line_count": 44
    },
    {
      "section": "Appendix",
      "code": "# load data CaseStudy11_TBI.xlsx\ntmp = tempfile(fileext = \".xlsx\")\ndownload.file(url = \"https://umich.instructure.com/files/416270/download?download_frd=1\", destfile = tmp, mode=\"wb\")\ndf_TBI <- openxlsx::read.xlsx(xlsxFile = tmp, sheet = \"Sheet1\", skipEmptyRows = TRUE)\ndim(df_TBI)",
      "line_count": 5
    },
    {
      "section": "Appendix",
      "code": "# install.packages(\"dendextend\")\nlibrary(dendextend)\n\n# Clean the data first (missing values, characters, etc.)\nna_strings <- c(\"NA\", \".\")\ndf_TBI_clean <- df_TBI %>% naniar::replace_with_na_all(condition = ~.x %in% na_strings)\n\ndf_TBI_clean <- as.data.frame(df_TBI_clean[, -c(3:4)])\ndf_TBI_clean <- df_TBI_clean %>% tidyr::drop_na\t()   \ndim(df_TBI_clean)  # [1] 23 17\n\nrownames(df_TBI_clean) <- as.character(df_TBI_clean[ ,1])\ndf_TBI_clean <- df_TBI_clean[, -1]\ndf_TBI_clean <- as.data.frame(sapply(df_TBI_clean, as.numeric))\ndf_TBI_clean <- df_TBI_clean[, c(\"age\", \"2013.gose\", \"skull.fx\", \"temp.injury\", \"surgery\", \"acute.sz\")]\ndf_TBI_clean <- as.data.frame(scale(df_TBI_clean))\n\nhc <- hclust(dist(df_TBI_clean), \"ave\")\ndend <- as.dendrogram(hc)\nplot_dendro(dend, height = 600) %>% \n  layout(xaxis = list(range = c(-1, 5))) %>% \n  hide_legend() %>% \n  highlight(persistent = TRUE, dynamic = TRUE)\n\n# cutree(hc, k = 2)\n# alternatively specify the height, which is, the value of the criterion associated with the \n# clustering method for the particular agglomeration -- cutree(hc, h= 10)\n\ntable(cutree(hc, h= 3)) # cluster distribution",
      "line_count": 29
    },
    {
      "section": "Appendix",
      "code": "# To identify the number of cases for varying number of clusters we can combine calls to cutree and table \n# in a call to sapply -- to see the sizes of the clusters for $2\\ge k \\ge 10$ cluster-solutions:\n# numbClusters=4; \nmyClusters = sapply(2:5, function(numbClusters)table(cutree(hc, numbClusters)))\nnames(myClusters) <- paste(\"Number of Clusters=\", 2:5, sep = \"\")\nmyClusters",
      "line_count": 6
    },
    {
      "section": "Appendix",
      "code": "#To see which SubjectIDs are in which clusters:\ntable(cutree(hc, k=2)) \ngroups.k.2 <- cutree(hc, k = 2)\nsapply(unique(groups.k.2), function(g) rownames(df_TBI_clean)[groups.k.2 == g])",
      "line_count": 4
    },
    {
      "section": "Appendix",
      "code": "groups.k.3 <- cutree(hc, k = 3)\nsapply(unique(groups.k.3), function(g) df_TBI_clean$age[groups.k.3 == g])\nsapply(unique(groups.k.3), function(g)df_TBI_clean$surgery[groups.k.3 == g])\n\n# Note that there may be dependencies between some variables\nfit <- lm(`2013.gose` ~ age, data = df_TBI_clean)\nplot_ly(df_TBI_clean, x = ~age, y = ~`2013.gose`, type = 'scatter', mode = \"markers\", name=\"Data\") %>% \n    add_lines(x = ~age, y = fit$fitted.values, mode = \"lines\", name=\"Linear Model\") %>%\n    layout(title=paste0(\"Correlation(2013.gose,age) = \", round(cor(df_TBI_clean$`2013.gose`, df_TBI_clean$age),3)))\n\n# drill down deeper\ntable(groups.k.3, df_TBI_clean$surgery)",
      "line_count": 12
    },
    {
      "section": "Appendix",
      "code": "aggregate(df_TBI_clean, list(groups.k.3), median) ",
      "line_count": 1
    },
    {
      "section": "Appendix",
      "code": "library(rvest)\n# draw data\nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SOCR_Data_Dinov_091609_SnP_HomePriceIndex\")\nhm_price_index<- html_table(html_nodes(wiki_url, \"table\")[[1]])\nhead(hm_price_index)\n\nperiod <- lubridate::parse_date_time(paste(hm_price_index$Year, hm_price_index$Month), \"ym\")\n\nhm_price_index <- hm_price_index[, c(-1,-2, -3)]\nhm_price_index$Date <- period\n\nlibrary(reshape2)\nhm_index_melted = melt(hm_price_index, id.vars='Date') #a common trick for plot, wide -> long format\n# ggplot(data=hm_index_melted, aes(x=Date, y=value, color=variable)) +\n#   geom_line(size=1.5) + ggtitle(\"HomePriceIndex:1991-2009\")\n\nplot_ly(hm_index_melted, x=~Date, y=~value, color=~variable,\n        type=\"scatter\", mode=\"lines+markers\") %>%\n  layout(title=\"US Housing Price Index (1991-2009)\", yaxis=list(title=\"HPI\"), legend=list(orientation = 'h'))\n",
      "line_count": 20
    },
    {
      "section": "Appendix",
      "code": "#Linear regression and predict\nhm_price_index$pred = predict(lm(`CA-SanFrancisco` ~ `CA-LosAngeles`, data=hm_price_index))\n# ggplot(data=hm_price_index, aes(x = `CA-LosAngeles`)) +\n#   geom_point(aes(y = `CA-SanFrancisco`)) +\n#   geom_line(aes(y = pred), color='Magenta', size=2) + ggtitle(\"PredictHomeIndex SF - LA\")\n\nplot_ly(hm_price_index, x=~`CA-LosAngeles`, y=~`CA-SanFrancisco`, color=~`Composite-10`,\n        type=\"scatter\", mode=\"lines+markers\", name=\"HPI Data\") %>%\n  add_lines(x = ~`CA-LosAngeles`, y = hm_price_index$pred, mode = \"lines\", name=\"Linear Model\") %>%\n  layout(title=\"LA (SoCal) vs. FS (NoCal)\", yaxis=list(title=\"Los Angeles\"), \n         yaxis=list(title=\"San Francisco\"), legend=list(orientation = 'h'))",
      "line_count": 11
    },
    {
      "section": "Appendix",
      "code": "# install.packages(\"GGally\")\nrequire(GGally)\npairs <- hm_price_index[, 10:15] \nhead(pairs)\ncolnames(pairs) <- c(\"Atlanta\", \"Chicago\", \"Boston\", \"Detroit\", \"Minneapolis\",  \"Charlotte\")\nggpairs(pairs) # you can define the plot design by specifying \"upper\", \"lower\", \"diag\", etc. ",
      "line_count": 6
    },
    {
      "section": "Appendix",
      "code": "library(rvest)\nlibrary(ggplot2)\n#draw data\nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SOCR_Data_LA_Neighborhoods_Data\")\nhtml_nodes(wiki_url, \"#content\")\nLA_Nbhd_data <- html_table(html_nodes(wiki_url, \"table\")[[2]])\n#display several lines of data\nhead(LA_Nbhd_data); \ntheme_set(theme_grey())\n#treat ggplot as a variable\n#When claim \"data\", we can access its column directly e.g., \"x = Longitude\"\nplot1 = ggplot(data=LA_Nbhd_data, aes(x=LA_Nbhd_data$Longitude, y=LA_Nbhd_data$Latitude)) \n#you can easily add attribute, points, label(e.g., :text) \nplot1 + geom_point(aes(size=Population, fill=LA_Nbhd_data$Income), pch=21, stroke=0.2, alpha=0.7, color=2)+\n  geom_text(aes(label=LA_Nbhd_data$LA_Nbhd), size=1.5, hjust=0.5, vjust=2, check_overlap = T)+\n  scale_size_area() + scale_fill_distiller(limits=c(range(LA_Nbhd_data$Income)), palette='RdBu', na.value='white', name='Income') + \n  scale_y_continuous(limits=c(min(LA_Nbhd_data$Latitude), max(LA_Nbhd_data$Latitude))) +\n  coord_fixed(ratio=1) + ggtitle('LA Neighborhoods Scatter Plot (Location, Population, Income)') ",
      "line_count": 18
    },
    {
      "section": "Appendix",
      "code": "library(rvest)\nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SOCR_LetterFrequencyData\")\nletter<- html_table(html_nodes(wiki_url, \"table\")[[1]])\nsummary(letter)\nhead(letter)\nsum(letter[, -1]) #reasonable\n# require(reshape)\n# library(scales)\n# dtm = melt(letter[, -14], id.vars = c('Letter'))\n# p = ggplot(dtm, aes(x = Letter, y = value, fill = variable)) + \n#   geom_bar(position = \"fill\", stat = \"identity\") + \n#   scale_y_continuous(labels = percent_format())+ggtitle('Pie Chart')\n# #or exchange \n# #p = ggplot(dtm, aes(x = variable, y = value, fill = Letter)) + geom_bar(position = \"fill\", stat = \"identity\") + scale_y_continuous(labels = percent_format())\n# p\n# #gg pie plot actually is stack plot + polar coordinate\n# p + coord_polar()\n\nreshape2::melt(letter, id.vars='Letter') %>%\nplot_ly(x = ~Letter, y = ~value, type = 'bar', \n                name = ~variable, color = ~variable) %>%\n      layout(yaxis = list(title = 'Count'), barmode = 'stack')\n",
      "line_count": 23
    }
  ]
}