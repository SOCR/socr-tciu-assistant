{
  "metadata": {
    "created_at": "2024-11-30T13:46:16.278758",
    "total_sections": 5,
    "total_code_chunks": 59,
    "total_tables": 1,
    "r_libraries": [
      "ada",
      "alphahull",
      "caret",
      "e1071",
      "ggplot2",
      "ipred",
      "kernlab",
      "neuralnet",
      "plotly",
      "randomForest",
      "sp",
      "sparsediscrim"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"DSPA2: Data Science and Predictive Analytics (UMich HS650)\"\nsubtitle: \"<h2><u>Black Box Machine-Learning Methods: Neural Networks, Support Vector Machines, Random Forests</u></h2>\"\nauthor: \"<h3>SOCR/MIDAS (Ivo Dinov)</h3>\"\ndate: \"`r format(Sys.time(), '%B %Y')`\"\ntags: [DSPA, SOCR, MIDAS, Big Data, Predictive Analytics] \noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: SOCR_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 3\n    toc_float:\n      collapsed: false\n      smooth_scroll: true\n    code_folding: show\nIn this chapter, we are going to cover several powerful black-box machine learning and artificial intelligence techniques. These techniques have complex mathematical formulations, however, efficient algorithms and reliable software packages have been developed to utilize them for various practical applications. We will (1) describe Neural Networks as analogues of biological neurons, (2) develop hands-on a neural network that can be trained to compute the square-root function, (3) describe support vector machine (SVM) classification, (4) present the random forest as an ensemble ML technique, and (5) analyze several case-studies, including optical character recognition (OCR), the Iris flowers, Google Trends and the Stock Market, and Quality of Life in chronic disease. \n\nLater, in [Chapter 14](https://socr.umich.edu/DSPA2/DSPA2_notes/14_DeepLearning.html), we will provide more details and additional examples of deep neural network learning. For now, let's start by exploring the *mechanics* inside black box machine learning approaches.",
      "word_count": 201
    },
    {
      "title": "Neural Networks",
      "content": "## From biological to artificial neurons\n\nAn `Artificial Neural Network (ANN)` model mimics the biological brain response to multisource (sensory-motor) stimuli (inputs). ANN simulates the brain using a network of interconnected neuron cells to create a massive parallel processor. Indeed, ANNs rely on graphs of artificial nodes, not brain cells, to model intrinsic process characteristics using observational data.\n\nThe basic ANN component is a *cell node.* Suppose we have the input $x=\\{x_i\\}$ to the node feeding information from upstream network nodes, and one output propagating the information downstream through the network. The first step in fitting an ANN involves estimation of the weight coefficients for each input feature. These weights ($w$'s) correspond to the relative importance of each input. Then, the weighted signals are summed by the \"neuron cell\" and this sum is passed on according to an **activation function** denoted by $f(\\cdot)$. The last step is generating an output $y$ at the end of each node. A typical output will have the following mathematical relationship to the inputs. The weights $\\{w_i\\}_{i\\ge 1}$ control the weight-averaging of the inputs, $\\{x_i\\}$, used to assess the activation function. The constant factor weight $w_o$ and the corresponding *bias term* $b$ allows us to shift or offset the entire activation function (left or right).\n$$\\underbrace{y(x)}_{output}=f\\left (w_o \\underbrace{b}_{bias}+\\sum_{i=1}^n \\overbrace{w_i}^{weights} \\underbrace{x_i}_{inputs}\\right ).$$\n\nThere are three important components for building a neural network:\n\n - **Activation function**: transforms weighted and aggregated inputs into an output.\n - **Network topology**: describes the number of “neuron cells”, the number of layers, nodes per layer, and manner in which the cells are connected.\n - **Training algorithm**: optimization strategy to estimate the network weights $\\{w_i\\}$.\n\nLet's look at each of these components one by one.\n\n## Activation functions\n\nThere are many alternative activation functions. One example is a threshold activation function that results in an output signal only when a specified input threshold has been attained.\n\n\n$$f(x)= \\left\\{\n\\begin{array}{ll}\n      0 & x<0 \\\\\n      1 & x\\geq 0 \\\\\n\\end{array} \n\\right. .$$\n\nThis is the simplest form of an activation function. It may be rarely used in real world situations. Most commonly used alternative is the sigmoid activation function where $f(x)=\\frac{1}{1+e^{-x}}$. The *Euler number* $e$ is defined by the limit of $e=\\displaystyle\\lim_{n\\longrightarrow\\infty}{\\left ( 1+\\frac{1}{n}\\right )^n}$. The output signal is no longer binary but can be any real number ranging from 0 to 1. \n\n\nOther activation functions might also be useful:\n\n\nDepending on the specific problem, we can choose a proper activation function based on the needs for a corresponding codomain or function range. For example, with hyperbolic tangent activation function, we can only have outputs ranging from -1 to 1 regardless of what input we have. With linear functions the output may range from $-\\infty$ to $+\\infty$. The Gaussian activation function yields an ANN model called *Radial Basis Function* network.\n\n## Network topology\n\nThe number of layers: The $x$'s, or features, in the dataset are called **input nodes** while the predicted values are called the **output nodes**. Multilayer networks include multiple hidden layers. The following graph represents a two-layer neural network: \n\n![](https://wiki.socr.umich.edu/images/3/36/DSPA_Figs_TwoLayer_Chapter6.png)\n$$\\text{Two Layer network.}$$\n\nWhen we have multiple layers, the information flow could be complicated.\n\n## The direction of information travel\n\nThe arrows in the last graph (with multiple layers) suggest a feed forward network. In such networks, we can also have multiple outcomes modeled simultaneously.\n\n![](https://wiki.socr.umich.edu/images/0/07/DSPA_Figs_multioutput_Chapter6.png)\n$$\\text{Multi-output}$$\n\nAlternatively, in a recurrent network (feedback network), information can also travel backwards in loops (or delays). This is illustrated in the following graph.  \n\n![](https://wiki.socr.umich.edu/images/f/f9/DSPA_Figs_delay_chapter6.png)\n$$\\text{Delay(feedback network)}$$\n\nThis short-term memory increases the power of recurrent networks dramatically. However, in practice, recurrent networks are not commonly used.\n\n## Network layers\n\nIn any network, the number of input nodes and output nodes are predetermined by the predictive variables in the dataset and the desired prediction outcome. Typically, researchers can specify the number of hidden layers and the number of nodes in each layer of the network model. Ideally, simpler networks with fewer nodes and lower number of hidden layers are preferred for simplicity, computational efficiency, and network model interpretability. \n\n## Training neural networks with backpropagation\n\nThis algorithm could determine the weights in the model using the strategy of optimizing back-propagating errors. First, we assign random weight values (all weights must be non-trivial, i.e., $\\not= 0$). For example, we can use a normal distribution, or any other random process, to assign initial weights (priors). Then, we can adjust the weights iteratively by repeating the process until a certain convergence or stopping criterion is met. Each iteration contains two phases. \n\n - *Forward phase*: run the data from the input layer to output layer using the current iteration weight estimates,\n - *Backward phase*: compare the generated outputs and the true target values (training validation). If the difference is significant, we change the weights and go through the forward phase, again.\n\nIn the end, we pick a set of weights minimizing the total aggregate error to be the weights of the specific neural network.\n\n## Case Study 1: Google Trends and the Stock Market - **Regression**\n\n### Step 1 - collecting data\n\nIn this case study, we are going to use the [Google trends and stock market dataset](https://wiki.socr.umich.edu/index.php/SOCR_Data_GoogleTrends_2005_2011). A [doc file with the meta-data](https://umich.instructure.com/files/416273/download?download_frd=1) and the [CSV data](https://umich.instructure.com/files/416274/download?download_frd=1) are available on the [supporting Case-Studies Canvas Site](https://umich.instructure.com/courses/38100/files/folder/Case_Studies). These daily data (between 2008 and 2009) can be used to examine the associations between Google search trends and market conditions, e.g., real estate or stock market indices.\n\n#### Variables\n\n - **Index**: Time Index of the Observation\n - **Date**: Date of the observation (Format: YYYY-MM-DD)\n - **Unemployment**: The Google Unemployment Index tracks queries related to \"unemployment, social, social security, unemployment benefits\" and so on.\n - **Rental**: The Google Rental Index tracks queries related to \"rent, apartments, for rent, rentals\", etc.\n - **RealEstate**: The Google Real Estate Index tracks queries related to \"real estate, mortgage, rent, apartments\" and so on.\n - **Mortgage**: The Google Mortgage Index tracks queries related to \"mortgage, calculator, mortgage calculator, mortgage rates\".\n - **Jobs**: The Google Jobs Index tracks queries related to \"jobs, city, job, resume, career, monster\" and so forth.\n - **Investing**: The Google Investing Index tracks queries related to \"stock, finance, capital, yahoo finance, stocks\", etc.\n - **DJI_Index**: The Dow Jones Industrial (DJI) index. These data are interpolated from 5 records per week (Dow Jones stocks are traded on week-days only) to 7 days per week to match the constant 7-day records of the Google-Trends data.\n - **StdDJI**: The standardized-DJI Index computed by: StdDJI = 3+(DJI-11091)/1501, where m=11091 and s=1501 are the approximate mean and standard-deviation of the DJI for the period (2005-2011).\n - **30-Day Moving Average Data Columns**: The 8 variables below are the 30-day moving averages of the 8 corresponding (raw) variables above: *Unemployment30MA, Rental30MA, RealEstate30MA, Mortgage30MA, Jobs30MA, Investing30MA, DJI_Index30MA*, and *StdDJI_30MA*.\n - **180-Day Moving Average Data Columns**: The 8 variables below are the 180-day moving averages of the 8 corresponding (raw) variables: *Unemployment180MA, Rental180MA, RealEstate180MA, Mortgage180MA, Jobs180MA, Investing180MA, DJI_Index180MA*, and *StdDJI_180MA*.\n\nWe’ll remove the first two columns since the goal now is to model and predict Real Estate or other economic indices.\n\n### Step 2 - exploring and preparing the data\n\nFirst we need to load the dataset into `R`.\n\n\nLet's delete the first two columns, since the only goal is to predict Google Real Estate Index with other indexes and DJI.\n\n\nAs we can see from the structure of the data, these indexes and DJI have different ranges. We should `rescale` the data to make all features unitless, and therefore, comparable. In [Chapter 5](https://socr.umich.edu/DSPA2/DSPA2_notes/05_SupervisedClassification.html), we learned that normalizing these features using our own `normalize()` function could fix the problem of heterogeneity of measuring units across features. We can use `lapply()` to apply the `normalize()` function to each feature (column in the data frame).\n\n\nThe last step clearly normalizes all feature vectors into the range $[0,1]$.\n\nThe next step would be to split the `google` dataset into *training* and *testing* sets. This time we will use the `sample()` and `floor()` function to separate training and test dataset (75:25). The `sample()` function creates a set of (random) indicators for row indices. We can subset the original dataset with random rows using these indicators. The `floor()` function takes a number *x* and returns the closest integer to *x*.\n\n`sample(row, floor(size))`\n\n - *row*: rows in the dataset that you want to select from. If you want to select all the rows, you can use $nrow(data)$ or $1:nrow(data)$ (for a single number or a vector).\n - *size*: how many rows you want for your subset.\n\n\nFollowing this data preprocessing, can move forward with the neural network training phase.\n\n### Step 3 - training a model on the data\n\nHere, we use the function `neuralnet::neuralnet()`, which returns a NN object containing:\n\n - *call*; the matched call.\n - *response*; extracted from the data argument.\n - *covariate*; the variables extracted from the data argument.\n - *model.list*; a list containing the covariates and the response variables extracted from the formula argument.\n - *err.fct* and *act.fct*; the error and activation functions.\n - *net.result*; a list containing the overall result of the neural network for every repetition.\n - *weights*; a list containing the fitted weights of the neural network for every repetition.\n - *result.matrix*; a matrix containing the reached threshold, needed steps, error, AIC, BIC, and weights for every repetition. Each column represents one repetition.\n\n`m <- neuralnet(target ~ predictors, data=mydata, hidden=1)`, where:\n\n - *target*: variable we want to predict.\n - *predictors*: predictors we want to use. Note that we cannot use \".\" to denote all the variables in this function. We have to add all predictors one by one to the model.\n - *data*: training dataset.\n - *hidden*: number of hidden nodes that we want to use in the model. By default, it is set to one.\n\n![](https://wiki.socr.umich.edu/images/e/e5/DSPA_Figs_plot_google_model_Ch6.png)\n\nThe above graph shows that we have only one hidden node. `Error` represents the aggregate sum of squared errors and `Steps` indicates the number of iterations until the ANN model converged. Note that these outputs could be different when you run exact same model-fitting optimization because the weights are stochastically estimated.\n\nAlso, *bias nodes* (blue singletons in the graph) may be added to feedforward neural networks acting like intermediate input nodes that produce constant values, e.g., 1. They are not connected to nodes in previous layers, yet they generate biased activation. Bias nodes are not required but are helpful in some neural networks as they allow network flexibility by offsetting the activation functions.\n\n### Step 4 - evaluating model performance\n\nSimilar to the `predict()` function that we have mentioned in previous chapters, `compute()` is an alternative method that could help us to generate the model predictions.\n\n`p<-compute(m, test)`\n\n - *m*: a trained neural networks model.\n - *test*: the test dataset. This dataset should only contain the same type of predictors in the neural network model.\n\nOur model used `Unemployment, Rental, Mortgage, Jobs, Investing, DJI_Index, StdDJI` as predictors. Therefore, we need to reference these corresponding column numbers in the test dataset, i.e., columns 1, 2, 4, 5, 6, 7, 8, respectively.\n\n\nAs mentioned in [Chapter 3](https://socr.umich.edu/DSPA2/DSPA2_notes/03_LinearAlgebraMatrixComputingRegression.html), we can still use the correlation between predicted results and observed Real Estate Index to evaluate the algorithm. For real datasets, a correlation exceeding $0.9$ is a very good indicator of the performance of the NN model. Could this be improved further?\n\n### Step 5 - improving model performance\n\nThis time we will include $4$ hidden nodes in the single-layer NN model. Let's see what results we can get from this more complicated model.\n\n![](https://wiki.socr.umich.edu/images/d/d1/DSPA_Figs_plot_google_model2_ch6.png)\n\nAlthough the graph looks more complicated than the previous neural network, we have smaller `Error`, i.e., sum of squared errors. The neural network models may be used both for *classification* and *regression*, which we will see in the next part. Let's first try regression.\n\n\nWe get an even higher correlation. This is almost an ideal result! The predicted and observed `RealEstate` indices have a strong linear relationship. Nevertheless, too many hidden nodes might sometimes decrease the correlation between predicted and observed values, which will be examined in the practice problems later in this chapter.\n\n\n### Step 6 - adding additional layers\n\nWe observe an even lower `Error` by using three hidden layers, each with $4,3,3$ nodes, respectively. However, this enhanced neural network may complicate the interpretation of the results (or may overfit the network to intrinsic noise in the data).\n\n\n## Simple NN demo - learning to compute $\\sqrt {\\ \\ \\ }$\n\nNeural networks can be used at the interface of experimental, theoretical, computational and data sciences. Here is one powerful example, [data science applications to string theory](https://doi.org/10.1016/j.physrep.2019.09.005).\n\nWe will demonstrate the foundation of the neural network prediction to estimate a basic mathematical function, square-root, $\\sqrt {\\ \\ \\ }: \\mathbb{R}^+ \\longrightarrow \\mathbb{R}^+$. First, let’s generate and plot the data.\n\n\nNext, fit the NN model.\n\n\nExamine the NN-prediction results on testing data.\n\n\nWe observe that the NN, `net.sqrt` actually learns and predicts pretty close to the complex square root function. Of course, everyone's results may vary as we randomly generate the training data (rand_data) and the NN construction (net.sqrt) is also stochastic.\n\n## Stochastic Neural Networks - Restricted Boltzmann Machines (RBMs)\n\n[DSPA Appendix 12 (Stochastic Neural Networks - Restricted Boltzmann Machine (RBM))](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_12_BoltzmannMachines\n.html) includes a description of stochastic neural networks, and more specifically, *Restricted Boltzmann Machine (RBM)*. RBMs are used for tasks such as dimensionality reduction, classification, regression, collaborative filtering, feature learning, and generative modeling. Its foundations span mathematics, statistics, and physics, with each field contributing essential principles to the structure and function of RBMs. This appendix provides an example of training \na RBM to predict the function $f(x)=x-\\sin(x)$.\n\n\n## Case Study 2: Google Trends and the Stock Market - *Classification*\n\nIn practice, NN may be more useful as a classifier. Let's demonstrate this by using the Stock Market data. We mark the samples according to their `RealEstate` categorization. Those higher than $75\\%$ percentile will be labeled $0$, those lower than $0.25$ percentile will get labeled $2$, and those in between will get labeled $1$. Note that even in the classification setting, the responses still must be numeric.\n\n\nWe divide the data into training and testing sets and generate three derived one-hot-encoding features (dummy variables), which correspond to the three `RealEstate` outcome labels (categories).\n\n\nWe specify non-linear output and report intermediate results every $5,000$ iterations.\n\n\nBelow is the prediction function using this neural network model to forecast the `RealEstate` class label.\n\n\nFinally, report the confusion matrix illustrating the agreement/disagreement between the 3 observed `RealEstate` class labels and their (NN) predicted counterparts.\n\n\nNow let's inspect the structure of the resulting Neural Network.\n\n\nSimilarly, we can change `hidden` to utilize multiple hidden layers, however, a more complicated model won't necessarily guarantee an improved performance.",
      "word_count": 2444
    },
    {
      "title": "Support Vector Machines (SVM)",
      "content": "Recall that in [Chapter 5](https://socr.umich.edu/DSPA2/DSPA2_notes/05_SupervisedClassification.html) we presented lazy machine learning methods, which assign class labels using geometrical distances of different features. In multidimensional feature spaces, we can utilize spheres, centered according to the training dataset, to assign testing data labels. What kinds of shapes may be embedded in $nD$ space to help with the classification process?\n\n## Classification with hyperplanes\n\nThe easiest shape would be an $(n-1)D$ plane embedded in $nD$, which splits the entire space into two parts. Support Vector Machines (SVM) can use hyperplanes to split the data into separate groups, or classes. Obviously, this may be useful for datasets that are *linearly separable*.\n\nAs an example, consider lines, $(n-1)D$ planes, embedded in $\\mathbb{R}^2$. Assuming that we have only two features, will you choose line $A$ or line $B$ as the better `hyperplane` separating the data? Or even another plane $C$?\n\n\n### Finding the maximum margin\n\nTo answer the above question, we need to search for the **Maximum Margin Hyperplane (MMH)**. That is the hyperplane that creates greatest separation between the two closest observations.\n\nWe define support vectors as the points from each class that are closest to MMH. Each class must have at least one observation as a support vector.\n\nUsing support vectors alone is insufficient for finding the MMH. Although some mathematical calculations are involved, the fundamentals of the SVM process is fairly simple. Let's look at linearly separable data and non-linearly separable data individually.\n\n### Linearly separable data\n\nIf the dataset is linearly separable, we can find the outer boundaries of our two groups of data points. These boundaries are called convex hulls (red lines in the following graph). The MMH line (orange solid) is just the line that is perpendicular to the shortest line (green dash) between the two convex hulls.\n\n\nMind the difference between *convex hull* and *concave hull* of a set of points.\n\n\nAn alternative way to linearly separate the data into (two) clusters is to find two parallel planes that can separate the data into two groups, and then increase the distance between the two planes as much as possible.\n\nWe can use vector notation to mathematically define planes. In $n$-dimensional space, a plane could be expressed by the following equation:\n$$\\vec{w}\\cdot\\vec{x}+b=0,$$\nwhere $\\vec{w}$ (weights) is the plane normal vector, $\\vec{x}$ is the vector of unknowns, both have *n* coordinates, and $b$ is a constant scalar that completely determines the plane (as it specifies a point the plane goes through). \n\nTo clarify this notation let's look at the situation in a 3D space where we can express (embed) 2D Euclidean planes using a point $(x_o,y_o,z_o)$ and normal-vector $(a,b,c)$ form. This is just a linear equation, where $d=-(ax_o + by_o + cz_0)$:\n$$ax + by + cz + d = 0,$$\nor equivalently\n$$w_1x_1+w_2x_2+w_3x_3+b=0$$\nWe can see that it is equivalent to the vector notation\n\nUsing the vector notation, we can specify two hyperplanes as follows:\n$$\\vec{w}\\cdot\\vec{x}+b\\geq+1$$\nand\n$$\\vec{w}\\cdot\\vec{x}+b\\leq-1$$\nWe require that all of the observations in the first class fall above the first plane and all observations in the other class fall below the second plane.\n\nThe distance between two planes is calculated as:\n$$\\frac{2}{\\lVert \\vec{w}\\rVert}$$\nwhere $\\lVert  \\cdot \\rVert$ is the Euclidean norm. To maximize the distance, we need to minimize the Euclidean norm.\n\nTo sum up we are going to find $\\min\\frac{\\lVert \\vec{w}\\rVert}{2}$ subject to the following constrain\n\n$$y_i(\\vec{w}\\cdot\\vec{x_i}-b)\\geq1, \\, 0\\leq i\\leq n\\ ,$$\nwhere for each data point index $i$, $y_i= \\pm1$ correspond to ${w}\\cdot x_{i} - b \\geq 1$ and ${w}\\cdot x_{i} - b \\leq -1$, respectively.\n\nWe will see more about *constrained and unconstrained optimization* later in [Chapter 13](https://socr.umich.edu/DSPA2/DSPA2_notes/13_FunctionOptimization.html). For each nonlinear programming problem, the **primal problem**, there is related nonlinear programming problem, also known as the **Lagrangian dual problem**. Under certain assumptions for convexity and suitable constraints, the [primal and dual problems have equal optimal objective values](https://socr.umich.edu/DSPA2/DSPA2_notes/13_FunctionOptimization.html). Primal optimization problems are typically described as:\n\n$$\\begin{array}{rcl} \\min_x{f(x)} \\\\ \n\\text{subject to}  \\\\\ng_i(x) \\leq 0\\\\\nh_j(x) = 0 \\\\\n\\end{array}.$$\n\nThen the Lagrangian dual problem is defined as a parallel nonlinear programming problem\n\n$$\\begin{array}{rcl} & \\min_{u,v}{\\theta(u,v)} & \\\\ \n& \\text{subject to} & \\\\\n& u \\geq 0 & \\\\\n\\end{array},$$\nwhere \n$$ \\theta(u,v)= \\inf_{x}{ \\left ( f(x)+\\displaystyle\\sum_i {u_i g_i(x)} +\\displaystyle\\sum_j {v_j h_j(x)} \\right )}.$$\n\n[Chapter 13](https://socr.umich.edu/DSPA2/DSPA2_notes/13_FunctionOptimization.html) provides additional technical details about optimization duality. \n\nSuppose the Lagrange primal is \n$$L_p = \\frac{1}{2}||w||^2-\\sum_{i=1}^{n}\\alpha_i[y_i(w_0+x_i^{t}w)-1],\\ \\text{where}\\ \\alpha_i\\geq 0.$$\n\nTo optimize that objective function, we can set the partial derivatives equal to zero:\n\n$$\\frac{\\partial}{\\partial w}\\ :\\ w = \\sum_{i=1}^{n}\\alpha_iy_ix_i$$\n\n$$\\frac{\\partial}{\\partial b}\\ :\\ 0 = \\sum_{i=1}^{n}\\alpha_iy_i.$$\n\nSubstituting into the Lagrange primal, we obtain the Lagrange dual:\n\n$$L_D = \\sum_{i=1}^{n}\\alpha_i - \\frac{1}{2} \\sum_{i=1}^{n}\\alpha_i\\alpha_i' y_i y_i' x_i^t x_i '=\n\\sum _{i=1}^{n}\\alpha_i-{\\frac {1}{2}}\\sum _{i=1}^{n}\\sum _{j=1}^{n}y_{i}\\alpha_{i}(x_{i}\\cdot x_{j})y_{j}\\alpha_{j}.$$\n\nThen, we maximize $L_D$ subject to $\\alpha_i \\geq 0$ and $\\sum_{i=1}^{n}\\alpha_iy_i =0$.\nFor each $i\\in \\{1,\\,\\cdots ,\\,n\\}$, this iterative optimization results in adjusting\nthe coefficient $\\alpha_{i}$ in the direction of \n$\\frac{\\partial f}{\\partial \\alpha_{i}}$. \n\nHence, the resulting coefficient vector $(\\alpha_{1}',\\cdots ,\\alpha_{n}')$ is projected onto the nearest vector of coefficients which satisfies the given constraints. Repeating this process drives the coefficient vector to a local optimum.\n\nBy the [Karush-Kuhn-Tucker optimization conditions](https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions), we have $\\hat\\alpha[y_i(\\hat{b}+x_i^t\\hat{w})-1]=0.$\n\nThis implies that if $y_i \\hat{f}(x_i)>1$, then $\\hat{\\alpha}_i=0$.\n\nThe **support** of a function ($f(x_i)=\\hat{b}+x_i^t\\hat{w}$) is the smallest subset of the domain containing only arguments ($x$) which are not mapped to zero ($f(x)\\not=0$). In our case, the solution $\\hat{w}$ is defined in terms of a linear combination of the **support points**:\n\n$$\\hat{f}(x)=w^t x = w = \\sum_{i=1}^{n}\\alpha_iy_ix_i. $$\n\nThat's where the name of Support Vector Machines (SVM) comes from.\n\n### Non-linearly separable data\n\nFor non-linearly separable data, we employ the *kernel trick* to linearize the problem in a higher dimensional space. Still, we use a separating hyperplane, but allow some of the points to be misclassified into the wrong class. To penalize for misclassification, we add a regularization term after the fidelity term (Euclidean norm) and then minimize the additive mixture of the two terms.\n\nTherefore, the solution will optimize the following *regularized* objective (cost) function:\n$$\\min \\left (\\frac{\\lVert \\vec{w}\\rVert}{2} +C\\sum_{i=1}^{n} \\xi_i \\right )$$\n$$\\text{subject to}$$\n$$y_i(\\vec{w}\\cdot\\vec{x}_i-b)\\geq1, \\, \\forall\\vec{x}_i, \\, \\xi_i\\geq0,$$\nwhere hyperparameter $C$ controls the error term (regularization) penalty and $\\xi_i$ is the distance between the misclassified observation $i$ and the plane.\n\nWe have the following Lagrange primal problem: \n$$L_p = \\frac{1}{2}||w||^2 + C\\sum_{i=1}^{n}\\xi_i-\\sum_{i=1}^{n}\\alpha_i[y_i(b+x_i^{t}w)-(1-\\xi_i)] - \\sum_{i=1}^{n}\\gamma_i\\xi_i,$$\nwhere $$\\alpha_i,\\gamma_i \\geq 0.$$\n\nSimilar to what we did earlier in the linearly separable case, we can use the derivatives of the primal problem to solve the dual problem. \n\nNotice the inner product in the final expression. We can replace this inner product with a kernel function that maps the feature space into a higher dimensional space (e.g., using a polynomial kernel) or an infinite dimensional space (e.g., using a Gaussian kernel).\n\n### Using kernels for non-linear spaces\n\nAn alternative way to solve for the non-linear separable is called the *kernel trick*. That is to add new dimensions (or features) to make these non-linear separable data to be separable in a higher dimensional space. \n\nThe solution of the quadratic optimization problem in this case involves *regularized* objective function:\n$$\\min_{w, b} \\left (\\frac{\\lVert \\vec{w}\\rVert}{2} +C\\sum_{i=1}^{n} \\xi_i \\right ),$$\n$$\\text{subject to}$$\n$$y_i(\\vec{w}\\cdot\\phi (\\vec{x}_i)-b)\\geq 1 -\\xi_i, \\, \\forall\\vec{x}_i, \\, \\xi_i\\geq 0.$$\nAgain, the hyperparameter $C$ controls the regularization penalty and $\\xi_i$ are the slack variables introduced by lifting the initial low-dimensional (non-linear) problem to a new higher dimensional linear problem. The quadratic optimization of this (primal) higher-dimensional problem is similarly transformed into a Lagrangian dual problem:\n\n$$L_p = \\max_{\\alpha} \\min_{w, b} \\left \\{\\frac{1}{2}||w||^2 + C\\sum_{i=1}^{n}\\alpha_i \\left ( 1- w^T\\phi(\\vec{x}_i) +b  \\right )\\right \\},$$\nwhere $$0\\leq \\alpha_i \\leq C, \\forall i.$$\n\nThe solution to the Lagrange dual problem provides estimates of $\\alpha_i$ and we can predict the *class label* of a new sample $x_{test}$ via:\n\n$$y_{test}={\\text{sign}}\\left (w^t \\phi (x_{test})+b\\right )=\n{\\text{sign}}\\left ( \\sum_{i=1}^{n} \\alpha_i y_i \\ \\underbrace{\\phi(\\vec{x}_{i,test})^t \\phi(\\vec{x}_{j,test})}_{kernel, \nK(\\vec{x}_i,\\vec{x}_j)=\\phi(\\vec{x}_{i,test}). \\phi(\\vec{x}_{j,test})} +b  \\right ).$$\n\nBelow is one example where the 2D data (`mtcars`, $n=32, k=10$ cars fuel consumption) doesn't appear as linearly separable in its native 2D ($weight\\times horsepower$), the binary colors correspond to *V-shaped* or *Straight* engine type.\n\n\nHowever, the data can be lifted in 3D where it is more clearly linearly separable (by engine type) via a 2D plane.\n\n\nHow can we do that in practice? We transform our data using kernel functions. A general form for kernel functions would be:\n$$K(\\vec{x_i}, \\vec{x_j})=\\phi(\\vec{x_i})\\cdot\\phi(\\vec{x_j}),$$\nwhere $\\phi$ is a mapping of the data into another space.\n\nThe linear kernel would be the simplest one that is just the dot product of the features.\n$$K(\\vec{x_i}, \\vec{x_j})=\\vec{x_i}\\cdot\\vec{x_j}.$$\nThe polynomial kernel of degree *d* transform the data by adding a simple non-linear transformation of the data.\n$$K(\\vec{x_i}, \\vec{x_j})=(\\vec{x_i}\\cdot\\vec{x_j}+1)^d.$$\nThe sigmoid kernel is very similar to the neural networks approach. It uses a sigmoid activation function.\n$$K(\\vec{x_i}, \\vec{x_j})=\\tanh(k\\vec{x_i}\\cdot\\vec{x_j}-\\delta).$$\nThe Gaussian radial basis function (RBF) kernel is similar to RBF neural network and may be a good place to start, in general.\n$$K(\\vec{x_i}, \\vec{x_j})=\\exp \\left (\\frac{-\\lVert \\vec{x_i}-\\vec{x_j}\\rVert^2}{2\\sigma^2}\\right ) .$$\n\n## Case Study 3: Optical Character Recognition (OCR)\n\nIn [Chapter 4](https://socr.umich.edu/DSPA2/DSPA2_notes/04_DimensionalityReduction.html) we saw machine learning strategies for hand-written digit recognition. We now want to expand that to character recognition. The following example illustrates management and transferring of handwritten notes (text) and converting them to typeset or printed text representing the characters in the original notes (unstructured image data).\n\n*Protocol*:\n\n - Divide the image (typically optical image of handwritten notes on paper) into a fine grid where each cell contains 1 glyph (symbol, letter, number).\n - Match the glyph in each cell to 1 of the possible characters in a dictionary.\n - Combine individual characters together into words to reconstitute the digital representation of the optical image of the handwritten notes.\n \nIn this example, we use an optical document image (data) that has already been pre-partitioned into rectangular grid cells containing 1 character of the [26 English letters, A through Z](https://wiki.socr.umich.edu/index.php/SOCR_LetterFrequencyData).\n\nThe resulting gridded dataset is distributed by the [UCI Machine Learning Data Repository](https://archive.ics.uci.edu/ml). The [dataset contains 20, 000 examples of 26 English capital letters printed using 20 different randomly reshaped and morphed fonts](https://umich.instructure.com/courses/38100/files/folder/Case_Studies/16_HandwrittenLetters).\n\n![This figure show an example of the preprocessed gridded handwritten letters.](https://wiki.socr.umich.edu/images/2/2d/SOCR_Data_Dinov_EnglishLetterFrequency_Fig2.png)\n\n### Step 1: Prepare and explore the data\n\nLoad the data and split it into training and testing sets.\n\n\n### Step 2: Training an SVM model\n\nWe can specify `vanilladot` as a linear kernel, or alternatively:\n\n - `rbfdot` Radial Basis kernel i.e, \"Gaussian\" \n - `polydot` Polynomial kernel\n - `tanhdot` Hyperbolic tangent kernel\n - `laplacedot` Laplacian kernel\n - `besseldot` Bessel kernel\n - `anovadot` ANOVA RBF kernel\n -  `splinedot` Spline kernel \n - `stringdot` String kernel\n\n\n\n### Step 3: Evaluating model performance\n\n\n### Step 4: Improving model performance\n\nReplacing the `vanilladot` linear kernel with `rbfdot` Radial Basis Function kernel, i.e., \"Gaussian\" kernel may improve the OCR prediction.\n    \n\nNote the improvement of automated (SVM) classification accuracy ($0.928$) for `rbfdot` compared to the previous (`vanilladot`) result ($0.844$).\n\n## Case Study 4: Iris Flowers\n\nLet's have another look at the *iris data* that we saw in [Chapter 2](https://socr.umich.edu/DSPA2/DSPA2_notes/02_Visualization.html).\n\n### Step 1 - collecting data\n\nSVM requires all features to be numeric and each feature has to be scaled into a relatively small interval. We are using Edgar Anderson's Iris Data in R for this case study. This dataset measures the length and width of sepals and petals from three Iris flower species.\n\n### Step 2 - exploring and preparing the data\n\nLet's load the data first. In this case study we want to explore the variable `Species`.\n\n\nThe data looks good. However, recall that we need fairly normalized data. We could normalize the data by hand. Luckily, the `R` package we are going to use will normalize the dataset automatically.\n\nNow we can separate the training and test dataset using the $75\\%-25\\% rule.\n\n\nLet's first try a toy (iris data) example.\n\n\n### Step 3 - training a model on the data\n\nWe are going to use `kernlab` for this case study. However other packages like `e1071` and `klaR` are available if you are quite familiar with C++.\n\nLet's break down the function `ksvm()`\n\n`m<-ksvm(target~predictors, data=mydata, kernel=\"rbfdot\", c=1)`\n\n - *target*: the outcome variable that we want to predict.\n - *predictors*: features that the prediction is based on. In this function we can use the \".\" to represent all the variables in the dataset again.\n - *data*: the training dataset that the *target* and *predictors* can be found.\n - *kernel*: is the kernel mapping we want to use. By default, it is the radial basis function (`rbfdot`).\n - $C$ is a number that specifies the cost of misclassification.\n\nLet's install the package and test it with some real data.\n\n\nHere, we used all the variables other than the `Species` in the dataset as predictors. In this model, we used the kernel `vanilladot`, a linear kernel, and obtained a training error of about 0.03.\n\n### Step 4 - evaluating model performance\n\nGiven any pre-fit model, we have already used the `predict()` function to make predictions. Here we have a factor outcome, so we need the command `table()` to show us how well the predictions and actual data match.\n\n\nWe can see that only a few cases of Iris `versicolor` flowers may be classified as `virginica`. The species of the majority of the flowers are all correctly identified.\n\nTo see the results more clearly, we can use the proportional table to show the agreements of the categories.\n\n\nHere `==` means \"equal to\". Over 90% of predictions are correct. Nevertheless, is there any chance that we can improve the outcome? What if we try a Gaussian kernel?\n\n### Step 5 - RBF kernel function\n\nLinear kernel is the simplest one but usually not the best one. Let's try the **RBF (Radial Basis \"Gaussian\" Function)** kernel instead.\n\n\nThe model performance did not drastically improve, compared to the previous *linear* kernel case (you might get slightly different results). This is because this Iris dataset has a mostly linear feature space separation. In practice, we could try alternative kernel functions and see which one fits the dataset the best.\n\n## Parameter Tuning\n\nWe can tune the SVM using the `tune.svm` function in the package `e1071`.\n\n\nFurther, we can draw a **cv** plot to gauge the model performance:\n\n\n## Improving the performance of Gaussian kernels\n\nNow, let's attempt to improve the performance of a Gaussian kernel by tuning:\n\n\nWe observe that the model achieves a better prediction now.\n\n\n[Chapter 14](https://socr.umich.edu/DSPA2/DSPA2_notes/14_DeepLearning.html) provides more details about neural networks and deep learning.",
      "word_count": 2395
    },
    {
      "title": "Ensemble meta-learning",
      "content": "*Meta-learning* involves building and ensembling multiple learners relying either on single or multiple learning algorithms. Meta-learners combine the outputs of several techniques and report consensus results that are more reliable, in general. For example, to decrease the [*variance* (bagging) or *bias* (boosting)](https://wiki.socr.umich.edu/index.php/SMHS_BiasPrecision), **random forest** attempts in two steps to correct the general decision trees' trend to overfit the model to the training set:\n\n 1. Step 1: producing a distribution of simple ML models on subsets of the original data.\n 2. Step 2: combine the distribution into one \"aggregated\" model.\n\nBefore stepping into the details, let's briefly summarize:\n\n - *Bagging* (stands for Bootstrap Aggregating) is the way to decrease the variance of your prediction by generating additional data for training from your original dataset using combinations with repetitions to produce multiple samples of the same cardinality/size as your original data. We can't expect to improve the model predictive power by synthetically increasing the size of the training set, however we may decrease the variance by narrowly tuning the prediction to the expected outcome.\n\n - *Boosting* is a two-step approach that aims to reduce bias in parameter estimation. First, we use subsets of the original data to produce a series of moderately performing models and then \"boost\" their performance by combining them together using a particular cost function (e.g., Accuracy). Unlike bagging, in classical boosting, the subset creation is not random and depends upon the performance of the previous models: every new subset contains the elements that were (likely to be) misclassified by previous models. Usually, when using boosting, we prefer weaker classifiers. For example, a prevalent choice is to use a stump (level-one decision tree) in AdaBoost (Adaptive Boosting).\n\n## Bagging\n\nOne of the most well-known meta-learning method is bootstrap aggregating or *bagging*. It builds multiple models with bootstrap samples using a single algorithm. The models' predictions are combined with voting (for classification) or averaging (for numeric prediction). Voting means the bagging model's prediction is based on the majority of learners' prediction for a class. Bagging is especially good with unstable learners like decision trees or SVM models.\n\nTo illustrate the Bagging method we will again use the Quality of life and chronic disease dataset we saw earlier in [Chapter 5](https://socr.umich.edu/DSPA2/DSPA2_notes/05_SupervisedClassification.html). Just like we did in the second practice problem in this chapter, we will use `CHARLSONSCORE` as the class label, which has 11 different levels.\n\n\nTo apply `bagging()`, we need to download the `ipred` package first. After loading the package, we build a bagging model with `CHARLSONSCORE` as class label and all other variables in the dataset as predictors. We can specify the number of voters (decision tree models we want to have), which defaults to 25.\n\n\nThe result, `mybag`, is a complex class object that includes `y` (vector of responses), `X` (data frame of predictors), `mtrees` (multiple trees as a list of length *nbagg* containing the trees for each bootstrap sample, `OOB` (logical indicating whether the out-of-bag estimate should be computed), `err` error\t(if OOB=TRUE, the out-of-bag estimate of misclassification or root mean squared error or the Brier score for censored data), and comb\t(Boolean indicating whether a combination of models was requested).\n\nNow we will use the `predict()` function to apply this forecasting model. For evaluation purposes, we create a table to inspect the re-substitution error.\n\n\nThis model works very well with its training data. It labeled 99.8% of the cases correctly. To evaluate its performance on testing data, we apply the `caret` `train()` function again with 10 repeated CVs as a re-sampling method. In `caret`, the bagged trees method is called `treebag`.\n\n\nWell, we got a very marginal accuracy of 52% and a fair Kappa statistics. This result is better than the one we got earlier using the `ksvm()` function alone ($\\sim 50\\%$). Here we combined the prediction results of $38$ decision trees to get this accuracy. It seems that we can't forecast `CHARLSONSCORE` too well, however other QoL outcomes may have higher prediction accuracy. For instance, we may predict `QOL_Q_01` with  $accuracy=0.6$ and $\\kappa=0.42$.\n\n\nIn addition to decision tree classification, `caret` allows us to explore alternative `bag()` functions. For instance, instead of bagging based on decision trees, we can bag using a SVM model. `caret` provides a nice setting for SVM training, making predictions and counting votes in a list object `svmBag`. We can examine these objects by using the `str()` function.\n\n\nClearly, `fit` provides the training functionality, `pred` the prediction and forecasting on new data, and `aggregate` is a way to combine many models and achieve voting-based consensus. Using the member operator, the $\\$$ sign, we can explore these three types of elements of the `svmBag` object. For instance, the `fit` element may be extracted from the SVM object by:\n\n\nThe SVM bag `fit` relies on the `kernlab::ksvm()` function. The other two methods, `pred` and `aggregate`, may be explored in a similar way. They follow the SVM model building and testing process we saw earlier. \n\nThis `svmBag` object could be used as an optional setting in the `train()` function. However, this option requires that all features are linearly independent, which may be rare in real world data. \n\n\n## Boosting\n\n*Bagging* uses equal weights for all learners we include in the model. *Boosting* is different as it employs non-uniform weights. Suppose we have the first learner correctly classifying 60% of the observations. This 60% of data may be less likely to be included in the training dataset for the next learner. So, we have more learners working on the remaining \"hard-to-classify\" observations.\n\nMathematically, the boosting technique uses a weighted sum of functions to predict the outcome class labels. We can try to fit the true model using weighted additive modeling. We start with a random learner that can classify some of the observations mostly correctly, possibly with some errors.\n\n$$\\hat{y}_1=l_1.$$\n\nThis $l_1$ is our first learner and $\\hat{y}_1$ denotes its predictions (this equation is in matrix form). Then, we can calculate the residuals of our first learner.\n\n$$\\epsilon_1=y-v_1\\times\\hat{y}_1,$$\nwhere $v_1$ is a shrinkage parameter to avoid overfitting. Next, we fit the residual with another learner. This learner minimizes the following objective function $\\sum_{i=1}^N||y_i-l_{k-1}-l_k||$. Here `k=2`. Then we obtain a second model $l_2$ with:\n\n$$\\hat{y}_2=l_2.$$\n\nAfter that, we can update the residuals:\n\n$$\\epsilon_2=\\epsilon_1-v_2\\times\\hat{y}_2.$$\n\nWe repeat this residual fitting until adding another learner $l_k$ results in updated residual $\\epsilon_k$ that is smaller than a small predefined threshold. In the end, we will have an additive model like:\n\n$$L=v_1\\times l_1+v_2\\times l_2+...+v_k\\times l_k,$$\n\nwhere we ensemble *k* weak learners to generate a stronger meta model.\n\n[Schapire and Freund](https://doi.org/10.1006/jcss.1997.1504) found that although individual learners trained on the pilot observations might be very weak in predicting in isolation, boosting the collective power of all of them is expected to generate a model **no worse than the best of all individual constituent models** included in the boosting ensemble. Usually, the boosting results are quite better than the top individual model. Although boosting can be used for almost all models, it's most commonly applied to decision trees.\n\n## Random forests\n\nRandom forests, or decision tree forests, represent a class of boosting methods focusing on decision tree learners. Random forests (RF) represent ensembles of a large number of (typically weaker) classifiers such as individual decision trees that provide independent class predictions. Then, for any testing set, the RF aggregates the predictions of all individual trees to pool the most likely class label which becomes the RF prediction. If and when a large number of relatively independent tree models reach a consensus, i.e., majority vote, this forecasting outcome is expected to outperform any specific individual decision tree model. Whereas many of the trees in the forest may yield vastly incorrect and wild predictions, any consistent pattern emerging from other trees would suggest strong candidate predictions that pull the consensus in a uniform (correct) direction. The main assumptions of the random forest ensemble method include (1) existence of an actual signal encoded in the data features that may guide the individual tree into a nonrandom guessing pattern, and (2) the individual trees in the forest should be fairly independently trained to output predictions with low correlations.\n\n### Random Forest Algorithm (Pseudo Code)\n\nAs RF relies on bagging to generate a meta ensemble regression or classification, it uses averaging of a large number of weak (noisy), mostly independent, and approximately unbiased models. This average pooling naturally reduces the performance variance. RF can be applied to any family of classifiers, and is particularly useful with decision trees, which tend to capture complex high-dimensional interactions. When grown sufficiently deep, the RFs have relatively low bias in their predictions. Individual trees are commonly expected to generate noisy predictions. Therefore, the expectation of the subsequent RF average pooling of the identically distributed $B$ trees is the same as the expectation of each of the constituent trees. Hence, the bias of bagged trees in the RF will be the same as the bias of any one of the individual trees. However, the RF improvement over each individual decision tree prediction rapidly decreases the forecasting variance. In boosting methods, the decision trees are not necessarily independent, but are grown adaptively to reduce the bias.\n\nRecall that by the [central limit theorem (CLT)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3152447/), the average of $B$ independent random variables from a distribution with a variance $\\sigma^2$, has a much lower variance $\\frac{\\sigma^2}{B}$, which goes to zero as the sample size $B\\to\\infty$. However, when the random and identically distributed variables are not independent, then the variance of the arithmetic mean could be much larger. For instance, if pairwise correlations of the variables is non-trivial, $\\rho>0$, the variance of the sampling distribution of the average would be on the order of $O(\\sigma^2)$. More specifically, in this case the variance would be\n$$\\left ( \\rho +\\frac{1-\\rho}{B}\\right )  \\sigma^2\\ \\  \\underbrace{\\longrightarrow}_{B\\to\\infty}\\ \\ \\rho\\sigma^2 .$$\n\nIn other words, the process of bagging dependent trees has less benefit on reducing prediction variability in the *average* pooled predictor. In RF, the improvement of prediction is based on the variance reduction of bagging, which is achieved by reducing tree correlations using tree-growing process based on *random selection of the input variables*.\n\nBelow is a pseudo code illustrating the core parts of a Random Forest approach for regression or classification.\n\n - Given a number of trees $B$, iterate over each tree index ($1\\le b\\le B$):\n   + Draw a bootstrap sample $Z^*$ of size $N$ from the training data\n   + Grow a random-forest tree $T_b$ to the bootstrapped data, by recursively repeating these steps for each terminal node of\nthe current tree, until the minimum node size $n_{min}$ is reached\n      - Choose a random set of $m\\ll p$ variables \n      - Decide on an optimal variable split among the $m$ features\n      - Split the node into two children nodes based on the features\n - Compile an output by ensembling the trees, $\\{T_b\\}_1^B$.\n \nThe *RF prediction* given a new testing case $x$ is given by:\n\n - For *regression problems*, pool across all random forest trees, $\\hat{f}^{RF}_B (x) = \\frac{1}{B}\\sum_{b=1}^B {T_b(x)}$, and\n - For *classification problems*: Suppose the $b$-th tree in the RF generates a class prediction $\\hat{C}_b(x)$. Then, the RF output (prediction) is \n \n$$\\hat{C}_B^{RF}(x) = {{majority}\\choose{vote}}\\{ \\hat{C}_b(x)\\}. $$\n\nAt each iteration, the bootstrapped sample dataset affects the growth of each tree. Prior to deciding whether and how to split a leaf node, we *randomly* choose $m\\leq p$ features as candidate splitting variables. In general, $1\\leq m\\sim \\sqrt{p} \\ll p$.\nSuppose the parameter vector $\\Omega_b$ characterizes the $b$-th random forest tree in terms of splitting variables, node cut-points, and terminal-node values. In the RF regression setting, growing $B$ trees $\\{T(x|\\Omega_b)\\}_1^B$ yields the following random forest regression predictor\n\n$$\\hat{f}_B^{RF}(x)=\\frac{1}{B}\\sum_{b=1}^B {T(x|\\Omega_b)} .$$\n\n### Training random forests\n\nOne approach to train and build random forests uses the `randomForest::randomForest()` method, which has the following invocation:\n\n`m<-randomForest(expression, data, ntree=500, mtry=sqrt(p))`\n\n - *expression*: the class variable and features we want to include in the model.\n - *data*: training data containing class and features.\n - *ntree*: number of voting decision trees\n - *mtry*: optional integer specifying the number of features to randomly select at each split. The parameter `p` stands for the number of features in the data.\n\nLet's build a random forest using the Quality of Life dataset.\n\n\nBy default the model contains 500 voter trees and tries 6 variables at each split. Its OOB (out-of-bag) error rate is about 38%, which corresponds with a moderate accuracy (62%). Note that the OOB error rate is not a re-substitution error. Next to the confusion matrix, we see the reported OOB error rate for all specific classes. All of these error rates are reasonable estimates of future performances with unseen data. We can see that this model is so far the best of all models, although it is still not highly predictive of `QOL_Q_01`.\n\n### Evaluating random forest performance\n\nIn addition to model building, the `caret` package also supports model evaluation. It reports more detailed model performance evaluations. As usual, we need to specify the re-sampling method and a parameter grid. Let's use a 10-fold CV re-sampling method as an example. The grid for this model contains information about the `mtry` parameter (the only tuning parameter for random forest). Previously we tried the default value $\\sqrt{38}=6$ (38 is the number of features). This time we could compare multiple `mtry` parameters.  \n\n\nNext, we apply the `train()` function with our `ctrl` and `grid_rf` settings.\n\n\nThis call may take a while to complete. The result appears to be a good model, when `mtry=16` we reached a moderately high accuracy (0.62) and good `kappa` statistic (0.44). This is a good result for a meta-learner of 6 dispersed classes (`table(as.factor(qol$QOL_Q_01))`).\n\nMore examples of using `randomForest()` and interpreting its results are shown in [Chapter 5](https://www.socr.umich.edu/DSPA2/).\n\n## Adaptive boosting\n\nWe may achieve even higher accuracy using **AdaBoost**. Adaptive boosting (AdaBoost) can be used in conjunction with many other types of learning algorithms to improve their performance. The output of the other learning algorithms ('weak learners') is combined into a weighted sum that represents the final output of the boosted classifier. AdaBoost is adaptive in the sense that subsequent weak learners are tweaked in favor of those instances misclassified by the previous classifiers. \n\nFor binary cases, we could use the method `ada::ada()` and for multiple classes (multinomial/polytomous outcomes) we can use the package `adabag`. The `adabag::boosting()` function allows us to specify a method by setting `coeflearn`. The two main types of adaptive boosting methods that are commonly used include the `AdaBoost.M1` algorithm, e.g., `Breiman` and `Freund`, or the `Zhu`'s `SAMME` algorithm. The key parameter in the `adabag::boosting()` method is *coeflearn*:\n\n - *Breiman* (default), corresponding to $\\alpha=\\frac{1}{2}\\times \\ln\\left (\\frac{1-err}{err} \\right )$, using the AdaBoost.M1 algorithm, where $\\alpha$ is the [weight updating coefficient](https://en.wikipedia.org/wiki/AdaBoost#Choosing_.CE.B1t)\n - *Freund*, corresponding to $\\alpha=\\ln\\left (\\frac{1-err}{err} \\right )$, or\n - *Zhu*, corresponding to $\\alpha=\\ln\\left (\\frac{1-err}{err} \\right ) + \\ln(nclasses-1)$.\n\nThe generalizations of AdaBoost for multiple classes ($\\geq 2$) include `AdaBoost.M1` (where individual trees are required to have an error $\\lt \\frac{1}{2}$) and `SAMME` (where individual trees are required to have an error $\\lt 1-\\frac{1}{nclasses}$). \n\nLet's see some examples using these three alternative adaptive boosting methods:\n\n\nWe observe that the `Zhu` approach achieves the best results, average $accuracy> 0.93$. Notice that the default method is M1 `Breiman` and the number of boosting iterations is specified by the parameter `mfinal`.",
      "word_count": 2536
    },
    {
      "title": "Practice SVM Problems",
      "content": "## Problem 1: Google Trends and the Stock Market\n\nUse the [Google trend data](https://wiki.socr.umich.edu/index.php/SOCR_Data_GoogleTrends_2005_2011). Fit a neural network model with the Google Trends data we saw earlier. This time use `Investing` as target and `Unemployment, Rental, RealEstate, Mortgage, Jobs, DJI_Index, StdDJI` as predictors. Use 3 hidden nodes. \n\n**Note**: remember to change the columns you want to include in the test dataset when predicting.\n\nThe following number is the correlation between predicted and observed values.\n\n\nYou might get slightly different results since the weights are generated randomly.\n\n## Problem 2: Quality of Life and Chronic Disease\n\nUse the [Quality of life and chronic disease](https://umich.instructure.com/files/481332/download?download_frd=1) and the corresponding [meta-data doc](https://umich.instructure.com/files/399150/download?download_frd=1&verifier=aq3okIt8HwhhGPPWmbz7yd7vYGOKILe0Wvu13E6d), which we used in [Chapter 5](https://socr.umich.edu/DSPA2/DSPA2_notes/05_SupervisedClassification.html), . \n\nLet's load the data first. In this case study, we want to use the variable `CHARLSONSCORE` as our target variable.\n\n\nDelete the first two columns (we don't need ID variables) and rows that have missing values in `CHARLSONSCORE`(where `CHARLSONSCORE`equals \"-9\")\n`!qol$CHARLSONSCORE==-9` means we want all the rows that have CHARLSONSCORE not equal to -9. The exclamation sign (!) indicates \"exclude\". Also, we need to convert our categorical variable `CHARLSONSCORE` into a factor.\n\n\nNow the dataset is ready. First, separate the dataset into training and test datasets using the $75\\%-25\\% rule. Then, build a SVM model using all other variables in the dataset to be predictor variables. Try to add different costs of misclassification to the model. Rather than the default `C=1` we use `C=2` and `C=3`. See how the model behaves. Here we utilize the radial basis kernel.\n\nOutput for `C=2`.\n\n\nOutput for `C=3`.\n\n\nTry to practice these techniques using [other data from the list of our Case-Studies](https://umich.instructure.com/courses/38100/files/).\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number \n\t\t\t\t<img class=\"statcounter\"\n\t\t\t\t\t\t\t\tsrc=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" \n\t\t\t\t\t\t\t\talt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 368
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    self_contained: yes\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Neural Networks",
      "code": "# x<-runif(1000, -10, 10)\n# y<-ifelse(x>=0, 1, 0)\n# plot(x, y, t=\"n\", xlab = \"Sum of input signals\", ylab = \"Output signal\", main = \"Threshold Activation (th=0.0)\")\n# segments(0, -0.1, 0, 1, col=\"black\", lty=2)\n# lines(x[order(x)], y[order(x)], pch=16, col=\"black\", lwd=4)\nlibrary(plotly)\n\nx <- c(-2, 0, 0, 0, 2)\ny <- c( 0, 0, 0, 1, 1) \nplot_ly() %>%\n  add_trace(x = x, y = y, type=\"scatter\", mode=\"lines\",\n        line = list(width = 4), name=\"Threshold\") %>%\n  layout(title='Threshold Activation Function (x=0.0)',\n           xaxis = list(title=\"Sum of Input Signals\"),\n           yaxis = list(title=\"Output signal\"),\n           legend = list(orientation = 'h'))",
      "line_count": 16
    },
    {
      "section": "Neural Networks",
      "code": "x <- runif(100000, -10, 10)\ny <- 1/(1+exp(-x))\n\n# plot(x, y, xlab = \"Sum of input signals\", ylab = \"Output signal\", main = \"Sigmoid Activation (th1=0; th2=2)\")\n# segments(0, -0.1, 0, 0.5, col=\"black\", lty=2)\n# segments(2, -0.1, 2, (1/(1+exp(-2))), col=\"black\", lty=2)\n\nplot_ly() %>%\n  add_trace(x = x, y = y, type=\"scatter\", mode=\"markers\",\n         name=\"Sigmoid\") %>%\n  add_trace(x = c(0,0), y = c(0, 0.5), type=\"scatter\", mode=\"markers+lines\",\n         name=\"\", showlegend=F) %>%\n  add_trace(x = c(2,2), y = c(0, (1/(1+exp(-2)))), type=\"scatter\", mode=\"markers+lines\",\n         name=\"\", showlegend=F) %>%\n  layout(title='Sigmoid Activation Function (x1=0; x2=2)',\n           xaxis = list(title=\"Sum of Input Signals\"),\n           yaxis = list(title=\"Output signal\"),\n           legend = list(orientation = 'h'))",
      "line_count": 18
    },
    {
      "section": "Neural Networks",
      "code": "x<-runif(10000, -10, 10)\ny <- 1/(1+exp(-x))\ny1<-x\ny2<-ifelse(x<=-5, -5, ifelse(x>=5, 5, x))\ny3<-(exp(x)-exp(-x))/(exp(x)+exp(-x))\ny4<-exp(-x^2/2)\ny5 <- 1/(1+exp(-(x+3)))\n\n# par(mfrow=c(2, 2))\n# plot(x, y1, main=\"Linear\", xlab=\"\", ylab=\"\")\n# plot(x, y2, main=\"Saturated Linear\", xlab=\"\", ylab=\"\")\n# plot(x, y3, main=\"Hyperbolic tangent\", xlab=\"\", ylab=\"\")\n# plot(x, y4, main = \"Gaussian\", xlab=\"\", ylab=\"\")\n\nplot_ly() %>%\n  add_trace(x = x, y = 1+(y1/10-1)/2, type=\"scatter\", mode=\"markers\", name=\"Linear\") %>%\n  add_trace(x = x, y = 1+(y2/5-1)/2, type=\"scatter\", mode=\"markers\", name=\"Saturated Linear\") %>%\n  add_trace(x = x, y = 1+(y3-1)/2, type=\"scatter\", mode=\"markers\", name=\"Hyperbolic Tangent\") %>%\n  add_trace(x = x, y = y4, type=\"scatter\", mode=\"markers\", name=\"Gaussian\") %>%\n  add_trace(x = x, y = y, type=\"scatter\", mode=\"markers\", name=\"Sigmoid\") %>%\n  add_trace(x = x, y = y5, type=\"scatter\", mode=\"markers\", name=\"Shifted (+3 Biased) Sigmoid\") %>%\n  layout(title='Various Activation Functions',\n           xaxis = list(title=\"Input Signals\"),\n           yaxis = list(title=\"Output signal\"),\n           legend = list(orientation = 'h'))",
      "line_count": 25
    },
    {
      "section": "Neural Networks",
      "code": "google <- read.csv(\"https://umich.instructure.com/files/416274/download?download_frd=1\", stringsAsFactors = F)",
      "line_count": 1
    },
    {
      "section": "Neural Networks",
      "code": "google <- google[, -c(1, 2)]\nstr(google)",
      "line_count": 2
    },
    {
      "section": "Neural Networks",
      "code": "normalize <- function(x) {\nreturn((x - min(x)) / (max(x) - min(x)))\n}\ngoogle_norm<-as.data.frame(lapply(google, normalize))\nsummary(google_norm$RealEstate)",
      "line_count": 5
    },
    {
      "section": "Neural Networks",
      "code": "sub <- sample(nrow(google_norm), floor(nrow(google_norm)*0.75))\ngoogle_train <- google_norm[sub, ]\ngoogle_test <- google_norm[-sub, ]",
      "line_count": 3
    },
    {
      "section": "Neural Networks",
      "code": "# install.packages(\"neuralnet\")\nlibrary(neuralnet)\ngoogle_model <- neuralnet(RealEstate~Unemployment+Rental+Mortgage+Jobs+Investing+DJI_Index+StdDJI, data=google_train)\nplot(google_model)  # neuralnet::plot.nn",
      "line_count": 4
    },
    {
      "section": "Neural Networks",
      "code": "google_pred <- compute(google_model, google_test[, c(1:2, 4:8)])\npred_results <- google_pred$net.result\ncor(pred_results, google_test$RealEstate)",
      "line_count": 3
    },
    {
      "section": "Neural Networks",
      "code": "google_model2 <- neuralnet(RealEstate~Unemployment+Rental+Mortgage+Jobs+Investing+DJI_Index+StdDJI, data=google_train, hidden = 4)\nplot(google_model2)",
      "line_count": 2
    },
    {
      "section": "Neural Networks",
      "code": "google_pred2 <- compute(google_model2, google_test[, c(1:2, 4:8)])\npred_results2 <- google_pred2$net.result\ncor(pred_results2, google_test$RealEstate)\n\nplot_ly() %>%\n  add_markers(x=pred_results2, y=google_test$RealEstate, \n              name=\"Data Scatter\", type=\"scatter\", mode=\"markers\") %>%\n  add_trace(x = c(0,1), y = c(0,1), type=\"scatter\", mode=\"lines\",\n        line = list(width = 4), name=\"Ideal Agreement\") %>%\n  layout(title=paste0('Scatterplot (Normalized) Observed vs. Predicted Real Estate Values, Cor(Obs,Pred)=',\n                      round(cor(pred_results2, google_test$RealEstate), 2)),\n           xaxis = list(title=\"NN (hidden=4) Real Estate Predictions\"),\n           yaxis = list(title=\"(Normalized) Observed Real Estate\"),\n           legend = list(orientation = 'h'))",
      "line_count": 14
    },
    {
      "section": "Neural Networks",
      "code": "google_model2 <- neuralnet(RealEstate~Unemployment+Rental+Mortgage+Jobs+Investing+DJI_Index+StdDJI, data=google_train, hidden = c(4,3,3))\ngoogle_pred2<-compute(google_model2, google_test[, c(1:2, 4:8)])\npred_results2<-google_pred2$net.result\ncor(pred_results2, google_test$RealEstate)\n# plot(google_model2)\n\nplot_ly() %>%\n  add_markers(x=pred_results2, y=google_test$RealEstate, \n              name=\"Data Scatter\", type=\"scatter\", mode=\"markers\") %>%\n  add_trace(x = c(0,1), y = c(0,1), type=\"scatter\", mode=\"lines\",\n        line = list(width = 4), name=\"Ideal Agreement\") %>%\n  layout(title=paste0('Scatterplot (Normalized) Observed vs. Predicted Real Estate Values, Cor(Obs,Pred)=',\n                      round(cor(pred_results2, google_test$RealEstate), 2)),\n           xaxis = list(title=\"NN (hidden=(4,3,3)) Real Estate Predictions\"),\n           yaxis = list(title=\"(Normalized) Observed Real Estate\"),\n           legend = list(orientation = 'h'))",
      "line_count": 16
    },
    {
      "section": "Neural Networks",
      "code": "# generate random training data: 1,000 |X_i|, where X_i ~ Uniform (0,100) or perhaps ~ N(0,1)\nrand_data <- abs(runif(1000, 0, 100))\n \n# create a 2 column data-frame (input=data, output=sqrt_data)\nsqrt_df <- data.frame(rand_data, sqrt_data=sqrt(rand_data)) \n# plot(rand_data, sqrt_df$sqrt_data)\n\ns <- seq(from=0, to=100, length.out=1000)\nplot_ly(x = ~s, y = ~sqrt(s), type=\"scatter\", mode = \"lines\") %>%\n  layout(title='Square-root Function',\n           xaxis = list(title=\"Input (x)\", scaleanchor=\"y\"),\n           yaxis = list(title=\"Output (y=sqrt(x))\", scaleanchor=\"x\"),\n           legend = list(orientation = 'h'))",
      "line_count": 13
    },
    {
      "section": "Neural Networks",
      "code": "# Train the neural net\nset.seed(1234)\nnet.sqrt <- neuralnet(sqrt_data ~ rand_data,  sqrt_df, hidden=10, threshold=0.1)",
      "line_count": 3
    },
    {
      "section": "Neural Networks",
      "code": "# report the NN\n# print(net.sqrt)\n \n# generate testing data seq(from=0.1, to=N, step=0.1)\nN <- 200 # out of range [100: 200] is also included in the testing!\ntest_data <- seq(0, N, 0.1); test_data_sqrt <- sqrt(test_data)\n \ntest_data.df <- data.frame(rand_data=test_data, sqrt_data=sqrt(test_data));\n # try to predict the square-root values using 10 hidden nodes\n # Compute or predict for test data input, test_data.df\npred_sqrt <- predict(net.sqrt, test_data.df)\n \n # compute uses the trained neural net (net.sqrt), \n # to estimate the square-roots of the testing data \n \n# compare real (test_data_sqrt) and NN-predicted (pred_sqrt) square roots of test_data\n# plot(pred_sqrt, test_data_sqrt, xlim=c(0, 12), ylim=c(0, 12)); \n# abline(0,1, col=\"red\", lty=2)\n# legend(\"bottomright\",  c(\"Pred vs. Actual SQRT\", \"Pred=Actual Line\"), cex=0.8, lty=c(1,2),\n#         lwd=c(2,2),col=c(\"black\",\"red\"))\n\nplot_ly(x = ~pred_sqrt[,1], y = ~test_data_sqrt, type = \"scatter\", mode=\"markers\", name=\"scatter\") %>%\n  add_trace(x = c(0,14), y = c(0,14), mode=\"lines\", line = list(width = 4), name=\"Ideal Agreement\") %>%\n  layout(title='Scatter Plot Predicted vs. Actual SQRT',\n           xaxis = list(title=\"NN Predicted\", scaleanchor=\"y\"),\n           yaxis = list(title=\"Actual Value (y=sqrt(x))\", scaleanchor=\"x\"),\n           legend = list(orientation = 'h'))\n\ncompare_df <-data.frame(pred_sqrt, test_data_sqrt); # compare_df\n \n# plot(test_data, test_data_sqrt)\n# lines(test_data, pred_sqrt, pch=22, col=\"red\", lty=2)\n# legend(\"bottomright\",  c(\"Actual SQRT\",\"Predicted SQRT\"),\n#        lty=c(1,2),lwd=c(2,2),col=c(\"black\",\"red\"))\n\nplot_ly(x = ~test_data, y = ~test_data_sqrt,  type=\"scatter\", mode=\"lines\", name=\"SQRT\") %>%\n  add_trace(x = ~test_data, y = ~pred_sqrt, mode=\"markers\", name=\"NN Model Prediction\") %>%\n  layout(title='Predicted vs. Actual SQRT',\n           xaxis = list(title=\"Inputs\"),\n           yaxis = list(title=\"Outputs (y=sqrt(x))\"),\n           legend = list(orientation = 'h'))",
      "line_count": 41
    },
    {
      "section": "Neural Networks",
      "code": "google_class = google_norm\nid1 = which(google_class$RealEstate>quantile(google_class$RealEstate,0.75))\nid2 = which(google_class$RealEstate<quantile(google_class$RealEstate,0.25))\nid3 = setdiff(1:nrow(google_class),union(id1,id2))\ngoogle_class$RealEstate[id1]=0\ngoogle_class$RealEstate[id2]=1\ngoogle_class$RealEstate[id3]=2\nsummary(as.factor(google_class$RealEstate))",
      "line_count": 8
    },
    {
      "section": "Neural Networks",
      "code": "set.seed(2017)\ntrain = sample(1:nrow(google_class),0.7*nrow(google_class))\ngoogle_tr = google_class[train,]\ngoogle_ts = google_class[-train,]\ntrain_x = google_tr[,c(1:2,4:8)]\ntrain_y = google_tr[,3]\ncolnames(train_x)\ntest_x = google_ts[,c(1:2,4:8)]\ntest_y = google_ts[3]\ntrain_y_ind = model.matrix(~factor(train_y)-1)\ncolnames(train_y_ind) = c(\"High\",\"Median\",\"Low\")\ntrain = cbind(train_x, train_y_ind)",
      "line_count": 12
    },
    {
      "section": "Neural Networks",
      "code": "nn_single = neuralnet(High+Median+Low~Unemployment+Rental+Mortgage+Jobs+Investing+DJI_Index+StdDJI,\n    data = train,\n    hidden=4,\n    linear.output=FALSE,\n    lifesign='full', lifesign.step=5000)",
      "line_count": 5
    },
    {
      "section": "Neural Networks",
      "code": "pred = function(nn, dat) {\n    # compute uses the trained neural net (nn=nn_single), and \n    # new testing data (dat=google_ts) to generate predictions (y_hat)\n    # compute returns a list containing: \n    #     (1) neurons: a list of the neurons' output for each layer of the neural network, and\n    #     (2) net.result: a matrix containing the overall result of the neural network.\n    yhat = compute(nn, dat)$net.result\n    \n    # find the maximum in each row (1) in the net.result matrix\n    # to determine the first occurrence of a specific element in each row (1)\n    # we can use the apply function with which.max\n    yhat = apply(yhat, 1, which.max)-1\n    return(yhat)\n}\n\nmean(pred(nn_single, google_ts[,c(1:2,4:8)]) != as.factor(google_ts[,3]))",
      "line_count": 16
    },
    {
      "section": "Neural Networks",
      "code": "table(pred(nn_single, google_ts[,c(1:2,4:8)]), as.factor(google_ts[,3]))",
      "line_count": 1
    },
    {
      "section": "Neural Networks",
      "code": "plot(nn_single)",
      "line_count": 1
    },
    {
      "section": "Neural Networks",
      "code": "nn_single = neuralnet(High+Median+Low~Unemployment+Rental+Mortgage+Jobs+Investing+DJI_Index+StdDJI,\n    data = train,\n    hidden=c(4,5),\n    linear.output=FALSE,\n    lifesign='full', lifesign.step=5000)\nmean(pred(nn_single, google_ts[,c(1:2,4:8)]) != as.factor(google_ts[,3]))",
      "line_count": 6
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "A <- c(1, 4, 3, 2, 4, 8, 6, 10, 9)\nB <- c(1, 5, 3, 2, 3, 8, 8, 7, 10)\n\n# plot(A, B, xlab=\"\", ylab=\"\", pch=16, cex=2)\n# abline(v=5, col=\"red\", lty=2)\n# text(5.4, 9, labels=\"A\")\n# abline(12, -1, col=\"red\", lty=2)\n# text(6, 5.4, labels=\"B\")\n\nmodelLabels <- c('A', 'B')\nmodelLabels.x <- c(5.4, 8.2)\nmodelLabels.y <- c(9, 4.1)\nmodelLabels.col <- c(\"blue\", \"red\")\n\nplot_ly(x = A, y = B, type=\"scatter\", mode=\"markers\", name=\"Data\") %>%\n  add_lines(x = c(5,5), y = c(1,10), name=\"Line A\")  %>% \n  add_lines(x = c(10,2), y = c(2,10), name=\"Line B\")  %>% \n  layout(title=\"Illustration of Hyperplane (line) Separation of 2D Data\",\n         xaxis=list(title=\"X\", scaleanchor=\"y\"),  # control the y:x axes aspect ratio\n         yaxis = list(title=\"Y\", scaleanchor  = \"x\"), legend = list(orientation = 'h'),\n         annotations = list(text=modelLabels,  x=modelLabels.x, y=modelLabels.y, textangle=c(90,0),\n                            font=list(size=15, color=modelLabels.col), showarrow=FALSE))",
      "line_count": 22
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "# plot(A, B, xlab=\"\", ylab=\"\", pch=16, cex=2)\n# segments(1, 1, 4, 5, lwd=1, col = \"red\")\n# segments(1, 1, 4, 3, lwd = 1, col = \"red\")\n# segments(4, 3, 4, 5, lwd = 1, col = \"red\")\n# segments(6, 8, 10, 7, lwd = 1, col = \"red\")\n# segments(6, 8, 9, 10, lwd = 1, col = \"red\")\n# segments(10, 7, 9, 10, lwd = 1, col = \"red\")\n# segments(6, 8, 4, 5, lwd = 1, lty=2)\n# abline(9.833, -2/3, lwd=2)\n\nmodelLabels <- c('A', 'B')\nmodelLabels.x <- c(5.4, 8.2)\nmodelLabels.y <- c(8, 4.1)\nmodelLabels.col <- c(\"blue\", \"red\")\n\nplot_ly() %>%\n  add_lines(x = c(6,4), y = c(8,5), name=\"Shortest Line Between the Convex Clusters (A)\", line=list(dash='dash'))  %>% \n  add_lines(x = c(10,2), y = c(3,8.7), name=\"MMH Line (B)\")  %>% \n  add_segments(x=1, xend=4, y=1, yend = 5, line=list(color=\"red\"), showlegend=F) %>%\n  add_segments(x=1, xend=4, y=1, yend = 3, line=list(color=\"red\"), showlegend=F) %>%\n  add_segments(x=4, xend=4, y=3, yend = 5, line=list(color=\"red\"), showlegend=F) %>%\n  add_segments(x=6, xend=10, y=8, yend = 7, line=list(color=\"red\"), showlegend=F) %>%\n  add_segments(x=6, xend=10, y=8, yend = 7, line=list(color=\"red\"), showlegend=F) %>%\n  add_segments(x=10, xend=9, y=7, yend = 10, line=list(color=\"red\"), showlegend=F) %>%\n  add_markers(x = A, y = B, type=\"scatter\", mode=\"markers\", name=\"Data\", marker=list(color=\"blue\")) %>%\n  add_markers(x = 4, y = 5, name=\"P1\", \n              marker = list(size = 20, color = 'blue', line = list(color = 'yellow', width = 2))) %>%\n  add_segments(x=6, xend=9, y=8, yend = 10, line=list(color=\"red\"), showlegend=F) %>%\n  add_markers(x = 6, y = 8, name=\"P2\", \n              marker = list(size = 20, color = 'blue', line = list(color = 'yellow', width = 2))) %>%\n  layout(title=\"Illustration of Hyperplane (line) Separation of 2D Data\",\n         xaxis=list(title=\"X\", scaleanchor=\"y\"),  # control the y:x axes aspect ratio\n         yaxis = list(title=\"Y\", scaleanchor  = \"x\"), legend = list(orientation = 'h'),\n         annotations = list(text=modelLabels,  x=modelLabels.x, y=modelLabels.y, textangle=c(-40,0),\n                            font=list(size=15, color=modelLabels.col), showarrow=FALSE))",
      "line_count": 35
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "# install.packages(\"alphahull\")\nlibrary(alphahull)\n\n# Define a convex spline polygon function\n#   Input 'boundaryVertices' (n * 2 matrix) include the ordered X,Y coordinates of the boundary vertices\n#   'vertexNumber' is the number of spline vertices to use; dim(boundaryVertices)[1] ... not all are necessary and some end vertices are clipped\n#   'k' controls the smoothness of the  periodic spline, i.e., the number of points to wrap around the ends\n#   Returns an array of points \nconvexSplinePolygon <- function(boundaryVertices, vertexNumber, k=3) \n  {\n    # Wrap k vertices around each end.\n    n <- dim(boundaryVertices)[1]\n    if (vertexNumber < n) {\n      print(\"vertexNumber< n!!!\")\n      stop()\n    }\n    if (k >= 1) {\n        data <- rbind(boundaryVertices[(n-k+1):n, ], boundaryVertices, boundaryVertices[1:k, ])\n    } else {\n        data <- boundaryVertices\n    }\n\n    # Spline-interpolate the x and y coordinates\n    data.spline <- spline(1:(n+2*k), data[ , 1], n=vertexNumber)\n    x <- data.spline$x\n    x1 <- data.spline$y\n    x2 <- spline(1:(n+2*k), data[,2], n=vertexNumber)$y\n\n    # Keep only the middle part\n    cbind(x1, x2)[k < x & x <= n+k, ]\n}\n\n# install.packages(\"alphahull\")\n# Concave hull (alpha-convex hull)\ngroup1 <- list(x=A[6:9], y=B[6:9])\n# if duplicate points are expected, remove them to prevent ahull() function errors\ngroup2 <- lapply(group1, \"[\" ,which(!duplicated(as.matrix(as.data.frame(group1)))))\nconcaveHull1 <- ahull(group2, alpha=6)\n\n# plot(concaveHull1, add=FALSE, col=\"blue\", wpoints=FALSE, xlim=c(0,10),ylim=c(0,10))\n# points(group2, pch=19)\n\nlibrary(alphahull)\n# Convex hull\ngroup3 <- list(x=A[1:5], y=B[1:5])\n# points(group3, pch=19)\nconvHull2 <- lapply(group3, \"[\", chull(group3))\n\n# polygon(convHull2, lty=2, border=\"gray\", lwd=2)\n# polygon(convexSplinePolygon(as.matrix(as.data.frame(convHull2)), 100),border=\"red\",lwd=2)\n# legend(\"topleft\",  c(\"Convex Hull\", \"Convex Spline Hull\", \"Concave Hull\"), lty=c(2,1,1), lwd=c(2,2,2),col=c(\"gray\",\"red\", \"blue\"), cex=0.8)\n# text(5,2, \"group 2\", col=\"red\"); text(8,6, \"group 1\", col=\"blue\")\n\nlibrary(sp)\nSpP = SpatialPolygons(list(Polygons(list(Polygon(group2)),ID=\"s1\"))) \n# plot(SpP)\n# points(XY)\nx1 <- SpP@polygons[[1]]@Polygons[[1]]@coords[,1]\ny1 <- SpP@polygons[[1]]@Polygons[[1]]@coords[,2]\ndf1 <- convexSplinePolygon(as.matrix(as.data.frame(convHull2)), 100)\n\nplot_ly() %>%\n  add_trace(x=df1[,1], y=df1[,2], type=\"scatter\", mode=\"lines\", name=\"Convex Hull\", line=list(color=\"lightblue\")) %>%\n  add_lines(x = x1, y = y1, type=\"scatter\", mode=\"lines\", name=\"Concave Region\", line=list(color=\"orange\")) %>%\n  add_segments(x = df1[1,1],  xend=df1[dim(df1)[1],1], y = df1[1,2], yend = df1[dim(df1)[1],2], type=\"scatter\", \n            mode=\"lines\", name=\"\", line=list(color=\"gray\"), showlegend=F) %>%\n  add_segments(x = x1[3],  xend=x1[4], y = y1[3], yend = y1[4], type=\"scatter\", \n            mode=\"lines\", name=\"Concave Region\", line=list(color=\"orange\"), showlegend=F) %>%\n  add_lines(x = c(6,4), y = c(8,5), name=\"Shortest Line Between the Convex Clusters (A)\", line=list(dash='dash'))  %>% \n  add_lines(x = c(10,2), y = c(3,8.7), mode=\"lines\", name=\"MMH Line (B)\")  %>% \n  add_segments(x=1, xend=4, y=1, yend = 5, line=list(color=\"gray\", dash='dash'), showlegend=F) %>%\n  add_segments(x=1, xend=4, y=1, yend = 3, line=list(color=\"gray\", dash='dash'), showlegend=F) %>%\n  add_segments(x=4, xend=4, y=3, yend = 5, line=list(color=\"gray\", dash='dash'), showlegend=F) %>%\n  add_segments(x=6, xend=10, y=8, yend = 7, line=list(color=\"gray\", dash='dash'), showlegend=F) %>%\n  add_segments(x=6, xend=10, y=8, yend = 7, line=list(color=\"gray\", dash='dash'), showlegend=F) %>%\n  add_segments(x=10, xend=9, y=7, yend = 10, line=list(color=\"gray\", dash='dash'), showlegend=F) %>%\n  add_markers(x = A, y = B, type=\"scatter\", mode=\"markers\", name=\"Data\", marker=list(color=\"blue\")) %>%\n  add_markers(x = 4, y = 5, name=\"P1\", \n              marker = list(size = 20, color = 'blue', line = list(color = 'yellow', width = 2))) %>%\n  add_segments(x=6, xend=9, y=8, yend = 10, line=list(color=\"gray\", dash='dash'), showlegend=F) %>%\n  add_markers(x = 6, y = 8, name=\"P2\", \n              marker = list(size = 20, color = 'blue', line = list(color = 'yellow', width = 2))) %>%\n  # add_lines(x = df1[,1], y = df1[,2], type=\"scatter\", mode=\"lines\", name=\"Convex Hull\")  %>%\n  layout(title=\"Illustration of Hyperplane (line) Separation of 2D Data\",\n         xaxis=list(title=\"X\", scaleanchor=\"y\"),  # control the y:x axes aspect ratio\n         yaxis = list(title=\"Y\", scaleanchor  = \"x\"), legend = list(orientation = 'h'),\n         annotations = list(text=modelLabels,  x=modelLabels.x, y=modelLabels.y, textangle=c(-40,0),\n                            font=list(size=15, color=modelLabels.col), showarrow=FALSE))\n\n#   # extract the row numbers of the boundary points, in convex order.\n# indx=concaveHull1$arcs[,\"end1\"]  \n# points <- df[indx,2:3]               # extract the boundary points from df\n# points <- rbind(points,points[1,])   # add the closing point\n# # create the SpatialPolygonsDataFrame\n# SpP = SpatialPolygons(list(Polygons(list(Polygon(points)),ID=\"s1\"))) \n# plot(SpP)\n# plot(SpP@polygons[[1]]@Polygons[[1]]@coords[,1], SpP@polygons[[1]]@Polygons[[1]]@coords[,2])",
      "line_count": 97
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "library(plotly)\n\nmtcars$vs[which(mtcars$vs == 0)] <- 'V-Shaped Engine'\nmtcars$vs[which(mtcars$vs == 1)] <- 'Straight Engine'\nmtcars$vs <- as.factor(mtcars$vs)\n\np_2D <- plot_ly(mtcars, x = ~wt, y = ~hp/10, color = ~vs, colors = c('blue', 'red'), name=~vs) %>%\n  add_markers() %>%\n  add_segments(x = 1, xend = 6, y = 8, yend = 18, colors=\"gray\", opacity=0.2, \n               showlegend = FALSE) %>%\n  layout(xaxis = list(title = 'Weight'), yaxis = list(title = 'Horsepower'), legend = list(orientation = 'h'),\n         title=\"(mtcars) Automobile Weight vs. Horsepower Relation\") %>% hide_colorbar()\np_2D",
      "line_count": 13
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "# library(plotly)\n# p_3D <- plot_ly(mtcars, x = ~wt, y = ~hp, z = ~qsec, color = ~vs, colors = c('blue', 'red')) %>%\n#   add_markers() %>%\n#   layout(scene = list(xaxis = list(title = 'Weight'),\n#                     yaxis = list(title = 'Horsepower'),\n#                     zaxis = list(title = '1/4 mile time')))\n#p_3D\n\n# Compute the Normal to the 2D PC plane\nnormVec = c(1, 1.3, -3.0)\n# Compute the 3D point of gravitational balance (Plane has to go through it)\ndMean <- c(3.2, -280, 2)\n\nd <- as.numeric((-1)*normVec %*% dMean)  # force the plane to go through the mean\nx=mtcars$wt; y=mtcars$hp; z=mtcars$qsec; w=mtcars$vs   # define the x, y, z dimensions\nw.col = ifelse(mtcars$vs==\"Straight Engine\", \"blue\", \"red\")\nw.name = ifelse(mtcars$vs==\"Straight Engine\", \"Straight\", \"V-shape\")\n  \n# Reparametrize the 2D (x,y) grid, and define the corresponding model values z on the grid. Recall z=-(d + ax+by)/c, where normVec=(a,b,c)\nx.seq <- seq(min(x),max(x),length.out=100)\ny.seq <- seq(min(y),max(y),length.out=100)\nz.seq <- function(x,y) -(d + normVec[1]*x + normVec[2]*y)/normVec[3]\n# define the values of z = z(x.seq, y.seq), as a Matrix of dimension c(dim(x.seq), dim(y.seq))\nz1 <- t(outer(x.seq, y.seq, z.seq))/10; range(z1)  # we need to check this 10 correction, to ensure the range of z is appropriate!!!\n\n# Draw the 2D plane embedded in 3D, and then add points with \"add_trace\"\nmyPlotly <- plot_ly(x=~x.seq, y=~y.seq, z=~z1,\n                    colors = \"gray\", type=\"surface\", opacity=0.5, showlegend = FALSE) %>%\n    add_trace(data=mtcars, x=x, y=y, z=mtcars$qsec, mode=\"markers\", type=\"scatter3d\",\n              marker = list(color=w.col, opacity=0.9, symbol=105)) %>%\n    layout(showlegend = FALSE,  scene = list(\n        aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1),\n        xaxis = list(title = \"Weight\", range = c(min(x),max(x))),\n        yaxis = list(title = \"Horsepower\", range = c(min(y),max(y))),\n        zaxis = list(title = \"1/4 mile time\", range = c(14, 23)))\n    ) %>% hide_colorbar()\nmyPlotly",
      "line_count": 37
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "# read in data and examine its structure\nhand_letters <- read.csv(\"https://umich.instructure.com/files/2837863/download?download_frd=1\", header = T)\nstr(hand_letters)\n\n# divide into training (3/4) and testing (1/4) data\nhand_letters_train <- hand_letters[1:15000, ]\nhand_letters_test  <- hand_letters[15001:20000, ]",
      "line_count": 7
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "# begin by training a simple linear SVM\nlibrary(kernlab)\nset.seed(123)\nhand_letter_classifier <- ksvm(as.factor(letter) ~ ., data = hand_letters_train, kernel = \"vanilladot\")\n\n# look at basic information about the model\nhand_letter_classifier",
      "line_count": 7
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "# predictions on testing dataset\nhand_letter_predictions <- predict(hand_letter_classifier, hand_letters_test)\n\nhead(hand_letter_predictions)\n\n# table(hand_letter_predictions, hand_letters_test$letter)\n\n# look only at agreements vs. disagreements\n# construct a vector of TRUE/FALSE indicating correct/incorrect predictions\nagreement <- hand_letter_predictions == hand_letters_test$letter # check if characters agree\ntable(agreement)\nprop.table(table(agreement))\n\ntab <- table(hand_letter_predictions, hand_letters_test$letter)\ntab_df <- tidyr::spread(as.data.frame(tab), key = Var2, value = Freq)\n\nsum(diag(table(hand_letter_predictions, hand_letters_test$letter)))\n\nplot_ly(x = colnames(tab), y = colnames(tab), z = as.matrix(tab_df[, -1]), type = \"heatmap\")",
      "line_count": 19
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "hand_letter_classifier_rbf <- ksvm(as.factor(letter) ~ ., data = hand_letters_train, kernel = \"rbfdot\")\nhand_letter_predictions_rbf <- predict(hand_letter_classifier_rbf, hand_letters_test)\n\nagreement_rbf <- hand_letter_predictions_rbf == hand_letters_test$letter\ntable(agreement_rbf)\nprop.table(table(agreement_rbf))",
      "line_count": 6
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "data(iris)\nstr(iris)\ntable(iris$Species)",
      "line_count": 3
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "sub<-sample(nrow(iris), floor(nrow(iris)*0.75))\niris_train<-iris[sub, ]\niris_test<-iris[-sub, ]",
      "line_count": 3
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "library(e1071)\niris.svm_1 <- svm(Species~Petal.Length+Petal.Width, data=iris_train,\n                kernel=\"linear\", cost=1)\niris.svm_2 <- svm(Species~Petal.Length+Petal.Width, data=iris_train,\n                kernel=\"radial\", cost=1)\npar(mfrow=c(2,1))\nplot(iris.svm_1, iris[,c(5,3,4)], symbolPalette = rainbow(4), color.palette = terrain.colors)\nlegend(\"center\", \"Linear\")\nplot(iris.svm_2, iris[,c(5,3,4)], symbolPalette = rainbow(4), color.palette = terrain.colors)\nlegend(\"center\", \"Radial\", )",
      "line_count": 10
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "# install.packages(\"kernlab\")\nlibrary(kernlab)\niris_clas <- ksvm(Species~., data=iris_train, kernel=\"vanilladot\")\niris_clas",
      "line_count": 4
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "iris.pred<-predict(iris_clas, iris_test)\ntable(iris.pred, iris_test$Species)",
      "line_count": 2
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "agreement<-iris.pred==iris_test$Species\nprop.table(table(agreement))",
      "line_count": 2
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "iris_clas1<-ksvm(Species~., data=iris_train, kernel=\"rbfdot\")\niris_clas1\niris.pred1<-predict(iris_clas1, iris_test)\ntable(iris.pred1, iris_test$Species)\nagreement<-iris.pred1==iris_test$Species\nprop.table(table(agreement))",
      "line_count": 6
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "costs = exp(-5:8)\ntune.svm(Species~., kernel = \"radial\", data = iris_train, cost = costs)",
      "line_count": 2
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "# install.packages(\"sparsediscrim\") \nset.seed(2017)\n\n# Install the Package sparsediscrim: https://cran.r-project.org/src/contrib/Archive/sparsediscrim/\n# install.packages(\"corpcor\", \"bdsmatrix\")\n# install.packages(\"C:/Users/Dinov/Desktop/sparsediscrim_0.2.4.tar.gz\", repos = NULL, type=\"source\")\nlibrary(sparsediscrim)\nlibrary (reshape); library(ggplot2)\nfolds = cv_partition(iris$Species, num_folds = 5)\ntrain_cv_error_svm = function(costC) {\n  #Train\n  ir.svm = svm(Species~., data=iris,\n                 kernel=\"radial\", cost=costC)\n  train_error = sum(ir.svm$fitted != iris$Species) / nrow(iris)\n  #Test\n  test_error = sum(predict(ir.svm, iris_test) != iris_test$Species) / nrow(iris_test)\n  #CV error\n  ire.cverr = sapply(folds, function(fold) {\n    svmcv = svm(Species~.,data = iris, kernel=\"radial\", cost=costC, subset = fold$training)\n    svmpred = predict(svmcv, iris[fold$test,])\n    return(sum(svmpred != iris$Species[fold$test]) / length(fold$test))\n  })\n  cv_error = mean(ire.cverr)\n  return(c(train_error, cv_error, test_error))\n}\n\ncosts = exp(-5:8)\nir_cost_errors = sapply(costs, function(cost) train_cv_error_svm(cost))\ndf_errs = data.frame(t(ir_cost_errors), costs)\ncolnames(df_errs) = c('Train', 'CV', 'Test', 'Logcost')\ndataL <- melt(df_errs, id=\"Logcost\")\n\n# ggplot(dataL, aes_string(x=\"Logcost\", y=\"value\", colour=\"variable\",\n#                          group=\"variable\", linetype=\"variable\", shape=\"variable\")) +\n#   geom_line(size=1) + labs(x = \"Cost\",\n#                            y = \"Classification error\",\n#                            colour=\"\",group=\"\",\n#                            linetype=\"\",shape=\"\") + scale_x_log10()\n\nplot_ly(dataL, x = ~log(Logcost), y = ~value, color = ~variable, \n        colors = c('blue', 'red', \"green\"), type=\"scatter\", mode=\"lines\") %>%\n  layout(xaxis = list(title = 'log(Cost)'), yaxis = list(title = 'Classifier Error'), legend = list(orientation = 'h'),\n         title=\"SVM CV-Plot of Model Performance (Iris Data)\") %>% hide_colorbar()",
      "line_count": 43
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "set.seed(2020)\ngammas = exp(-5:5)\ntune_g = tune.svm(Species~., kernel = \"radial\", data = iris_train, cost = costs, gamma = gammas)\ntune_g",
      "line_count": 4
    },
    {
      "section": "Support Vector Machines (SVM)",
      "code": "iris.svm_g <- svm(Species~., data=iris_train,\n                kernel=\"radial\", gamma=0.0183, cost=20)\ntable(iris_test$Species, predict(iris.svm_g, iris_test))\nagreement<-predict(iris.svm_g, iris_test)==iris_test$Species\nprop.table(table(agreement))",
      "line_count": 5
    },
    {
      "section": "Ensemble meta-learning",
      "code": "qol <- read.csv(\"https://umich.instructure.com/files/481332/download?download_frd=1\")\nqol <- qol[!qol$CHARLSONSCORE==-9 , -c(1, 2)]\nqol$CHARLSONSCORE <- as.factor(qol$CHARLSONSCORE)",
      "line_count": 3
    },
    {
      "section": "Ensemble meta-learning",
      "code": "# install.packages(\"ipred\")\nlibrary(ipred)\nset.seed(123)\nmybag<-bagging(CHARLSONSCORE ~ ., data=qol, nbagg=25)",
      "line_count": 4
    },
    {
      "section": "Ensemble meta-learning",
      "code": "bt_pred <- predict(mybag, qol)\nagreement <- bt_pred==qol$CHARLSONSCORE\nprop.table(table(agreement))",
      "line_count": 3
    },
    {
      "section": "Ensemble meta-learning",
      "code": "library(caret)\nset.seed(123)\nctrl <- trainControl(method=\"repeatedcv\", number = 10, repeats = 10)\ntrain(CHARLSONSCORE ~ ., data=as.data.frame(qol), method=\"treebag\", trControl=ctrl)",
      "line_count": 4
    },
    {
      "section": "Ensemble meta-learning",
      "code": "set.seed(123)\nctrl <- trainControl(method=\"repeatedcv\", number = 10, repeats = 10)\ntrain(as.factor(QOL_Q_01) ~ . , data=as.data.frame(qol), method=\"treebag\", trControl=ctrl)",
      "line_count": 3
    },
    {
      "section": "Ensemble meta-learning",
      "code": "str(svmBag)",
      "line_count": 1
    },
    {
      "section": "Ensemble meta-learning",
      "code": "svmBag$fit",
      "line_count": 1
    },
    {
      "section": "Ensemble meta-learning",
      "code": "bagctrl <- bagControl(fit=svmBag$fit, predict = svmBag$pred, aggregate=svmBag$aggregate)\nqol.rand <- qol[order(runif(2328)), ]\nset.seed(123)\nsvmbag <- train(grade ~ ., data=boystown_n, \"bag\", trControl=ctrl, bagControl=bagctrl)\nsvmbag",
      "line_count": 5
    },
    {
      "section": "Ensemble meta-learning",
      "code": "# install.packages(\"randomForest\")\nlibrary(randomForest)\nset.seed(123)\nrf <- randomForest(as.factor(QOL_Q_01) ~ . , data=qol)\nrf",
      "line_count": 5
    },
    {
      "section": "Ensemble meta-learning",
      "code": "library(caret)\nctrl <- trainControl(method=\"cv\", number=10)\ngrid_rf <- expand.grid(mtry=c(2, 4, 8, 16))",
      "line_count": 3
    },
    {
      "section": "Ensemble meta-learning",
      "code": "set.seed(123)\nm_rf <- train(as.factor(QOL_Q_01) ~ ., data = qol, method = \"rf\", \nmetric = \"Kappa\", trControl = ctrl, tuneGrid = grid_rf)\nm_rf",
      "line_count": 4
    },
    {
      "section": "Ensemble meta-learning",
      "code": "# Prep the data\nqol <- read.csv(\"https://umich.instructure.com/files/481332/download?download_frd=1\")\nqol <- qol[!qol$CHARLSONSCORE==-9 , -c(1, 2)]\nqol$CHARLSONSCORE <- as.factor(qol$CHARLSONSCORE)\n#qol$QOL_Q_01 <- as.factor(qol$QOL_Q_01)\nqol <- qol[!qol$CHARLSONSCORE==-9 , -c(1, 2)]\nqol$cd <- qol$CHRONICDISEASESCORE>1.497\nqol$cd <- factor(qol$cd, levels=c(F, T), labels = c(\"minor_disease\", \"severe_disease\"))\nqol <- qol[!qol$CHRONICDISEASESCORE==-9, ]\n\n# install.packages(\"ada\"); install.packages(\"adabag\")\nlibrary(\"ada\"); library(\"adabag\")\nset.seed(123)\n# qol_boost <- boosting(QOL_Q_01 ~ . , data=qol, mfinal = 100, coeflearn = 'Breiman')\n# mean(qol_boost$class==qol$QOL_Q_01)\nqol_boost <- boosting(cd ~ . , data=qol[, -37], mfinal = 100, coeflearn = 'Breiman')\nmean(qol_boost$class==qol$cd)\n\nset.seed(123)\n#qol_boost <- boosting(QOL_Q_01 ~ ., data=qol, mfinal = 100, coeflearn = 'Breiman')\n#mean(qol_boost$class==qol$QOL_Q_01)\nqol_boost <- boosting(cd ~ . , data=qol[, -37], mfinal = 100, coeflearn = 'Breiman')\nmean(qol_boost$class==qol$cd)\n\nset.seed(1234)\n#qol_boost <- boosting(QOL_Q_01 ~ ., data=qol, mfinal = 100, coeflearn = 'Zhu')\n#mean(qol_boost$class==qol$QOL_Q_01)\nqol_boost <- boosting(cd ~ . , data=qol[, -37], mfinal = 100, coeflearn = 'Zhu')\nmean(qol_boost$class==qol$cd)",
      "line_count": 29
    },
    {
      "section": "Practice SVM Problems",
      "code": "google_model3 <- neuralnet(Investing~Unemployment+Rental+RealEstate+Mortgage+Jobs+DJI_Index+StdDJI, data=google_train, hidden = 3)\nplot(google_model3)\ngoogle_pred3<-compute(google_model3, google_test[, c(1:5, 7:8)])\npred_results3<-google_pred3$net.result\ncor(pred_results3, google_test$Investing)",
      "line_count": 5
    },
    {
      "section": "Practice SVM Problems",
      "code": "qol <- read.csv(\"https://umich.instructure.com/files/481332/download?download_frd=1\")\nfeatureLength <- dim(qol)[2]\nstr(qol[, c((featureLength-3):featureLength)])",
      "line_count": 3
    },
    {
      "section": "Practice SVM Problems",
      "code": "qol <- qol[!qol$CHARLSONSCORE==-9 , -c(1, 2)]\nqol$CHARLSONSCORE<-as.factor(qol$CHARLSONSCORE)\nfeatureLength <- dim(qol)[2]\nstr(qol[, c((featureLength-3):featureLength)])",
      "line_count": 4
    },
    {
      "section": "Practice SVM Problems",
      "code": "sub <- sample(nrow(qol), floor(nrow(qol)*0.75))\nqol_train <- qol[sub, ]\nqol_test <- qol[-sub, ]\nqol_clas2 <- ksvm(CHARLSONSCORE~., data=qol_train, kernel=\"rbfdot\", C=2)\nqol_clas2\nqol.pred2 <- predict(qol_clas2, qol_test)\n\n# table(qol.pred2, qol_test$CHARLSONSCORE)\nagreement <- qol.pred2==qol_test$CHARLSONSCORE\nprop.table(table(agreement))\n\ntab <- table(qol.pred2, qol_test$CHARLSONSCORE)\ntab_df <- tidyr::spread(as.data.frame(tab), key = Var2, value = Freq)\n\nsum(diag(table(hand_letter_predictions, hand_letters_test$letter)))\n\nplot_ly(x = colnames(tab), y = colnames(tab), z = as.matrix(tab_df[, -1]), type = \"heatmap\")",
      "line_count": 17
    },
    {
      "section": "Practice SVM Problems",
      "code": "qol_clas3 <- ksvm(CHARLSONSCORE~., data=qol_train, kernel=\"rbfdot\", C=3)\nqol_clas3\nqol.pred3 <- predict(qol_clas3, qol_test)\n# table(qol.pred3, qol_test$CHARLSONSCORE)\nagreement <- qol.pred3==qol_test$CHARLSONSCORE\nprop.table(table(agreement))\n\ntab <- table(qol.pred3, qol_test$CHARLSONSCORE)\ntab_df <- tidyr::spread(as.data.frame(tab), key = Var2, value = Freq)\n\nsum(diag(table(hand_letter_predictions, hand_letters_test$letter)))\n\nplot_ly(x = colnames(tab), y = colnames(tab), z = as.matrix(tab_df[, -1]), type = \"heatmap\")",
      "line_count": 13
    }
  ]
}