{
  "metadata": {
    "created_at": "2024-11-30T13:46:16.161521",
    "total_sections": 39,
    "total_code_chunks": 48,
    "total_tables": 3,
    "r_libraries": [
      "MASS",
      "Rtsne",
      "factoextra",
      "fastICA",
      "ggplot2",
      "graphics",
      "imager",
      "nFactors",
      "plotly",
      "reshape2",
      "reticulate",
      "rgl",
      "rvest",
      "scatterplot3d",
      "simplextree",
      "umap"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"DSPA2: Data Science and Predictive Analytics (UMich HS650)\"\nsubtitle: \"<h2><u>Linear and Nonlinear Dimensionality Reduction</u></h2>\"\nauthor: \"<h3>SOCR/MIDAS (Ivo Dinov)</h3>\"\ndate: \"`r format(Sys.time(), '%B %Y')`\"\ntags: [DSPA, SOCR, MIDAS, Big Data, Predictive Analytics] \noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: SOCR_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 3\n    toc_float:\n      collapsed: false\n      smooth_scroll: true\n    code_folding: show\nWe use a simple 2D rotation matrix example to demonstrate the rationale for representing complex phenomena in terms of corresponding simple lower-dimensional fundamental constituents. Specifically, we will discuss linear and nonlinear data dimensionality reduction techniques, such as principal and independent component analyses, factor analysis, matrix singular value decomposition, t-distributed stochastic neighbor embedding, and uniform manifold approximation and projection. These methods will be applied to hand-written digit recognition imaging data and Parkinsonâ€™s disease clinical data.",
      "word_count": 129
    },
    {
      "title": "Motivational Example: Reducing 2D to 1D",
      "content": "Now that we have most of the `R` fundamentals covered and saw a model-based forecasting (multivariate linear regression), we can delve into more interesting ML/AI data analytic methods. *Dimension reduction* reduces the number of features when dealing with a very large number of variables. Linear and nonlinear dimension reduction can help us extract a set of \"uncorrelated\" (principal) variables, reduce the complexity of the data, and facilitate supervised data clustering and unsupervised classification. Dimensionality reduction is related to feature selection, however, it goes beyond simply picking some of the original variables. Rather, we are constructing new (uncorrelated) variables, which sometimes may be expressed as linear functions of the original features, and sometimes can only be inferred as highly nonlinear transformations (maps) of the initial state space.\n\nDimensionality reduction techniques enable exploratory data analytics by reducing the complexity of the dataset, still approximately preserving important process characteristics, such as retaining the distances between cases or subjects. If we are able to reduce the complexity down to a few dimensions and protect some of that information content in the data, then we may visually inspect the data and try other lower-dimensional methods to untangle its intrinsic characteristics.\n\nAll *dimensionality reduction* techniques carry some resemblance to *variable selection*, which we will see in [Chapter 11](https://socr.umich.edu/DSPA2/DSPA2_notes/11_FeatureSelection.html). The *continuous* process of dimensionality reduction yields lower variability compared to the *discrete* feature selection process, e.g., see [Wolfgang M. Hartmann's paper](https://link.springer.com/chapter/10.1007/11558958_113).\n\nSpecifically, we will (1) start with a synthetic example demonstrating the reduction of a 2D data into 1D, (2) explain the notion of rotation matrices, (3) show examples of principal component analysis (PCA), singular value decomposition (SVD), independent component analysis (ICA), factor analysis (FA), and t-distributed Stochastic Neighbor Embedding (t-SNE), Uniform Manifold Approximation and Projection (UMAP), and (4) present a Parkinson's disease case-study at the end.\n\nLet's consider a simple example of twin heights. Suppose we simulate $1,000$ 2D points that representing *normalized* individual heights, i.e., number of standard deviations from the mean height. Each 2D point represents a pair of twins. We will simulate this scenario using [Bivariate Normal Distribution](https://socr.umich.edu/HTML5/BivariateNormal/).\n\n\n$$ y^T_{2\\times500} = \\begin{bmatrix}\n    y[1, ]=Twin1_{Height} \\\\\n    y[2, ]=Twin2_{Height}\n\\end{bmatrix} \\sim BVN \\left ( \\mu= \\begin{bmatrix}\n    Twin1_{Height} \\\\\n    Twin2_{Height}\n\\end{bmatrix} , \\Sigma=\\begin{bmatrix}\n    1 & 0.95 \\\\\n    0.95 & 1\n\\end{bmatrix}\n\\right ) .$$\n \n\nThese data may represent a fraction of the information included in a high-throughput neuroimaging genetics study of twins. You can see [one example of such pediatric study here](https://wiki.socr.umich.edu/index.php/SOCR_Data_Oct2009_ID_NI). \n\nTracking the distances between any two samples can be accomplished using the `dist` function. `stats::dist()` is a function computing the distance matrix (according to a user-specified  distance metric, default=Euclidean) representing the distances between the *rows of the data matrix*. For example, here is the distance between the two RED points in the figure above:\n\n\nTo reduce the 2D data to a simpler 1D plot we can transform the data to a 1D matrix (vector) preserving (approximately) the distances between the 2D points.\n\nThe 2D plot shows the Euclidean distance between the pair of RED points, the length of this line is the distance between the 2 points. In 2D, these lines tend to go along the direction of the diagonal. If we `rotate` the plot so that the diagonal aligned with the x-axis we get the following *raw* and *transformed* plots:\n\n\nOf course, matrix linear algebra notation can be used to represent this affine transformation of the data. Here we can see that to get the result `z`, we multiplied `y` by the matrix $A$:\n\n$$ A = \\begin{pmatrix}\n1/2&1/2\\\\\n1&-1\\\\\n\\end{pmatrix}\n\\implies z = A \\times y .$$\n\nWe can invert this transform by multiplying the result by the `inverse` (rotation matrix?) $A^{-1}$ as follows:\n\n$$ A^{-1} = \\begin{pmatrix}\n1&1/2\\\\\n1&-1/2\\\\\n\\end{pmatrix}\n\\implies y = A^{-1} \\times z $$\n\nYou can try this in `R`:\n\nNote that this matrix transformation did not preserve distances, i.e., it's not a simple rotation in 2D:",
      "word_count": 649
    },
    {
      "title": "Matrix Rotations",
      "content": "One important question is how to identify transformations that preserve distances. In mathematics, transformations between metric spaces that are distance-preserving are called `isometries` (or `congruences` or congruent transformations).\n\nFirst, let's test the MA transformation we used above:\n$$A=\\frac{Y_1+Y_2}{2} \\\\ M=Y_1 - Y_2.$$\n\n\nObserve that this MA transformation is not an isometry - the distances are not preserved. Here is one example with $v1=\\begin{bmatrix} v1_x=0 \\\\ v1_y=1 \\end{bmatrix}$, $v2=\\begin{bmatrix} v2_x=1 \\\\ v2_y=0 \\end{bmatrix}$, which are distance $\\sqrt{2}$ apart in their native space, but separated further by the transformation $MA$, $d(MA(v1),MA(v2))=2$.\n\n\nMore generally, if\n$$ \\begin{pmatrix}\nY_1\\\\\nY_2\\\\\n\\end{pmatrix}\n\\sim BVN \\left( \\begin{pmatrix}\n\\mu_1\\\\\n\\mu_2\\\\\n\\end{pmatrix},\n\\begin{pmatrix}\n\\sigma_1^2&\\sigma_{12}\\\\\n\\sigma_{12}&\\sigma_2^2\\\\\n\\end{pmatrix}\n\\right).$$\n\nThen,\n$$ Z = AY + \\eta \\sim BVN(\\eta + A\\mu,A\\Sigma A^{T}),$$\n\nwhere [BVN denotes bivariate normal distribution](http://www.distributome.org/V3/calc/2D_BivariateNormalCalculator.html), $A = \\begin{pmatrix}a&b\\\\c&d\\\\ \\end{pmatrix}$, $Y=(Y_1,Y_2)^T$, $\\mu = (\\mu_1,\\mu_2)$, $\\Sigma = \\begin{pmatrix} \\sigma_1^2&\\sigma_{12}\\\\ \\sigma_{12}&\\sigma_2^2\\\\ \\end{pmatrix}$.\n\nYou can verify this by using the [change of variable theorem](https://en.wikipedia.org/wiki/Change_of_variables). Thus, affine transformations preserve bivariate normality. However, in general, the linear transformation ($A$) is not guaranteed to be an isometry. \n\nThe question now is under what additional conditions for the transformation matrix $A$, can we guarantee an isometry.\n\nNotice that,\n$$ d^2(P_i,P_j) =\\sum_{k=1}^{n} (P_{jk}-P_{ik})^2 = ||P||^2 = P^TP,$$\n\nwhere $P = (P_{j,1}-P_{i,1},...,P_{j,n}-P_{i,n})^T$, $P_i,P_j \\in \\mathbb{R}^n$ are any two points in $n$ dimensions.\n\nThus, the only requirement we need for $A$ to be an isometry is $(AY)^T(AY)=Y^TY$, i.e., $A^TA=I$, which implies that $A$ is an orthogonal (rotational) matrix.\n\nLet's use a two dimension orthogonal matrix to illustrate this.\n\nSet $A = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}1&1\\\\1&-1\\\\ \\end{pmatrix}$. It's easy to verify that $A$ is an orthogonal (2D rotation) matrix.\n\nThe simplest way to test the isometry is to perform the linear transformation directly as follows.\n\n\nWe can observe that the distances between points computed from original data and the transformed data are the same. Thus, the transformation $A$ is called a rotation (isometry) of $y$. \n\nThe alternative method is to simulate from the joint distribution of $Z = (Z_1,Z_2)^T$. \n\nAs we have mentioned above: $Z = AY + \\eta \\sim BVN(\\eta + A\\mu,A\\Sigma A^{T})$.\n\nwhere $\\eta = (0,0)^T$, $\\Sigma = \\begin{pmatrix} 1&0.95\\\\0.95&1\\\\ \\end{pmatrix}$, $A = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}1&1\\\\1&-1\\\\ \\end{pmatrix}$.\n\nWe can compute $A\\Sigma A^{T}$ by hand or using matrix multiplication in `R`:\n\n\n$A\\Sigma A^{T}$ represents the variance-covariance matrix, $cov(z_1,z_2)$.  We can simulate $z_1$, $z_2$ independently from $z_1\\sim N(0,1.95)$ and $z_2 \\sim N(0,0.05)$. Note that *independence* and *uncorrelation* are equivalent for bivariate normal distribution.\n\n\nLet's demonstrate that the rotation transform $A = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}1&1\\\\1&-1\\\\ \\end{pmatrix}: y\\to z\\equiv Ay$ preserves twin-pair distances by plotting the raw and transformed distances and computing the pre- and post-transform distances between two pair of twins.\n\n\nWe applied this transformation and observed that the *distances between points were unchanged after the rotation* $A$. This rotation achieves the goals of:\n\n* preserving the distances between points, and \n* reducing the dimensionality of the data (see plot reducing 2D to 1D). \n\n*Removing the second dimension* and recomputing the distances, we get:\n\n\nThe 1D distance provides a very good approximation to the actual 2D distance. This first dimension of the transformed data is called the first `principal component`. In general, this idea motivates the use of principal component analysis (PCA) and the singular value decomposition (SVD) to achieve dimension reduction.",
      "word_count": 537
    },
    {
      "title": "Notation",
      "content": "In the notation above, the rows represent variables and columns represent cases. In general, rows represent cases and columns represent variables. Hence, in our example shown here, $Y$ would be transposed to be an $N \\times 2$ matrix. This is the most common way to represent the data: individuals in the rows, features are columns. In genomics, it is more common to represent subjects/SNPs/genes in the columns. For example, genes are rows and samples are columns. The sample covariance matrix usually denoted with\n$\\mathbf{X}^\\top\\mathbf{X}$ and has cells representing covariance between two units. Yet for this to be the case, we need the rows of $\\mathbf{X}$ to represent units. Here, we have to compute $\\mathbf{Y}\\mathbf{Y}^\\top$ instead following the rescaling.",
      "word_count": 118
    },
    {
      "title": "Summary (PCA vs. ICA vs. FA)",
      "content": "Principal Component Analysis (PCA), Independent Component Analysis (ICA), and Factor Analysis (FA) are similar strategies, seeking to identify a new basis (vectors representing the principal directions) that the data is projected against to maximize certain (specific to each technique) objective function. These basis functions, or vectors, are just linear combinations of the original features in the data/signal. \n\nThe singular value decomposition (SVD), discussed later in this chapter, provides a specific matrix factorization algorithm that can be employed in various techniques to decompose a data matrix $X_{m\\times n}$ as ${U\\Sigma V^{T}}$, where ${U}$ is an $m \\times m$ real or complex unitary matrix (${U^TU=UU^T=I}$, i.e., $|\\det(U)|=1$), ${\\Sigma }$ is a $m\\times n$ rectangular diagonal matrix of *singular values*, representing non-negative values on the diagonal, and ${V}$ is an $n\\times n$ unitary matrix.",
      "word_count": 131
    },
    {
      "title": "Principal Component Analysis (PCA)",
      "content": "PCA (principal component analysis) is a mathematical procedure that transforms a number of possibly correlated variables into a smaller number of uncorrelated variables through a process known as orthogonal transformation.\n\n**Principal Components**\n\nLet's consider the simplest situation where we have *n* observations $\\{p_1, p_2, ..., p_n\\}$ with 2 features $p_i=(x_i, y_i)$. When we draw them on a plot, we use x-axis and y-axis for positioning. However, we can make our own coordinate system by principal components.\n\n\nIllustrated on the graph, the first PC, $pc_1$ is a minimum distance fit in the feature space. The second PC is a minimum distance fit to a line perpendicular to the first PC. Similarly, the third PC would be a minimum distance fit to all previous PCs. In our case of a 2D space, two PCs are the most we can have. In higher dimensional spaces, we need to consider how many PCs do we need to make the best performance.\n\nIn general, the formula for the first PC is $pc_1=a_1^TX=\\sum_{i=1}^N a_{i, 1}X_i$ where $X_i$ is a $n\\times 1$ vector representing a column of the matrix $X$ (representing a total of n observations and N features). The weights $a_1=\\{a_{1, 1}, a_{2, 1}, ..., a_{N, 1}\\}$ are chosen to maximize the variance of $pc_1$. According to this rule, the $k^{th}$ PC is $pc_k=a_k^TX=\\sum_{i=1}^N a_{i, k}X_i$. $a_k=\\{a_{1, k}, a_{2, k}, ..., a_{N, k}\\}$ has to be constrained by more conditions:\n\n1. Variance of $pc_k$ is maximized\n2. $Cov(pc_k, pc_l)=0$, $\\forall 1\\leq l<k$\n3. $a_k^Ta_k=1$ (the weights vectors are unitary)\n\nLet's figure out how to find $a_1$. First we need to express the variance of our first principal component using the variance covariance matrix of $X$:\n$$Var(pc_1)=E(pc_1^2)-(E(pc_1))^2=$$\n$$\\sum_{i, j=1}^N a_{i, 1} a_{j, 1} E(x_i x_j)-\\sum_{i, j=1}^N a_{i, 1} a_{j, 1} E(x_i)E(x_j)=$$\n$$\\sum_{i, j=1}^N a_{i, 1} a_{j, 1} S_{i, j}.$$\n\nWhere $S_{i, j}=E(x_i x_j)-E(x_i)E(x_j)$.\n\nThis implies $Var(pc_1)=a_1^TS a_1$ where $S=S_{i, j}$ is the covariance matrix of $X=\\{X_1, ..., X_N\\}$. Since $a_1$ maximized $Var(pc_1)$ and the constrain $a_1^T a_1=1$ holds, we can rewrite $a_1$ as:\n$$a_1=max_{a_1}(a_1^TS a_1-\\lambda (a_1^T a_1-1))$$\nWhere the second part after the minus sign should be 0. To maximize this quadratic expression, we can take the derivative of this expression w.r.t. $a_1$ and set it to 0. This yields $(S-\\lambda I_N)a_1=0$.\n\nIn [Chapter 3](https://socr.umich.edu/DSPA2/DSPA2_notes/03_LinearAlgebraMatrixComputingRegression.html) we showed that $a_1$ will correspond to the largest eigenvalue of $S$, the variance covariance matrix of $X$. Hence, $pc_1$ retains the largest amount of variation in the sample. Likewise, $a_k$ is the $k^{th}$ largest eigenvalue of $S$.\n\nPCA requires the mean for each column in the data matrix to be zero. That is, the sample mean of each column is shifted to zero. \n\nLet's use a subset (N=33) of [Parkinson's Progression Markers Initiative (PPMI) data](https://wiki.socr.umich.edu/index.php/SMHS_PCA_ICA_FA#Parkinson.27s_disease_case_study) to demonstrate the relationship between $S$ and PC loadings. First, we need to import the dataset into R and delete the patient ID column.\n\n\nThen, we need to center the `pdsub` by subtracting the average of all column means from each element in the column. Next, we cast `pd.sub` as a matrix and compute its variance covariance matrix, $S$. Finally, we can calculate the corresponding eigenvalues and eigenvectors of $S$.\n\n\nThe next step would be calculating the PCs using the `prcomp()` function in R. Note that we will use the raw (`uncentered`) version of the data and have to specify the `center=TRUE` option to ensure the column means are trivial. We can save the model information into `pca1` where `pca1$rotation` provides the loadings for each PC.\n\n\nWe notice that the loadings are just the eigenvectors times `-1`. These loadings represent vectors in 6D space (we have 6 columns in the original data). The scale factor `-1`  just represents the opposite direction of the eigenvector. We can also load the `factoextra` package and compute the eigenvalues of each PC.\n\n\nThe eigenvalues correspond to the amount of the variation explained by each principal component (PC), which is the same as the eigenvalues of the $S$ matrix.\n\nTo see a detailed information about the *variances* explained by each PC, relative to the corresponding PC loadings.\n\nIn the 3D loadings interactive plot below, you need to zoom-in to see the smaller projections (original features that have lower impact after the linear PC rotation).\n\n\nThe scree-plot has a clear \"elbow\" point at the second PC, suggesting that the first two PCs explain about 95% of the variation in the original dataset. Thus, we say we can use the first 2 PCs to represent the data. In this case, the dimension of the data is substantially reduced. \n\nThe dynamic 3D `plot_ly` graph uses PC1, PC2, and PC3 as the coordinate axes to represent the new variables and the lines radiating from the origin show the loadings on the original features. This *triplot* help us to visualize how the loadings are used to rearrange the structure of the data. \n\nNext, let's try to obtain a bootstrap test for the confidence interval of the explained variance.\n\n\nSuppose we want to fit a linear model `Top_of_SN_Voxel_Intensity_Ratio ~ Side_of_SN_Voxel_Intensity_Ratio + Part_IA`. We can use `plot_ly` to show a 3D scatterplot and the (univariate) linear model. \n\n\nWe can also plot in 3D a bivariate 2D plane model (e.g., `lm.fit', or `pca1`) for the 3D scatter (Top_of_SN_Voxel_Intensity_Ratio, Side_of_SN_Voxel_Intensity_Ratio, Part_IA). Below is an example using the linear model.\n\n\nNext are examples of plotting the 3D scatter along with the 2D PCA model using either `rgl` or `plot_ly`.\n\n\nAnother alternative is to use `plot_ly` for the interactive 3D visualization. First, we demonstrate displaying the `lm()` derived plane modeling superimposed on the 3D scatterplot (using `pd.sub$Side_of_SN_Voxel_Intensity_Ratio`, `pd.sub$Top_of_SN_Voxel_Intensity_Ratio`, and `pd.sub$Part_IA`).\n\n\nSecond, we show the PCA-derived 2D plane model superimposed on the 3D scatterplot.\n\n\nAs stated in the [summary table](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/05_DimensionalityReduction.html#4_summary_(pca_vs_ica_vs_fa)), classical PCA assumes that the bivariate relations are linear in nature. The non-linear PCA is a generalization that allows us to incorporate nominal and ordinal variables, as well as to handle and identify nonlinear relationships between variables in the dataset. See Chapter 2 of this textbook [Nonparametric inference in nonlinear principal components analysis: exploration and beyond](https://openaccess.leidenuniv.nl/handle/1887/12386).\n\nNon-linear PCA assigns values to the categories representing the numeric variables, which maximize the association (e.g., correlation) between the quantified variables (i.e., optimal scaling to quantify the variables according to their analysis levels). The [Bioconductor's pcaMethods](https://www.bioconductor.org/packages/release/bioc/html/pcaMethods.html) package provides the functionality for non-linear PCA.",
      "word_count": 1046
    },
    {
      "title": "Independent component analysis (ICA)",
      "content": "ICA aims to find basis vectors representing independent components of the original data. For example, this may be achieved by maximizing the norm of the $4^{th}$ order normalized kurtosis, which iteratively projects the signal on a new basis vector, computes the objective function (e.g., the norm of the kurtosis) of the result, slightly adjusts the basis vector (e.g., by gradient ascent), and recomputes the kurtosis again. At the end, this iterative process generates a basis vector corresponding to the highest (residual) kurtosis representing the next independent component. \n\nThe process of Independent Component Analysis is to maximize the statistical independence of the estimated components. Assume that each variable $X_i$ is generated by a sum of *n* independent components.\n$$X_i=a_{i, 1}s_1+...+a_{i, n}s_n$$\nHere, $X_i$ is generated by $s_1, ..., s_n$ and $a_{i,1}, ... a_{i,n}$ are the corresponding weights. Finally, we rewrite $X$ as\n$$X=As,$$\nwhere $X=(X_1, ..., X_n)^T$, $A=(a_1, ..., a_n)^T$, $a_i=(a_{i,1}, ..., a_{i,n})$ and $s=(s_1, ..., s_n)^T$. Note that $s$ is obtained by maximizing the independence of the components. This procedure is done by maximizing some *independence* objective function.\n\nICA does not assume that all of its components ($s_i$) are Gaussian and independent of each other.\n\nWe will utilize the `fastICA` function in R.\n\n`fastICA(X, n.comp, alg.typ, fun, rownorm, maxit, tol)`\n\n* **X**: data matrix\n* **n.comp**:number of components, \n* **alg.type**: components extracted simultaneously(`alg.typ == \"parallel\"`) or one at a time(`alg.typ == \"deflation\"`)\n* **fun**: functional form of F to approximate to neg-entropy, \n* **rownorm**: whether rows of the data matrix X should be standardized beforehand\n* **maxit**: maximum number of iterations \n* **tol**: a positive scalar giving the tolerance at which the un-mixing matrix is considered to have converged.\n\nNow we can create a correlated matrix $X$. \n\nThe correlation between two variables is -0.4. Then we can start to fit the ICA model.\n\nTo visualize the correlation of the original pre-processed data ($X$) and the independence of the corresponding ICA components $S=fastICA(X)\\$S$ we can draw the following composite scatter-plot.\n\n\nFinally we can confirm that the correlation of two components is nearly 0.\n\n\nLet's look at a more interesting example, based on the `pd.sub` dataset. It has 6 variables and the correlation is relatively high. After fitting the ICA model. The components are nearly independent.\n\nNotice the independence of the ICA components, $\\rho(i,j)\\sim 0, \\ \\forall i\\not= j$. Furthermore, we can reduce the dimension of the original data (6D) to 2-3 ICA components.",
      "word_count": 402
    },
    {
      "title": "Factor analysis (FA)",
      "content": "Similar to ICA and PCA, FA tries to find special principal components in data. As a generalization of PCA, FA requires that the number of components is smaller than the original number of variables (or columns of the data matrix). FA optimization relies on iterative perturbations with full-dimensional Gaussian noise and maximum-likelihood estimation where every observation in the data represents a sample point in a higher dimensional space. Whereas PCA assumes the noise is spherical, Factor Analysis allows the noise to have an arbitrary diagonal covariance matrix and estimates the subspace as well as the noise covariance matrix.\n\nUnder FA, the centered data can be expressed in the following from:\n\n$$x_i-\\mu_i=l_{i, 1}F_1+...+l_{i, k}F_k+\\epsilon_i=LF+\\epsilon_i,$$\n\nwhere $i\\in {1, ..., p}$, $j \\in{1, ..., k}$, $k<p$ and $\\epsilon_i$ are independently distributed error terms with zero mean and finite variance.\n\nLet's try FA in R using the function `factanal()`. According to the previous PCA, our `pd.sub` dataset can explain 95% of variance using only the first two principal components. This suggests that we might need 2 factors in FA. We can double check that by examining the *scree* plot.\n\n\nNote that 3 out of 4 Cattell's Scree test rules summary suggest we should use 2 factors. Thus, in the function `factanal()` we can specify `factors=2`. In addition, we can use `varimax` rotation of the factor axes maximizing the variance of the squared loadings of factors (columns) on the original variables (rows), which effectively differentiates the original variables by the extracted factors. Oblique `promax` and `Procrustes rotation` (projecting the loadings to a target matrix with a simple structure) are two alternative and commonly used matrix rotations that may be specified.\n\n\nHere the p-value 0.854 is very large, suggesting that we failed to reject the null-hypothesis that 2 factors are sufficient. We can also visualize the loadings for all the variables.\n\n\nThis plot displays *factors 1* and *2* on the x-axis and y-axis, respectively.",
      "word_count": 318
    },
    {
      "title": "Singular Value Decomposition (SVD)",
      "content": "SVD is a factorization of a real or complex matrix. If we have a data matrix $X$ with $n$ observation and $p$ variables it can be factorized into the following form:\n$$X=U D V^T,$$ \nwhere $U$ is a $n \\times p$ unitary matrix that $U^TU=I$, $D$ is a $p \\times p$ diagonal matrix, and $V^T$ is a $p \\times p$ unitary matrix, which is the conjugate transpose of the $n\\times n$ unitary matrix, $V$. Thus, we have $V^TV=I$.\n\nSVD is closely linked to PCA (when correlation matrix is used for calculation). $U$ represents the left singular vectors, $D$ the singular values, $U%*%D$ yields the PCA scores, and $V$  the right singular vectors - PCA loadings.\n\nUsing the `pd.sub` dataset, we can compare the outputs from the `svd()` function and the `princomp()` function (another R function for PCA). Prior to the SVD, we need to `scale` the data matrix.\n\n\nWhen correlation matrix is used for calculation (`cor=T`), the $V$ matrix of SVD contains the corresponding PCA loadings.\n\n## SVD Summary\nIntuitively, the SVD approach $X= UD V^T$ represents a composition of the (centered!) data into 3 geometrical transformations: a rotation or reflection ($U$), a scaling ($D$), and a rotation or reflection ($V$). Here we assume that the data $X$ stores samples/cases in rows and variables/features in columns. If these are reversed, then the interpretations of the $U$ and $V$ matrices reverse as well.\n\n* The columns of $V$ represent the directions of the principal axes, the columns of $UD$ are the principal components, and the singular values in $D$ are related to the eigenvalues of data variance-covariance matrix ($\\Sigma$) via $\\lambda_i = \\frac{d_i^2}{n-1}$, where the eigenvalues $\\lambda_i$ capture the magnitude of the data variance in the respective PCs.\n* The standardized scores are given by columns of $\\sqrt{n-1}U$, the corresponding loadings are given by columns of $\\frac{1}{n-1}VD$. However, these \"loadings\" *are not* the principal directions. The requirement for $X$ to be centered is needed to ensure that the covariance matrix $Cov(X) = \\frac{1}{n-1}X^TX$.\n* Alternatively, to perform PCA on the *correlation matrix* (instead of the covariance matrix), the columns of $X$ need to be *scaled* (centered and standardized).\n* Reduce the data dimensionality from $p$ to $k<p$, we multiply the first $k$ columns of $U$ by the $k\\times k$ upper-left corner of the matrix $D$ to get an $n\\times k$ matrix $U_kD_k$ containing the first $k$ PCs.\n* Multiplying the first $k$ PCs by their corresponding principal directions $V_k^T$ reconstructs the original data from the first $k$ PCs, $X_k=U_k D_kV_k^T$, with the lowest possible reconstruction error.\n* Typically we have more subjects/cases ($n$) than variables/features ($p<n$). As $U_{n\\times n}$ and $V_{p\\times p}$, the last $n-p>0$ columns of $U$ may be trivial (zeros). It's customary to drop the zero columns of $U$ for $n>>p$ to avoid dealing with unnecessarily large (trivial) matrices.",
      "word_count": 470
    },
    {
      "title": "t-SNE (t-distributed Stochastic Neighbor Embedding)",
      "content": "The t-SNE technique represents a recent machine learning strategy for nonlinear dimensionality reduction that is useful for embedding (e.g., scatter-plotting) of high-dimensional data into lower-dimensional (1D, 2D, 3D) spaces. For each object (point in the high-dimensional space), the method models *similar objects* using nearby and *dissimilar objects* using remote distant objects. The two steps in t-SNE include (1) construction of a probability distribution over pairs of the original high-dimensional objects where similar objects have a high probability of being paired and correspondingly, dissimilar objects have a small probability of being selected; and (2) defining a similar probability distribution over the points in the derived low-dimensional embedding minimizing the [Kullback-Leibler divergence](https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence) between the high- and low-dimensional distributions relative to the locations of the objects in the embedding map. Either Euclidean or non-Euclidean distance measures between objects may be used as similarity metrics.\n\n## t-SNE Formulation\nSuppose we have high dimensional data ($N$D): $x_1, x_2,..., x_N$. In `step 1`, for each pair ($x_i, x_j$), t-SNE estimates the probabilities $p_{i,j}$ that are proportional to their corresponding similarities, $p_{j | i}$:\n\n$$p_{j | i} = \\frac{\\exp\\left (\\frac{-||x_i - x_j||^2}{2\\sigma_i^2} \\right )}{\\sum_{k \\neq i} \\exp\\left (\\frac{-||x_i - x_k||^2}{2\\sigma_i^2} \\right )}.$$\n\nThe similarity between $x_j$ and $x_i$ may be thought of as the conditional probability, $p_{j | i}$. That is, assuming $N$D Gaussian distributions centered at each point $x_i$, neighbors are selected based on a probability distribution (proportion of their probability density), which represents the chance that $x_i$ may select $x_j$ as its neighbor, $p_{i,j} = \\frac{p_{j | i} + p_{i |j}}{2N}$.\n\nThe **perplexity** ($perp$) of a discrete probability distribution, $p$, is defined as an exponential function of the entropy, $H(p)$, over all discrete events: $perp(x)=2^{H(p)}=2^{-\\sum _{x}p(x)\\log_{2}p(x)}$. t-SNE performs a binary search for the value $\\sigma_i$ that produces a predefined value $perp$. The simple interpretation of the perplexity at a data point $x_i$, $2^{H(p_i)}$, is as a smooth measure of the effective number of points in the $x_i$ neighborhood. The performance of t-SNE may vary with the perplexity value, which is typically specified by the user, e.g., between $5\\leq perp\\leq 50$.\n\nThen, the precision (variance, $\\sigma_i$) of the local Gaussian kernels may be chosen to ensure that the *perplexity* of the conditional distribution equals a specified perplexity. This allows adapting the kernel bandwidth to the sample data density -- smaller $\\sigma_i$ values are fitted in denser areas of the sample data space, and correspondingly, larger $\\sigma_i$ are fitted in sparser areas. A particular value of $\\sigma_i$ yields a probability distribution, $p_i$, over all of the other data points, which has an increasing entropy as $\\sigma_i$ increases.\n\nt-SNE learns a mapping $f: \\{x_1, x_2, ..., x_N\\} \\longrightarrow \\{y_1, y_2, ..., y_d\\}$, where $x_i\\in \\mathbb{R}^N$ and $y_i \\in \\mathbb{R}^d$ ($N\\gg d$) that resembles closely the *original similarities*, $p_{i,j}$ and represents the *derived similarities*, $q_{i,j}$ between pairs of embedded points $y_i,y_j$, defined by:\n\n$$q_{i,j} = \\frac{(1 + ||y_i - y_j||^2)^{-1}}{\\sum_{k \\neq i} (1 + ||y_i - y_k||^2)^{-1}}.$$\n\nThe `t-distributed` reference in t-SNE refers to the heavy-tailed *Student-t distribution* ($t_{df=1}$) which [coincides](https://wiki.socr.umich.edu/index.php/AP_Statistics_Curriculum_2007_StudentsT) with [Cauchy distribution](https://wiki.socr.umich.edu/index.php/AP_Statistics_Curriculum_2007_Cauchy), $f(z)=\\frac{1}{1+z^2}$. It is used to model and measure similarities between closer points in the embedded low-dimensional space, as well as dissimilarities of objects that map far apart in the embedded space. \n\nThe rationale for using *Student t distribution* for mapping the points is based on the fact that the volume of an $N$D ball of radius $r$, $B^N$, is proportional to $r^N$. Specifically, $V_N(r) = \\frac{\\pi^\\frac{N}{2}}{\\Gamma\\left(\\frac{N}{2} + 1\\right)}r^N$, where $\\Gamma()$ is the [Euler's gamma function](https://en.wikipedia.org/wiki/Gamma_function), which is an extension of the factorial function to non-integer arguments. For large $N$, when we select uniformly random points inside $B^N$, most points will be expected to be close to the ball surface (boundary), $S^{N-1}$, and few will be expected near the $B^N$ center, as half the volume of $B^N$ is included in the hyper-area *inside* $B^N$ and *outside* a ball of radius $r_1=\\frac{1}{\\sqrt[N]{2}}\\times r \\sim r$. You can try this with $N=2$, $\\{x\\in \\mathbb{R}^2 |\\ ||x||\\leq r\\}$, representing a disk in a 2D plane. \n\nWhen reducing the dimensionality of a dataset, if we used the  Gaussian distribution for the mapping embedding into the lower dimensional space, there will be a distortion of the distribution of the distances between neighboring objects. This is simply because the *distribution* of the distances is much different between the original (high-dimensional) and the map-transformed low-dimensional spaces. t-SNE tries to (approximately) preserve the distances in the two spaces  to avoid imbalances that may lead to biases due to excessive attraction-repulsion forces. Using Student t distribution $df=1$ (aka Cauchy distribution) for mapping the points preserves (to some extent) the distance similarity distribution, because of the heavier tails of $t$ compared to the Gaussian distribution. For a given similarity between a pair of data points, the two corresponding map points will need to be much further apart in order for their similarity to match the data similarity. \n\nA minimization process with respect to the objects $y_i$ using gradient descent of a (non-symmetric) objective function, *Kullback-Leibler divergence* between the distributions $Q$ and $P$ , is used to determine the object locations $y_i$ in the map, i.e.,\n\n$$KL(P || Q) = \\sum_{i \\neq j} p_{i,j} \\log \\frac{p_{i,j}}{q_{i,j}}.$$\n\nThe minimization of the KL objective function by gradient descent may be analytically represented by:\n\n$$\\frac{\\partial {KL(P||Q)}}{\\partial {y_i}}= \\sum_{j}{(p_{i,j}-q_{i,j})f(|x_i-x_j|) u_{i,j}},$$\nwhere $f(z)=\\frac{z}{1+z^2}$ and $u_{i,j}$ is a unit vector from $y_j$ to $y_i$. This gradient represents the aggregate sum of all spring forces applied to map point $x_i$.\n\nThis optimization leads to an embedding mapping that \"preserves\" the object (data point) similarities of the original high-dimensional inputs into the lower dimensional space. Note that the data similarity matrix ($p_{i,j}$) is fixed, whereas its counterpart, the map similarity matrix ($q_{i,j}$) depends on the embedding map. Of course, we want these two distance matrices to be as close as possible, implying that similar data points in the original space yield similar map-points in the reduced dimension.\n\n## t-SNE Example: Hand-written Digit Recognition\n\nLater, in [Chapter 6](https://socr.umich.edu/DSPA2/DSPA2_notes/06_ML_NN_SVM_RF_Class.html) and [Chapter 14](https://socr.umich.edu/DSPA2/DSPA2_notes/14_DeepLearning.html), we will present the Optical Character Recognition (OCR) and analysis of hand-written notes (unstructured text). \n\nBelow, we show a simple example of generating a 2D embedding of the [hand-written digits dataset](https://www.socr.umich.edu/people/dinov/2017/Spring/DSPA_HS650/data/DigitRecognizer_TrainingData.zip) using t-SNE.\n\n\nThe [hands-on interactive SOCR t-SNE Dimensionality Reduction Activity](https://socr.umich.edu/HTML5/SOCR_TensorBoard_UKBB) provides an interactive demonstration of t-SNE utilizing TensorBoard and the UK Biobank data.",
      "word_count": 1049
    },
    {
      "title": "Uniform Manifold Approximation and Projection (UMAP)",
      "content": "In 2018, McInnes and Healy proposed the [Uniform Manifold Approximation and Projection (UMAP)](https://arxiv.org/abs/1802.03426) (UMAP) technique for dimensional reduction.\n\nSImilar to t-SNE, UMAP first constructs a high dimensional graph representation of initial data and employs graph-layout algorithms to project the original high-dimensional data into a lower dimensional space. The iterative process aims to preserve the *graph structure* as much as possible. The initial high-dimensional graph representation uses *simplicial complexes*, as weighted graphs where edge weights represent likelihoods of the connectivity between two graph points are connected, i.e., neighborhoods. For a given point, the UMAP connectedness metric computes the distance with other points based on the overlap of their respective neighborhoods.\n\nThe parameter controlling the neighborhood size (i.e., radius) determines the tradeoff between within and between cluster sizes. Choosing too small a radius may lead to small and rather isolated clusters. Selecting too large a radius may cluster all points into a single group. For local radius selection, UMAP preprocessing utilizes the distances between each point and its n-th nearest neighbor. \n\nA \"fuzzy\" simplicial complex (graph) is constructed by iterative minimization of the connectivity likelihood function as the radius increases. Assuming that each point is connected to at least one of its closest neighbors, UMAP ensures that local and global graph structure is (somewhat protected and) preserved during the optimization process (e.g., based on stochastic gradient descent).\n\n## Mathematical formulation\n\nUMAP relies on local approximations of patches on the manifold to construct local fuzzy simplicial complex (topological) representations of the high dimensional data.  For each low dimensional representation of the projection of the data, UMAP tries to generate an analogous equivalent simplicial complex representation. The iterative UMAP optimization process aims to preserve the topological layout in the low dimensional space by minimizing the cross-entropy between the high- and low-dimensional topological representations.\n\nThe [DSPA Appendix on Shape](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_03.1_Geometric_Parametric_Surface_Viz.html) includes examples of how to generate some of geometric and topological primitives, including 0, 1, and 2 simplicial complexes.\n\n\n<!-- ```{r launchPython, warning=F, message=FALSE, error=F} -->\n<!-- # Launch the Python environment early! -->\n<!-- # install.packages(\"reticulate\") -->\n<!-- library(reticulate) -->\n<!-- # specify the path of the Python version that you want to use -->\n<!-- py_path = \"C:/Users/IvoD/Anaconda3/\"  # manual -->\n<!-- # py_path = Sys.which(\"python3\")       # automated -->\n<!-- use_python(py_path, required = T)  -->\n<!-- # Sys.setenv(RETICULATE_PYTHON = \"C:/Users/IvoD/Anaconda3/\") -->\n<!-- ``` -->\n\n\nThe figure below shows the first few such primitives - a point, line, triangle, and tetrahedron.\n\n\nFor a given finite set of data observations, we are trying to represent the underlying topological space the data is sampled from. This topological formulation can be approximated as patches of open covers modeled by simplicial complexes. Locally, the data may be assumed to lie in a metric space where distances between data points can be measured. This leads to neighborhood approximations that can locally be represented as $nD$ balls centered at each data point. This topological space covering may not represent a complete and open cover as all data samples are finite and small, biased, or incomplete samples may lead to poor approximations of the topology of the problem state-space. Zero-cells (0-simplexes, points) are fit for each observed data point, 1-cells (lines) are fit for each pair of data in the same neighborhood, and so on. More information about simplex trees is available in this article [The Simplex Tree: An Efficient Data Structure for General Simplicial Complexes](https://link.springer.com/chapter/10.1007/978-3-642-33090-2_63).\n\nExample of simplicial tree decomposition of 10 data points using the `R` package [simplextree](https://cran.r-project.org/web/packages/simplextree/).\n\n**Note** If you encounter errors like `pillow`, there may be some conflicts between \n`conda` and `pip` installations of the python package . In this case, re-install `pillow`\nusing `pip`: `pip install --force pillow`.\n\n\n\nGo into python to generate and visualize the simplicial complex as a topological model\nfor the point-cloud data. To run `python` interactively in the `R` console, use the *reticulate* package's `repl_python()` and `exit` functions. Note that we are using `R` to preload the `python` code from \n[this source file *SimplicialComplex.py*](https://socr.umich.edu/DSPA2/DSPA2_notes/SimplicialComplex.py), \nby utilizing the method `reticulate::source_python(()`.\n\n```{python pythonSimplicialComplex}",
      "word_count": 668
    },
    {
      "title": ">pip install --upgrade Pillow",
      "content": "import matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os",
      "word_count": 12
    },
    {
      "title": "os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = 'C:/Users/IvoD/Anaconda3/Library/plugins/platforms'",
      "content": "print(r.df)",
      "word_count": 1
    },
    {
      "title": "simplicial complex from point data",
      "content": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef euclidianDist(a, b):\n  return np.linalg.norm(a - b)  # Euclidean distance metric\n\n\ndef lower_nbrs(nodeSet, edgeSet, node):\n  return {x for x in nodeSet if {x, node} in edgeSet and node > x}\n\n\ndef rips(graph, k):\n  nodes, edges = graph[0:2]\n  VRcomplex = [{n} for n in nodes]\n  for e in edges:  # add 1-simplices (edges)\n    VRcomplex.append(e)\n  for i in range(k):\n#",
      "word_count": 66
    },
    {
      "title": "skip 0-simplices",
      "content": "for simplex in [x for x in VRcomplex if len(x) == i+2]:",
      "word_count": 12
    },
    {
      "title": "for each u in simplex",
      "content": "nbrs = set.intersection(\n        *[lower_nbrs(nodes, edges, z) for z in simplex])\n      for nbr in nbrs:\n        VRcomplex.append(set.union(simplex, {nbr}))\n  return VRcomplex",
      "word_count": 18
    },
    {
      "title": "raw_data is a numpy array",
      "content": "def buildGraph(raw_data, epsilon=3.1, metric=euclidianDist):\n# \n#",
      "word_count": 6
    },
    {
      "title": "initialize node set, reference indices from original data array",
      "content": "nodes = [x for x in range(raw_data.shape[0])]\n  edges = []  # initialize empty edge array",
      "word_count": 15
    },
    {
      "title": "(which in this case is the distance) for each edge",
      "content": "weights = []\n  for i in range(raw_data.shape[0]):  # iterate through each data point",
      "word_count": 13
    },
    {
      "title": "inner loop to calculate pairwise point distances",
      "content": "for j in range(raw_data.shape[0]-i):\n      a = raw_data[i]",
      "word_count": 7
    },
    {
      "title": "each simplex is a set (no order), hence [0,1]=[1,0]; only store 1",
      "content": "b = raw_data[j+i]\n      if (i != j+i):\n        dist = metric(a, b)\n        if dist <= epsilon:\n          edges.append({i, j+i})  # add edge",
      "word_count": 20
    },
    {
      "title": "store index and weight",
      "content": "weights.append([len(edges)-1, dist])\n  return nodes,edges,weights\n\n\ndef drawComplex(origData, ripsComplex, axes=[-12, 12, -8, 8]):\n  plt.clf()\n  plt.axis(axes)\n  print(origData)\n  plt.scatter(origData[:, 0], origData[:, 1])  # plotting just for clarity\n  for i, txt in enumerate(origData):\n    plt.annotate(i, (origData[i][0]+0.05, origData[i][1]))  # add labels",
      "word_count": 34
    },
    {
      "title": "add lines for edges",
      "content": "for edge in [e for e in ripsComplex if len(e) == 2]:",
      "word_count": 12
    },
    {
      "title": "print(edge)",
      "content": "pt1, pt2 = [origData[pt] for pt in [n for n in edge]]",
      "word_count": 12
    },
    {
      "title": "plt.gca().add_line(plt.Line2D(pt1, pt2))",
      "content": "line = plt.Polygon([pt1, pt2], closed=None, fill=None, edgecolor='gray')\n    plt.gca().add_patch(line)",
      "word_count": 8
    },
    {
      "title": "add triangles",
      "content": "for triangle in [t for t in ripsComplex if len(t) == 3]:\n    pt1, pt2, pt3 = [origData[pt] for pt in [n for n in triangle]]",
      "word_count": 25
    },
    {
      "title": "plt.gca().add_line(plt.Line2D(pt1, pt2, pt3))",
      "content": "line = plt.Polygon([pt1, pt2, pt3], closed=False,\n    facecolor=\"blue\", alpha=0.3, fill=True, edgecolor=\"red\")\n    plt.gca().add_patch(line)",
      "word_count": 11
    },
    {
      "title": "plt.gca().add_line(line)",
      "content": "plt.show()\n\n#This set of functions allows for building a Vietoris-Rips simplicial complex from point data\n\n#### These functions are already preloaded from Python source ############################\n#",
      "word_count": 26
    },
    {
      "title": "import matplotlib.pyplot as plt",
      "content": "# \n#",
      "word_count": 2
    },
    {
      "title": "return np.linalg.norm(a - b)  # euclidian distance metric",
      "content": "#",
      "word_count": 1
    },
    {
      "title": "return nodes, edges, weights",
      "content": "# \n#",
      "word_count": 2
    },
    {
      "title": "return {x for x in nodeSet if {x, node} in edgeSet and node > x}",
      "content": "# \n#",
      "word_count": 2
    },
    {
      "title": "return VRcomplex",
      "content": "# \n#",
      "word_count": 2
    },
    {
      "title": "plt.annotate(i, (origData[i][0]+0.05, origData[i][1]))  # add labels",
      "content": "#",
      "word_count": 1
    },
    {
      "title": "plt.show()",
      "content": "### TEST\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nn = 50 #number of points to generate",
      "word_count": 18
    },
    {
      "title": "generate Elipcical space of parameter",
      "content": "theta = np.linspace(0, 2.0*np.pi, n) \n\na, b, r = 0.0, 0.0, 5.0\n\nx = a + 2*r*np.cos(theta)\ny = b + r*np.sin(theta)\n\n#code to plot the circle for visualization\nplt.plot(x, y)\nplt.show()\n\nx2 = np.random.normal(0, 0.5, n) + x # add some \"noise\" to points on Elliptical model\ny2 = np.random.normal(0, 0.5, n) + y\nfig, ax = plt.subplots()\nax.scatter(x2,y2)\nplt.show()\n\nnewData = np.array(list(zip(x2,y2)))",
      "word_count": 64
    },
    {
      "title": "import SimplicialComplex",
      "content": "#",
      "word_count": 1
    },
    {
      "title": "SimplicialComplex.drawComplex(origData=newData, ripsComplex=ripsComplex)",
      "content": "graph = buildGraph(raw_data=newData, epsilon=3.0) #Notice the epsilon parameter is 3.0\nripsComplex = rips(graph=graph, k=3)\ndrawComplex(origData=newData, ripsComplex=ripsComplex)\n```\n\n\n<!-- ```{python} -->\n<!-- # In anaconda, install pandas package -->\n<!-- #      pip install pandas  -->\n<!-- from matplotlib import pyplot as plt -->\n<!-- import SimplicialComplex -->\n<!-- newData = np.array(r.df, ndmin=2) # np.array ([x0,]*n  #  df.to_numpy() -->\n<!-- # print(newData) -->\n<!-- graph = buildGraph(raw_data=newData, epsilon=1.7) -->\n<!-- ripsComplex = rips(graph=graph, k=3) -->\n<!-- drawComplex(origData=newData, ripsComplex=ripsComplex) -->\n<!-- ``` -->\n\nThe 2D simplicial complex construction above illustrates a weighted graph representation of the 2D data using 0, 1, and 2 cells. In general, similar decomposition using higher order simplexes can be obtained, with increasing computational complexity. This simplex graph helps with the lower dimensional projections in the UMAP algorithm as the simplicial decomposition captures the topological structure of the data.\n\nOur aim is to generate a low dimensional representation of the data that has similar (or homologous) topological structure as the higher-dimensional simplicial decomposition. The UMAP projection is a low dimensional representation of the data into the desired embedding space (e.g., $\\mathbb{R}^2$ or $\\mathbb{R}^3$). We will measure distances on the manifolds using some metric, e.g., standard Euclidean distance. In particular, we focus on distances to the nearest neighbors, where neighborhoods are defined as balls centered at specific data points of a `min_dist` diameter, a user-specified hyper-parameter.\n\nThe lower dimensional projections are driven by iteratively solving optimization problems of finding the low dimensional simplicial graph that closely resembles the fuzzy topological structure of the previous graph (or the original simplicial decomposition. The simplexes are represented as graphs with weighted edges that can be thought of as probabilities that compare the homologous 0-simplexes, 1-simplexes, and so on. These probabilities can be modeled as Bernoulli processes as (corresponding) simplexes either exist or don't exist and the probability is the univariate parameter of the Bernoulli distribution, which can be estimated using the cross entropy measure.\n\nFor example, if $S1$ the set of all possible 1-simplexes, let's denote by $\\omega(e)$ and $\\omega'(e)$ the weight functions of the 1-simplex $e$ in the high dimensional space and the corresponding lower dimensional counterpart. Then, the cross entropy measure for the 1-simplexes is:\n\n$$\\sum_{e\\in E} {\\left [ \\underbrace{\\omega(e)log\\left ( \\frac{\\omega(e)}{\\omega'(e)}\\right )}_\\text{attractive force}+\n\\underbrace{(1-\\omega(e))log\\left ( \\frac{1-\\omega(e)}{1-\\omega'(e)}\\right ) }_\\text{repulsive force}\\right ]} .$$\n\nThe iterative optimization process would minimize the objective function composed of all cross entropies for all simplicial complexes using a strategy like stochastic gradient descent.\n\nThe optimization process balances the push-pull between the *attractive forces* between the points favoring larger values of $\\omega'(e)$ (that correspond to small distances between the points), and the *repulsive forces* between the ends of $e$ when $\\omega(e)$ is small (that correspond to small values of $\\omega'(e)$.\n\nIf $X$ and $Y$ are some topological spaces, a map $f: X \\to Y$ is called a *homeomorphism* if it is a continuous bijection with a continuous inverse, $f^{-1}: Y \\to X$, $f\\circ f^{-1}\\equiv I$. In 2D, there exists a homeomorphism between a circle and an ellipse, however no homeomorphism maps\na circle onto an open interval. Homeomorphisms consider only the open subsets of the embedding space and they are not affected by the metric on the space. Any pair of n-simplices are homeomorphic. As high-dimensional data may be considered as point clouds in a high dimensional spaces, we can study the embedding manifolds as simplicial complexes by decomposing them into their topological building blocks - *simplices.* A simplicial complex $X$ is a collection of simplices in $\\mathbb{R}^N$ where for any simplex in $X$, all of its faces (lower-order simplices) are also in $X$ and the intersection of any two simplices is either empty or a face in both of them. All simplicial complexes $X$ can be described, up to homeomorphism, by listing the vertices of each simplex in $X$. Common vertices allow us to understand which simplices share faces.\n\nThere is a generalization of simplices defined by their vertices to abstract simplicial\ncomplexes, where $X$ is a series of sets $\\{X_i\\}_{i \\geq 0}$, such that the elements of $X^n$ (the $n$-simplices) are $(n + 1)$-element sets that satisfy the condition\n$\\forall x_{i=1}^n\\in X^n$, all n-element subsets of this set are in $X^{nâˆ’1}$. \nDifferent simplices can share common elements, e.g., vertices, edges, faces. For instance, a square in $\\mathbb{R}^2$ can be describe by explicating the 0-, 1- and 2-cells \n$$S_0 = \\{\\{a\\}, \\{b\\}, \\{c\\}, \\{d\\}\\}; \\  \nS_1 = \\{\\{a, b\\}, \\{a, c\\}, \\{a, d\\}, \\{b, c\\}, \\{c, d\\}\\}, \\ \nS_2 = \\{\\{a, b, c\\}, \\{a, c, d\\}\\}.$$\n\nThe simplex vertex order is important for defining face-maps. An ordered $n$-simplex can be\nrepresented as $[x_0, x_1, \\cdots, x_n]$. We can characterise an $n$-simplex in a\nsimplicial complex by the collection of its $n + 1$ face-maps, the $i$-th face-map sends the simplex to the face excluding the $i$-th vertex from the original simplex, i.e., \n$$f_i:[x_0, x_1, \\cdots, x_i, \\cdots, x_n] \\to [x_0, x_1, \\cdots, x_{i-1},x_{i+1}, \\cdots, x_n].$$\n\nFuzzy sets are sets where element participation in the set is represented by continuous membership functions, i.e., set membership is not binary (in or out) but rather probabilistic. Hence, a fuzzy set is a set of objects $A$ and a function $\\mu:A \\to [0, 1]$ where $\\mu(a) = 1$ indicates a definitive membership of $a$ in the fuzzy set. Fuzzy simplicial sets have the property that the membership strength of the face of a simplex is at least the membership strength of the simplex.\n\nSuppose we start with a Riemannian manifold $(M, g)$ embedded in $\\mathbb{R}^n$. Given a point\n$p\\in M$, consider a ball $B$, $p\\in B\\subseteq M$, whose volume with respect to the locally constant metric $g$ is $V(B)=\\frac{\\pi^{n/2}}{\\Gamma(1+n/2)}$. Then the distance of the shortest path in $M$ from $p$ to another point $q\\in B$ is $\\frac{1}{r}d_{\\mathbb{R}^N} (p,q)$, where $r$ is the radius of $B$ in $M$ and $d_{\\mathbb{R}^N} (p,q)$ is the chosen $\\mathbb{R}^N$ distance between $p$ and $q$ in $\\mathbb{R}^N$.\n\nTo convert between metric spaces and fuzzy simplicial sets consider a fixed data point $x_i$ in the dataset $D$. We can approximate the distance from $x_i$ to any other point $x_j$ in $D$ by $d_{x_i} (x_i, x_j) =\\frac{1}{r_i} d_{\\mathbb{R}^N} (x_i, x_j)$. This gives us a partly defined metric space, using the (observed) distances between $x_i$ and $x_j, \\ \\forall j$, even though we may not know the distances between $x_j$ and $x_k$ for $j, k \\not= i$. Denote by $\\rho_i$ the distance between $x_i$ and its nearest neighbor in $D$ in $\\mathbb{R}^N$ and assume $M$ is locally connected, i.e., $x_i$ must be connected to its nearest neighbor $\\forall j \\not= i$. Then,\n\n$$d_{x_i} (x_i, x_j) = \n    \\begin{cases} \n        \\frac{1}{r_i} d_{\\mathbb{R}^N} (x_i, x_j), & \\text{if } j =i \\text{ or } k=i\\\\\n        \\infty, & \\text{otherwise}\n    \\end{cases} .$$\n\nBy this definition, $x_i$ and its nearest neighbor are distance $0$ apart, and\n$\\forall j,k \\not= i$, the unknown distances of $x_j$ and $x_k$ relative to $x_i$ are set this to infinity. With this formulation, we lose the exact metric characterization of the state space and instead utilize the extended *pseudo-metric space* consisting of the set $X$ and the function \n$d: X \\times X \\to \\mathbb{R}\\cup \\{\\infty\\}$, which has pseudo-metric properties:\n(1) $d(x, y) \\geq 0$, (2) $d(x, x) = 0$, (3) $d(x, y) = d(y, x)$, and (4) either $d(x, z) =\\infty$\nor $d(x, z) \\leq d(x, y) + d(y, z)$. The pseudo-metric permits infinite distances as well as the posibility that $d(x, y) = 0$ for $x\\not= y$.\n\nThe most commonly used objective function in UMAP is `cross entropy` of pairs of fuzzy sets represented via symmetric weight matrices\n\n$$C_{UMAP} = \\sum_{i,j}  \\left [\\underbrace{v_{i,j} \\log \\left (\\frac{v_{i,j}}{w_{i,j}} \\right )}_{\\text{attarctive force}} +\n\\underbrace{(1âˆ’v_{i,j}) \\log \\left (\\frac{1-v_{i,j}}{1-w_{i,j}}\\right )}_{\\text{repulsive force}} \\right ], $$\n\nwhere $v_{i,j}$ are *symmetrized input weights* (affinities), weights of the corresponding fuzzy simplices in the native high-dimensional space. For 1-simpex, these are effectively graph edge weights. The associated UMAP *unsymmetrized input weights* are $v_{i|j}=e^{âˆ’(r_{i,j}âˆ’\\rho_{i})/{\\sigma_{i}}}$, where \n$r_{i,j}$ are the input distances, $\\rho_{i}$ is the distance to the nearest neighbor (suppressing zero distances for duplicate neighbors), and $\\sigma_{i}$ (perplexity parameters) are estimated using the number of nearest neighbors (hyperparameter $k$) via the restriction $\\sum_{j}v_{i|j}=\\log(2k)$.\n\nThe relation between symmetrized and unsymmetrized input weights is given by\n\n$$v_{i,j}=(v_{j|i}+v_{i|j})âˆ’ v_{j|i}v_{i|j} \\ \\ \\ (\\text{element-wise}), $$\n\n$$V_{symm}= V+V^Tâˆ’V \\circ  V^T \\ \\ \\ (\\text{matrix-wise}), $$\n\nwhere the Hadamard element-wise product is $\\circ$ and  $V^T$ is the transpose matrix. The symmetrization corresponds to a fuzzy set union.\n\nThe corresponding *output weights* in the lower-dimensional projection space are\n$$w_{i,j}=\\frac{1}{1+ad^{2b}_{i,j}},$$\n\nwhere the parameters $a$ and $b$, typically in the range $[0.5,5]$ are estimated using non-linear least squares subject to the distances $d_{i,j}$ that control the tightness of the lower-dimensional compression function.\n\nThe attractive and repulsive UMAP gradient expressions for stochastic gradient descent (SGD, Chapter 13) are\n\n$$\\underbrace{\\frac{\\partial C^+_{UMAP}}{\\partial y_i}}_{\\text{attractive}}= \\frac{âˆ’2abd^{2(bâˆ’1)}_{i,j}}{1+ad^{2b}_{i,j}}(y_iâˆ’y_j),$$\n$$\\underbrace{\\frac{\\partial C^-_{UMAP}}{\\partial y_i}}_{\\text{repulsive}}= \\frac{2b}{(\\epsilon + d^{2}_{i,j})(1+ad^{2b}_{i,j})}(y_iâˆ’y_j),$$\n\nwhere the correction $\\epsilon\\sim 0.001$ avoids singularities. Note that in the repulsive SGD expression, the exact gradient also contains a term $1âˆ’v_{i,j}$, which can be ignored as for most pairs of edges (paired distances) $v_{i,j}=0$.\n\n\n## Hand-Written Digits Recognition\n\nLet's go back to the [MNIST digits dataset](https://en.wikipedia.org/wiki/MNIST_database) and apply UMAP projection from the original 784D space to 2D or 3D.\n\nThe R package `umap` provides functionality to use UMAP for dimensional reduction of high-dimensional data.\n\nLet's demonstrate UMAP projecting the hand-written digits dataset in 2D and 3D, as well as show how to use the projection for *prediction* and *forecasting* for new testing/validation data.\n\n\n\n\n## Apply UMAP for class-prediction using new data\n\nUsing the MNIST hand-written digits dataset, or the simpler iris dataset, we will show how we can use UMAP for predicting the image-to-digit, or flower-to-species (taxa) mappings. In the MNIST data, we use a set of $1,000$ new 2D images for prediction, and for the iris data, we simulate new iris flower features by introducing random (additive) noise $N(0,0.1)$ to the original Iris data.\n\n\n## UMAP Parameters\n\nThe UMAP configuration allows specifying the 21 parameters controlling the UMAP projection embedding of the function `umap()`.\n\n - *n_neighbors*: integer; number of nearest neighbors\n - *n_components*: integer; dimension of target (output) space\n - *metric*: character or function determining how distances between data points are computed. String-labeled metrics include : *euclidean*, *manhattan*, *cosine*, *pearson*, *pearson2*. The triangle inequality may not be satisfied by some  metrics and the internal **knn** search may not be optimal \n - *n_epochs*: integer; number of iterations performed during layout optimization\n - *input*: character, use either \"data\" or \"dist\"; determines whether the primary input argument to `umap()` is treated as a data matrix or as a distance matrix\n - *init*: character or matrix. The default string \"spectral\" computes an initial embedding using eigenvectors of the connectivity graph matrix. An alternative is the string \"random\", which creates an initial layout based on random coordinates. This setting.can also be set to a matrix, in which case layout optimization begins from the provided coordinates.\n - *min_dist*: numeric; determines how close points appear in the final layout\n  - *set_op_ratio_mix_ratio*: numeric in range [0,1]; determines the knn-graph  used to create a fuzzy simplicial graph\n - *local_connectivity*: numeric; used during construction of fuzzy simplicial set\n - *bandwidth*: numeric; used during construction of fuzzy simplicial set\n - *alpha*: numeric; initial value of \"learning rate\" of layout optimization\n - *gamma*: numeric; determines, together with alpha, the learning rate of layout optimization\n - *negative_sample_rate*: integer; determines how many non-neighbor points are used per point and per iteration during layout optimization\n - *a*: numeric; contributes to gradient calculations during layout optimization. When left at NA, a suitable value will be estimated automatically.\n - *b*: numeric; contributes to gradient calculations during layout optimization.\n - *spread*: numeric; used during automatic estimation of a/b parameters.\n - *random_state*: integer; seed for random number generation used during umap()\n - *transform_state*: integer; seed for random number generation used during `predict()`\n - *knn.repeat*: number of times to restart knn search\n - *verbose*: logical or integer; determines whether to show progress messages\n - *umap_learn_args*: vector of arguments to python package umap-learn\n\n\n## Stability, Replicability and Reproducibility\n\n*Reproducibility* is a stronger condition that requires obtaining consistent computational results using a *fixed* protocol including input data, computational steps, scientific methods, software code, compiler, and other experimental conditions. \n\n*Replicability* is a weaker condition that requires obtaining homologous results across multiple studies examining the same phenomenon aiming at answering the same scientific questions, each study using its own independent (yet homologous) input data.\n\nAs most UMAP implementations involve stochastic processes that employ random number generation, there may be variations in the output results from repeated runs of the algorithm. To stabilize these outputs and ensure result reproducibility we can use seed-setting, `umapData.umap.1234 = umap(umapData, random_state=1234)`. \n\n## UMAP Interpretation\n\nBelow is a summary of key UMAP interpretation points:\n\n  - The choice of the hyperparameters will affect the output: Choosing optimal parameter values may be difficult and is always data dependent. The stability of running UMAP repeatedly with a range of hyperparameters may provide a more sensible interpretation of the lower dimensional MAP projection.\n  - The sizes of the lower dimensional UMAP cluster should not be over-interpreted, since UMAP relies only on local graph neighborhood distances (not global) to construct the initial high-dimensional graph representation.\n  - Similarly, between-cluster distances are not representative of dissimilarities between the cluster elements.\n  - Initial random noise in the data will not be preserved as random variation in the UMAP projections and some spurious clustering may be present that may not be signal related.",
      "word_count": 2230
    },
    {
      "title": "Dimensionality Reduction Case Study (Parkinson's Disease)",
      "content": "## Step 1: Collecting Data\n\nThe data we will be using in this case study is the Clinical, Genetic and Imaging Data for Parkinson's Disease in the SOCR website. A detailed data explanation is on the following link [PD data](https://wiki.socr.umich.edu/index.php/SOCR_Data_PD_BiomedBigMetadata). Let's import the data into R.\n\n\n## Step 2: Exploring and preparing the data\n\nTo make sure that the data is ready for further modeling, we need to fix a few things. Firstly, the `Dx` variable or diagnosis is a factor. We need to change it to a numeric variable. Second, we don't need the patient ID and time variable in the dimension reduction procedures. \n\n\n## PCA\n\nNow we start the process of fitting a PCA model. Here we will use the `princomp()` function and use the correlation rather than the covariance matrix for calculation. Mind that previously we used `prcomp()` and now we are employing `princomp()`, two different functions, to compute the PCA.\n\n\nAlbeit the two cohorts (normal controls and patients, $DX$, red and gray colored markers in the 3D scene) are slightly separated in the second principal direction, we can see in this real world example that PCs do not necessarily correspond to a definitive \"elbow\" plot suggesting an optimal number of components. In our PCA model, each PC explains about the same amount of variation. Thus, it is hard to tell how many PCs, or factors, we need to select. This would be an *ad hoc* decision in this case. We can understand this better after understanding the following FA model. \n\n## FA\n\nLet's set up an Cattel's Scree test to determine the number of factors first. FOr a given variable, the *variance communality* is the proportion of the variability for the specific variable that is *shared* with other covariates. The *variable uniqueness* is the variance that is uniquely attributed to the specific features, i.e.,  not shared with any other\nvariables,  $uniqueness= 1 â€“ communality$.\n\n\nAlthough the Cattel's Scree test suggests that we should use 14 factors, the real fit shows 14 is not enough. Previous PCA results suggest we need around 20 PCs to obtain a cumulative variance of 0.6. After a few trials we find that 19 factors can pass the chi square test for a sufficient number of factors at $0.05$ level.\n\n\nThis data matrix has relatively low correlation. Thus, it is not suitable for ICA. \n\n\n## t-SNE\n\nNext, let's try the t-Distributed Stochastic Neighbor Embedding method on the [PD data](https://wiki.socr.umich.edu/index.php/SOCR_Data_PD_BiomedBigMetadata).\n\n\n## Uniform Manifold Approximation and Projection (UMAP)\n\nSimilarly, we can try the UMAP method on the PD data.\n\n\nThe results of the PCA, ICA, FA, t-SNE, and UMAP methods on the [PD data](https://wiki.socr.umich.edu/index.php/SOCR_Data_PD_BiomedBigMetadata) imply that the data is complex and intrinsically high-dimensional, which prevents explicit embeddings into a low-dimensional (e.g., 2D or 3D) space. More advanced methods to interrogate this dataset will be demonstrated later. The [SOCR publications site](https://www.socr.umich.edu/people/dinov/publications.html) provides additional examples of Parkinson's disease studies.\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\"\n\t\t\t\t\t\t\t\tsrc=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" \n\t\t\t\t\t\t\t\talt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 578
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    self_contained: yes\n---",
      "row_count": 2
    },
    {
      "section": "Motivational Example: Reducing 2D to 1D",
      "content": "$Twin1_{Height}$ | $Twin2_{Height}$\n-----------------|-----------------\n$y[1,1]$  | $y[1,2]$ \n$y[2,1]$  | $y[2,2]$ \n$y[3,1]$  | $y[3,2]$ \n$\\cdots$ | $\\cdots$\n$y[500,1]$  | $y[500,2]$ ",
      "row_count": 7
    },
    {
      "section": "Summary (PCA vs. ICA vs. FA)",
      "content": "Method | Assumptions | Cost Function Optimization | Applications\n-------|-------------|----------------------------|-------------\n*PCA* |  Gaussian signals, linear bivariate relations | Aims to explain the variance in the original signal. Minimizes the covariance of the data and yields high-energy orthogonal vectors in terms of the signal variance. PCA looks for an orthogonal linear transformation that maximizes the variance of the variables   |  Relies on $1^{st}$ and $2^{nd}$ moments of  the measured data, which makes it useful when data features are close to Gaussian\n*ICA* |  No Gaussian signal assumptions  | Minimizes higher-order statistics (e.g., $3^{rd}$ and $4^{th}$ order skewness and kurtosis), effectively minimizing the *mutual information* of the transformed output. ICA seeks a linear transformation where the basis vectors are statistically independent, but neither Gaussian, orthogonal or ranked in order  | Applicable for non-Gaussian, very noisy, or mixture processes composed of simultaneous input from multiple sources\n*FA* | Approximately Gaussian data | Objective function relies on second order moments to compute likelihood ratios. FA *factors* are linear combinations that maximize the shared portion of the variance underlying *latent variables*, which may use a variety of optimization strategies (e.g., maximum likelihood)  | PCA-generalization used to test a theoretical model of latent factors causing the observed features",
      "row_count": 5
    }
  ],
  "r_code": [
    {
      "section": "Motivational Example: Reducing 2D to 1D",
      "code": "library(MASS)\n\nset.seed(1234)\nn <- 1000\ny=t(mvrnorm(n, c(0, 0), matrix(c(1, 0.95, 0.95, 1), 2, 2)))",
      "line_count": 5
    },
    {
      "section": "Motivational Example: Reducing 2D to 1D",
      "code": "# plot(y[1, ], y[2, ], xlab=\"Twin 1 (standardized height)\", \n#      ylab=\"Twin 2 (standardized height)\", xlim=c(-3, 3), ylim=c(-3, 3))\n# points(y[1, 1:2], y[2, 1:2], col=2, pch=16)\n\nlibrary(plotly)\nplot_ly() %>% \n  add_markers(x = ~y[1, ], y = ~y[2, ], name=\"Data Scatter\") %>% \n  add_markers(x = y[1, 1], y = y[2, 1], marker=list(color = 'red', size = 20,\n                   line = list(color = 'yellow', width = 2)), name=\"Twin-pair 1\") %>% \n  add_markers(x = y[1, 2], y = y[2, 2], marker=list(color = 'green', size = 20,\n                   line = list(color = 'orange', width = 2)), name=\"Twin-pair 2\")%>% \n    layout(title='Scatter Plot Simulated Twin Data (Y)', \n           xaxis = list(title=\"Twin 1 (standardized height)\"), yaxis = list(title=\"Twin 2 (standardized height)\"),\n           legend = list(orientation = 'h'))",
      "line_count": 14
    },
    {
      "section": "Motivational Example: Reducing 2D to 1D",
      "code": "d=dist(t(y))\nas.matrix(d)[1, 2]",
      "line_count": 2
    },
    {
      "section": "Motivational Example: Reducing 2D to 1D",
      "code": "z1 = (y[1, ]+y[2, ])/2 # the sum (actually average)\nz2 = (y[1, ]-y[2, ])   # the difference\n\nz = rbind( z1, z2) # matrix z has the same dimension as y\n\nthelim <- c(-3, 3)\n# par(mar=c(1, 2))\n# par(mfrow=c(2,1))\n# plot(y[1, ], y[2, ], xlab=\"Twin 1 (standardized height)\", \n#      ylab=\"Twin 2 (standardized height)\", \n#      xlim=thelim, ylim=thelim)\n# points(y[1, 1:2], y[2, 1:2], col=2, pch=16)\n\n# plot(z[1, ], z[2, ], xlim=thelim, ylim=thelim, xlab=\"Average height\", ylab=\"Difference in height\")\n# points(z[1, 1:2], z[2, 1:2], col=2, pch=16)\n# par(mfrow=c(1,1))\n\nplot_ly() %>% \n  add_markers(x = ~z[1, ], y = ~z[2, ], name=\"Data Scatter\") %>% \n  add_markers(x = z[1, 1], y = z[2, 1], marker=list(color = 'red', size = 20,\n                   line = list(color = 'yellow', width = 2)), name=\"Twin-pair 1\") %>% \n  add_markers(x = y[1, 2], y = y[2, 2], marker=list(color = 'green', size = 20,\n                   line = list(color = 'orange', width = 2)), name=\"Twin-pair 2\") %>% \n  layout(title='Scatter Plot Transformed Twin Data (Z)', \n         xaxis = list(title=\"Twin 1 (standardized height)\", scaleanchor = \"y\", scaleratio = 2), \n         yaxis = list(title=\"Twin 2 (standardized height)\", scaleanchor = \"x\", scaleratio = 0.5),\n         legend = list(orientation = 'h'))",
      "line_count": 27
    },
    {
      "section": "Motivational Example: Reducing 2D to 1D",
      "code": "A <- matrix(c(1/2, 1, 1/2, -1), nrow=2, ncol=2); A   # define a matrix\nA_inv <- solve(A); A_inv  # inverse\nA %*% A_inv # Verify result",
      "line_count": 3
    },
    {
      "section": "Motivational Example: Reducing 2D to 1D",
      "code": "d=dist(t(y)); as.matrix(d)[1, 2]     # distance between first two points in Y\nd1=dist(t(z)); as.matrix(d1)[1, 2]   # distance between first two points in Z=A*Y",
      "line_count": 2
    },
    {
      "section": "Matrix Rotations",
      "code": "MA <- matrix(c(1/2, 1, 1/2, -1), 2, 2)\n\nMA_z <- MA%*%y\nd <- dist(t(y))\nd_MA <- dist(t(MA_z))\n\n# plot(as.numeric(d), as.numeric(d_MA)) \n# abline(0, 1, col=2)\n\nplot_ly() %>% \n  add_markers(x = ~as.numeric(d)[1:5000], y = ~as.numeric(d_MA)[1:5000], name=\"Transformed Twin Distances\") %>% \n  add_markers(x = ~as.numeric(d)[1], y = ~as.numeric(d_MA)[1], marker=list(color = 'red', size = 20,\n                   line = list(color = 'yellow', width = 2)), name=\"Twin-pair 1\") %>% \n  add_markers(x = ~as.numeric(d)[2], y = ~as.numeric(d_MA)[2], marker=list(color = 'green', size = 20,\n                   line = list(color = 'orange', width = 2)), name=\"Twin-pair 2\") %>% \n  add_trace(x = ~c(0,8), y = ~c(0,8), mode=\"lines\",\n        line = list(color = \"red\", width = 4), name=\"Preserved Distances\") %>% \n    layout(title='Preservation of Distances Between Twins (Transform=MA_Z)', \n           xaxis = list(title=\"Original Twin Distances\", range = c(0, 8)), \n           yaxis = list(title=\"Transformed Twin Distances\", range = c(0, 8)),\n           legend = list(orientation = 'h'))",
      "line_count": 21
    },
    {
      "section": "Matrix Rotations",
      "code": "MA; t(MA); solve(MA); t(MA) - solve(MA)\nv1 <- c(0,1); v2 <- c(1,0); rbind(v1,v2)\neuc.dist <- function(x1, x2) sqrt(sum((x1 - x2) ^ 2))\neuc.dist(v1,v2)\nv1_t <- MA %*% v1; v2_t <- MA %*% v2\neuc.dist(v1_t,v2_t)",
      "line_count": 6
    },
    {
      "section": "Matrix Rotations",
      "code": "A <- 1/sqrt(2)*matrix(c(1, 1, 1, -1), 2, 2)\nz <- A%*%y\nd <- dist(t(y))\nd2 <- dist(t(z))\n\n# plot(as.numeric(d), as.numeric(d2)) \n# abline(0, 1, col=2)\n\nplot_ly() %>% \n  add_markers(x = ~as.numeric(d)[1:5000], y = ~as.numeric(d2)[1:5000], name=\"Transformed Twin Distances\") %>% \n  add_trace(x = ~c(0,8), y = ~c(0,8), mode=\"lines\",\n        line = list(color = \"red\", width = 4), name=\"Preserved Distances\") %>% \n  add_markers(x = ~as.numeric(d)[1], y = ~as.numeric(d2)[1], marker=list(color = 'red', size = 20,\n                   line = list(color = 'yellow', width = 2)), name=\"Twin-pair 1\") %>% \n  add_markers(x = ~as.numeric(d)[2], y = ~as.numeric(d2)[2], marker=list(color = 'green', size = 20,\n                   line = list(color = 'orange', width = 2)), name=\"Twin-pair 2\")  %>% \n    layout(title='Preservation of Distances Between Twins (Transform=A)', \n           xaxis = list(title=\"Original Twin Distances\", range = c(0, 8)), \n           yaxis = list(title=\"Transformed Twin Distances\", range = c(0, 8)),\n           legend = list(orientation = 'h'))",
      "line_count": 20
    },
    {
      "section": "Matrix Rotations",
      "code": "sig <- matrix(c(1,0.95,0.95,1),nrow=2)\nA%*%sig%*%t(A)",
      "line_count": 2
    },
    {
      "section": "Matrix Rotations",
      "code": "set.seed(2017)\nzz1 = rnorm(1000,0,sd = sqrt(1.95))\nzz2 = rnorm(1000,0,sd = sqrt(0.05))\nzz = rbind(zz1,zz2)\nd3 = dist(t(zz))\n# qqplot(d,d3)\n# abline(a = 0,b=1,col=2)\n\n# compute the quantiles\nQQ <- qqplot(d,d3, plot.it=FALSE)\n# take a smaller sample size to expedite the viz\nind <-  sample(1:length(QQ$x), 10000, replace = FALSE)\nx1 <- QQ$x[ind]\ny1 <- QQ$y[ind]\nplot_ly() %>%\n  # add_markers(x = ~as.numeric(d)[1:1000], y = ~as.numeric(d3)[1:1000], name=\"Transformed Twin Distances\") %>%\n  add_markers(x = ~x1, y = ~y1, name=\"Transformed Distances\") %>%\n  add_trace(x = ~c(0,8), y = ~c(0,8), mode=\"lines\",\n        line = list(color = \"red\", width = 4), name=\"Preserved Distances\") %>%\n  add_markers(x = ~x1[1], y = ~y1[1], marker=list(color = 'red', size = 20,\n                   line = list(color = 'yellow', width = 2)), name=\"Pair 1\") %>%\n  add_markers(x = ~x1[2], y = ~y1[2], marker=list(color = 'green', size = 20,\n                   line = list(color = 'orange', width = 2)), name=\"Pair 2\")  %>%\n    layout(title='Preservation of Distances (Random Bivariate))',\n           xaxis = list(title=\"Original Distances\", range = c(0, 8)),\n           yaxis = list(title=\"Transformed Distances\", range = c(0, 8)),\n           legend = list(orientation = 'h'))",
      "line_count": 27
    },
    {
      "section": "Matrix Rotations",
      "code": "\n# thelim <- c(-3, 3)\n# #par(mfrow=c(2,1))\n# plot(y[1, ], y[2, ], xlab=\"Twin 1 (standardized height)\", \n#      ylab=\"Twin 2 (standardized height)\", \n#      xlim=thelim, ylim=thelim)\n# points(y[1, 1:2], y[2, 1:2], col=2, pch=16)\n\n# plot(z[1, ], z[2, ], xlim=thelim, ylim=thelim, xlab=\"Average height\", ylab=\"Difference in height\")\n# points(z[1, 1:2], z[2, 1:2], col=2, pch=16)\n# par(mfrow=c(1,1))\n\n# Original (pre-transform)\neuc.dist <- function(x1, x2) sqrt(sum((x1 - x2) ^ 2))\nplot_ly() %>% \n  add_markers(x = ~y[1,], y = ~y[2,], name=\"Twin Distances\") %>% \n  add_markers(x = ~y[1, 1], y = ~y[2, 1], marker=list(color = 'red', size = 20,\n                   line = list(color = 'yellow', width = 2)), name=\"Twin-pair 1\") %>% \n  add_markers(x = ~y[1, 2], y = ~y[2, 2], marker=list(color = 'green', size = 20,\n                   line = list(color = 'orange', width = 2)), name=\"Twin-pair 2\")  %>% \n    layout(title=paste0('(Pre-Transform) Original Twin Heights (standardized): Twin-Pair Distance = ', \n              round(euc.dist(y[, 1], y[, 2]),3)),\n           xaxis = list(title=\"Twin 1\"), \n           yaxis = list(title=\"Twin 2\"),\n           legend = list(orientation = 'h'))\n\n# Transform\nplot_ly() %>% \n  add_markers(x = ~z[1,], y = ~z[2,], name=\"Transformed Twin Distances\") %>% \n  add_markers(x = ~z[1, 1], y = ~z[2, 1], marker=list(color = 'red', size = 20,\n                   line = list(color = 'yellow', width = 2)), name=\"Twin-pair 1\") %>% \n  add_markers(x = ~z[1, 2], y = ~z[2, 2], marker=list(color = 'green', size = 20,\n                   line = list(color = 'orange', width = 2)), name=\"Twin-pair 2\")  %>% \n    layout(title=paste0('(Transform) Twin Heights: Twin-Pair Distance = ', \n              round(euc.dist(z[, 1], z[, 2]),3)),\n           xaxis = list(title=\"Twin 1\", scaleanchor = \"y\", scaleratio = 2), \n           yaxis = list(title=\"Twin 2\", scaleanchor = \"x\", scaleratio = 0.5),\n           legend = list(orientation = 'h'))",
      "line_count": 38
    },
    {
      "section": "Matrix Rotations",
      "code": "d4 = dist(z[1, ]) ##distance computed using just first dimension\n# plot(as.numeric(d), as.numeric(d4)) \n# abline(0, 1)\n\n# take a smaller sample size to expedite the viz\nind <-  sample(1:length(d4), 10000, replace = FALSE)\nx1 <- d[ind]\ny1 <- d4[ind]\nplot_ly() %>%\n  add_markers(x = ~x1, y = ~y1, name=\"Transformed Distances\") %>%\n  add_trace(x = ~c(0,8), y = ~c(0,8), mode=\"lines\",\n        line = list(color = \"red\", width = 4), name=\"Preserved Distances\") %>%\n  layout(title='Approximate Distance Preservation in 1D',\n           xaxis = list(title=\"(1D) Original Distances\", range = c(0, 8)),\n           yaxis = list(title=\"(1D) A-Transformed Distances\", range = c(0, 8)),\n           legend = list(orientation = 'h'))\n  # add_markers(x = ~x1[1], y = ~y1[1], marker=list(color = 'red', size = 20,\n  #                  line = list(color = 'yellow', width = 2)), name=\"Pair 1\") %>%\n  # add_markers(x = ~x1[2], y = ~y1[2], marker=list(color = 'green', size = 20,\n  #                  line = list(color = 'orange', width = 2)), name=\"Pair 2\")  %>%\n  # layout(title=paste0('Approximate Distance Estimated in 1D(Transform): Twin-Pair Distance = ', \n  #             round(euc.dist(x1[1], y1[1]),3)),\n  #          xaxis = list(title=\"Original Distances\", range = c(0, 8)),\n  #          yaxis = list(title=\"Transformed Distances\", range = c(0, 8)),\n  #          legend = list(orientation = 'h'))",
      "line_count": 25
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "ex<-data.frame(x=c(1, 3, 5, 6, 10, 16, 50), y=c(4, 6, 5, 7, 10, 13, 12))\n# reg1<-lm(y~x, data=ex)\n# plot(ex)\n# abline(reg1, col='red', lwd=4)\n# text(40, 10.5, \"pc1\")\n# segments(10.5, 11, 15, 7, lwd=4)\n# text(11, 7, \"pc2\")\n\nyLM <- lm(y ~ x, data=ex)\nperpSlope = - 1/(yLM$coefficients[2]) # slope of perpendicular line\nnewX <- data.frame(x = mean(ex$x))\nnewY <- predict.lm(yLM,newX)\n\npoint0 <- c(x=newX, y=newY)  # (x,y) coordinates of point0 on LM line\npoint1 <- c(x=newX[1]-1, y=newY-perpSlope)  # (x,y) coordinates of point1 on perpendicular line\npoint2 <- c(x=newX[1]+1, y=newY+perpSlope)  # (x,y) coordinates of point2 on perpendicular line\n\nmodelLabels <- c('PC 1 (LM)', 'PC 2 (Perp_LM)')\nmodelLabels.x <- c(40, 20)\nmodelLabels.y <- c(10, 6)\nmodelLabels.color <- c(\"blue\", \"green\")\n\nplot_ly(ex) %>%\n  add_lines(x = ~x, y = ~yLM$fitted, name=\"First PC, Linear Model lm(Y ~ X)\", \n            line = list(width = 4)) %>%\n  add_markers(x = ~x, y = ~y, name=\"Sample Simulated Data\") %>%\n  add_lines(x = ~c(point1$x,point2$x), y = ~c(point1$y,point2$y), name=\"Second PC, Orthogonal to lm(Y ~ X)\", \n            line = list(width = 4))  %>% \n  add_markers(x = ~newX[1]$x, y = ~newY, name=\"Center (avg(x),avg(y))\", marker = list(size = 20,\n                                    color = 'green', line = list(color = 'yellow', width = 2))) %>%\n  layout(xaxis = list(title=\"X\", scaleanchor  = \"y\"),  # control the y:x axes aspect ratio\n         yaxis = list(title=\"Y\", scaleanchor  = \"x\"), legend = list(orientation = 'h'),\n         annotations = list(text=modelLabels,  x=modelLabels.x, y=modelLabels.y, \n                            color = modelLabels.color, showarrow=FALSE ))",
      "line_count": 34
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "library(rvest)\nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SMHS_PCA_ICA_FA\")\nhtml_nodes(wiki_url, \"#content\")\npd.sub <- html_table(html_nodes(wiki_url, \"table\")[[1]])\nsummary(pd.sub)\npd.sub<-pd.sub[, -1]",
      "line_count": 6
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "mu<-apply(pd.sub, 2, mean)\nmean(mu)\npd.center<-as.matrix(pd.sub)-mean(mu)\nS<-cov(pd.center)\neigen(S)",
      "line_count": 5
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "pca1<-prcomp(as.matrix(pd.sub), center = T)\nsummary(pca1)\npca1$rotation",
      "line_count": 3
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "# install.packages(\"factoextra\")\nlibrary(\"factoextra\")\neigen<-get_eigenvalue(pca1)\neigen",
      "line_count": 4
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "# plot(pca1)\n# library(graphics)\n# biplot(pca1, choices = 1:2, scale = 1, pc.biplot = F)\n\nplot_ly(x = c(1:length(pca1$sdev)), y = pca1$sdev*pca1$sdev, name = \"Scree\", type = \"bar\") %>%\n  layout(title=\"Scree Plot\", xaxis = list(title=\"PC's\"),  yaxis = list(title=\"Variances (SD^2)\"))\n\n\n# Scores\nscores <- pca1$x\n\n# Loadings\nloadings <- pca1$rotation\n\n# Visualization scale factor for loadings\nscaleLoad <- 10\n\np <- plot_ly() %>%\n  add_trace(x=scores[,1], y=scores[,2], z=scores[,3], type=\"scatter3d\", mode=\"markers\", name=\"\",\n            marker = list(color=scores[,2], colorscale = c(\"#FFE1A1\", \"#683531\"), opacity = 0.7)) \nfor (k in 1:ncol(loadings)) {\n   x <- c(0, loadings[6, k])*scaleLoad  # Project PCAs only on the last 3 original data dimensions (6,5,4)\n   y <- c(0, loadings[5, k])*scaleLoad\n   z <- c(0, loadings[4, k])*scaleLoad\n   p <- p %>% add_trace(x=x, y=y, z=z, type=\"scatter3d\", mode=\"lines\", \n  name=paste0(\"Loading PC \", k, \" \", colnames(pd.sub)[k]), line=list(width=8), opacity=1) \n  # %>%\n  # add_annotations( x = 0, y = 0, z = 0,\n  #           xref = \"x\", yref = \"y\",  zref = \"z\",\n  #           # axref = \"x\", ayref = \"y\", azref = \"z\",\n  #           text = \"\", showarrow = T,\n  #           ax = c(0, loadings[k,1])*scaleLoad, ay = c(0, loadings[k,2])*scaleLoad, az = c(0,\n  #                  loadings[k,3])*scaleLoad)\n}\n\np <- p %>%\n  layout(legend = list(orientation = 'h'), title=\"3D Projection of 6D Data along First 3 PCs\",\n         scene = list ( xaxis = list(title = rownames(loadings)[6]),\n                        yaxis = list(title = rownames(loadings)[5]),\n                        zaxis = list(title = rownames(loadings)[4]))) \np\n\n#          scene = list(\n#             dragmode = \"turntable\",\n#             annotations = list(\n#               list(showarrow = T, x = c(0, loadings[1,1])*scaleLoad, y = c(0, loadings[1,2])*scaleLoad, \n#                    z = c(0, loadings[1,3])*scaleLoad, text = \"Point 1\", xanchor = \"left\", xshift = 2, opacity=0.7),\n#               list(showarrow = T, x = c(0, loadings[2,1])*scaleLoad, y = c(0, loadings[2,2])*scaleLoad, \n#                    z = c(0, loadings[2,3])*scaleLoad, text=\"Point 2\", textangle=0, ax = 0, ay = -1, font = list(\n#                 color = \"black\", size = 12), arrowcolor = \"black\", arrowsize = 3, arrowwidth = 1, arrowhead = 1),\n#               list(showarrow = T, x = c(0, loadings[3,1])*scaleLoad, y = c(0, loadings[3,2])*scaleLoad, \n#                    z = c(0, loadings[3,3])*scaleLoad, text = \"Point 3\", arrowhead = 1,\n#                    xanchor = \"left\", yanchor = \"bottom\")\n#     )))\n\n# library(\"factoextra\")\n# # Data for the supplementary qualitative variables\n# qualit_vars <- as.factor(pd.sub$Part_IA)\n# head(qualit_vars)\n# # for plots of individuals\n# # fviz_pca_ind(pca1, habillage = qualit_vars, addEllipses = TRUE, ellipse.level = 0.68) +\n# #  theme_minimal()\n# # for Biplot of individuals and variables \n# fviz_pca_biplot(pca1, axes = c(1, 2), geom = c(\"point\", \"text\"),\n#   col.ind = \"black\", col.var = \"steelblue\", label = \"all\",\n#   invisible = \"none\", repel = T, habillage = qualit_vars, \n#   palette = NULL, addEllipses = TRUE, title = \"PCA - Biplot\")\n\n# A slightly more representative 3D plot of the original data and the new PC's\na <- as.matrix(pd.sub[, c(4:6)])\n\np <- plot_ly() %>%\n    add_trace(x=a[,1], y=a[,2], z=a[,3], type=\"scatter3d\", mode=\"markers\", name=\"\",\n              marker = list(color=a[,2], colorscale = c(\"#FFE1A1\", \"#683531\"), opacity = 0.7)) \nfor (k in 1:ncol(loadings)) {\n    x <- c(0, -loadings[6, k])*scaleLoad  # Project PCAs only on the last 3 original data dimensions (6,5,4)\n    y <- c(0, -loadings[5, k])*scaleLoad\n    z <- c(0, -loadings[4, k])*scaleLoad\n    p <- p %>% add_trace(x=x, y=y, z=z, type=\"scatter3d\", mode=\"lines\", \n                         name=paste0(\"Loading PC \", k, \" \", colnames(pd.sub)[k]), line=list(width=8), opacity=1) \n}\np <- p %>%\n    layout(legend = list(orientation = 'h'), title=\"Alternative 3D Projection of 3D Data along with First 3 PCs\",\n           scene = list ( xaxis = list(title = rownames(loadings)[6]),\n                        yaxis = list(title = rownames(loadings)[5]),\n                        zaxis = list(title = rownames(loadings)[4]))) \np",
      "line_count": 87
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "set.seed(12)\nnum_boot = 1000\nbootstrap_it = function(i) {\n  data_resample = pd.sub[sample(1:nrow(pd.sub), nrow(pd.sub), replace=TRUE),] \n  p_resample = princomp(data_resample,cor = T) \n  return(sum(p_resample$sdev[1:3]^2)/sum(p_resample$sdev^2))\n  }\n\npco = data.frame(per=sapply(1:num_boot, bootstrap_it)) \nquantile(pco$per, probs = c(0.025,0.975))  # specify 95-th % Confidence Interval\ncorpp = sum(pca1$sdev[1:3]^2)/sum(pca1$sdev^2)\n\n# require(ggplot2)\n# plot = ggplot(pco, aes(x=pco$per)) +\n#   geom_histogram() + geom_vline(xintercept=corpp, color='yellow')+ \n#   labs(title = \"Percent Var Explained by the first 3 PCs\") +\n#   theme(plot.title = element_text(hjust = 0.5))+\n#   labs(x='perc of var')\n# show(plot)\n\nplot_ly(x = pco$per, type = \"histogram\", name = \"Data Histogram\") %>% \n    layout(title='Histogram of a Bootstrap Simulation <br /> Percent of Data Variability Captured by first 3 PCs', \n           xaxis = list(title = \"Percent of Variability\"), yaxis = list(title = \"Frequency Count\"), bargap=0.1)",
      "line_count": 23
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "library(scatterplot3d)\n\n#Fit linear model\nlm.fit <- lm(Top_of_SN_Voxel_Intensity_Ratio ~\tSide_of_SN_Voxel_Intensity_Ratio + Part_IA, data = pd.sub)\n\n# Get the ranges of the variable.names\nsummary(pd.sub$Side_of_SN_Voxel_Intensity_Ratio)\nsummary(pd.sub$Part_IA)\nsummary(pd.sub$Top_of_SN_Voxel_Intensity_Ratio)\n\n# #plot results\n# myPlot <- scatterplot3d(pd.sub$Side_of_SN_Voxel_Intensity_Ratio, pd.sub$Part_IA,\n#                 pd.sub$Top_of_SN_Voxel_Intensity_Ratio)\n# # Plot the linear model (line in 3D)\n# myCoef <- lm.fit$coefficients\n# plotX <- seq(0.93, 1.4,length.out = 100)\n# plotY <- seq(0,6,length.out = 100)\n# plotZ <- myCoef[1] + myCoef[2]*plotX + myCoef[3]*plotY # linear model\n# #Add the linear model to the 3D scatterplot\n# myPlot$points3d(plotX,plotY,plotZ, type = \"l\", lwd=2, col = \"red\")\n\ncf = lm.fit$coefficients\npltx = seq(summary(pd.sub$Side_of_SN_Voxel_Intensity_Ratio)[1],\n           summary(pd.sub$Side_of_SN_Voxel_Intensity_Ratio)[6], \n           length.out = length(pd.sub$Side_of_SN_Voxel_Intensity_Ratio))\nplty = seq(summary(pd.sub$Part_IA)[1], summary(pd.sub$Part_IA)[6],length.out = length(pd.sub$Part_IA))\npltz = cf[1] + cf[2]*pltx + cf[3]*plty\n\n# Plot Scatter and add the LM line to the plot\nplot_ly() %>%\n  add_trace(x = ~pltx, y = ~plty, z = ~pltz, type=\"scatter3d\", mode=\"lines\",\n        line = list(color = \"red\", width = 4), \n        name=\"lm(Top_of_SN_Voxel_Intensity_Ratio ~\tSide_of_SN_Voxel_Intensity_Ratio + Part_IA)\") %>% \n  add_markers(x = ~pd.sub$Side_of_SN_Voxel_Intensity_Ratio, y = ~pd.sub$Part_IA, \n              z = ~pd.sub$Top_of_SN_Voxel_Intensity_Ratio, color = ~pd.sub$Part_II, mode=\"markers\") %>% \n  layout(title=\"lm(Top_of_SN_Voxel_Intensity_Ratio ~\tSide_of_SN_Voxel_Intensity_Ratio + Part_IA)\",\n    legend=list(orientation = 'h'), showlegend = F,\n    scene = list(xaxis = list(title = 'Side_of_SN_Voxel_Intensity_Ratio'),\n                 yaxis = list(title = 'Part_IA'),\n                 zaxis = list(title = 'Top_of_SN_Voxel_Intensity_Ratio'))) %>% \n  hide_colorbar()",
      "line_count": 41
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "myPlot <- scatterplot3d(pd.sub$Side_of_SN_Voxel_Intensity_Ratio, pd.sub$Part_IA, pd.sub$Top_of_SN_Voxel_Intensity_Ratio)\n\n# Static Plot\nmyPlot$plane3d(lm.fit, lty.box = \"solid\")\n# planes3d(a, b, c, d, alpha = 0.5)\n# planes3d draws planes using the parametrization a*x + b*y + c*z + d = 0.\n# Multiple planes may be specified by giving multiple values for the normal\n# vector (a, b, c) and the offset parameter d",
      "line_count": 8
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "pca1 <- prcomp(as.matrix(cbind(pd.sub$Side_of_SN_Voxel_Intensity_Ratio, pd.sub$Part_IA, pd.sub$Top_of_SN_Voxel_Intensity_Ratio)), center = T); summary(pca1)\n\n# Given two vectors PCA1 and PCA2, the cross product V = PCA1 x PCA2\n\n# is orthogonal to both A and to B, and a normal vector to the \n# plane containing PCA1 and PCA2\n# If PCA1 = (a,b,c) and PCA2 = (d, e, f), then the cross product is\n# PCA1 x PCA2 =  (bf - ce, cd - af, ae - bd)\n# PCA1 = pca1$rotation[,1] and PCAS2=pca1$rotation[,2]\n# https://en.wikipedia.org/wiki/Cross_product#Names\n#normVec = c(pca1$rotation[,1][2]*pca1$rotation[,2][3]-\n#              pca1$rotation[,1][3]*pca1$rotation[,2][2],\n#            pca1$rotation[,1][3]*pca1$rotation[,2][1]-\n#              pca1$rotation[,1][1]*pca1$rotation[,2][3],\n#            pca1$rotation[,1][1]*pca1$rotation[,2][2]-\n#              pca1$rotation[,1][2]*pca1$rotation[,2][1]\n#            )\nnormVec = c(pca1$rotation[2,1]*pca1$rotation[3,2]-\n              pca1$rotation[3,1]*pca1$rotation[2,2],\n            pca1$rotation[3,1]*pca1$rotation[1,2]-\n              pca1$rotation[1,1]*pca1$rotation[3,2],\n            pca1$rotation[1,1]*pca1$rotation[2,2]-\n              pca1$rotation[2,1]*pca1$rotation[1,2]\n            )\n\n# Interactive RGL 3D plot with PCA Plane\nlibrary(rgl) \n\n# Compute the 3D point representing the gravitational balance\ndMean <- apply( cbind(pd.sub$Side_of_SN_Voxel_Intensity_Ratio, pd.sub$Top_of_SN_Voxel_Intensity_Ratio, pd.sub$Part_IA), 2, mean)\n# then the offset plane parameter is (d):\nd <- as.numeric((-1)*normVec %*% dMean)  # force the plane to go through the mean\n\n# Plot the PCA Plane\nplot3d(pd.sub$Side_of_SN_Voxel_Intensity_Ratio, pd.sub$Part_IA, pd.sub$Top_of_SN_Voxel_Intensity_Ratio, type = \"s\", col = \"red\", size = 1)\nplanes3d(normVec[1], normVec[2], normVec[3], d, alpha = 0.5)",
      "line_count": 36
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "# Define the 3D features\nx <- pd.sub$Side_of_SN_Voxel_Intensity_Ratio\ny <- pd.sub$Top_of_SN_Voxel_Intensity_Ratio\nz <- pd.sub$Part_IA\nmyDF <- data.frame(x, y, z)\n\n### Fit a (bivariate-predictor) linear regression model\nlm.fit <- lm(z ~ x+y)\ncoef.lm.fit <- coef(lm.fit)\n\n### Reparameterize the 2D (x,y) grid, and define the corresponding model values z on the grid\nx.seq <- seq(min(x),max(x),length.out=100)\ny.seq <- seq(min(y),max(y),length.out=100)\nz.seq <- function(x,y) coef.lm.fit[1]+coef.lm.fit[2]*x+coef.lm.fit[3]*y\n# define the values of z = z(x.seq, y.seq), as a Matrix of dimension c(dim(x.seq), dim(y.seq))\nz <- t(outer(x.seq, y.seq, z.seq))\n\n# First draw the 2D plane embedded in 3D, and then add points with \"add_trace\"\n# library(plotly)\n# myPlotly <- plot_ly(x=~x.seq, y=~y.seq, z=~z,\n#     colors = c(\"blue\", \"red\"),type=\"surface\", opacity=0.7) %>%\n#   \n#   add_trace(data=myDF, x=x, y=y, z=pd.sub$Part_IA, mode=\"markers\", \n#             type=\"scatter3d\", marker = list(color=\"green\", opacity=0.9, \n#                                             symbol=105)) %>%\n#   \n#   layout(scene = list(\n#     aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1),\n#     xaxis = list(title = \"Side_of_SN_Voxel_Intensity_Ratio\"),\n#     yaxis = list(title = \"Top_of_SN_Voxel_Intensity_Ratio\"),\n#     zaxis = list(title = \"Part_IA\"))\n#     )\n# # print(myPlotly)\n# myPlotly\n\n#Setup Axis\naxis_x <- seq(min(x), max(x), length.out=100)\naxis_y <- seq(min(y), max(y), length.out=100)\n\n#Sample points\nlibrary(reshape2)\nlm_surface <- expand.grid(x = axis_x, y = axis_y, KEEP.OUT.ATTRS = F)\nlm_surface$z <- predict.lm(lm.fit, newdata = lm_surface)\nlm_surface <- acast(lm_surface, x ~ y, value.var = \"z\") # z ~ 0 + x + y\n\nplot_ly(myDF, x = ~x, y = ~y, z = ~z,\n        text = paste0(\"Part_II: \", pd.sub$Part_II), type=\"scatter3d\", mode=\"markers\", color=pd.sub$Part_II) %>%\n  add_trace(x=~axis_x, y=~axis_y, z=~lm_surface, type=\"surface\", color=\"gray\", name=\"LM model\", opacity=0.3) %>%\n  layout(title=\"3D Plane Regression (Part_IA ~ Side_of_SN_Voxel + Top_of_SN_Voxel); Color=Part II\", showlegend = F,\n         scene = list ( xaxis = list(title = \"Side_of_SN_Voxel_Intensity_Ratio\"),\n                        yaxis = list(title = \"Top_of_SN_Voxel_Intensity_Ratio\"),\n                        zaxis = list(title = \"Part_IA\"))) %>% \n  hide_colorbar()",
      "line_count": 53
    },
    {
      "section": "Principal Component Analysis (PCA)",
      "code": "# define the original 3D coordinates\nx <- pd.sub$Side_of_SN_Voxel_Intensity_Ratio\ny <- pd.sub$Top_of_SN_Voxel_Intensity_Ratio\nz <- pd.sub$Part_IA\nmyDF <- data.frame(x, y, z)\n\n### Fit (compute) the 2D PCA space (dimensionality reduction)\npca1 <- prcomp(as.matrix(cbind(pd.sub$Side_of_SN_Voxel_Intensity_Ratio, pd.sub$Top_of_SN_Voxel_Intensity_Ratio, pd.sub$Part_IA)), center = T); summary(pca1)\n# Compute the Normal to the 2D PC plane\nnormVec = c(pca1$rotation[2,1]*pca1$rotation[3,2]-\n              pca1$rotation[3,1]*pca1$rotation[2,2],\n            pca1$rotation[3,1]*pca1$rotation[1,2]-\n              pca1$rotation[1,1]*pca1$rotation[3,2],\n            pca1$rotation[1,1]*pca1$rotation[2,2]-\n              pca1$rotation[2,1]*pca1$rotation[1,2]\n            )\n# Compute the 3D point of gravitational balance (Plane has to go through it)\ndMean <- apply( cbind(pd.sub$Side_of_SN_Voxel_Intensity_Ratio, pd.sub$Top_of_SN_Voxel_Intensity_Ratio, pd.sub$Part_IA), 2, mean)\n\nd <- as.numeric((-1)*normVec %*% dMean)  # force the plane to go through the mean\n\n# Reparameterize the 2D (x,y) grid, and define the corresponding model values z on the grid. Recall z=-(d + ax+by)/c, where normVec=(a,b,c)\nx.seq <- seq(min(x),max(x),length.out=100)\ny.seq <- seq(min(y),max(y),length.out=100)\nz.seq <- function(x,y) -(d + normVec[1]*x + normVec[2]*y)/normVec[3]\n# define the values of z = z(x.seq, y.seq), as a Matrix of dimension c(dim(x.seq), dim(y.seq))\n#z <- t(outer(x.seq, y.seq, z.seq))/10; range(z)  # we need to check this 10 correction, to ensure the range of z is appropriate!!!\nz <- t(outer(x.seq, y.seq, z.seq)); range(z)\n\n# Draw the 2D plane embedded in 3D, and then add points with \"add_trace\"\n# library(plotly)\nmyPlotly <- plot_ly(x=~x.seq, y=~y.seq, z=~z,\n    colors = c(\"blue\", \"red\"),type=\"surface\", opacity=0.7) %>%\n    add_trace(data=myDF, x=x, y=y, z=(pd.sub$Part_IA-mean(pd.sub$Part_IA))*10, mode=\"markers\", \n            showlegend=F, type=\"scatter3d\", marker=list(color=\"green\", opacity=0.9, symbol=105)) %>%\n    layout(scene = list(\n    aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1),\n    xaxis = list(title = \"Side_of_SN_Voxel_Intensity_Ratio\"),\n    yaxis = list(title = \"Top_of_SN_Voxel_Intensity_Ratio\"),\n    zaxis = list(title = \"Part_IA\")) ) %>%\n  hide_colorbar()\n# print(myPlotly)\nmyPlotly",
      "line_count": 43
    },
    {
      "section": "Independent component analysis (ICA)",
      "code": "S <- matrix(runif(10000), 5000, 2)\nS[1:10, ]\nA <- matrix(c(1, 1, -1, 3), 2, 2, byrow = TRUE)\nX <- S %*% A # In R,  \"*\" and \"%*%\" indicate \"scalar\" and matrix multiplication, respectively!\ncor(X)",
      "line_count": 5
    },
    {
      "section": "Independent component analysis (ICA)",
      "code": "# install.packages(\"fastICA\")\nlibrary(fastICA)\na <- fastICA(X, 2, alg.typ = \"parallel\", fun = \"logcosh\", alpha = 1, \n            method = \"C\", row.norm = FALSE, maxit = 200, tol = 0.0001)",
      "line_count": 4
    },
    {
      "section": "Independent component analysis (ICA)",
      "code": "# par(mfrow = c(1, 2))\n# plot(a$X, main = \"Pre-processed data\")\n# plot(a$S, main = \"ICA components\")\n\nplot_ly() %>%  \n  add_markers(x = a$X[ , 1], y =~a$X[ , 2], name=\"Pre-processed data\", \n              marker = list(color=\"green\", opacity=0.9, symbol=105)) %>%\n  add_markers(x = a$S[ , 1], y = a$S[ , 2], name=\"ICA components\",\n              marker = list(color=\"blue\", opacity=0.99, symbol=5))  %>% \n  layout(title='Scatter Plots of the Original (Pre-processed) Data and the corresponding ICA Transform', \n         xaxis = list(title=\"Twin 1 (standardized height)\", scaleanchor = \"y\"), \n         yaxis = list(title=\"Twin 2 (standardized height)\", scaleanchor = \"x\"),\n         legend = list(orientation = 'h'))",
      "line_count": 13
    },
    {
      "section": "Independent component analysis (ICA)",
      "code": "cor(a$S)",
      "line_count": 1
    },
    {
      "section": "Independent component analysis (ICA)",
      "code": "cor(pd.sub)\na1<-fastICA(pd.sub, 6, alg.typ = \"parallel\", fun = \"logcosh\", alpha = 1, \n                 method = \"C\", row.norm = FALSE, maxit = 200, \n                 tol = 0.0001)\npar(mfrow = c(1, 2))\ncor(a1$X)\ncor(a1$S)",
      "line_count": 7
    },
    {
      "section": "Factor analysis (FA)",
      "code": "# Determine Number of Factors to Extract\n# install.packages(\"nFactors\")\n\nlibrary(nFactors)\npar(mfrow=c(1, 1))\nev <- eigen(cor(pd.sub)) # get eigenvalues\nap <- parallel(subject=nrow(pd.sub), var=ncol(pd.sub), rep=100, cent=.05)\nnS <- nScree(x=ev$values, aparallel=ap$eigen$qevpea)\nsummary(nS)\n# plotnScree(nS)\n\nplot_ly() %>% \n  add_trace(y = nS$Analysis$Eigenvalues, type=\"scatter\", name = 'Eigenvalues', \n              mode = 'lines+markers', marker = list(opacity=0.99, size=20, symbol=5)) %>%\n  add_trace(y = nS$Analysis$Par.Analysis, type=\"scatter\", \n            name = 'Parallel Analysis (centiles of random eigenvalues)', \n            mode = 'lines+markers', marker = list(opacity=0.99, size=20, symbol=2)) %>%\n  # add_trace(y = nS$Analysis$OC, type=\"scatter\", \n  #           name = 'Critical Optimal Coordinates', \n  #           mode = 'lines+markers', marker = list(opacity=0.99, size=20, symbol=3)) %>%\n  add_trace(y = nS$Analysis$Acc.factor, type=\"scatter\", \n            name = 'Acceleration Factor', \n            mode = 'lines+markers', marker = list(opacity=0.99, size=20, symbol=15)) %>%\n  layout(title='Scree plot', \n         xaxis = list(title=\"Components)\", scaleanchor = \"y\"), \n         yaxis = list(title=\"Eigenvalues)\", scaleanchor = \"x\"),\n         legend = list(orientation = 'h'))",
      "line_count": 27
    },
    {
      "section": "Factor analysis (FA)",
      "code": "fit<-factanal(pd.sub, factors=2, rotation=\"varimax\")\n# fit<-factanal(pd.sub, factors=2, rotation=\"promax\") # the most popular oblique rotation; And fitting a simple structure\nfit",
      "line_count": 3
    },
    {
      "section": "Factor analysis (FA)",
      "code": "load <- fit$loadings\n# plot(load, type=\"n\") # set up plot \n# text(load, labels=colnames(pd.sub), cex=.7) # add variable names\n\ndf <- as.data.frame(load[])\nFeatures <- rownames(df)\nX <- df$Factor1\nY <- df$Factor2\ndf1 <- data.frame(Features, X, Y)\ncols <- palette(rainbow(6))   # as.numeric(as.factor(Features))\ncols <- cols[2:7]   # this is necessary as cols has 8 rows (not 6, as df1 does!)\n\nplot_ly(df1, x = ~X, y = ~Y, text = ~Features, color = cols) %>% \n  add_markers(marker = list(opacity=0.99, size=20, color=cols, symbol=~as.numeric(as.factor(Features)))) %>% \n  add_text(textfont = list(family= \"Times\", size= 20, color= cols), textposition=\"top right\") %>% \n  layout(title = '2D FA', xaxis = list(title = 'Factor 1', zeroline = TRUE,range = c(-0.5, 1)),\n         yaxis = list(title = 'Factor 2'), showlegend = FALSE)",
      "line_count": 17
    },
    {
      "section": "Singular Value Decomposition (SVD)",
      "code": "#SVD output\ndf<-nrow(pd.sub)-1\nzvars<-scale(pd.sub)\nz.svd<-svd(zvars)\nz.svd$d/sqrt(df)\nz.svd$v\n#PCA output\npca2<-princomp(pd.sub, cor=T)\npca2\nloadings(pca2)",
      "line_count": 10
    },
    {
      "section": "t-SNE (t-distributed Stochastic Neighbor Embedding)",
      "code": "# install.packages(\"tsne\"); library (tsne)\n# install.packages(\"Rtsne\")\nlibrary(Rtsne)\n\n# Download the hand-written digits data\npathToZip <- tempfile()\t\ndownload.file(\"https://www.socr.umich.edu/people/dinov/2017/Spring/DSPA_HS650/data/DigitRecognizer_TrainingData.zip\", pathToZip)\t\ntrain <- read.csv(unzip(pathToZip))\t\ndim(train)\t\nunlink(pathToZip)\t\n\n# identify the label-nomenclature - digits 0, 1, 2, ..., 9 - and map to diff colors\ncolMap <- function(x){\n  cols <- rainbow(length(x))[order(order(x))] # reindexing by ranking the observed values\n}\n\n# Note on \"order(order())\": set.seed(123); x <- sample(10)\n# This experiment shows that order(order()) = rank()\n# set.seed(12345); data <- sample(6); data\n# order(data); order(order(data)); rank(data)\n# Ordering acts as its own inverse and returns a sequence starting with the index of the\n# smallest data value (1). Nested odd \"order\" applications yield the same vector outputs.\n# Order outputs an index vector useful for sorting the original data vector. \n# The location of the smallest value is in the first position of the order-output.\n# The index of the second smallest data value is next, etc.\n# The last order output item represents the index of the largest data value.\n# Double-order application yields an indexing vector where the first element is the index \n# of the smallest first-order-index, etc., which corresponds to the data vector's rank.\n\ntrain.labels<-train$label\ntrain$label<-as.factor(train$label)\ntrain.labels.colors <- colMap(train.labels)\nnames(train.labels.colors) <- train$label # unique(train$label)\n\n# May need to check and increase the RAM allocation\nmemory.limit() \nmemory.limit(50000)\n\n# Remove the labels (column 1) and Scale the image intensities to [0; 1]\ntrain  <- data.matrix(train[, -1]); dim(train)\ntrain <- t(train/255)\n\n# Visualize some of the images\nlibrary(\"imager\")\n# first convert the CSV data (one row per image, 42,000 rows)\narray_3D <- array(train[ , ], c(28, 28, 42000))\nmat_2D <- matrix(array_3D[,,1], nrow = 28, ncol = 28)\nplot(as.cimg(mat_2D))\n\n# We can also use plot_ly to display the image as heatmap\nplot_ly(z=~t(mat_2D[, ncol(mat_2D):1]), type=\"heatmap\", showscale = FALSE) %>%\n  layout(xaxis=list(title=\"X)\", scaleanchor=\"y\"), yaxis=list(title=\"Y)\", scaleanchor=\"x\"), legend=list(orientation='h'))\n\nN <- 42000\nimg_3D <- as.cimg(array_3D[,,], 28, 28, N)\n\n# plot the k-th image (1<=k<=N)\nk <- 5; plot(img_3D, k)\nk <- 6; plot(img_3D, k)\nk <- 7; plot(img_3D, k)\n\npretitle <- function(index) bquote(bold(\"Image: \"~.(index)))\n#layout(t(1:2))\nop <- par(mfrow = c(2,2), oma = c(5,4,0,0) + 0.1, mar = c(0,0,1,1) + 0.1)\n\nfor (k in 1:4) {\n  plot(img_3D, k, xlim = c(0,28), ylim = c(28,0), axes=F, ann=T, main=pretitle(k))\n}\n\n# Run the t-SNE, tracking the execution time (artificially reducing the sample-size to get reasonable calculation time)\nexecTime_tSNE <- system.time(tsne_digits <- Rtsne(t(train)[1:10000 , ], dims = 2, perplexity=30, verbose=TRUE, max_iter = 500)); execTime_tSNE\n# Full dataset(42K * 1K) execution may take over 5-mins\n# execTime_tSNE <- system.time(tsne_digits <- Rtsne(train[ , ], dims = 2, perplexity=30, verbose=TRUE, max_iter = 500)); execTime_tSNE\n\n# Plot only first 1,000 cases (to avoid clutter)\n# plot(tsne_digits$Y[1:1000, ], t='n', main=\"t-SNE\") # don't plot the points to avoid clutter\n# text(tsne_digits$Y[1:1000, ], labels=names(train.labels.colors)[1:1000], col=train.labels.colors[1:1000])\n\n# 2D t-SNE Plot\ndf <- data.frame(tsne_digits$Y[1:1000, ], train.labels.colors[1:1000])\nplot_ly(df, x = ~X1, y = ~X2, mode = 'text') %>%\n  add_text(text = names(train.labels.colors)[1:1000], textfont = list(color = df$train.labels.colors.1.1000.)) %>%\n  layout(title = \"t-SNE 2D Embedding\", xaxis = list(title = \"\"),  yaxis = list(title = \"\"))\n\n# 3D t_SNE plot\nexecTime_tSNE <- system.time(tsne_digits3D <- Rtsne(t(train)[1:10000 , ], dims = 3, perplexity=30, verbose=TRUE, max_iter = 500)); execTime_tSNE\n\ndf3D <- data.frame(tsne_digits3D$Y[1:1000, ], train.labels.colors[1:1000])\nplot_ly(df3D, x = ~df3D[, 1], y = ~df3D[, 2], z= ~df3D[, 3], mode = 'markers+text') %>%\n  add_text(text = names(train.labels.colors)[1:1000], textfont = list(color = df$train.labels.colors.1.1000.)) %>%\n  layout(title = \"t-SNE 3D Embedding\", \n         scene = list(xaxis = list(title=\"\"),  yaxis=list(title=\"\"), zaxis=list(title=\"\")))\n\n# Classic plot all cases as solid discs with colors corresponding to each of the 10 numbers\n# plot(tsne_digits$Y, main=\"t-SNE Clusters\", col=train.labels.colors, pch = 19)\n# legend(\"topright\", unique(names(train.labels.colors)), fill=unique(train.labels.colors), bg='gray90', cex=0.5)\n\nplot_ly(df3D, x = ~df3D[, 1], y = ~df3D[, 2], z= ~df3D[, 3], mode = 'markers+text') %>%\n  add_text(text = names(train.labels.colors)[1:1000], textfont = list(color = df$train.labels.colors.1.1000.)) %>%\n  layout(title = \"t-SNE 3D Embedding\", \n         scene = list(xaxis = list(title=\"\"),  yaxis=list(title=\"\"), zaxis=list(title=\"\")))\n\ncols <- palette(rainbow(10)) \n\nplot_ly(df3D, x=~df3D[, 1], y=~df3D[, 2], z=~df3D[, 3], color=train.labels.colors[1:1000], \n        colors=cols, name=names(train.labels.colors)[1:1000]) %>% \n  add_markers() %>% \n  layout(scene=list(xaxis=list(title=''), yaxis=list(title=''), zaxis=list(title='')), showlegend=F) %>%\n  hide_colorbar()",
      "line_count": 109
    },
    {
      "section": "Uniform Manifold Approximation and Projection (UMAP)",
      "code": "## Preload the SimplicialComplex.py functions ...\n\n##############################################################################\n# source_python(\"https://socr.umich.edu/DSPA2/DSPA2_notes/SimplicialComplex.py\")\n##############################################################################\n\n# loadPythonScript <- function(\n#     filePythonURL=\"https://socr.umich.edu/DSPA2/DSPA2_notes/SimplicialComplex.py\") {\n#     tryCatch( {   \n#         message(\"This is the 'try' part\")\n#         suppressWarnings(\n#            source_python(filePythonURL)\n#         )},\n#         error = function(cond) {\n#             message(\"Error loading external Pythin script\")\n#             message(\"Here's the original error message:\")\n#             message(conditionMessage(cond))\n#             # Choose a return value in case of error\n#             NA\n#         },\n#         warning = function(cond) {\n#             message(\"Python function loading caused a warning ...\")\n#             message(conditionMessage(cond))\n#             # Choose a return value in case of warning\n#             NULL\n#         },\n#         finally = { # everything that should be executed at the end,\n#             source_python(filePythonURL)\n#         }\n#     )\n# }\n# \n# loadPythonScript(filePythonURL=\"https://socr.umich.edu/DSPA2/DSPA2_notes/SimplicialComplex.py\")\n\nlibrary(plotly)\n\np <- plot_ly(type = 'mesh3d',\n             # Define all (4) zero-cells (points or vertices)\n             # P_i(x,y,z), 0<=i<4\n             x = c(0,           1/sqrt(3), -1/(2*sqrt(3)), -1/(2*sqrt(3))),\n             y = c(sqrt(2/3),   0,          0,             0),\n             z = c(0,           0,          -1/2,          1/2),\n             \n             # Next define all triples (i,j,k) of vertices that form a 2-cell face. \n             # All Tetrahedra have 4 faces\n             i = c(0, 0, 0, 1),\n             j = c(1, 2, 3, 2),\n             k = c(2, 3, 1, 3),\n             \n             # Define the appearance of the 4 faces (2-cells)\n             facecolor = toRGB(viridisLite::viridis(4)),\n             showscale = TRUE, \n             opacity=0.8\n) \ntraceEdge <- list( \n  x1 = c(-1/(2*sqrt(3)), -1/(2*sqrt(3))), \n  y1 = c(0, 0), \n  z1 = c(-1/2, 1/2), \n  line = list(\n    color = \"rgb(1, 1, 1)\",  #dark color for line traces\n    width = 20 # width of line\n  ), \n  mode = \"lines\", \n  opacity = 1,\n  type = \"scatter3d\"\n)\n\n# emphasize one of the faces by stressing the three 1-cells (edges)\np <- add_trace(p, x=~traceEdge$x1, y=~traceEdge$y1, z=~traceEdge$z1,\n               type=\"scatter3d\", mode=traceEdge$mode,\n               opacity=traceEdge$opacity,\n               line = list(color=traceEdge$line$color,\n                           width=traceEdge$line$width), showlegend=F)\n# add one 0-cell (point)\np <- add_trace(p, x=-1/(2*sqrt(3)), y=0, z=1/2, type=\"scatter3d\",\n                mode=\"markers\", marker = list(size =16, \n                                      color=\"blue\", opacity = 1.0)) %>%\n  layout(title = \"Simplicial Complexes (0,1,2,3) Cells\", showlegend = FALSE,\n         scene = list(\n          xaxis = list(title = \"X\"),\n          yaxis = list(title = \"Y\"),\n          zaxis = list(title = \"Z\")\n        ))\np",
      "line_count": 84
    },
    {
      "section": "Uniform Manifold Approximation and Projection (UMAP)",
      "code": "# first install Python for your system\n# for instance, for Windows, use Anaconda 3:\n# https://www.anaconda.com/products/distribution\n# https://www.anaconda.com/download/success\n# install.packages(\"simplextree\")\n\n# Launch the Python environment early!\n# install.packages(\"reticulate\")\nlibrary(reticulate)\n# specify the path of the Python version that you want to use\n# py_path = \"C:/Users/IvoD/Anaconda3/\"  # manual\n# py_path = Sys.which(\"python3\")       # automated\n# use_python(py_path, required = T) \n# Sys.setenv(RETICULATE_PYTHON = \"C:/Users/IvoD/Anaconda3/\")\n\nlibrary(simplextree)\nlibrary(plotly)\n\nsimplicialTreeExample <- simplex_tree(list(1:2, 1:3, 2:5, 5:8, 7:9, c(7,9,10), 15:18))\nplot(simplicialTreeExample, color_pal = rainbow(simplicialTreeExample$dimension + 1))\n\n# Generate some data\nn <- 30 #number of points to generate\n\n#generate space of parameter\ntheta = seq(length.out=n, from=0, to=pi) \n\na <- 0.0; b <- 0.0; r <- 5.0\n\nx = a + r*cos(theta) + rnorm(n, 0, 0.4)\ny = b + r*sin(theta) + rnorm(n, 0, 0.4)\n\nx1 = a + r*cos(theta)\ny1 = b + r*sin(theta)\n\ndf <- as.data.frame(cbind(x,y))\n#code to plot the circle for visualization\n# plot(x,y)\n\nplot_ly() %>% \n  add_trace(x=x, y=y, type=\"scatter\", name = 'Simulated Data Sample', \n              mode = 'markers', marker = list(opacity=0.99, size=20, symbol=1)) %>%\n  add_trace(x=x1, y = y1, type=\"scatter\", \n            name = '(Quadratic) Model', \n            mode = 'lines') %>%\n  layout(title='Sample Data from Quadratic Model', \n         xaxis = list(title=\"X)\", scaleanchor = \"y\"), \n         yaxis = list(title=\"Y)\", scaleanchor = \"x\"),\n         legend = list(orientation = 'h'))\n\n\n# install the matplotlib python package\n# py_install(packages = \"matplotlib\")\n\n# Test the R --> Python --> R data transfer:\nas.data.frame(py_to_r(r_to_py(df)))\n\n# See: https://cran.r-project.org/web/packages/reticulate/vignettes/calling_python.html",
      "line_count": 58
    },
    {
      "section": "SimplicialComplex.drawComplex(origData=newData, ripsComplex=ripsComplex)",
      "code": "# install.packages('plotly')\nlibrary(plotly)\n# install.packages('umap')\nlibrary(umap)\n# \n# # Specify the input data \n# umapData <- iris[ , 1:4]\n# umapLabels <- iris[ , 5]\n# \n# # UMAP projection in 2D\n# umapData.umap <- umap(umapData)   # exclude the iris 3-class labels\n# \n# # Using Python through R-reticulate interface\n# # library(reticulate)\n# # iris.umap_learn <- umap(umapData, method=\"umap-learn\")\n# \n# # Plot UMAP reduction in 2D\n# plot(umapData.umap$layout, col=as.factor(umapLabels))\n\n# https://rdrr.io/cran/umap/man/umap.defaults.html\ncustom.settings = umap.defaults\ncustom.settings$n_neighbors = 5\ncustom.settings$n_components=3\n# custom.settings\nexecTime_UMAP <- system.time(umap_digits3D <- umap(t(train)[1:10000 , ], umap.config=custom.settings)); execTime_UMAP\n\ncols <- palette(rainbow(10)) \n\n# 2D UMAP Plot\ndfUMAP <- data.frame(umap_digits3D$layout[1:1000, ], train.labels.colors[1:1000])\nplot_ly(dfUMAP, x = ~X1, y = ~X2, mode = 'text') %>%\n  add_text(text=names(train.labels.colors)[1:1000], textfont=list(color=dfUMAP$train.labels.colors.1.1000.)) %>%\n  layout(title=\"UMAP (784D->2D) Embedding\", xaxis = list(title = \"\"),  yaxis = list(title = \"\"))\n\n# 3D UMAP plot\nexecTime_UMAP <- system.time(umap_digits3D <- umap(t(train)[1:10000 , ], umap.config=custom.settings, n_components=3))\nexecTime_UMAP\n\ndf3D <- data.frame(umap_digits3D [[\"layout\"]], train.labels.colors[1:1000])\nplot_ly(df3D, x = ~df3D[1:1000, 1], y = ~df3D[1:1000, 2], z= ~df3D[1:1000, 3], mode = 'markers+text') %>%\n  add_text(text = names(train.labels.colors)[1:1000], textfont = list(color = df3D$train.labels.colors.1.1000.)) %>%\n  layout(title = \"UMAP 3D Embedding\",\n         scene = list(xaxis = list(title=\"\"),  yaxis=list(title=\"\"), zaxis=list(title=\"\")))",
      "line_count": 43
    },
    {
      "section": "SimplicialComplex.drawComplex(origData=newData, ripsComplex=ripsComplex)",
      "code": "# execTime_UMAP <- system.time(umapData.umap <- \n#                                umap(t(train)[1:10000 , ])) \n# execTime_UMAP\n# # Full dataset(42K * 1K) execution may take much longer\n# \n# # Plot the result 2D UMAP embedding of the data with digits or solid discs\n# par(mfrow=c(1,1)) # reset the plot canvas\n# \n# # Plot only first 1,000 cases (to avoid clutter)\n# plot(umapData.umap$layout[1:200 , ], t='n', main=\"UMAP (784D->2D)\") # don't plot the points to avoid clutter\n# text(umapData.umap$layout[1:200,], labels=names(train.labels.colors)[1:200], col=train.labels.colors[1:200])\n# \n# # plot(umapData.umap$layout[1:200 , ],\n# #      col=as.factor(train.labels.colors[1:200]))",
      "line_count": 14
    },
    {
      "section": "SimplicialComplex.drawComplex(origData=newData, ripsComplex=ripsComplex)",
      "code": "# for IRIS data\n# umapData <- iris[ , 1:4]\n# umapLabels <- iris[ , 5]\n# \n# # UMAP projection in 2D\n# umapData.umap <- umap(umapData)\n# \n# # Generate a new random set (from the original iris data)\n# umapDataNoise <- umapData + matrix(rnorm(150*40, 0, 0.1), ncol=4)\n# colnames(umapDataNoise) <- colnames(umapData)\n# head(umapDataNoise, 5)\n# \n# # Prediction/Forecasting\n# umapDataNoisePred <- predict(umapData.umap, umapDataNoise)\n# \n# # Stack the original and noise-corrupted data into the same object and plot\n# plot(umapData.umap$layout, col=umapLabels, pch = 1, \n#      xlab='UMAP Dim 1', ylab='UMAP Dim 2')  # UMAP of Original data\n# par(new=TRUE)\n# plot(umapDataNoisePred, col=umapLabels, pch = 3, \n#      xaxt='n', yaxt='n', ann=FALSE)  # UMAP of Predictions on Noisy data\n# Stack the original and noise-corrupted data into the same object and plot\n# plot(umap_digits3D$layout, col=umapLabels, pch = 1, \n#      xlab='UMAP Dim 1', ylab='UMAP Dim 2')  # UMAP of Original data\n# par(new=TRUE)\n# plot(umapDataNoisePred, col=umapLabels, pch = 3, \n#      xaxt='n', yaxt='n', ann=FALSE)  # UMAP of Predictions on Noisy data\n\n\n# Use the next 1,000 images as prospective new data to classify into 0,1, ..., 9 labels\numapData_1000 <- train[ , 10001:11000]\nstr(umapData_1000)\n\n# Prediction/Forecasting\numapData_1000_Pred <- predict(umap_digits3D, t(umapData_1000))  # mind transpose of data (case * Feature)\n# train.labels.colors <- colMap(train.labels)\n\n# 2D UMAP Plot\ndfUMAP <- data.frame(x=umap_digits3D$layout[1:1000, 1], y=umap_digits3D$layout[1:1000, 2],\n                     col=train.labels.colors[1:1000])\nplot_ly(dfUMAP, x = ~x, y = ~y, mode = 'text') %>%\n    # Add training data UMAP projection scatter Digits\n    add_text(text=names(train.labels.colors)[1:1000], textfont=list(color=~col, size=15), showlegend=F) %>%\n    # Add 1,000 testing hand-written digit cases onto the 2D UMAP projection pane as colored scatter points\n    # add_markers(marker = list(opacity=0.99, size=10, color=train.labels.colors[10001:11000],\n    #                           symbol=~as.numeric(as.factor(train.labels.colors[10001:11000]))))\n    add_markers(x=umapData_1000_Pred[ , 1], y=umapData_1000_Pred[ , 2], \n                name =train.labels[10001:11000], marker = list(color=train.labels.colors[10001:11000], opacity=0.3)) %>%\n    layout(title=\"UMAP Prediction: Projection of 1,000 New Images in 2D\", \n           xaxis = list(title = \"\"),  yaxis = list(title = \"\"))\n\n# #############################################################################\n# # plot(range(umapData.umap$layout)[ , 1], range(umapData.umap$layout[ , 2]))\n# # points(umapData.umap$layout[,1], umapData.umap$layout[,2],\n# #        col=umapLabels, cex=2, pch=1)\n# # mtext(side=3, main=\"UMAP\")\n# # df <- as.data.frame(cbind(umapData.umap$layout[ , 1], umapData.umap$layout[ , 2]))\n# library(plotly)\n# plot_ly(x = umapData.umap$layout[ , 1] , \n#         y = umapData.umap$layout[ , 2], z = umapData.umap$layout[ , 2], \n#         color = ~umapLabels,\n#         opacity = .5,\n#         colors = c('darkgreen', 'red'), \n#         type = \"scatter3d\", \n#         mode = \"markers\",\n#         marker = list(size = 5, width=2), \n#         text = ~umapLabels,\n#         hoverinfo = \"text\") %>%\n#   layout(\n#     title = \"UMAP clusters\"\n#   )\n# \n# # p <-plot_ly(\n# #   x = umapData.umap$layout[ , 1] , \n# #         y = umapData.umap$layout[ , 2], z = umapData.umap$layout[ , 2], \n# #   type=\"scatter3d\",\n# #   mode = \"markers\",\n# #   color = as.factor(umapLabels)) %>%\n# #   layout(\n# #     title = \"UMAP clusters\"\n# #   )\n# # p",
      "line_count": 82
    },
    {
      "section": "Dimensionality Reduction Case Study (Parkinson's Disease)",
      "code": "# Loading required package: xml2\nwiki_url <- read_html(\"https://wiki.socr.umich.edu/index.php/SOCR_Data_PD_BiomedBigMetadata\")\nhtml_nodes(wiki_url, \"#content\")\npd_data <- html_table(html_nodes(wiki_url, \"table\")[[1]])\nhead(pd_data); summary(pd_data)",
      "line_count": 5
    },
    {
      "section": "Dimensionality Reduction Case Study (Parkinson's Disease)",
      "code": "pd_data$Dx <- gsub(\"PD\", 1, pd_data$Dx)\npd_data$Dx <- gsub(\"HC\", 0, pd_data$Dx)\npd_data$Dx <- gsub(\"SWEDD\", 0, pd_data$Dx)\npd_data$Dx <- as.numeric(pd_data$Dx)\nattach(pd_data)\npd_data<-pd_data[, -c(1, 33)]",
      "line_count": 6
    },
    {
      "section": "Dimensionality Reduction Case Study (Parkinson's Disease)",
      "code": "library(factoextra)\npca.model <- princomp(pd_data, cor=TRUE)\nsummary(pca.model) # pc loadings (i.e., eigenvector columns)\nplot(pca.model)\nbiplot(pca.model)\n\nfviz_pca_biplot(pca.model, axes = c(1, 2), geom = \"point\",\n  col.ind = \"black\", col.var = \"steelblue\", label = \"all\",\n  invisible = \"none\", repel = F, habillage = pd_data$Sex, \n  palette = NULL, addEllipses = TRUE, title = \"PCA - Biplot\")\n\n\nplot_ly(x = c(1:length(pca.model$sdev)), y = pca.model$sdev*pca.model$sdev, name = \"Scree\", type = \"bar\") %>%\n  layout(title=\"Scree Plot\", xaxis = list(title=\"PC's\"),  yaxis = list(title=\"Variances (SD^2)\"))\n\n# Scores\nscores <- pca.model$scores\n# Loadings\nloadings <- pca.model$loadings\n\n# Visualization scale factor for loadings\nscaleLoad <- 10\n\np <- plot_ly() %>%\n  add_trace(x=scores[,1], y=scores[,2], z=scores[,3], type=\"scatter3d\", mode=\"markers\", name=pd_data$Dx,\n            marker = list(color=pd_data$Dx, colorscale = c(\"gray\", \"red\"), opacity = 0.7), showlegend=F) \nfor (k in 1:nrow(loadings)) {\n   x <- c(0, loadings[k,1])*scaleLoad\n   y <- c(0, loadings[k,2])*scaleLoad\n   z <- c(0, loadings[k,3])*scaleLoad\n   p <- p %>% add_trace(x=x, y=y, z=z, type=\"scatter3d\", mode=\"lines\", \n  name=paste0(\"Loading PC \", k, \" \", colnames(pd.sub)[k]), line=list(width=8), opacity=1) \n}\n\np <- p %>%\n  layout(legend = list(orientation = 'h'), \n         title=paste0(\"3D Projection of \", length(pca.model$sdev),\"D PD Data along First 3 PCs (Colored by Dx)\")) \np",
      "line_count": 38
    },
    {
      "section": "Dimensionality Reduction Case Study (Parkinson's Disease)",
      "code": "library(nFactors)\nev <- eigen(cor(pd_data)) # get eigenvalues\nap <- parallel(subject=nrow(pd_data), var=ncol(pd_data), rep=100, cent=.05)\nnS <- nScree(x=ev$values, aparallel=ap$eigen$qevpea)\nsummary(nS)",
      "line_count": 5
    },
    {
      "section": "Dimensionality Reduction Case Study (Parkinson's Disease)",
      "code": "fa.model<-factanal(pd_data, 19, rotation=\"varimax\")\nfa.model",
      "line_count": 2
    },
    {
      "section": "Dimensionality Reduction Case Study (Parkinson's Disease)",
      "code": "cor(pd_data)[1:10, 1:10]\n\n# generate some random categorical labels for all N observations\nclass <- pd_data$Dx\ndf <- as.data.frame(pd_data[1:5], class=class)\n\nplot_ly(df) %>%\n    add_trace(type = 'splom', dimensions = list( list(label=colnames(pd_data)[1], values=~L_caudate_ComputeArea),\n                                                 list(label=colnames(pd_data)[2], values=~L_caudate_Volume),\n                                                 list(label=colnames(pd_data)[3], values=~R_caudate_ComputeArea),\n                                                 list(label=colnames(pd_data)[4], values=~R_caudate_Volume),\n                                                 list(label=colnames(pd_data)[5], values=~L_putamen_ComputeArea)),\n              text=~class, marker = list(line = list(width = 1, color = 'rgb(230,230,230)'))) %>%\n    layout(title= 'Parkinsons Disease (PD) Data Pairs Plot', hovermode='closest', dragmode= 'select',\n        plot_bgcolor='rgba(240,240,240, 0.95)')",
      "line_count": 15
    },
    {
      "section": "Dimensionality Reduction Case Study (Parkinson's Disease)",
      "code": "# install.packages(\"Rtsne\")\nlibrary(Rtsne)\n\n# If working with post-processed PD data above: remove duplicates (after stripping time)\n# pd_data <- unique(pd_data[,])\n\n# If working with raw PD data: reload it\npd_data <- html_table(html_nodes(wiki_url, \"table\")[[1]])\n\n# Run the t-SNE, tracking the execution time (artificially reducing the sample-size to get reasonable calculation time)\nexecTime_tSNE <- system.time(tsne_PD <- Rtsne(pd_data, dims = 3, perplexity=30, verbose=TRUE, max_iter = 1000)); execTime_tSNE\n\n# Plot the result 2D map embedding of the data\n# table(pd_data$Sex)\n# plot(tsne_PD$Y, main=\"t-SNE Clusters\", col=rainbow(length(unique(pd_data$Sex))), pch = 1)\n#legend(\"topright\", c(\"Male\", \"Female\"), fill=rainbow(length(unique(pd_data$Sex))), bg='gray90', cex=0.5)\n\ntable(pd_data$Dx)\n\n# Either use the DX label column to set the colors col = as.factor(pd_data$Dx) \n#plot(tsne_PDs$Y, main=\"t-SNE Clusters\", col=as.factor(pd_data$Dx), pch = 15)\n#legend(\"topright\", c(\"HC\", \"PD\", \"SWEDD\"), fill=unique(as.factor(pd_data$Dx)), bg='gray90', cex=0.5)\n\n\n# Or to set the colors explicitly\nCharToColor = function(input_char){ \n    mapping = c(\"HC\"=\"blue\", \"PD\"=\"red\", \"SWEDD\"=\"yellow\")\n    mapping[input_char]\n}\npd_data$Dx.col = sapply(pd_data$Dx, CharToColor)\n\n# plot(tsne_PD$Y, main=\"t-SNE Clusters\", col=pd_data$Dx.col, pch = 15)\n# legend(\"topright\", c(\"HC\", \"PD\", \"SWEDD\"), fill=unique(pd_data$Dx.col), bg='gray90', cex=0.5)\n\ndf3D <- data.frame(tsne_PD$Y, pd_data$Dx.col)\nplot_ly(df3D, x = ~df3D[, 1], y = ~df3D[, 2], z= ~df3D[, 3], type=\"scatter3d\",  mode = 'markers', \n        color = pd_data$Dx.col, name=pd_data$Dx) %>%\n  layout(title = \"PD t-SNE 3D Embedding\", \n         scene = list(xaxis = list(title=\"\"),  yaxis=list(title=\"\"), zaxis=list(title=\"\")))",
      "line_count": 39
    },
    {
      "section": "Dimensionality Reduction Case Study (Parkinson's Disease)",
      "code": "execTime_UMAP <- system.time(umap_PD_3D <- umap(pd_data[, -c(27, 34)]))   # remove \"Dx.col\" & \nexecTime_UMAP\n\ncols <- palette(rainbow(3)) \n\n# 2D UMAP Plot\ndfUMAP <- data.frame(umap_PD_3D$layout, df3D$pd_data.Dx.col)\nplot_ly(dfUMAP, x = ~X1, y = ~X2, mode = 'text') %>%\n  add_text(text=pd_data$Dx, textfont=list(color=dfUMAP$df3D.pd_data.Dx.col)) %>%\n  layout(title=\"UMAP PD (32D->2D) Embedding\", xaxis = list(title = \"\"),  yaxis = list(title = \"\"))",
      "line_count": 10
    }
  ]
}