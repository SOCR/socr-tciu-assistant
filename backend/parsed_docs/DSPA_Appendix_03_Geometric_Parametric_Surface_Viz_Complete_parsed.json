{
  "metadata": {
    "created_at": "2024-11-30T13:46:17.125807",
    "total_sections": 5,
    "total_code_chunks": 11,
    "total_tables": 1,
    "r_libraries": [
      "freesurfer",
      "geometry",
      "geomorph",
      "jsonlite",
      "plotly",
      "scales"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Data Science and Predictive Analytics (UMich HS650)\"\nsubtitle: \"<h2><u>Geometric and Parametric Surface Visualization</u></h2>\"\nauthor: \"<h3>SOCR/MIDAS (Ivo Dinov)</h3>\"\ndate: \"`r format(Sys.time(), '%B %Y')`\"\ntags: [DSPA, SOCR, MIDAS, Big Data, Predictive Analytics] \noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: SOCR_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n\n\nIn this [DSPA Appendix section](https://dspa2.predictive.space) we will demonstrate the surface rendering of various mathematical representations of shape, form and size.\n\nIt is important to realize that there are different types of [manifolds](https://en.wikipedia.org/wiki/Manifold) and their shape can be represented as a number of alternative mathematical objects. There are [parametric](https://en.wikipedia.org/wiki/Parametric_surface), [PDE](https://en.wikipedia.org/wiki/PDE_surface), [triangulated](https://en.wikipedia.org/wiki/Surface_triangulation), [implicit ($f(x,y,x)=0$)](https://en.wikipedia.org/wiki/Implicit_surface) explicit ($r=r(u,v)$), and other analytic strategies to represent the [surface topology](https://en.wikipedia.org/wiki/Surface_(topology)). In addition, some manifolds are [orientable](https://en.wikipedia.org/wiki/Orientability) and some are non-orientable, some are [closed with no boundaries](https://en.wikipedia.org/wiki/Closed_manifold) and some are [open with boundaries](https://en.wikipedia.org/wiki/Topological_manifold#Manifolds_with_boundary). The deep topological [classification of manifolds](https://en.wikipedia.org/wiki/Classification_of_manifolds) provides further details on the mathematical analytic approaches to represent form, shape and size. Below. We will demonstrate examples of visualizing common geometric manifolds and some mathematical models representing the boundaries of specific manifolds.\n\nFor example, a parametric mesh-based representation of an open surface with boundaries requires individual definition of each component: $x=x(u,v)$,$y=y(u,v)$, $z=z(u,v)$. In the saddle point surface example below, we use a single parameter $0\\leq u=\\phi <2\\pi$. However, all other 3D scene components need to be transformed using [spherical coordinates](https://en.wikipedia.org/wiki/Spherical_coordinate_system), e.g., the orthogonal vertical planes need to be parameterized using\n$0\\leq u=\\phi <2\\pi \\text { and } 0\\leq v=\\psi <\\pi$.\n\n\nOn the other hand, an orientable closed surface without boundary can be displayed by explicitly defining a triangulation of the surface, as illustrated below for a [tetrahedron](https://en.wikipedia.org/wiki/Tetrahedron).\n\n\nNext, we demonstrate how to render a more complex, naturally-triangulated surface; [12-face Icosahedron](https://en.wikipedia.org/wiki/Icosahedron):",
      "word_count": 283
    },
    {
      "title": "Geometric Primitive Surfaces with and without Boundaries",
      "content": "## Saddle Point Surface\n\nA [saddle point](https://en.wikipedia.org/wiki/Saddle_point) is a point on the surface represented by a function $z=z(x,y)$, where the gradient slopes (partial derivatives) of orthogonal function components defining the surface are trivial ($0$), however the point does not represent a local extremum on both axes, as may be expected. We already showed a simple example of a saddle point earlier, which we rendered as a `surface`. Now we will illustrate the parametric definition of a surface with a saddle point and it's triangulated representation as a  `mesh3d`.\n\n\n## Geometric Shapes: 3D Spherical Parameterization\n\nBelow, we show three complementary examples of rendering synthetic geometric shapes; convex shapes (*cone*, *sphere*) and a non-convex surface (*complex*). It's worthwhile reviewing the [fundamentals of the spherical coordinate system representation](https://en.wikipedia.org/wiki/Spherical_coordinate_system).",
      "word_count": 125
    },
    {
      "title": "Non-Orientable Surfaces",
      "content": "## Mobius Band Triangulation\n\nThe [Mobius band (or Moebius strip](https://en.wikipedia.org/wiki/Mobius_strip) is a non-orientable 2D surface with a single (curve) boundary. The example below shows the parameterization, triangulation and rendering of the Mobius band. The example also demonstrates how to add additional traces (curves or surfaces) to the same 3D scene.\n\n\n## Klein Bottle\n\nA more interesting example of a non-orientable 2-manifold that is closed and has no boundary. It is natively embedded in $R^4$, but can be rendered in $R^3$ with some imagination. The Klein bottle surface does not intersect itself when it's natively embedded in $R^4$, however, it's projection in $R^3$ appears to be self-intersecting. See the [Klein Bottle parametrization details online](https://en.wikipedia.org/wiki/Klein_bottle).\n\n\nWe can also try to render the Klein Bottle using a precomputed JSON object including the geometric, topological and meta-data attributes needed for the 3D rendering of the surface.",
      "word_count": 142
    },
    {
      "title": "Brain Surfaces",
      "content": "Oftentimes, we are interested in modeling the boundaries of complex 3D solids using 2D manifolds. One of these interesting examples is reconstructing the mammalian cortical brain surface, e.g., rodents or humans. Below, we demonstrate two examples of loading precomputed, i.e., triangulated, surface models into R/RStudio for rendering and visualization using `plotly`. You can also see the [SOCR Brian Viewer](https://socr.umich.edu/HTML5/BrainViewer/), which provides a more complex WebGL mechanism for visualization and interrogation of complex brain surfaces, models and stereotactic volumes. \n\n## Human Brain\n\nThere a many different software tools that can be used to model the human brain cortical surface using [3D sMRI data]( https://en.wikipedia.org/wiki/Magnetic_resonance_imaging), e.g., [Freesurfer](https://surfer.nmr.mgh.harvard.edu) and [BrainSuite](http://brainsuite.org). Below we demonstrate an example using a Freesurfer surface model using the [FS pial](http://www.grahamwideman.com/gw/brain/fs/surfacefileformats.htm) surface file format.\n\n\n## Rodent Brain\n\nThis final example illustrates a simpler model of a rodent brain represented as a [PLY](https://en.wikipedia.org/wiki/PLY_(file_format)) surface model.",
      "word_count": 144
    },
    {
      "title": "References",
      "content": "* Additional [brain surface data are available online](http://www.freesurfer.net/pub/data/tutorial_data/long-tutorial/).\n* [R plot_ly documentation and details are available here](https://plot.ly/r/).\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number \n\t\t\t\t<img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 112
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "      smooth_scroll: true\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "knitr::opts_chunk$set(echo = TRUE)",
      "line_count": 1
    },
    {
      "section": "Main",
      "code": "library(plotly)\n\n# Define Saddle-point Surface\nx <- sin(seq(0, 2*pi, length.out = 200))\ny <- cos(seq(0, 2*pi, length.out = 200))\nz <- sin(seq(0, 2*pi, length.out = 200))*cos(seq(0, 2*pi, length.out = 200))\n#plot_ly(x = ~x, y = ~y, z = ~z, type = 'mesh3d',\n#             contour=list(show=TRUE, color=\"#000\", width=15, lwd=10),\n#             opacity=1.0, hoverinfo=\"none\", legendshow=F)\n\n# Define plane 1 (X=Y)\nphi1 <- pi/4  # x=y in spherical coordinates\npsi1 <- seq(from = 0, to = pi, by = ((pi - 0)/(200 - 1)))\nr1 = seq(from = -1, to = 1, by = ((1 - (-1))/(200 - 1)))  # r = radius\nscale1 <- 1.1\n\n# if you want to display planes as rectangles/squares\n# you need to transform the radial measure (r1)\n#for (i in 1:length(psi1)) {\n#  r1[i] = min(1/abs(cos(psi1[i])), 1/abs(sin(psi1[i])))\n#}\n# plot(x=r1*cos(psi1), y=r1*sin(psi1))\n\nx1 = scale1 * cos(phi1) * (r1 %o% sin(psi1))     # x1 = r1 cos(phi1)sin(psi1)\ny1 = scale1 * x1                                 # x1 = y1\nz1 = scale1 * (r1 %o% cos(psi1)) \n\n# Define plane 2 (Orthogonal to Plane 1 and along the Z axis)\nphi2 <- (3*pi)/4  #  in spherical coordinates\npsi2 <- seq(from = 0, to = pi, by = ((pi - 0)/(200 - 1)))\nr2 = seq(from = -1, to = 1, by = ((1 -(-1))/(200 - 1)))  # r = radius\n\nx2 = scale1 * cos(phi2) * (r2 %o% sin(psi2))     # x2 = r2 cos(phi2)sin(psi2)\ny2 = scale1 * sin(phi2) * (r2 %o% sin(psi2))     # y2 = r2 sin(phi2)sin(psi2)\nz2 = scale1 * (r2 %o% cos(psi2)) \n\np <- plot_ly(x=~x1, y=~y1, z=~z1,   # draw vertical plane 1\n        colors = c(\"yellow\", \"white\"),type=\"surface\", \n        hoverinfo=\"none\", opacity=0.7, \n        legendshow=FALSE, showscale = FALSE) %>%\n  add_trace(x=~x2, y=~y2, z=~z2,    # draw vertical plane 2 (orthogonal to 1)\n        colors = c(\"blue\", \"yellow\"),type=\"surface\", \n        hoverinfo=\"none\", opacity=0.7, \n        legendshow=FALSE, showscale = FALSE) %>%\n  # draw the saddle point surface\n  add_trace(x = ~x, y = ~y, z = ~z, type = 'mesh3d',\n       contour=list(show=TRUE, color=\"#000\", width=15, lwd=10),\n       opacity=1.0, hoverinfo=\"none\", legendshow=F) %>%\n  # trace the boundary of the saddle point surface\n  add_trace(x=~x, y=~y, z=~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color=\"red\"), name=\"Surface Boundary\",\n              hoverinfo=\"none\", legendshow=F) %>%\n  # trace the main Z-axis\n  add_trace(x=0, y=0, z=~(scale1*2*z), type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color=\"navy blue\"), name=\"Z\",\n              hoverinfo=\"none\", legendshow=F) %>%\n  layout(title = \"Saddle Point with Planes\")\np",
      "line_count": 58
    },
    {
      "section": "Main",
      "code": "library(plotly)\n\np <- plot_ly(type = 'mesh3d',\n             # Define all (4) zero-cells (points or vertices)\n             # P_i(x,y,z), 0<=i<4\n             x = c(0, 0, 2, 0),\n             y = c(0, 0, 0, 2),\n             z = c(0, 2, 0, 0),\n             \n             # Next define all triples (i,j,k) of vertices that form a 2-cell face. \n             # All Tetrahedra have 4 faces\n             i = c(0, 0, 0, 1),\n             j = c(1, 2, 3, 2),\n             k = c(2, 3, 1, 3),\n             \n             # Define the appearance of the 4 faces (2-cells)\n             intensity = c(0, 0.33, 0.66, 1),\n             color = c(0, 0.33, 0.66, 1),\n             colors = colorRamp(c(\"yellow\", \"light blue\", \"navy blue\"))\n); p",
      "line_count": 20
    },
    {
      "section": "Main",
      "code": "library(plotly)\n# http://blog.andreaskahler.com/2009/06/creating-icosphere-mesh-in-code.html\n\nphi <- (1 + sqrt(5))/2\n\np <- plot_ly(type = 'mesh3d',\n             # define 12 vertices\n             x = c(-1, 1, -1, 1, 0, 0, 0, 0, phi, phi, -phi, -phi),\n             y = c(phi, phi, -phi, -phi, -1, 1, -1, 1, 0, 0, 0, 0),\n             z = c(0, 0, 0, 0, phi, phi, -phi, -phi, -1, 1, -1, 1),\n \n             # Define all 20 2-cells (faces) \n             i = c(0,0,0,0,0,1,5,11,10,7,3,3,3,3,3,4,2,6,8,9),\n             j = c(11,5,1,7,10,5,11,10,7,1,9,4,2,6,8,9,4,2,6,8),\n             k = c(5,1,7,10,11,9,4,2,6,8,4,2,6,8,9,5,11,10,7,1),\n             # 0 1 2 3 4 5 6 7 8 9 10 11 \n             # A B C D E F G H I J  K  L\n             \n             # Define the appearance\n             facecolor = toRGB(viridisLite::viridis(20)),\n             showscale = TRUE, \n             opacity=0.5\n) \ntraceEdges <- list( \n  x = c(-1, -phi, -phi, -1), \n  y = c(phi, 0, 0, phi), \n  z = c(0, -1, 1, 0), \n  line = list(\n    color = \"rgb(10, 10, 10)\",  #dark color for line traces\n    width = 20 # width of line\n  ), \n  mode = \"lines\", \n  opacity = 1,\n  type = \"scatter3d\"\n)\n\n# emphasize one of the faces by stressing the three 1-cells (edges)\np <- add_trace(p, x=traceEdges$x, y=traceEdges$y, z=traceEdges$z, type=\"scatter3d\", mode=\"lines\", line = list(color=traceEdges$line$color, width=traceEdges$line$width), showscale=T); p",
      "line_count": 38
    },
    {
      "section": "Geometric Primitive Surfaces with and without Boundaries",
      "code": "library (geometry)\n\n# Plotly layout \naxs <- list(\n  backgroundcolor=\"rgb(200,200,200)\", # gray\n  gridcolor=\"rgb(255,255,255)\",       # white\n  showbackground=TRUE,\n  zerolinecolor=\"rgb(255,255,255)\"     # white\n)\n\nn <- 36\nh <- 1/(n-1)\nr = seq(h, 1, length.out=n)\ntheta = seq(0, 2*pi, length.out=100)\n \ngrid.df <- expand.grid(r=r, theta=theta)\n \nx <- c(grid.df$r * cos(grid.df$theta), 0)\ny <- c(grid.df$r * sin(grid.df$theta), 0)\nz <- sin(x*y)\n \nmat <- matrix(\n  c(x,y,z), \n  ncol = 3,\n  dimnames = list(NULL, c(\"x\", \"y\", \"z\"))\n)\n \ntriangulated <- delaunayn(mat[,1:2])\n \n# now figure out the colormap\nzmean <- apply(triangulated, MARGIN=1, function(row){mean(mat[row,3])})\n \nlibrary(scales)\n\nfacecolor = colour_ramp(\n  colorRampPalette(c(\"pink\", \"purple\"))(20)\n)(rescale(x=zmean))\n \nplot_ly(\n  x=x, y=y, z=z,\n  i=triangulated[,1]-1, j=triangulated[,2]-1, k=triangulated[,3]-1,\n  facecolor=facecolor,\n  type=\"mesh3d\",\n  opacity = 0.7,\n  contour=list(show=TRUE, color=\"#000\", width=15)\n) %>%\n  layout(\n    title=\"Triangulated Saddle Point surface\",\n    scene=list(\n      xaxis=axs,\n      yaxis=axs,\n      zaxis=axs,\n      camera=list(\n        eye=list(x=1.75,y=-0.7,z=0.75)\n      )\n    )\n  )\n",
      "line_count": 58
    },
    {
      "section": "Geometric Primitive Surfaces with and without Boundaries",
      "code": "# library(plotly)\n\n# sweep or define (u,v) spherical coordinate parameter ranges\nphi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(200 - 1)))\npsi <- seq(from = 0, to = pi, by = ((pi - 0)/(200 - 1)))\n\n#p <- plot_ly(x = ~x, y = ~y, z = ~z, type = 'surface', opacity=1,\n#             contour=list(show=TRUE, color=\"#000\", width=15, lwd=10))  %>%\n#  layout(title = paste(\"Layout \", shape), \n#         scene = list(xaxis=x_label,yaxis=y_label, zaxis=z_label))\n#p\n\n# shape==\"complex\")\n    # rendering (u,v) parametric surfaces requires x,y,z arguments to be 2D arrays\n    # In out case, the three coordinates have to be 200*200 parameterized tensors/arrays\n    r1 = 2 + sin(3 * phi + 5 * psi)    # r = 2 + sin(7phi+5psi)\n    x1 = (r1 * cos(phi)) %o% sin(psi)    # x = r*cos(phi)*sin(psi)\n    y1 = (r1 * sin(phi)) %o% sin(psi)     # y = r*sin(phi)*sin(psi)\n    z1 = r1 %o% cos(psi)  # z = r*cos(psi)\n    \n#shape==\"cone\")\n    h2= 10   # cone height\n    r2 = seq(from = 0, to = h2, by = ((h2 - 0)/(200 - 1)))  # r = radius\n    x2 = 3* ((h2 - r2)/h2 ) %o% rep(1, 200)             # x = 3*r\n    y2 = 3* ((h2 - r2)/h2 ) %o% sin(phi)   # y = r*sin(phi)\n    z2 = 3* ((h2 - r2)/h2 ) %o% cos(phi)   # z = r*cos(phi)\n\n#shape==\"sphere\") \n    r3 = 1                           # r = 1\n    x3 = r3 * cos(phi) %o% sin(psi)   # x = r*cos(phi)*sin(psi)\n    y3 = r3 * sin(phi) %o% sin(psi)   # y = r*sin(phi)*sin(psi)\n    z3 = r3 * rep(1, 200) %o% cos(psi) # still need z to be 200*200 parameterized tensor/array\n\nshape_names <- c(\"complex\", \"cone\", \"sphere\")\n\n# https://plot.ly/r/custom-buttons/\n\n#p <- plot_ly(x = ~x, y = ~y, z = ~z, type = 'surface', opacity=1,\n#             contour=list(show=TRUE, color=\"#000\", width=15, lwd=10),\n#             layout=layout_shapes)\n\n# updatemenus component\nupdatemenus <- list(\n  list(\n    active = -1,\n    type = 'buttons',\n    buttons = list(\n      list(\n        label = shape_names[1],\n        method = \"update\",\n        args = list(list(visible = c(TRUE, FALSE, FALSE)),\n                    list(title = shape_names[1]))),\n      list(\n        label = shape_names[2],\n        method = \"update\",\n        args = list(list(visible = c(FALSE, TRUE, FALSE)),\n                    list(title = shape_names[2]))),\n      list(\n        label = shape_names[3],\n        method = \"update\",\n        args = list(list(visible = c(FALSE, FALSE, TRUE)),\n                    list(title = shape_names[3])))\n    )\n  )\n)\n\np <- plot_ly(hoverinfo=\"none\", legendshow=FALSE, showscale = FALSE) %>%\n  add_trace(x = ~x1, y = ~y1, z = ~z1, type = 'surface', opacity=1, visible=T,\n             contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n                          opacity=1.0, hoverinfo=\"none\", legendshow=F)) %>%\n  add_trace(x = ~x2, y = ~y2, z = ~z2, type='surface', opacity=1,visible=F,\n             contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n                          opacity=1.0, hoverinfo=\"none\", legendshow=F)) %>%\n  add_trace(x = ~x3, y = ~y3, z = ~z3, type = 'surface', opacity=0.7,visible=F,\n             contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n                          opacity=0.7, hoverinfo=\"none\", legendshow=F)) %>%\n  layout(title = \"Choose a Shape\", showlegend = FALSE,\n         updatemenus = updatemenus)\np\n",
      "line_count": 80
    },
    {
      "section": "Non-Orientable Surfaces",
      "code": "# library(plotly)\nlibrary(geometry)\n \n# Create a data.frame of all (u,v) coordinates\ngrid.df <- expand.grid(\n  u = seq(0, 2*pi, length.out = 100),\n  v = seq(-1, 1, length.out = 50)\n)\n\n# Define the Mobius Band parametric value\ntp <- 1 + (grid.df$v * cos(grid.df$u / 2))/2\nmat <- matrix(\n  c(tp * cos(grid.df$u), tp * sin(grid.df$u), \n    0.5 * grid.df$v * sin(grid.df$u / 2)), \n  ncol = 3, dimnames = list(NULL, c(\"x\", \"y\", \"z\"))\n)\n \n# Delaunay triangulation on grid.df (not on the matrix of values mat)\n# The Delaunay matrix has m rows and dim+1 columns. For each row, the matrix contains a set of indices to the points (zero-cells), which describes a simplex of dimension dim. The 3D simplex is a tetrahedron.\n# grid.df is an n-by-dim matrix. The rows of grid.df represent \n# n points in dim-dimensional space\nDelaunay.mat <- delaunayn(grid.df)\nDelaunay.mat.t <- t(Delaunay.mat)\n#  Use mat to plot (not the 2D grid grid.df\n \n# Plotly layout \naxs <- list(\n  backgroundcolor=\"rgb(200,200,200)\", # gray\n  gridcolor=\"rgb(255,255,255)\",       # white\n  showbackground=TRUE,\n  zerolinecolor=\"rgb(255,255,255)\"     # white\n)\n \n#  Apply the colormap\n#  Compute the mean of z for each row of the Delaunay vertices\nzmean <- apply(Delaunay.mat, MARGIN=1, function(row){mean(mat[row,3])})\n \nlibrary(scales)\n# Determine the 2-cell face's colors\n# plotted color result will be slightly different\n#  since colour_ramp uses CIELAB instead of RGB\n#  could use colorRamp for exact replication\nfacecolor = colour_ramp(\n  # brewer_pal(palette=\"RdBu\")(10); # brewer_pal(\"div\")(10)\n  colorRampPalette(c(\"gold\", \"navy blue\"))(4)\n)(rescale(x=zmean))\n \n \nplot_ly(\n  # x = x, y = y, z = z,  # vertex (0-cell) coordinates\n  # i = i, j = j, k = k,  # indices to the vertices, which describe a 2-cell (face or a simplex) of dimension dim\n  # see docs: https://plot.ly/r/3d-mesh-plots/\n  x = mat[, 1], y = mat[, 2], z = mat[, 3],\n  # JavaScript is 0 based index so subtract 1\n  i=Delaunay.mat[, 1]-1, j=Delaunay.mat[, 2]-1, k=Delaunay.mat[, 3]-1,\n  facecolor = facecolor,\n  type = \"mesh3d\",\n  contour=list(show=TRUE, color=\"#000\", width=15)\n) %>%\n  # add two planes as curve traces\n  add_trace(x=mat[, 1], y=mat[, 2], z=0, type=\"scatter3d\", mode=\"lines\", line = list(color=\"rgb(0, 255, 0)\")) %>%\n  add_trace(x=mat[, 1], y=0, z=mat[, 3], type=\"scatter3d\", mode=\"lines\", line = list(color=\"rgb(255, 0, 0)\"), opacity=0.5) %>%\n  layout(\n    title=\"Mobius Strip Triangulation\",\n    scene=list(xaxis=axs, yaxis=axs, zaxis=axs)\n  )\n",
      "line_count": 67
    },
    {
      "section": "Non-Orientable Surfaces",
      "code": "# library(plotly)\nlibrary(geometry)\n\ngrid.df <- expand.grid(\n  u = seq(0, pi, length.out = 100),\n  v = seq(0, 2*pi, length.out = 100)\n)\n\n# Define a 3D Klein Bottle parameterization (see Wikipedia)\nmat <- matrix(\n    c(\n      -2/15 * cos(grid.df$u) * \n          (3*cos(grid.df$v)-30*sin(grid.df$u) + \n              90*cos(grid.df$u)^4 * sin(grid.df$u)\n              -60*cos(grid.df$u)^6 * sin(grid.df$u) +\n              5*cos(grid.df$u) * cos(grid.df$v) * sin(grid.df$u)), # x\n      -1/15*sin(grid.df$u) * \n          (3*cos(grid.df$v) - 5*cos(grid.df$u)^2 * cos(grid.df$v)\n              -48*cos(grid.df$u)^4 * cos(grid.df$v) + \n              48*cos(grid.df$u)^6 * cos(grid.df$v) - 60*sin(grid.df$u) +\n              5*cos(grid.df$u)*cos(grid.df$v)*sin(grid.df$u) -\n              5*cos(grid.df$u)^3 * cos(grid.df$v) *sin(grid.df$u) -\n              80* cos(grid.df$u)^5 * cos(grid.df$v) *sin(grid.df$u) +\n              80*cos(grid.df$u)^7 * cos(grid.df$v) *sin(grid.df$u)), # y\n        4/15 *(3 + 5*cos(grid.df$u)*sin(grid.df$u)) *sin(grid.df$v) # z\n      ), \n    ncol = 3, dimnames = list(NULL, c(\"x\", \"y\", \"z\"))\n)\n\nDelaunay.mat <- delaunayn(grid.df)\nDelaunay.mat.t <- t(Delaunay.mat)\n#  Use mat to plot (not the 2D grid grid.df\n \n# Plotly layout \naxs <- list(\n  backgroundcolor=\"rgb(200,200,200)\", # gray\n  gridcolor=\"rgb(255,255,255)\",       # white\n  showbackground=TRUE,\n  zerolinecolor=\"rgb(255,255,255)\"     # white\n)\n \n#  Apply the colormap\n#  Compute the mean of z for each row of the Delaunay vertices\nzmean <- apply(Delaunay.mat, MARGIN=1, function(row){mean(mat[row,3])})\n \nlibrary(scales)\n# Determine the 2-cell face's colors\n# plotted color result will be slightly different\n#  since colour_ramp uses CIELAB instead of RGB\n#  could use colorRamp for exact replication\nfacecolor = colour_ramp(\n  # brewer_pal(palette=\"RdBu\")(10); # brewer_pal(\"div\")(10)\n  colorRampPalette(c(\"pink\", \"purple\"))(10)\n)(rescale(x=zmean))\n \n \nplot_ly(\n  # x = x, y = y, z = z,  # vertex (0-cell) coordinates\n  # i = i, j = j, k = k,  # indices to the vertices, which describe a 2-cell (face or a simplex) of dimension dim\n  # see docs: https://plot.ly/r/3d-mesh-plots/\n  x = mat[, 1], y = mat[, 2], z = mat[, 3],\n  # JavaScript is 0 based index so subtract 1\n  i=Delaunay.mat[, 1]-1, j=Delaunay.mat[, 2]-1, k=Delaunay.mat[, 3]-1,\n  facecolor = facecolor,\n  type = \"mesh3d\",\n  opacity = 0.3,\n  contour=list(show=TRUE, color=\"#000\", width=15)\n) %>%\n  # add_trace(x=mat[, 1], y=mat[, 2], z=0, type=\"scatter3d\", mode=\"lines\", line = list(color=\"rgb(0, 255, 0)\")) %>%\n  layout(\n    title=\"Klein Bottle Triangulation\",\n    scene=list(xaxis=axs, yaxis=axs, zaxis=axs)\n  )\n\n# Plot surface using markers\np <- plot_ly() %>% \n  add_trace(type = 'scatter3d', size = 1, \n     x = mat[, 1], y = mat[, 2], z = mat[, 3], opacity=0.001, mode = \"markers\"); p\n\n# Plot surface using \"surface\"\n# To use add_surface instead, we will have to first convert the surface\n# into a different format, with a vector of x locations, a vector of y locations, z as a matrix (dimensions equal to x by y). \n# As the Klein Bottle does not have boundary, we also need to split the \n# z values into two separate surface layers one for the top half of the surface and one for the bottom half\n# p <- plot_ly(showscale = FALSE) %>%  add_surface(x = mat[, 1], y = mat[, 2], z = mat[, 3], opacity=0.5); p\n",
      "line_count": 86
    },
    {
      "section": "Non-Orientable Surfaces",
      "code": "library(plotly)\n\nlibrary(jsonlite)\nKB_data <- fromJSON(\"http://socr.umich.edu/data/DSPA/surfaces/KlineBottle.json\", flatten=TRUE)\n\n# Examine the 3 cardinal projection planes (Klein Bottle cross-sections)\nimage(KB_data$data$z[[1]])\nimage(KB_data$data$y[[1]])\nimage(KB_data$data$x[[1]])\n\np <- plot_ly( # 'mesh3d' assumes vector inputs where z=z(x,y)\n              #x = ~as.vector(KB_data$data$x[[1]]), \n              #y = ~as.vector(KB_data$data$y[[1]]),\n              #z = ~as.vector(KB_data$data$z[[1]]),\n  \n              # 'surface' type assumes (u,v) parametric descriptions\n              # x=x(u,v), y=y(u,v), z=z(u,v)\n              x = ~KB_data$data$x[[1]], \n              y = ~KB_data$data$y[[1]],\n              z = ~KB_data$data$z[[1]],\n              type = 'surface', opacity=0.7); p\n",
      "line_count": 22
    },
    {
      "section": "Brain Surfaces",
      "code": "rm(list=ls())  # clean the environment\nlibrary(plotly)\nlibrary(geomorph)\n# install.packages(\"freesurfer\")\n# https://github.com/joebathelt/ZDHHC9_connectome\n# FS Data/Surfaces: http://www.freesurfer.net/pub/data/tutorial_data/long-tutorial/OAS2_0185_MR1.long.OAS2_0185/surf/\n\nlibrary(freesurfer)\n\nfs <- freesurfer_read_surf('http://socr.umich.edu/data/DSPA/surfaces/lh.pial')\ncolnames(fs$vertices) <- c('x', 'y', 'z')\n# str(fs)\nx <- fs$vertices[ , 'x']\ny <- fs$vertices[ , 'y']\nz <- fs$vertices[ , 'z']\n  \nmat <- matrix(c(x,y,z), ncol=3, dimnames=list(NULL,c(\"x\",\"y\",\"z\")))\n\n# plot_ly(x = x, y = y, z = z, type = \"scatter3d\", \n#        mode = \"markers\", marker = list(size = 3))\n\n# now figure out the colormap for each 2-cell (face) by averaging\n# the z-coordinates, mat[ , 3], of all 3 vertices of the face\nzmean <- apply(t(fs$faces),MARGIN=2,function(row){mean(mat[row,3])})\n# length(zmean); length(mesh$it[1,]) # equal?\n# str(zmean); str(mat[,3]); str(mesh) # check structures\n \nlibrary(scales)\n# color each 2-cell (face), ideally, this would be cortical thickness or another 4D values (e.g., p-value, curvature, etc.)\nfacecolor = colour_ramp(\n  colorRampPalette(c(\"light blue\", \"gold\"))(5)\n)(rescale(x=zmean))\n\n#facecolor = colour_ramp(\n#   colorRampPalette(c(\"navy blue\", \"gold\"))(5)\n# )(rescale(x=fs$faces[,4]))\n#length(fs$faces[,4])\n\nplot_ly(\n  x = x, y = y, z = z,\n  i = fs$faces[ , 1], j = fs$faces[ , 2], k = fs$faces[ , 3],\n  facecolor = facecolor,\n  type = \"mesh3d\",\n  opacity = 0.7,  # change opacity to make see through the surface\n  contour=list(show=TRUE, color=\"#000\", width=15)\n)",
      "line_count": 46
    },
    {
      "section": "Brain Surfaces",
      "code": "# library(\"plotly\")\nplyFile <- 'http://socr.umich.edu/data/DSPA/surfaces/Mouse_Brain.ply'\ndest <- basename(plyFile)\nif (!file.exists(dest)) {\n  download.file(plyFile, dest)\n}\n\n# For ASCII PLY data: \nmesh <- geomorph::read.ply(dest, ShowSpecimen = F)\n\n# For Binary PLY data use: mesh <- vcgPlyRead(dest, updateNormals = TRUE, clean = TRUE)\n\n# see getS3method(\"shade3d\", \"mesh3d\") for details on how to plot \n\n# plot point cloud\nx <- mesh$vb[\"xpts\",]\ny <- mesh$vb[\"ypts\",]\nz <- mesh$vb[\"zpts\",]\nmat <- matrix(c(x,y,z), ncol=3, dimnames=list(NULL,c(\"x\",\"y\",\"z\")))\n\n# plot_ly(x = x, y = y, z = z, type = \"scatter3d\", \n#        mode = \"markers\", marker = list(size = 3))\n\n# now figure out the colormap for each 2-cell (face) by averaging\n# the z-coordinates, mat[ , 3], of all 3 vertices of the face\nzmean <- apply(t(mesh$it),MARGIN=1,function(row){mean(mat[row,3])})\n# length(zmean); length(mesh$it[1,]) # equal?\n# str(zmean); str(mat[,3]); str(mesh) # check structures\n \nlibrary(scales)\n# color each 2-cell (face)\nfacecolor = colour_ramp(\n  colorRampPalette(c(\"light blue\", \"gold\"))(5)\n)(rescale(x=zmean))\n\nplot_ly(\n  x = x, y = y, z = -z,  # flip in z-direction to show anatomically\n  i = mesh$it[1,]-1, j = mesh$it[2,]-1, k = mesh$it[3,]-1, # JS indices start at zero\n  facecolor = facecolor,\n  type = \"mesh3d\",\n  opacity = 0.8,\n  contour=list(show=TRUE, color=\"#000\", width=15)\n)",
      "line_count": 43
    }
  ]
}