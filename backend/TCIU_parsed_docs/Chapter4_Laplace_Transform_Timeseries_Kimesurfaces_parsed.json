{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.253374",
    "total_sections": 11,
    "total_code_chunks": 25,
    "total_tables": 1,
    "r_libraries": [
      "EBImage",
      "TCIU",
      "brainR",
      "cubature",
      "doParallel",
      "ggplot2",
      "plotly",
      "pracma",
      "spatstat"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Spacekime Analytics (Time Complexity and Inferential Uncertainty)\"\nsubtitle: \"TCIU: The Laplace Transform of Longitudinal Data: Analytic Duality of Time-series and Kimesurfaces\"\nauthor: \"SOCR Team \"\ndate: \"`r format(Sys.time(),'%m/%d/%Y')`\"",
      "word_count": 30
    },
    {
      "title": "- \\usepackage{tikzcd}",
      "content": "output: \n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n      smooth_scroll: true\n\n\n\nThe [Laplace Transform](https://en.wikipedia.org/wiki/Laplace_transform), $\\mathcal{L}$, allows us to examine the relations between the space-time and space-kime representations of longitudinal data. The Fourier transformation is a linear operator that maps complex-valued functions of real variables (e.g., space, time domains) to complex valued functions of other real variables (e.g., frequency domain). The Laplace transform is similar, however, it sends complex-valued functions of positive real variables (e.g., time) to complex-valued functions defined on complex variables (e.g., kime).",
      "word_count": 93
    },
    {
      "title": "*Continuous* Forward and Inverse Laplace Transforms (LT)",
      "content": "The *forward* and *inverse* (continuous) Laplace transforms are defined below.\n\n* For a given function function (of time) $f(t): \\mathbb{R}^+ \\longrightarrow \\mathbb{C}$, the **Laplace transform** is the function of a complex frequency argument, $F(z)={\\mathcal {L}}(f)(z):\\mathbb{C} \\longrightarrow \\mathbb{C}$:\n\n$${\\mathcal {L}}(f)(z)=F(z)=\\int_{0}^{\\infty} {f(t)e^{-z t} dt}.$$\n\n* For a given function function of a complex frequency argument, $F(z)$, the **Inverse Laplace transform** (ILT) is the function of a positive real (time-like) argument $f(t)={\\mathcal {L}}^{-1}(F)(t):\\mathbb{R}^+ \\longrightarrow \\mathbb{C}$, which is defined in terms of a complex path integral (a.k.a. Bromwich integral or Fourier–Mellin integral):\n\n$$f(t)={\\mathcal {L}}^{-1}(F)(t)={\\frac {1}{2\\pi i}} \\lim_{T\\to \\infty }\n\\int_{\\gamma -iT}^{\\gamma +iT} { e^{z t}F(z) dz},$$\n\t\nwhere the parameter $\\gamma\\in \\mathbb{R}$ is chosen so that the entire complex contour path of the integral is inside of the region of convergence of $F(z)$.\n\nThe Laplace transform plays an interesting role as an expected value in the field of probability and statistics. If $X$ is a random variable, then its Laplace transform, i.e., the LT of its probability density function $f_X$, is given by the expectation of an exponential:\n\n$${\\mathcal {L}}(X)={\\mathcal {L}}(f)(z)= E\\left ( e^{-zX}\\right ).$$\n\nNote that when $z=−t\\in R$, then the ${\\mathcal {L}}(X)=E\\left ( e^{tX}\\right )$ is just the *moment generating function* of $X$. \n\nAnother application of LT involves recovering the *cumulative distribution function* of a continuous random variable $X$, $F_{X}(x)=\\int_{y<x}{f_X(y) dy}$:\n\n$$ F_{X}(x)={\\mathcal {L}}^{-1} \\left \\{ {\\frac {1}{z}} \nE \\left[e^{-zX}\\right]\\right \\}\\!(x)= \n{\\mathcal {L}}^{-1} \\left \\{ {\\frac {1}{z}} {\\mathcal {L}}(f)(z)\n \\right \\}\\!(x).$$",
      "word_count": 238
    },
    {
      "title": "*Discrete* Forward Laplace Transforms",
      "content": "The *discrete* Forward and Inverse Laplace Transforms are computed by numerically estimating the corresponding continuous transformation integrals.\nThe numerical approximation of the LT is defined by the `LT()` method below.\n\nNow we can test and compare the discrete and continuous LT ($\\mathcal{L}$) on a pair of functions that have closed-form analytical expressions.\n\n$$f_1(t)=\\mathcal{L}^{-1}(F_1)(t)=t\\ \\underset{ILT}{\\overset{LT}{\\longleftrightarrow}} \\ F_1(z)=\\mathcal{L}(f_1)(z)=\\frac{1}{z^2}.$$\nAnd\n$$ f_2(t)=\\mathcal{L}^{-1}(F_2)(t)=e^{-5t} \\ \n\\underset{ILT}{\\overset{LT}{\\longleftrightarrow}}\\  F_2(z)=\\mathcal{L}(f_2)(z)=\\frac{1}{z+5}.$$",
      "word_count": 62
    },
    {
      "title": "Discrete Inverse Laplace Transform",
      "content": "## Basic functions\n\nLet's start by defining some basic functions that transform between *Cartesian* and *Polar* coordinates.\n\n\n## Contour paths in $C$\n\nNext we will define alternative contour paths in the complex plane, $C$, the *optimal* contour `optimContour()`, the Bromwich contour, and their corresponding numerical derivatives along contour paths, `analyticalPathDerivative()` and `bromwichPathDerivative()` functions.\n\n\n## Define the discrete Inverse Laplace Transform (ILT)\n\nNext, we will define the discrete `ILT()` function, which inverts the Laplace Transform, $\\mathcal{L}^{-1}$.\n\nLet's test the `ILT()` function using some [simple functions](https://en.wikipedia.org/wiki/Laplace_transform#Table_of_selected_Laplace_transforms). For instance, we can use the same 2 functions we defined above:\n\n$$f_1(t)=\\mathcal{L}^{-1}(F_1)(t)=t\\ \\underset{ILT}{\\overset{LT}{\\longleftrightarrow}} \\ F_1(z)=\\mathcal{L}(f_1)(z)=\\frac{1}{z^2},$$\nand\n$$ f_2(t)=\\mathcal{L}^{-1}(F_2)(t)=e^{-5t} \\ \n\\underset{ILT}{\\overset{LT}{\\longleftrightarrow}}\\  F_2(z)=\\mathcal{L}(f_2)(z)=\\frac{1}{z+5}.$$\n\n\nFor longitudinal data, the Laplace transform provides one explicit mapping of the *duality* between functions of time (time-series) and functions of kime (kimesurfaces). The next sections illustrate that dichotomy.",
      "word_count": 135
    },
    {
      "title": "Regularizing Kimesurfaces by Stereographic Projection of the Laplace Transform",
      "content": "As infinities and singularities may introduce substantive analytical challenges \nassociated with the spacekime analytics based on the Laplace transformed time-series,\nvarious **regularization** schemes can be introduced to annihilate such singularities \nover the complex domain. One example of a Laplace transform regularization utilizes\n[stereographic projection](https://en.wikipedia.org/wiki/Stereographic_projection), \nwhich removes the singularities $F(z)$ by compactifying the *range* space.\n\nThe surface of the unit sphere $S^2\\subseteq \\mathbb{R}^3$ is the set comprised of all\n3D Cartesian coordinates ${\\bf{x}}=(x, y, z)\\in\\mathbb{R}^3$ satisfying the \nequation of a sphere $||{\\bf{x}}||^2=x^2 + y^2 + z^2 = 1$. Set the north pole of the\nsphere to be $N = (0, 0, 1)$ and $M=S^2 \\setminus \\{N\\}$ represent all points on\nthe sphere other than the north pole $N$. The canonical *axial (transferse) plane* \n$A=\\{(x, y, z)\\in\\mathbb{R}^3 \\ |\\ z = 0\\}$ runs through the center of the sphere \nand splits it into 2 hemispheres with the *equator* \n$E=S^2\\cap A\\equiv \\{(x, y, z)\\in\\mathbb{R}^3 \\ |\\ z = 0\\ \\& \\ x^2+y^2=1\\}$.\n\nFor each point on the sphere other than the north pole, $\\forall P\\in M$, \n$\\exists! \\ \\vec{NP}$, a line through $N$ and $P$, such that\n$\\vec{NP} \\cap A=P'$ is the *stereographic projection* of $P$ onto the axial plane $A$.\n\nFor each point on the sphere, $(x, y, z)\\in M$, the *bijective stereographic maps*\n$\\mathcal{S}:M\\to A$, $\\mathcal{S}(x,y,z)=(X,Y)$, and $\\mathcal{S}^{-1}:A\\to M$, \n$\\mathcal{S}^{-1}(X,Y)=(x,y,z)$, such \n$\\mathcal{S}^{-1}\\circ \\underbrace{\\mathcal{S}(x,y,z)}_{(X,Y)} = (x,y,z)$ and\n$\\mathcal{S}\\circ \\underbrace{\\mathcal{S}^{-1}(X,Y)}_{(x,y,z)} = (X,Y)$\nare inverse of each other:\n\n$$\\mathcal{S}(x,y,z)\\equiv \\left({\\frac {x}{1-z}},{\\frac {y}{1-z}}\\right)=(X,Y)\\in A,\n\\ \\forall (x,y,z)\\in M,\\ z\\not=1,$$\n$$\\mathcal{S}^{-1}(X,Y)\\equiv \\left({\\frac {2X}{1+X^{2}+Y^{2}}},{\\frac {2Y}{1+X^{2}+Y^{2}}},\n{\\frac {-1+X^{2}+Y^{2}}{1+X^{2}+Y^{2}}}\\right)=(x,y,z)\\in M.$$\n\nRemember that we are trying to regularize the *range* $\\mathbb{C}$ of the Laplace transform values, $F(z)\\in\\mathbb{C}$, not its kime *domain*, $z\\in\\mathbb{C}$. \n\nWe can also consider the 3D *spherical coordinates* parameterizing the sphere by the *zenith angle*, $0\\leq \\phi \\leq \\pi$ and the *azimuth phase*, $0 \\leq \\theta\\leq 2\\pi$, \n$M=\\{(r\\equiv 1, \\phi, \\theta)\\ |\\ 0\\leq \\phi \\leq \\pi, 0 \\leq \\theta\\leq 2\\pi\\}$.\n\nAnd similarly parameterize the 2D axial projection plane using *polar coordinates* \n$A=\\{(R, \\Theta)\\ |\\ R\\geq 0, 0 \\leq \\Theta\\leq 2\\pi\\}$. Then\nthe *bijective stereographic maps* are\n\n$$\\mathcal{S}(\\phi,\\theta)\\equiv \\left({\\frac {\\sin \\phi }{1-\\cos \\phi }},\\theta \\right)=\\left(\\cot {\\frac {\\phi }{2}},\\theta \\right)=(R,\\Theta )\\in A,$$\n$$\\mathcal{S}^{-1}(R,\\Theta)\\equiv \\left(2\\arctan \\left (\\frac {1}{R}\\right ),\n\\Theta \\right)= (\\phi ,\\theta ) \\in M.$$\n\nThe wellposedness of these maps requires specifying that $\\phi=\\pi \\iff R = 0$. \nLet's derive the analytical expression of the *inverse stereographic map in polar coordinates.*\n\nThe 2D schematic below shows the projection triangle consisting of $A$ is the center of the sphere, the points $A$ and $B$ are on the axial projection complex plane, and the pair of points $N$ (North Pole) and $D$ that are on the sphere.\n\n\n\n\n\nWe present three equivalent definitions of the spherical angle using representation of $R$ varying the starting axis of the spherical zenith angle, $\\varphi\\in (0,\\pi)$ (left most column A1),  $\\varphi'\\in (-\\frac{\\pi}{2},\\frac{\\pi}{2})$ (middle column A2), $\\phi''\\in (0,\\pi)$(right column A3), where\n$$\\varphi' = \\varphi - \\frac{\\pi}{2}, \\varphi''=\\pi -\\varphi$$\nBy definition then, the $\\varphi'$ on the top of column A2 is positive and on the bottom is negative. We show that $\\varphi = 2\\text{arctan}(R)$, $\\varphi' = 2\\text{arcsin}\\left (\\frac{R^2-1}{R^2+1}\\right )$, $\\varphi'' = 2\\text{arctan}(\\frac{1}{R})$ and they are equivalent.\n\n - **Formula for A1**: The derivation for column A1 is straightforward as $\\varphi =2\\angle ANB=2\\arctan (\\frac{R}{1})=2\\arctan (R)$\n\n - **Formula for A3**: $\\varphi''=\\pi -\\varphi=\\pi -2\\arctan (R)=2(\\frac{\\pi}{2}-\\arctan (R))=2{\\text{arccot}}(R)=2\\arctan(\\frac{1}{R})$\n\n - **Formula for A2**: Considering $AB=R, AD=AN=1, AE\\perp BN, AN \\perp AB$, We need to explicate $\\phi=\\angle DAB$ in terms of $R$. Let $\\angle NAE=\\angle DAE = \\beta$. Set $AE=x$. First we observed the similarity relation $\\triangle EAB \\sim \\triangle ACB$. Then $\\frac{AE}{AC}=\\frac{x}{1}=\\frac{R}{\\sqrt{R^2+1}}=\\frac{AB}{BC}$. \n\nNow \n$$\\begin{equation}\n\\sin(\\phi)= \\cos(2\\beta) = 2\\cos^2(\\beta)-1=2x^2-1 = \\frac{R^2-1}{R^2+1}\n\\end{equation}\\ .$$\n\nTherefore, $\\phi=\\arcsin\\left (\\frac{R^2-1}{R^2+1}\\right )$.\n\n - **Finally, the A1 and A2 equivalence can be verified from the identity** $2\\arctan(R)=\\arcsin\\left (\\frac{R^2-1}{R^2+1}\\right )+\\frac{\\pi}{2}$.",
      "word_count": 616
    },
    {
      "title": "Laplace Transform Applications",
      "content": "## ILT of Kimesurfaces $(F(z))$ to Time-series $(f(t))$\n\n### Example 1: $F(z)=F_1(z)+F_2(z)\\times F_3(z) +F_4(z)$\n\nSuppose we want to apply the ILT ($\\mathcal{L}^{-1}$ ) to reconstruct a time-series, $\\hat{f}(t)=\\mathcal{L}^{-1}(F)(t)$, corresponding to a given a *composite kimesurface*:\n$$F(z)=\\mathcal{L}(f)=\\underbrace{\\frac{1}{z+1} }_{F_1(z)=\\mathcal{L}\\left( f_1(t)=e^{-t}\\right )} + \n\\underbrace{\\frac{1}{z^2 + 1}}_{F_2(z)=\\mathcal{L}\\left( f_2(t)=\\sin(t)\\right )} \\times \n\\underbrace{\\frac{z}{z^2 + 1}}_{F_3(z)=\\mathcal{L}\\left( f_3(t)=\\cos(t)\\right )} + \n\\underbrace{\\frac{1}{z^2}}_{F_4(z)=\\mathcal{L}\\left( f_4(t)=t\\right )} .$$\n\nMind the decomposition of the compound (*time* and *kime*) functions in terms of their building blocks, i.e., simpler functions. Using the linearity and convolution-to-product properties of the Laplace transform, we have:\n\n$$F(z)=F_1(z)+F_2(z)\\times F_3(z) +F_4(z)$$\nTherefore, \n$$f(t)=\\mathcal{L}^{-1}\\left ( F \\right ) = \n\\mathcal{L}^{-1}\\left ( F_1+F_2\\times F_3 +F_4) \\right )=$$\n$$\\mathcal{L}^{-1}( F_1) + \\left ( \\underbrace{\\mathcal{L}^{-1}(F_2) * \n\\mathcal{L}^{-1} (F_3)}_{\\text{convolution}}\\right )(t)  + \\mathcal{L}^{-1}(F_4)=$$\n\n$$ \\mathcal{L}^{-1}(\\mathcal{L}(f_1))(t) + \\left ( \\mathcal{L}^{-1}(\\mathcal{L}(f_2)) * \n\\mathcal{L}^{-1}(\\mathcal{L}(f_3))\\right )(t) + \\mathcal{L}^{-1}(\\mathcal{L}(f_4))(t).$$\n\n<!-- https://www.wolframalpha.com/input/?i=integral+%28sin%28r%29cos%28t-r%29dr+r+from+0+to+t%29+ -->\n\nFinally,\n\n$$f(t)=\\mathcal{L}^{-1}(F)(t)=f_1(t) + \\left ( f_2 * f_3\\right )(t) + f_4(t)=e^{-t}+ \\int_{0}^{t}{\\sin(\\tau) \\times \\cos(t-\\tau)d\\tau} +t=t+e^{-t}+\\frac{t\\sin(t)}{2}. $$\n\nLet's validate this analytical derivation by using the discrete LT.\n\n\nRecall that kimesurfaces are defined over complex-time (Complex-pane) and have complex-value ranges. The plot below shows the original kimesurface as a 2D manifold whose *height* (vertical dimension) is represented by the *Real* part of the kimesurface intensity, `Re(fMRI_Kimesurface)`, and the *surface color* encodes the *Imaginary* part of the kimesurface intensity, `Im(fMRI_Kimesurface)`.\n\n\nWe can also render the kimesurface as a manifold whose *height* (vertical dimension) is represented by the *Magnitude* and *color* encodes the *Phase* of the kimesurface.\n\n\n\n#### Regularize the Kimesurface\n\nRecall the *inverse stereographic projection* mapping, which needs to be applied to\nthe values in the range of the Laplace transform.\n\n * Cartesian coordinate *inverse stereographic projection* mapping:\n \n$$\\mathcal{S}^{-1}\\left (\\underbrace{X}_{Re(z2\\_grid)},\n\\underbrace{Y}_{Im(z2\\_grid)} \\right )\\equiv \\left({\\frac {2X}{1+X^{2}+Y^{2}}},{\\frac {2Y}{1+X^{2}+Y^{2}}},\n{\\frac {-1+X^{2}+Y^{2}}{1+X^{2}+Y^{2}}}\\right)=(x,y,z)\\in M.$$\n\n * Spherical coordinate *inverse stereographic projection* mapping:\n\n$$\\mathcal{S}^{-1}\\left (\\underbrace{\\underbrace{R}_{LT\\ Magnitude,\\ ||(z2\\_grid)||},\n\\overbrace{\\Theta}^{LT\\ Phase,\\ \\arctan\\left (\\frac{Re(z2\\_grid)}{Im(z2\\_grid)}\\right )} }_{2D\\ polar\\ coordinates}\n\\right )\\equiv \\\\\n\\left(1, 2\\arctan \\left (\\frac {1}{R}\\right ),\\Theta \\right)=\n\\underbrace{\\ \\ \\left (\\overbrace{1}^{sphere\\ radius}, \\overbrace{\\phi}^{zenith\\ angle} ,\n\\overbrace{\\theta}^{azimuth\\ } \\right )\\ \\ }_{3D\\ spherical\\ coordinates} \\in M.$$\n\n$$M=\\{(r\\equiv 1, \\phi, \\theta)\\ |\\ 0\\leq \\phi \\leq \\pi,\\ 0 \\leq \\theta\\leq 2\\pi\\}.$$\n\n\n#### Inverse Laplace Transform\n\nLet's now reconstruct and plot the reconstructed 1D function $f(t)=\\mathcal{L}^{-1}(F)(t)$.\n\nThis uses the raw (unregularized) kimesurface, but we can also use the regularized\nLaplace transform (kimesurface).\n\n\n### Example 2: $F(z)=|z|$\n\nAnother example is finding the time-series Laplace dual to the kimesurface \n$$F(z)=|z| .$$\n\n\n\n\n### Example 3: $F(z)=\\frac{w}{z^2+w^2}$\n\n$$f(t)=\\mathcal{L}^{-1}(F_1)(t)=\\sin(w t)\\ \\underset{ILT}{\\overset{LT}{\\longleftrightarrow}} \\ F_1(z)=\\mathcal{L}(f_1)(z)=\\frac{w}{z^2+w^2}.$$\n\nWe can choose $w=2$ without loss of generosity.\n\n\n\n\n## Laplace Transformation of Time-series $(f(t))$ to Kimesurfaces $(F(z))$\n\nNext, we will demonstrate the reverse operation - finding the Laplace-dual kimesurface corresponding to a given time-series. Starting with the time-series:\n\n### Discrete Representation of $\\mathcal{L}^{-1}(\\mathcal{L}(\\sin(x)))$\n\nLet's explore the duality of the LT, ($\\mathcal{L}^{-1}(\\mathcal{L})=I?$), using $f(t)=\\sin(t)$.\n\n\n\n## Foliating the Laplace Transform to Synthetically Generate Simulated Time-series\n\n$$\\begin{array}{ccc}\n    & LT & \\\\\n\\overbrace{f(t):\\mathbb{R}^+\\to \\mathbb{C}}^{spacetime\\ signal} & \\xrightarrow{\\hspace{2cm}} & \n\\overbrace{F(\\kappa):\\mathbb{C}\\to \\mathbb{C}}^{LT(signal)} \\\\\n    & & \\\\\n\\overset{Samples}{\\theta=\\theta_o}  \\Bigg\\updownarrow\n& & \\Bigg\\downarrow\n\\overset{Foliate}{\\overset{\\kappa=te^{i\\theta}}{\\theta=\\theta_o}}\\\\\n    & ILT & \\\\\n\\underbrace{g(t|\\theta_o):\\mathbb{R}^+\\to \\mathbb{C}}_{SK\\ simulated\\ data} & \\xleftarrow{\\hspace{2cm}} & \n\\underbrace{F(\\kappa=te^{i\\theta_o}):\\mathbb{C}\\to \\mathbb{C}}_{kimesurface\\ leaf}  \\\\\n\\end{array}$$\n\nSee the [TCIU *manifold foliation* notes](https://www.socr.umich.edu/TCIU/HTMLs/Chapter2_ComplexWavefunctions_ComplexTime.html#1_Manifold_Foliation).",
      "word_count": 500
    },
    {
      "title": "ILT of the explicit definition of the kimesurface function $F(z)=\\mathcal{L}(\\sin)(z)$",
      "content": "Next, we will compare the original time-signal $f(t)=\\sin(t)$ against a spline-smoothed $f_1(t)=\\mathcal{L}^{-1}(\\mathcal{L}(\\sin))(t)$ over the range $t\\in [0 : 2\\pi]$.",
      "word_count": 19
    },
    {
      "title": "Compare the analytical and discrete Laplace transforms",
      "content": "Using the function $f(t)=\\sin(t)$ and its closed-form LT, \n$F(z)=\\mathcal{L}(f)(z)=\\frac{1}{z^2 + 1}$, we will compare the analytical and \ndiscrete kime-surface reconstructions.\n\n\nIn these 3D displays, we intentionally offset vertically the two kimesurfaces to illustrate their identical geometric, topological, and shape characteristics. This validates that the theoretical and the pragmatic implementation of the Laplace Transform agree on the example function, $f(t)=sin(t)$.",
      "word_count": 59
    },
    {
      "title": "Compare the analytical and discrete Inverse Laplace Transforms",
      "content": "We can also similarly validate the agreement between the exact (continuous) theoretical and the approximate (discrete) Inverse Laplace Transforms using the kimesurface, $F(z)=\\mathcal{L}(f)(z)=\\frac{1}{z^2 + 1}$, corresponding to the original function $f(t)=sin(t)$.",
      "word_count": 31
    },
    {
      "title": "fMRI example",
      "content": "Let's demonstrate the Laplace dual of a single time-series representing the real-valued intensity of a functional magnetic resonance imaging (fMRI) data at a fixed spatial location (single voxel in the brain). The entire fMRI data is a 4D hypervolume with intensities encoding the blood oxygenation level dependence at a specific spacetime location $(x,y,z,t)$. For simplicity, we are only focusing on one fixed spatial voxel location $(x_o,y_o,z_o)$. Start by loading and plotting the original fMRI data, $f_{(x_o,y_o,z_o)}(t)$.\n\nAs the fMRI series is extremely noisy (almost nowhere differentiable), we need to apply preprocess filtering (smoothing) to ensure the LT is well-defined, i.e., the fMRI time-series is integrable against the exponential kernel.  \n\n## Load the fMRI data\n\n\n## Compute the LT $\\mathcal{L}(fMRI)(z)$\n\nNext, we will compute and display in 3D the Laplace-dual, $F_{(x_o,y_o,z_o)}(z)=\\mathcal{L}(f_{(x_o,y_o,z_o)}(z)$ and display the kimesurface as a complex-valued, complex-time, analytic (holomorphic) function.\n\n*Warning*: This $\\mathcal{L}(fMRI)(z)$ kimesurface calculation is intensive. To ensure near-real-time computation, below we only show a low-resolution $49\\times49$ kimesurface representation where the kime-manifold height and color represent the kimesurface magnitude and phase, respectively.\n\n\n\n## Regularize the fMRI Kimesurface\n\nRecall the earlier discussion of the *inverse stereographic projection* mapping. \nIn this case, it is applied to the values in the range of the fMRI Laplace transform.\n\n\n\n## Invert the LT $\\mathcal{L}^{-1}(\\mathcal{L}(fMRI))(t)$\n\nFinally, we can invert the fMRI kimesurface back in the time-domain and compare it to the original fMRI time-series.\n\n\nThe observed discrepancy between the smoothed original fMRI time-series and the raw and smoothed reconstructions, ILT(LT(fMRI)), is due to the over-simplified coarse representation of the kimesurface and the discrete transform approximation to the continuous Laplace transform (forward and inverse).\n\nThis example illustrates the foundation of [spacekime analytics](https://spacekime.org/), where we derive statistical inference by lifting the observed time-series into kime-surfaces, which contain additional geometric and topological information that can then be modeled, interrogated, and analyzed to obtain robust prediction or forecasting.\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 405
    }
  ],
  "tables": [
    {
      "section": "- \\usepackage{tikzcd}",
      "content": "    code_folding: hide\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "- \\usepackage{tikzcd}",
      "code": "knitr::opts_chunk$set(echo = TRUE, warings = FALSE)\nlibrary(pracma)\nlibrary(cubature)\nlibrary(plotly)\nlibrary(ggplot2)\nlibrary(doParallel)\nlibrary(TCIU)\nlibrary(EBImage)\nlibrary(brainR)\nlibrary(spatstat)\n# number of cores for parallel computing\nncor = 8 ",
      "line_count": 12
    },
    {
      "section": "*Discrete* Forward Laplace Transforms",
      "code": "### 2. Tests the LT\nz= 1+1i # Complex-domain value\nf <- function(t) { t }  # test function, F(z)=L(f)(z)=1/z^2\nLT(f, z); 1/z^2\nf <- function(t) { exp(-5*t) }  # test function, F(z)=L(f)(z)=1/(z+5)\nLT(f, z); 1/(z+5)",
      "line_count": 6
    },
    {
      "section": "Discrete Inverse Laplace Transform",
      "code": "################ Cartesian to Polar Coordinate Transform ##############################################\n#' Cartesian to Polar Coordinate Transform\n#' @title Cartesian to Polar Coordinate Transform\n#' @description In r.xy Returns polar coordinate r from a pair of Cartesian coordinates (x, y)\n#' @param x x co-ordinate\n#' @param y y co-ordinate\n#' @return r or phi respectively from x and y\nr.xy <- function(x, y){\n  return(sqrt(x^2 + y^2))\n}\n\n#' @description In r.xy Returns polar coordinate phi from a pair of Cartesian coordinates (x, y).\nphi.xy <- function(x, y){\n  return(atan2(y, x)) \n}\n\n################ Polar to Cartesian Coordinate Transform ##############################################\n#' Polar to Cartesian Coordinate Transform\n#' @title Polar to Cartesian Coordinate Transform\n#' @description In x.rphi Returns cartesian coordinate x from a pair of polar coordinates (r, phi)\n#'\n#' @param r distance from origin (Time)\n#' @param phi phase\n#' @return x or y respectively from r and phi\nx.rphi <- function(r, phi){\n  return(r*cos(phi))\n}\n\n#' @description In y.rphi turns cartesian coordinate y from a pair of polar coordinates (r, phi)\ny.rphi <- function(r, phi){\n  return(r*sin(phi))\n}",
      "line_count": 32
    },
    {
      "section": "Discrete Inverse Laplace Transform",
      "code": "################## Optimum contour path in Complex plane (needed for ILT) ##########################\n# Uses Evans, Chung (2000) method\n#'\n#' @title Optimum Contour Path\n#' @description The optimum contour path in polar coordinates (r,phi)\n#'\n#' @param phi phi (polar phase) value\n#' @param m contour width; small values may lead to singularities on negative x-axis; \n#' large values may lead to instabilities on the positive x-axis\n#' @param t time (R^+ domain) variable, interdependent with the contour width, m\n#'\n#' @references Evans, Chung, 2000: Laplace transform inversions using optimal contours \n#' in the complex plane, International Journal of Computer Mathematics, v73, pp 531-543.\n#'\noptimContour <- function(phi, m=1, t=5){\n  if(identical(t, 0)){ t <- 5 } # reset t=0 to avoid singularities\n  return(m*phi/(t*sin(phi)))\n}\n\n#' Numerical derivative of contour path length with respect to phi\n#' return(((m*phi/(t*sin(phi)))^2 + (1/sin(phi) - phi/(tan(phi)*sin(phi)))^2)^0.5) \n#' s as magnitude: real\n#' s as dx and dy components: complex\n#' @param phi phi (polar phase) value\n#' @param m contour width; small values may lead to singularities on negative x-axis; \n#' large values may lead to instabilities on the positive x-axis\n#' @param t time value\nanalyticalPathDerivative <- function(phi, m=1, t=5) {\n  if(identical(t, 0)) { t <- 100 } # reset t = 0 to avoid singularities\n  if(identical(phi, 0)) { dx_dphi <- 0 } # avoid small phi value singularities\n  else{ dx_dphi <- (m/t)*((sin(phi) - phi*cos(phi))*cos(phi)/(sin(phi))^2 - phi) }\n  dy_dphi <- (m/t) \n  return( complex(real=dx_dphi, imaginary = dy_dphi) )\n}\n\n#' @title Bromwich contour path\n#' @description Bromwich contour path - a straight vertical line through x=gamma\n#' @param phi phi (polar phase) value\n#' @param gamma value on the positive x-axis for the vertical line representing the contour\n#' @param t time value\nbromwichContour = function(phi, gamma = 0.5) {\n  return(gamma/cos(phi))\n}\n\n#' Numerical derivative of Bromwich contour\n#' @param phi phi (polar phase) value\n#' @param gamma value on the positive x-axis for the vertical line representing the contour\nbromwichPathDerivative=function (phi, gamma = 0.5) {\n  return((0+1i) * (bromwichContour(phi, gamma)^2 + (gamma * tan(phi)/cos(phi))^2)^0.5)\n}",
      "line_count": 50
    },
    {
      "section": "Discrete Inverse Laplace Transform",
      "code": "# Tests the ILT\nt = 1/5 # R-domain value\nf <- function(z) { 1/(z^2) }  # test function, F(z)=L(f)(z)=1/z^2 ==> f(t)=t\nILT(f, t); t\nf <- function(z) { 1/(z+5) }  # test function, F(z)=L(f)(z)=1/(z+5) ==> f(t)=e^-{5t}\nILT(f, t); exp(-5*t)",
      "line_count": 6
    },
    {
      "section": "Regularizing Kimesurfaces by Stereographic Projection of the Laplace Transform",
      "code": "circle_seg <- function(from, to,scaling){\n  by <- (to-from)/4\n  t <- seq(from*pi/180, to*pi/180 , by*pi/180)\n  x0 <- 0\n  y0 <- 0\n  r <- 0.1*scaling\n  x <- x0 + r*cos(t)\n  y<- y0 + r*sin(t)\n  lists <- list(x, y)\n  return (lists)\n}",
      "line_count": 11
    },
    {
      "section": "Regularizing Kimesurfaces by Stereographic Projection of the Laplace Transform",
      "code": "# set up the circle segment\n#return five point to interpolate the circle segment \n#from: starting phase, to: ending phase\nscaling <- 3\nlista <- circle_seg(-90,37,3)\nlistb <- circle_seg(0,37,3)\nlistc <- circle_seg(90,37,3)\nlistd <- circle_seg(-90,-53,3)\nliste <- circle_seg(0,-53,3)\nlistf <- circle_seg(90,-53,3)\nwidth=780\nheight=400\n\nlibrary(plotly)\nx <- c(0,2,0.8,0.4,0)\ny <- c(0,0,0.6,0.8,1)\nxp <- c(0,0,0.3,1/3,0.6)\nyp <- c(0,1,0.1,0,-0.8)\ndata <- data.frame(x, y)\nt <- list(family = \"Arial\",  size = 14, color = toRGB(\"grey50\"))\n\nfig1 <- plot_ly(data, x = ~x, y = ~y, type = 'scatter', mode = 'lines',\n               text = c(\"A\",\"B\",\"D\",\"E\",\"N\"),width=width,height=height)\nfig1 <- fig1 %>% add_markers() %>% \n  add_text(textfont = t, textposition = \"top right\") %>% \n  add_lines(y = c(0,0.6), x = c(0,0.8), line = list(color = \"grey\"),\n    inherit = FALSE, showlegend = FALSE) %>% \n  add_lines(y = c(0,0.8), x = c(0,0.4), line = list(color = \"grey\", dash='dot'),\n    inherit = FALSE, showlegend = FALSE) %>% \n  add_trace(y = c(0.6), x = c(0.8), mode = \"c\",\n            text = c(\"D\"), textposition = \"top right\") %>% \n  add_trace( x=lista[[1]], y = lista[[2]], line = list(shape = \"spline\",color = '#e763fa'),mode=\"lines\") %>% \n  #set up the triangle\n  add_trace(\n   x = c(0.07986,0.07986,0.07986,0.08986,0.09986)*scaling-0.01,\n    y = c(0.04,0.05,0.06,0.06,0.06)*scaling-0.01,\n    fill = 'toself',\n    fillcolor = '#e763fa',\n    line = list(\n      color = '#e763fa'\n    ),\n    text = \"Points only\",\n    mode=\"lines\"\n  )%>% \n  add_annotations(x=c(0.4),y=c(-0.2),text=TeX(\"\\\\varphi\"),showarrow=FALSE,font=list(size=24)) %>%\n  layout(xaxis= list(showticklabels = FALSE, title=\"R\", range=c(-1.1,2.2)),\n         yaxis = list(title=\"\", range=c(-1.2,1.2)), showlegend = FALSE,\n         scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1)),\n         shapes = list(list(type = 'circle', name=\"Sphere cross-section\",\n                     xref = 'x', x0 = -1, x1 = 1, yref = 'y', y0 =  -1, y1 = 1,\n                     line = list(color = 'blue')))) %>% config(mathjax = \"cdn\")\n\nfig2 <- plot_ly(data, x = ~x, y = ~y, type = 'scatter', mode = 'lines',\n               text = c(\"A\",\"B\",\"D\",\"E\",\"N\"),width=width,height=height)\nfig2 <- fig2 %>% add_markers() %>% \n  add_text(textfont = t, textposition = \"top right\") %>% \n  add_lines(y = c(0,0.6), x = c(0,0.8), line = list(color = \"grey\"),\n    inherit = FALSE, showlegend = FALSE) %>% \n  add_lines(y = c(0,0.8), x = c(0,0.4), line = list(color = \"grey\", dash='dot'),\n    inherit = FALSE, showlegend = FALSE) %>% \n  add_trace(y = c(0.6), x = c(0.8), mode = \"c\",\n            text = c(\"D\"), textposition = \"top right\") %>% \n  add_trace( x=~listb[[1]], y = ~listb[[2]], line = list(shape = \"spline\",color = '#e763fa'),mode=\"lines\") %>% \n  #set up the triangle\n  add_trace(\n    x = c(0.07986,0.07986,0.07986,0.08986,0.09986)*scaling-0.01,\n    y = c(0.04,0.05,0.06,0.06,0.06)*scaling-0.01,\n    fill = 'toself',\n    fillcolor = '#e763fa',\n    line = list(\n      color = '#e763fa'\n    ),\n    text = \"Points only\",\n    mode=\"lines\"\n  )%>% \n  add_annotations(x=c(0.5),y=c(0.15),text=TeX(\"\\\\varphi '\"),showarrow=FALSE,font=list(size=24)) %>%\n  layout(xaxis= list(showticklabels = FALSE, title=\"R\", range=c(-1.1,2.2)),\n         yaxis = list(title=\"\", range=c(-1.2,1.2)), showlegend = FALSE,\n         scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1)),\n         shapes = list(list(type = 'circle', name=\"Sphere cross-section\",\n                     xref = 'x', x0 = -1, x1 = 1, yref = 'y', y0 =  -1, y1 = 1,\n                     line = list(color = 'blue')))) %>% config(mathjax = \"cdn\")\n\nfig3 <- plot_ly(data, x = ~x, y = ~y, type = 'scatter', mode = 'lines',\n               text = c(\"A\",\"B\",\"D\",\"E\",\"N\"),width=width,height=height)\nfig3 <- fig3 %>% add_markers() %>% \n  add_text(textfont = t, textposition = \"top right\") %>% \n  add_lines(y = c(0,0.6), x = c(0,0.8), line = list(color = \"grey\"),\n    inherit = FALSE, showlegend = FALSE) %>% \n  add_lines(y = c(0,0.8), x = c(0,0.4), line = list(color = \"grey\", dash='dot'),\n    inherit = FALSE, showlegend = FALSE) %>% \n  add_trace(y = c(0.6), x = c(0.8), mode = \"c\",\n            text = c(\"D\"), textposition = \"top right\") %>% \n  add_trace( x=~listc[[1]], y = ~listc[[2]], line = list(shape = \"spline\",color = '#e763fa'),mode=\"lines\") %>% \n  #set up the triangle\n  add_trace(\n    x = c(0.07986,0.07986,0.07986,0.06986,0.05986)*scaling,\n    y = c(0.08,0.07,0.06,0.06,0.06)*scaling,\n    fill = 'toself',\n    fillcolor = '#e763fa',\n    line = list(\n      color = '#e763fa'\n    ),\n    text = \"Points only\",\n    mode=\"lines\"\n  )%>% \n  add_annotations(x=c(0.2),y=c(0.4),text=TeX(\"\\\\varphi ''\"),showarrow=FALSE,font=list(size=24)) %>%\n  layout(xaxis= list(showticklabels = FALSE, title=\"R\", range=c(-1.1,2.2)),\n         yaxis = list(title=\"\", range=c(-1.2,1.2)), showlegend = FALSE,\n         scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1)),\n         shapes = list(list(type = 'circle', name=\"Sphere cross-section\",\n                     xref = 'x', x0 = -1, x1 = 1, yref = 'y', y0 =  -1, y1 = 1,\n                     line = list(color = 'blue')))) %>% config(mathjax = \"cdn\")\n\ndata <- data.frame(xp, yp)\nt <- list(family = \"Arial\",  size = 14, color = toRGB(\"grey50\"))\n\nfig4 <- plot_ly(data, x = ~xp, y = ~yp, type = 'scatter', mode = 'lines',\n               text = c(\"A\",\"N\",\"E\",\"B\",\"D\"),width=width,height=height)\nfig4 <- fig4 %>% add_markers() %>% \n  add_text(textfont = t, textposition = \"top right\") %>% \n  add_lines(y = c(0,-0.8), x = c(0,0.6), line = list(color = \"grey\"),\n    inherit = FALSE, showlegend = FALSE) %>% \n  add_lines(y = c(0,0.1), x = c(0,0.3), line = list(color = \"grey\", dash='dot'),\n    inherit = FALSE, showlegend = FALSE) %>%\n  add_trace( x=listd[[1]], y = listd[[2]], line = list(shape = \"spline\",color = '#e763fa'),mode=\"lines\") %>% \n  #set up the triangle\n  add_trace(\n   x = c(0.181,0.135,0.09,0.16,0.17),\n    y = c(-0.24,-0.245,-0.25,-0.3,-0.27),\n    fill = 'toself',\n    fillcolor = '#e763fa',\n    line = list(\n      color = '#e763fa'\n    ),\n    text = \"Points only\",\n    mode=\"lines\"\n  )%>% \n  add_annotations(x=c(0.1),y=c(-0.4),text=TeX(\"\\\\varphi\"),showarrow=FALSE,font=list(size=24)) %>%\n  layout(xaxis= list(showticklabels = FALSE, title=\"R\", range=c(-1.1,2.2)),\n         yaxis = list(title=\"\", range=c(-1.2,1.2)), showlegend = FALSE,\n         scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1)),\n         shapes = list(list(type = 'circle', name=\"Sphere cross-section\",\n                     xref = 'x', x0 = -1, x1 = 1, yref = 'y', y0 =  -1, y1 = 1,\n                     line = list(color = 'blue'))))%>% config(mathjax = \"cdn\")\n\nfig5 <- plot_ly(data, x = ~xp, y = ~yp, type = 'scatter', mode = 'lines',\n               text = c(\"A\",\"N\",\"E\",\"B\",\"D\"),width=width,height=height)\nfig5 <- fig5 %>% add_markers() %>% \n  add_text(textfont = t, textposition = \"top right\") %>% \n  add_lines(y = c(0,-0.8), x = c(0,0.6), line = list(color = \"grey\"),\n    inherit = FALSE, showlegend = FALSE) %>% \n  add_lines(y = c(0,0.1), x = c(0,0.3), line = list(color = \"grey\", dash='dot'),\n    inherit = FALSE, showlegend = FALSE) %>% \n  add_trace( x=liste[[1]], y = liste[[2]], line = list(shape = \"spline\",color = '#e763fa'),mode=\"lines\") %>% \n  #set up the triangle\n  add_trace(\n   x = c(0.181,0.231,0.281,0.181,0.181),\n    y = c(-0.24,-0.24,-0.24,-0.19,-0.14),\n    fill = 'toself',\n    fillcolor = '#e763fa',\n    line = list(\n      color = '#e763fa'\n    ),\n    text = \"Points only\",\n    mode=\"lines\"\n  )%>% \n  add_annotations(x=c(0.4),y=c(-0.2),text=TeX(\"\\\\varphi'\"),showarrow=FALSE,font=list(size=24)) %>%\n  layout(xaxis= list(showticklabels = FALSE, title=\"R\", range=c(-1.1,2.2)),\n         yaxis = list(title=\"\", range=c(-1.2,1.2)), showlegend = FALSE,\n         scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1)),\n         shapes = list(list(type = 'circle', name=\"Sphere cross-section\",\n                     xref = 'x', x0 = -1, x1 = 1, yref = 'y', y0 =  -1, y1 = 1,\n                     line = list(color = 'blue')))) %>% config(mathjax = \"cdn\")\n\nfig6 <- plot_ly(data, x = ~xp, y = ~yp, type = 'scatter', mode = 'lines',\n               text = c(\"A\",\"N\",\"E\",\"B\",\"D\"),width=width,height=height)\nfig6 <- fig6 %>% add_markers() %>% \n  add_text(textfont = t, textposition = \"top right\") %>% \n  add_lines(y = c(0,-0.8), x = c(0,0.6), line = list(color = \"grey\"),\n    inherit = FALSE, showlegend = FALSE) %>% \n  add_lines(y = c(0,0.1), x = c(0,0.3), line = list(color = \"grey\", dash='dot'),\n    inherit = FALSE, showlegend = FALSE) %>% \n  add_trace( x=listf[[1]], y = listf[[2]], line = list(shape = \"spline\",color = '#e763fa'),mode=\"lines\") %>% \n  #set up the triangle\n  add_trace(\n   x = c(0.181,0.231,0.281,0.181,0.181),\n    y = c(-0.24,-0.24,-0.24,-0.19,-0.14),\n    fill = 'toself',\n    fillcolor = '#e763fa',\n    line = list(\n      color = '#e763fa'\n    ),\n    text = \"Points only\",\n    mode=\"lines\"\n  )%>% \n  add_annotations(x=c(0.4),y=c(-0.2),text=TeX(\"\\\\varphi''\"),showarrow=FALSE,font=list(size=24)) %>%\n  layout(xaxis= list(showticklabels = FALSE, title=\"R\", range=c(-1.1,2.2)),\n         yaxis = list(title=\"\", range=c(-1.2,1.2)), showlegend = FALSE,\n         scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1)),\n         shapes = list(list(type = 'circle', name=\"Sphere cross-section\",\n                     xref = 'x', x0 = -1, x1 = 1, yref = 'y', y0 =  -1, y1 = 1,\n                     line = list(color = 'blue'))))%>% config(mathjax = \"cdn\")\n\nfig <- subplot(fig1,fig2,fig3,fig4,fig5,fig6,nrows=2) %>% config(mathjax = \"cdn\") %>%\n  layout(annotations = list(\n    list(x = 0.1 , y = 1.05, text = TeX(\"A1:\\ \\\\varphi\\\\in (0,\\\\pi)\"), \n         showarrow = F, xref='paper', yref='paper'),\n    list(x = 0.5 , y = 1.05, text = TeX(\"A2:\\ \\\\varphi'\\\\in (-\\\\frac{\\\\pi}{2},\\\\frac{\\\\pi}{2})\"), \n         showarrow = F, xref='paper', yref='paper'),\n    list(x = 0.9 , y = 1.05, text = TeX(\"A3:\\ \\\\varphi''\\\\in (0,\\\\pi)\"), \n         showarrow = F, xref='paper', yref='paper')))\nfig",
      "line_count": 213
    },
    {
      "section": "Regularizing Kimesurfaces by Stereographic Projection of the Laplace Transform",
      "code": "# generate the DF with lines\nrangeX <- rangeY <- 5  # x-axis range for animation\nlen <- 20              # number of animation frames\nt <- seq(from=-rangeX, to=rangeX, length.out = len) # equidistance P1x coordinates\n\n# Define the projection point P1\nP1x <- t; P1y <- 0\n\n# define the *corresponding* point on the circle/sphere\nPx <- (2*P1x)/(1+P1x^2+P1y^2)\nPy <- (-1+P1x^2 + P1y^2)/(1+P1x^2 + P1y^2)\nlineX <- P1x\nlineY <- rep(P1y, len)\nfor (i in 1:length(P1x)) {\n  if (abs(P1x[i]) < 1) {\n    lineX[i] <- Px[i]\n    lineY[i] <- Py[i]\n  }\n}\ndf <- data.frame(Nx=0, Ny=1, P1x=P1x, P1y=P1y, Px=Px, Py=Py, \n                 lineX=lineX, lineY=lineY, frame=c(1:length(P1x))) \n\n# render the animation\nlibrary(plotly)\ndf %>% plot_ly(x=~Px, y = ~Py, frame=~frame, type='scatter', name=\"3D Point on Sphere\",\n               mode='lines+markers', marker=list(color='green', size=15), showlegend=F) %>%\n  add_segments(x = ~Nx, y = ~Ny, xend = ~lineX[frame], yend = ~lineY[frame], \n               showlegend = F, name=\"stereographic map\") %>%\n  add_trace(x = ~P1x, y = ~P1y, frame=~frame, showlegend = F,\n               marker=list(color='red', size=15), name=\"2D Projection\") %>%\n  layout(title=\"Bijective Stereographic Projection Map\",\n    shapes = list(list(type = 'circle', name=\"Sphere cross-section\",\n                     xref = 'x', x0 = -1, x1 = 1, yref = 'y', y0 =  -1, y1 = 1,\n                     line = list(color = 'blue'))),\n          xaxis = list(title=\"Axial plane (X,Y)\", range=c(-rangeX,rangeX)), \n          yaxis = list(title=\"Azimuthal Axis (Z)\", range=c(-rangeY,rangeY)))",
      "line_count": 36
    },
    {
      "section": "Laplace Transform Applications",
      "code": "\n### Analytical-Model-based ILT: F(z) =  1/(z+1) + (1/(z^2 + 1))*(z/(z^2 + 1)) + 1/(z^2)\nfMRI_Kimesurface <- function (z) {\n  return ( 1/(z+1) + (1/(z^2 + 1))*(z/(z^2 + 1)) + 1/(z^2) )  # F(z)\n}\n\n# Test F=fMRI_kimesurface\n# fMRI_Kimesurface(0.5+ 0.5i) \n\n######### Display the actual kimesurface: F(z)\nx2 <- seq(from = -2, to = 2, length.out = 200)\ny2 <- seq(from = -2, to = 2, length.out = 200)\nz2_grid = array(complex(), dim=c(length(x2), length(y2)))\n\nfor (i in 1:dim(z2_grid)[1]) {\n  for (j in 1:dim(z2_grid)[2]) {\n    z2_grid[i,j] = fMRI_Kimesurface(complex(real=x2[i], imaginary = y2[j]))\n  }\n}\n\nimage(Im(z2_grid), axes=FALSE); contour(Im(z2_grid), add=T, col=\"red\", lwd=2, drawlabels=FALSE, axes=FALSE);\ncontour(Re(z2_grid), add=T, col=\"blue\", lwd=2, drawlabels=F, \n        main = \"Im(f) Image with Re(f) and Im(f) Contours in red and blue\", axes=F); \ntitle(\"Re(f) Image with Re(f) and Im(f) Contours in red and blue\", font = 5)",
      "line_count": 24
    },
    {
      "section": "Laplace Transform Applications",
      "code": "# Surface height= Re(fMRI_Kimesurface); Surface color = Im(fMRI_Kimesurface)\nz3 <- Im(z2_grid)\nsurf_color <- z3\nfor (i in 1:dim(z2_grid)[1]) {\n  for (j in 1:dim(z2_grid)[2]) {\n    if (z3[i,j]>0)  surf_color[i,j] <- min(z3[i,j], 5)\n    else surf_color[i,j] <- max(z3[i,j], -5)\n  }\n}\n\ncolorscale = cbind(seq(0, 1, by=1/(length(x2) - 1)), rainbow(length(x2)))\n\np <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(z = Re(z2_grid),   # z = Im(z2_grid),  # Real or Imaginary part of f(t)\n              surfacecolor=surf_color, colorscale=colorscale,   #Phase-based color\n              type = 'surface', opacity=1, visible=T #,\n              # contour=list(x = list(highlight = FALSE),\n              #              y = list(highlight = FALSE),\n              #              z = list( highlight = TRUE, highlightcolor = \"blue\"),\n              #              color=\"#000\", width=15, lwd=10,\n              #              opacity=1.0, hoverinfo=\"none\")\n              ) %>%\n    layout(title = \n           paste0(\"Kime-Surface, Height=Re(F), Color=Im(F) \\n\", \n           \"F=LT(f)=1/(z+1) + (1/(z^2 + 1))*(z/(z^2 + 1)) + 1/(z^2)\"), \n           showlegend = FALSE,\n           scene = list(aspectmode = \"manual\", zaxis = list(range = c(-5,5)),\n                        aspectratio = list(x=1, y=1, z=0.5)) #,\n                        # xaxis = list(range = c(min(x2), max(x2))), \n                        # yaxis = list(range = c(min(x2), max(x2)))\n              # )\n          ) # 1:1:1 aspect ratio\np",
      "line_count": 33
    },
    {
      "section": "Laplace Transform Applications",
      "code": "magnitude <- sqrt((Re(z2_grid))^2+(Im(z2_grid))^2)\nx5 <- Re(z2_grid); y5 <- Im(z2_grid)\nphase <- atan2(y5,x5)\nsurf_color <- phase\nfor (i in 1:200) {\n  for (j in 1:200) {\n    if (phase[i,j]>0)  surf_color[i,j] <- min(phase[i,j], 5)\n    else surf_color[i,j] <- max(phase[i,j], -5)\n  }\n}\n\ncolorscale = cbind(seq(0, 1, by=1/(length(x2) - 1)), rainbow(length(x2)))\n\np <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(z = magnitude,   # z = Magnitude\n              surfacecolor=surf_color, colorscale=colorscale,   #Phase-based color\n              type = 'surface', opacity=1, visible=T,\n              contour=list(x = list(highlight = FALSE),\n                           y = list(highlight = FALSE),\n                           z = list( highlight = TRUE, highlightcolor = \"blue\"),\n                           color=\"#000\", width=15, lwd=10,\n                           opacity=1.0, hoverinfo=\"none\")\n              ) %>%\n    layout(title = \n             paste0(\"Kime-Surface, Height=Magnitude(F), Color=Phase(F) \\n\", \n                    \"F=LT(f)=1/(z+1) + (1/(z^2 + 1))*(z/(z^2 + 1)) + 1/(z^2)\"), \n           showlegend = FALSE,\n           scene = list(aspectmode = \"manual\",\n                            aspectratio = list(x=1, y=1, z=0.5),\n                            zaxis = list(range = c(-2,5))\n              )\n          ) # 1:1:1 aspect ratio\np",
      "line_count": 33
    },
    {
      "section": "Laplace Transform Applications",
      "code": "# regularize  kimesurface by computing the Stereographic Projection of the LT\n# generate the DF with lines\nmagnitude <- sqrt((Re(z2_grid))^2+(Im(z2_grid))^2)\nx5 <- Re(z2_grid); y5 <- Im(z2_grid)\nphase <- atan2(y5,x5)\n\n# spherical coordinates   str(phi1); str(theta1)  #  num [1:200, 1:200]\nphi1 <- 2*atan2(1, magnitude)  # zenith\ntheta1 <- phase                # azimuth\n\n# simple 2D plots of the zenith and azimuth values of the regularized LT\n# Mind the tempering of the LT -- no singularities!\n#image(phi1); hist(phi1)   # Zenith\nplot_ly(z=~phi1, type=\"heatmap\") %>% \n  layout(title=\"Heatmap of Zenith Angle (phi)\") %>% hide_colorbar()\nplot_ly(x=~as.vector(phi1), type = \"histogram\", name = \"Zenith Angle\", \n        histnorm = \"probability\") %>%    \n    # add_trace(x =~fit$x, y =~5*fit$y, type = \"scatter\", mode = \"lines\", opacity=0.1,    \n    #           fill = \"tozeroy\", name = \"Normal Density\") %>%    \n    layout(title='Zenith Angle Histogram',   \n           xaxis = list(title = \"Zenith\"), \n           yaxis = list(title = \"relative frequency/density\"),  \n           legend = list(orientation = 'h'))    \n\n#  image(theta1); hist(theta1)  # Azimuth; mind the symmetry in [-\\pi, \\pi]\nplot_ly(z=~theta1, type=\"heatmap\") %>% \n  layout(title=\"Heatmap of Azimuth Angle (theta)\") %>% hide_colorbar()\nplot_ly(x=~as.vector(theta1), type = \"histogram\", name = \"Azimuth Angle\", \n        histnorm = \"probability\") %>%    \n    # add_trace(x =~fit$x, y =~5*fit$y, type = \"scatter\", mode = \"lines\", opacity=0.1,    \n    #           fill = \"tozeroy\", name = \"Normal Density\") %>%    \n    layout(title='Azimuth Angle Histogram',   \n           xaxis = list(title = \"Azimuth\"), \n           yaxis = list(title = \"relative frequency/density\"),  \n           legend = list(orientation = 'h'))    \n\n# Spherical to Cartesian coordinate mapping\n\n# plot the regularized kimesurface\nsurf_color <- theta1  # azimuth\nx2new <- seq(from = -pi, to = pi, length.out = 200)\n\ncolorscale = cbind(seq(0, 1, by=1/(length(x2new) - 1)), rainbow(length(x2new)))\n\np <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(z = phi1,   # z = zenith\n              surfacecolor=surf_color, colorscale=colorscale, #Phase-based color (azimuth)\n              type = 'surface', opacity=1, visible=T #,\n              # contour=list(x = list(highlight = FALSE),\n              #              y = list(highlight = FALSE),\n              #              z = list( highlight = TRUE, highlightcolor = \"blue\"),\n              #              color=\"#000\", width=15, lwd=10,\n              #              opacity=1.0, hoverinfo=\"none\")\n              ) %>%\n    layout(title = \n             paste0(\"Regularized Kime-Surface (LT)\\n Height=Zenith(F), Color=Azimuth(F) \\n\", \n                    \"F=LT(f)=1/(z+1) + (1/(z^2 + 1))*(z/(z^2 + 1)) + 1/(z^2)\"), \n           showlegend = FALSE,\n           scene = list(aspectmode = \"manual\",\n                            aspectratio = list(x=1, y=1, z=0.5),\n                            zaxis = list(range = c(-2,5))\n              )\n          ) # 1:1:1 aspect ratio\np",
      "line_count": 64
    },
    {
      "section": "Laplace Transform Applications",
      "code": "##### f(t): 1D version #############################################\ntime_points <- seq(0+0.001, 2*pi, length.out = 160)\n\n# Apply ILT to recover f=ILT(F) and evaluate f(time_points)\n# using parallel computing to improve coding speed\ncl <- makeCluster(4)\nregisterDoParallel(cl)\nf_result <- foreach(t=1:length(time_points))  %dopar% { \n  TCIU::ILT(FUNCT=fMRI_Kimesurface, t=time_points[t], \n      nterms = 31L, m = 1, fail_val = complex(1))\n}\nstopCluster(cl)\nf <- array(complex(1), dim = length(time_points)) # length(f)\nf[1:length(f)] = unlist(f_result)\n\n\n# Convert f=ILT(F) to a data-frame for ggplot\nfMRI_time_Intensities_ILT_df <- as.data.frame(cbind(Re=Re(f),Im=Im(f),time_points=time_points))\n# ggplot(fMRI_time_Intensities_ILT_df, aes(x=Re(time_points))) + \n#   geom_line(aes(y = Im, colour=\"Imaginary\"), lwd=3)+\n#   geom_line(aes(y = Re, colour = \"Real\"), lwd=3) +\n#   scale_color_manual(\"Index\",\n#                      breaks=c(\"Imaginary\", \"Real\"),\n#                      values = c(\"steelblue\", \"darkred\")) +\n#   xlab(\"Time\") + ylab(\"fMRI Image Intensities (f)\") + \n#   # ggtitle(\"Real (Re) and Imaginary (Im) parts \\n of the original fMRI Time-series, f=ILT(F)\") +\n#   labs(title = \n#          \"ILT Reconstructed fMRI Time-series, f=ILT(F)\") +\n#   scale_y_continuous() +\n#   theme_grey(base_size = 16) +\n#   theme(legend.title = element_text(size=14, color = \"black\", face=\"bold\"),\n#         panel.grid.minor.y = element_blank(),\n#         panel.grid.major.y = element_blank(),\n#         plot.title = element_text(hjust = 0.5))\n\nplot_ly(fMRI_time_Intensities_ILT_df, x=~Re(time_points), y=~Im, \n        type=\"scatter\", mode=\"lines\", name=\"Imaginary\") %>%\n  add_trace(x=~Re(time_points), y=~Re, type=\"scatter\", mode=\"lines\", \n        name=\"Real\") %>%\n  layout(title=\"ILT Reconstructed fMRI Time-series, f=ILT(F)\", \n         legend = list(orientation = 'h'),\n         xaxis=list(title=\"Time\"), yaxis=list(title=\"fMRI Image Intensities (f)\"))",
      "line_count": 42
    },
    {
      "section": "Laplace Transform Applications",
      "code": "### F(z)= ABS(z) ==>  f(t) ~= -1/t\nF <- function (z) {\n  return (abs(z))\n}\n\nneg_reciprocal <- array(complex(1), dim = length(time_points));\nfor (t in 1:length(time_points)) {\n  neg_reciprocal[t] <- ILT(FUNCT=F, t=time_points[t], nterms = 31L, m = 1, fail_val = complex(1))\n}\n\n# Convert f=ILT(F) to a data-frame for ggplot\nfMRI_time_Intensities_ILT_df <- as.data.frame(cbind(Re=Re(neg_reciprocal),\n                                                    Im=Im(neg_reciprocal),time_points=time_points))\n# ggplot(fMRI_time_Intensities_ILT_df, aes(x=time_points), ylim=c(-10,10)) + \n#   geom_line(aes(y = Im, color=\"Imaginary\"), linetype=1, lwd=3)+\n#   geom_line(aes(y = Re, color = \"Real\"), lwd=2) + \n#   ggtitle(\"Original Time-series, f=ILT(F), F=|z|\") +\n#   xlab(\"Time\") + ylab(\"Intensities (f)\") +\n#   scale_color_manual(name=\"Index\",\n#                      breaks=c(\"Imaginary\", \"Real\"),\n#                      values = c(\"steelblue\", \"darkred\"))+\n#   scale_y_continuous(limits = c(-5, 1)) +\n#   theme_grey(base_size = 16) +\n#   theme(legend.title = element_text(size=14, color = \"black\", face=\"bold\"),\n#         panel.grid.minor.y = element_blank(),\n#         panel.grid.major.y = element_blank(),\n#         plot.title = element_text(hjust = 0.5))\n\nplot_ly(fMRI_time_Intensities_ILT_df, x=~time_points, y=~Re, type=\"scatter\", mode=\"lines\", \n        name=\"Real\") %>%\n  add_trace(x=~time_points, y=~Im, type=\"scatter\", mode=\"lines\", \n        name=\"Imaginary\") %>%\n  layout(title=\"Original Time-series, f=ILT(F), F=|z|\", \n         legend = list(orientation = 'h'),\n         xaxis=list(title=\"Time\"), yaxis=list(title=\"Function Intensity\", range=c(-5,0.1)))",
      "line_count": 35
    },
    {
      "section": "Laplace Transform Applications",
      "code": "###### f(t)=sin(w t)*u(t) <--> F(z)=\tw/(z^2+w^2)\n# https://en.wikipedia.org/wiki/Laplace_transform\n\n################## Analytical-Model-based ILT: F(z) =  2/(z^2+2^2); w=2\nfMRI_Kimesurface <- function (z) {\n  return (2/(z^2+4))\n}\n# Test F=fMRI_kimesurface\n# fMRI_Kimesurface(1+ 1i) # 1.04-0.78i\n# fMRI_Kimesurface(0.5+ 0.5i) # 0.4923077-0.0615385i\n\n######################## Display the actual kimesurface: F(z)\nx2 <- seq(from = -2, to = 2, length.out = 200)\ny2 <- seq(from = -2, to = 2, length.out = 200)\nz2_grid = array(complex(), dim=c(length(x2), length(y2)))\n\nfor (i in 1:dim(z2_grid)[1]) {\n  for (j in 1:dim(z2_grid)[2]) {\n    z2_grid[i,j] = fMRI_Kimesurface(complex(real=x2[i], imaginary = y2[j]))\n  }\n}\nz3 <- Im(z2_grid)\nsurf_color <- z3\nfor (i in 1:200) {\n  for (j in 1:200) {\n    if (z3[i,j]>0) {surf_color[i,j] <- min(z3[i,j], 5) }\n    else{surf_color[i,j] <- max(z3[i,j], -5)}\n  }\n}\n\ncolorscale = cbind(seq(0, 1, by=1/(length(x2) - 1)), rainbow(length(x2)))\n\np <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(z = Re(z2_grid),   # z = Im(z2_grid),  # Real or Imaginary part of f(t)\n              surfacecolor=surf_color, colorscale=colorscale,   #Phase-based color\n              type = 'surface', opacity=1, visible=T) %>%\n    layout(title = \"Kime-Surface, Height=Re(F), Color=Im(F) \\n F=LT(f)=2/(z^2+4)\", showlegend = FALSE,\n           scene = list(aspectmode = \"manual\",\n                            aspectratio = list(x=1, y=1, z=0.5),\n                            zaxis = list(range = c(-2,5))\n              )\n          ) # 1:1:1 aspect ratio\np",
      "line_count": 43
    },
    {
      "section": "Laplace Transform Applications",
      "code": "##### f(t): 1D version #############################################\ntime_points <- seq(0+0.001, 2*pi, length.out = 160)\n\nf <- array(NA, dim = length(time_points));\n\n# using parallel computing to speed up the code\ncl <- makeCluster(ncor)\nregisterDoParallel(cl)\nILT_F_result <-\n  foreach(t = 1:length(time_points)) %dopar% {\n    TCIU::ILT(FUNCT=fMRI_Kimesurface, t=time_points[t], nterms = 31L, m = 1, fail_val = complex(1))\n  }\nstopCluster(cl)\nILT_F <- array(NA, dim = length(time_points)) # length(f)\nILT_F[1:length(ILT_F)] = unlist(ILT_F_result)\n\nfor (t in 1:length(time_points)) {\n  f[t] = sin(2*time_points[t])   # f(t)=sin(w t)*u(t)\n}\n\n# Convert f=ILT(F) to a data-frame for ggplot\nfMRI_time_Intensities_ILT_df <- as.data.frame(cbind(time_points=time_points, Re_f=Re(f),Im_f=Im(f),\n                                                    Re_ILT_F=Re(ILT_F),Im_ILT_F=Im(ILT_F)))\n\n# ggplot(fMRI_time_Intensities_ILT_df, aes(x=time_points)) + \n#   geom_line(aes(y = Re_f, color = \"Sin\"), lwd=1, lty=\"dashed\") +\n#   geom_line(aes(y = Re_ILT_F+0.01, color = \"Real f'\"), lwd=2, lty=\"dotted\") +\n#   geom_line(aes(y = Im_ILT_F, color=\"Imaginary f'\"), linetype=1, lwd=2) +\n#   scale_color_manual(\"Index\", \n#                      values = c(\"Sin\"=\"darkred\",\"Real f'\"=\"darkgreen\", \"Imaginary f'\"=\"steelblue\")) + \n#   # ggtitle(\"Real (Re) and Imaginary (Im) parts \\n of the original fMRI Time-series, f=ILT(F)\")\n#   labs(title = \"Original fMRI Time-series f(t)=sin(2t) and \\n Reconstructed f'(t)=ILT(F)=ILT(LT(f))\",\n#        subtitle = bquote(\"F\" ~ \"=\" ~ \"LT(f)\" ~ \"=\" ~ 2/(z^2+2^2))) +#\"F=LT(f)=2/(z^2+2^2)\")\n#   xlab(\"Time\") + ylab(\"fMRI Image Intensities (f and f')\") +\n#   theme_grey(base_size = 16) +\n#   theme(legend.title = element_text(size=14, color = \"black\", face=\"bold\"),\n#         panel.grid.minor.y = element_blank(),\n#         panel.grid.major.y = element_blank(),\n#         plot.title = element_text(hjust = 0.5),\n#         plot.subtitle = element_text(hjust = 0.5))\n\nplot_ly(fMRI_time_Intensities_ILT_df, x=~time_points, y=~Re_f, type=\"scatter\", mode=\"lines\", \n        name=\"Sine\") %>%\n  add_trace(x=~time_points, y=~Re_ILT_F+0.02, type=\"scatter\", mode=\"markers\", \n        name=\"Real f\") %>%\n  add_trace(x=~time_points, y=~Im_ILT_F, type=\"scatter\", mode=\"lines\", \n        name=\"Imaginary f'\") %>%\n  layout(title=\"Original fMRI Time-series f(t)=sin(2t) and \\n Reconstructed f'(t)=ILT(F)=ILT(LT(f))\", \n         legend = list(orientation = 'h'),\n         xaxis=list(title=\"Time\"), yaxis=list(title=\"Function Intensity\"))",
      "line_count": 50
    },
    {
      "section": "Laplace Transform Applications",
      "code": "#######################################################################\n###### ILT on discrete laplace transform of sine (analytical form) ####\n#######################################################################\nf_sin <- function(t) { sin(t) }\n# Define the LT(sin) as a C-valued function \nlt_func = function(z) TCIU::LT(f_sin, z)# LT(FUNCT, z), not LT(z, FUNCT) # discrete Laplace Transform of sine\n\ntvalsn <- seq(0, pi*2, length.out = 20)\n# using parallel computing to improve coding speed\ncl <- makeCluster(ncor)\nregisterDoParallel(cl)\nsinvalsn <- foreach(t=1:length(tvalsn),\n                    .export='cubintegrate', \n                    .packages='cubature')  %dopar% { \n  TCIU::ILT(FUNCT=lt_func, t=tvalsn[t])\n}\nstopCluster(cl)\nsinvalsn = unlist(sinvalsn)\nsinvalsn_df <- as.data.frame(cbind(Re=Re(sinvalsn),Im=Im(sinvalsn), Sin=sin(tvalsn), time_points=tvalsn))\n# ggplot(sinvalsn_df, aes(x=time_points))+\n#   geom_line(aes(y=Re, color=\"Real\"), linetype=1, lwd=2) +\n#   geom_line(aes(y = Sin, color=\"Sin\"), linetype=2, lwd=1) + \n#   scale_color_manual(name=\"Index\",\n#                      values = c(\"Real\"=\"steelblue\", \"Sin\"=\"darkred\"))+\n#   labs(title = \"Original fMRI Time-series f(t)=sin(t) and \\n Reconstructed f'(t)=ILT(F)=ILT( discrete LT(f))\",\n#        subtitle = bquote(\"F\" ~ \"=\" ~ \"discrete LT(f)\")) + #\"F=LT(f)=2/(z^2+2^2)\"\n#   xlab(\"Time\") + ylab(\"fMRI Image Intensities (f and f')\") +\n#   theme_grey(base_size = 16) +\n#   theme(legend.title = element_text(size=14, color = \"black\", face=\"bold\"),\n#         panel.grid.minor.y = element_blank(),\n#         panel.grid.major.y = element_blank(),\n#         plot.title = element_text(hjust = 0.5),\n#         plot.subtitle = element_text(hjust = 0.5))\n\nplot_ly(sinvalsn_df, x=~time_points, y=~Re, type=\"scatter\", mode=\"lines\", \n        name=\"Real\") %>%\n  add_trace(x=~time_points, y=~Sin, type=\"scatter\", mode=\"lines\", \n        name=\"Sine\") %>%\n  add_trace(x=~time_points, y=~Im, type=\"scatter\", mode=\"lines\", \n        name=\"Imaginary\") %>%\n  layout(title=\"Original fMRI Time-series f(t)=sin(t) and \\n Reconstructed f'(t)=ILT(F)=ILT( discrete LT(f))\", \n         legend = list(orientation = 'h'),\n         xaxis=list(title=\"Time\"), yaxis=list(title=\"Function Intensity\"))",
      "line_count": 43
    },
    {
      "section": "Laplace Transform Applications",
      "code": "#######################################################################\n###### ILT on discrete Laplace transform of sine (analytical form) ####\n#######################################################################\nf_sin <- function(t) { sin(t) }\nf_sinNoise <- function(t) { sin(t) + rnorm(1, mean=0, sd=0.1) }\n\nkimesurfaceFoliation <- function (fun=f_sin, n=50, theta=pi/4, centerOffset=10) {\n  # Compute the LT(sin) Foliation (at \\theta=\\pi/2) a C-valued function \n  # n=100  # sample size\n  z <- complex(length.out = n, real = 0, imaginary = 0) # initialize the kimesurface foliation domain\n  # theta <- pi/4 # foliation along a fixed kime-phase (theta= pi/4)\n  theta <- rep(theta, n) # initialize the kime-phase of hte foliation plane\n  off <- centerOffset     # offset the start of the foliation plane, if needed\n  \n  for (i in c(1:n)) {   # linear grid over foliation plane at \\theta=\\pi/4\n    the = theta[i]    # in general, theta ~ \\Phi (random sample from the phase distribution)\n    radius = (i*2*pi)/n # time restricted to [0, 2\\pi]\n    z[i] = complex(real = off + radius*cos(the), imaginary = off + radius*sin(the))\n  }\n  \n  # Generic LT function - kimesurface, defined over each kime in the complex domain\n  lt_func = function(z) TCIU::LT(fun, z)# LT(FUNCT, z), not LT(z, FUNCT) # discrete Laplace Transform of sine\n  \n  # Define the leaf-generating function intersecting the foliating plane with the kimesurface\n  lt_func_Leaf = function(z) {\n    r = abs(z)                # kime-magnitude\n    # phi = atan2(Im(z), Re(z)) # kime-phase\n    return (lt_func(complex(real=r*cos(theta), imaginary=r*sin(theta))))\n  } \n    \n  tvalsn <- seq(0, pi*2, length.out = n)\n  # using parallel computing to improve coding speed\n  cl <- makeCluster(detectCores()-3)\n  registerDoParallel(cl)\n  sinvalsn <- foreach(t=1:length(tvalsn),\n                      .export='cubintegrate', \n                      .packages='cubature')  %dopar% { \n    TCIU::ILT(FUNCT=lt_func_Leaf, t=tvalsn[t])\n  }\n  stopCluster(cl)\n  sinvalsn = unlist(sinvalsn)\n  reMin <- min(Re(sinvalsn))\n  imMin <- min(Im(sinvalsn))\n  sinvalsn_df <- as.data.frame(cbind(Re=log(2+abs(reMin)+Re(sinvalsn)), \n                     Im=log(2+abs(imMin)+Im(sinvalsn)), Sin=fun(tvalsn), time_points=tvalsn))\n  \n  return(sinvalsn_df)\n}\n\n#  Sample 1: \\theta_1 = pi/4\n# sinvalsn_df1 <- kimesurfaceFoliation(fun=f_sin, n=50, theta=pi/4, centerOffset=10)\nsinvalsn_df1 <- kimesurfaceFoliation(fun=f_sin, n=50, theta=pi/(2.5), centerOffset=10)\n#  Sample 2: \\theta_2 = pi/3\nsinvalsn_df2 <- kimesurfaceFoliation(fun=f_sin, n=50, theta=pi/3, centerOffset=10)\n  \n# ggplot(sinvalsn_df2, aes(x=time_points))+\n#   geom_line(aes(y=Re, color=\"Real\"), linetype=1, lwd=2) +\n#   geom_line(aes(y = Sin, color=\"Sin\"), linetype=2, lwd=1) + \n#   scale_color_manual(name=\"Index\",\n#                      values = c(\"Real\"=\"steelblue\", \"Sin\"=\"darkred\"))+\n#   labs(title = \"Original fMRI Time-series f(t)=sin(t) and \\n Reconstructed f'(t)=ILT(F)=ILT( discrete LT(f))\",\n#        subtitle = bquote(\"F\" ~ \"=\" ~ \"discrete LT(f)\")) + #\"F=LT(f)=2/(z^2+2^2)\"\n#   xlab(\"Time\") + ylab(\"fMRI Image Intensities (f and f')\") +\n#   theme_grey(base_size = 16) +\n#   theme(legend.title = element_text(size=14, color = \"black\", face=\"bold\"),\n#         panel.grid.minor.y = element_blank(),\n#         panel.grid.major.y = element_blank(),\n#         plot.title = element_text(hjust = 0.5),\n#         plot.subtitle = element_text(hjust = 0.5))\n\n# Show Real and Imaginary timeseries\nplot_ly(x=sinvalsn_df1$time_points,y=sinvalsn_df1$Sin, type=\"scatter\", mode=\"lines\", name=\"Sine\") %>%\n  # first sample, corresponding to \\theta= pi/2\n  add_trace(x=sinvalsn_df1$time_points, y=sinvalsn_df1$Re, type=\"scatter\", mode=\"lines\",\n            name=\"Re(theta=pi/4)\") %>%\n  add_trace(x=sinvalsn_df1$time_points, y=sinvalsn_df1$Im, type=\"scatter\", mode=\"lines\",\n            name=\"Im(theta=pi/4)\") %>%\n  # second sample, corresponding to \\theta= pi/3\n  add_trace(x=sinvalsn_df2$time_points, y=sinvalsn_df2$Re, type=\"scatter\", mode=\"lines\",\n            name=\"Re(theta=pi/3)\") %>%\n  add_trace(x=sinvalsn_df2$time_points, y=sinvalsn_df2$Im, type=\"scatter\", mode=\"lines\",\n            name=\"Im(theta=pi/3)\") %>%\n  layout(title=\"Original Time-series f(t)=sin(t) and Random Time-series Sampling by \\n Inverting the Foliated Kimesurface, g(t)=ILT(F(t,theta))\", \n         legend = list(orientation = 'h', y=-0.2),\n         xaxis=list(title=\"Time\"), yaxis=list(title=\"Real and Imaginaty parts\\n Foliation ILT(Leaf Function) Intensity\"))\n\n# Plot only the Magnitudes\nplot_ly(x=sinvalsn_df1$time_points,y=sinvalsn_df1$Sin, type=\"scatter\", mode=\"lines\", name=\"Sine\") %>%\n    # first sample, corresponding to \\theta= pi/2\n    add_trace(x=sinvalsn_df1$time_points, y=sqrt((sinvalsn_df1$Re)^2+(sinvalsn_df1$Im)^2), \n              type=\"scatter\", mode=\"lines\", name=\"MAG(theta=pi/4)\") %>%\n    # second sample, corresponding to \\theta= pi/3\n    add_trace(x=sinvalsn_df2$time_points, y=sqrt((sinvalsn_df2$Re)^2+(sinvalsn_df2$Im)^2), \n              type=\"scatter\", mode=\"lines\", name=\"MAG(theta=pi/3)\")  %>%\n    layout(title=\"Original Time-series f(t)=sin(t) and Random Time-series Sampling by \\n Inverting the Foliated Kimesurface, g(t)=ILT(F(t,theta))\", \n         legend = list(orientation = 'h', y=-0.2),\n         xaxis=list(title=\"Time\"), yaxis=list(title=\"Magnitude of Foliated ILT(Leaf Function) Intensity\"))",
      "line_count": 97
    },
    {
      "section": "ILT of the explicit definition of the kimesurface function $F(z)=\\mathcal{L}(\\sin)(z)$",
      "code": "# reduce the grid-resolution from 200*200 down to (50-1)*(50-1)\nrange_limit = 2\nx2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n  # drop the first row to avoid real part value of 0\ny2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n  # drop the first column to to avoid imaginary part value of 0\n\n# Recompute the LT(sin) discretized on lower-res grid\nz2_grid = array(dim=c(length(x2), length(y2)))# x2 %o% y2\n\nf_sin <- function(t) { sin(t) }\n\n# kime surface transform\n# use parallel computing to speed up code\ncl <- makeCluster(ncor)\nregisterDoParallel(cl)\nF = list()\nfor (i in 1:length(x2) ){\n  F[[i]] = \n    foreach(j = 1:length(y2),\n            .export='cubintegrate', \n            .packages='cubature') %dopar% {\n      F_result = TCIU::LT(FUNCT=f_sin, complex(real=x2[i], imaginary = y2[j]))# LT(FUNCT, z), not LT(z, FUNCT)\n      mag = log(sqrt( Re(F_result)^2+ Im(F_result)^2))   \n      # log-transform the magnitude to temper the kimesurface amplitude\n      phase = atan2(Im(F_result), Re(F_result))\n      mag * exp(1i*phase)#z2_grid[i,j] = \n    }\n}\n  \nstopCluster(cl)\nF_vec = lapply(F, unlist)\nz2_grid = unlist(do.call(rbind, F_vec))\n\n\n#### define Kimesurface_fun #####\nKimesurface_fun <- function (z, array_2D) {\n  # array_2D <- z2_grid\n  # convert z in C to Cartesian (x,y) coordinates\n  x1 <- ceiling(Re(z))-1; # if (x1<2 || x1>dim(array_2D)[1]) x1 <- 2\n  y1 <- ceiling(Im(z))-1; # if (y1<2 || y1>dim(array_2D)[2]) y1 <- 2\n  # if exceed the domain use the default 1\n  if(!is.na(x1)){\n    if((x1 < 1) || (x1 > dim(array_2D)[1])){ x1 <- 1 }\n  }\n  if(!is.na(y1)){\n    if((y1 < 1) || (y1 > dim(array_2D)[2])){ y1 <- 1 }\n  }\n  \n  # Exponentiate to Invert the prior (LT) log-transform of the kimesurface magnitude\n  val1 = complex(length.out=1, real=Re(array_2D[x1, y1]), imaginary = Im(array_2D[x1, y1]))\n  mag = exp(sqrt( Re(val1)^2+ Im(val1)^2))\n  # mag = sqrt( Re(val1)^2+ Im(val1)^2)\n  phase = atan2(Im(val1), Re(val1))\n  value <- complex(real=Re(mag * exp(1i*phase)), imaginary = Im(mag * exp(1i*phase))) \n  return ( value )\n}\n\n# Kimesurface_fun(5+5i, z2_grid)\n\n##### Time-domain grid (regular equidistant positive real break points)\ntime_points <- seq(0+0.001, 2*pi, length.out = 160)\n\nf2 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f2[t] <- ILT(FUNCT=function(z) Kimesurface_fun(z, array_2D=z2_grid), \n               t= time_points[t], nterms = 31L,\n               m = 1, gamma=0.5, fail_val = complex(1), msg=TRUE)\n}\n\n# interpolate f(t) to 20 samples in [0 : 2*pi]. Note that 20~2*PI^2\ntvalsn <- seq(0, pi*2, length.out = 20)\nf3 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f3[t] <- f2[ceiling(t/20)]\n}\nf4 <- smooth.spline(time_points, Re(f3), spar = 1)$y; # plot(f4)\n\ntime_Intensities_ILT_df2 <- as.data.frame(cbind(Re=Re(f4), Im=Re(f3),\n                                                Sin=sin(time_points),\n                                                time_points=time_points))\nmin_range <- range(Re(f4))[1]; max_range <- range(Re(f4))[2]\ntime_Intensities_ILT_df2$Re <- time_Intensities_ILT_df2$Re/(8*max_range/9)\ntime_Intensities_ILT_df2$Im <- time_Intensities_ILT_df2$Im/(8*max_range/9)\ncolnames(time_Intensities_ILT_df2) <- \n  c(\"Smooth Reconstruction\", \"Raw Reconstruction\", \"Original sin()\", \"time_points\")\n\ndf <- reshape2::melt(time_Intensities_ILT_df2, id.var = \"time_points\")\n# ggplot(df, aes(x = time_points, y = value, colour = variable)) + \n#   geom_line(linetype=1, lwd=3)+\n#   ylab(\"Function Intensity\") + xlab(\"Time\") +\n#   theme(legend.position=\"top\")+\n#   labs(title=\n#          \"Comparison between f(t)=sin(t) and SplineSmooth(ILT(LT(sin)))(t); Range [\" ~ 0 ~\":\"~ 2*pi~\"]\")\n\nplot_ly(df, x=~time_points, y=~value, type=\"scatter\", mode=\"lines\", \n        color =~variable, name=~variable) %>%\n  layout(title=\"Comparison between f(t)=sin(t) and SplineSmooth(ILT(LT(sin)))(t); Range=[0,2pi]\", \n         legend = list(orientation = 'h'),\n         xaxis=list(title=\"Time\"), yaxis=list(title=\"Function Intensity\"))",
      "line_count": 100
    },
    {
      "section": "Compare the analytical and discrete Laplace transforms",
      "code": "# range_limit = 2\n# x2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n#   # drop the first row to avoid real part value of 0\n# y2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n#   # drop the first column to to avoid imaginary part value of 0\n\n#############################################################################\n### Explicit (continuous-function) form of laplace transformation of sine ###\n#############################################################################\nXY = expand.grid(X=x2,Y=y2)       \n# XY\nlaplace_sine = function(p) { 1/(p^2 + 1) } # Exact laplace transform of sin(x), continuous function\ncomplex_xy = mapply(complex, real=XY$X,imaginary=XY$Y)\nsine_z =laplace_sine(complex_xy)\ndim(sine_z) = c(length(x2), length(y2)); \n# dim(sine_z)  # [1] 49 49\n\n# Log-transform the Intensity of the Kime surface (to make a better-looking surface plot, not a big deal)\nmag_sine_z = log(sqrt( Re(sine_z)^2+ Im(sine_z)^2))\n# log-transform the magnitude to temper the kimesurface amplitude\nphase_sine_z = atan2(Im(sine_z), Re(sine_z))\nsine_z_new = mag_sine_z * exp(1i*phase_sine_z)\n\n\n# draw the surface whose heights are based on real, imaginary, \n# magnitude and phase of the both results respectively\n# the two kinds of result are from closed-formed LT and discrete LT of sine\nplot_ly(hoverinfo=\"none\", showscale = FALSE)%>%\n  add_trace(z=Re(sine_z_new)-0.5, type=\"surface\", surfacecolor=phase_sine_z)  %>%\n  add_trace(z = Re(z2_grid), type=\"surface\", opacity=0.7, surfacecolor=Im(z2_grid) )%>%\n  layout(title = \n  \"Kime-Surface, LT(sin()), Height=Re(LT(sin())), Color=Re(LT(sin())) \\n Contrast Exact (Continuous) vs. \n         Approximate (Discrete) Laplace Transform\", showlegend = FALSE)\n\nplot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n  add_trace(z=Im(sine_z_new)-0.5, type=\"surface\")  %>%\n  add_trace(z = Im(z2_grid), type=\"surface\", opacity=0.7)%>%\n  layout(title = \n  \"Kime-Surface, LT(sin()), Height=Im(LT(sin())) \\n Contrast Exact (Continuous) vs. \n         Approximate (Discrete) Laplace Transform\", showlegend = FALSE)\n\nmag_sine_z_new = sqrt(Re(sine_z_new)^2 + Im(sine_z_new)^2)\nmag_z2_grid = sqrt( Re(z2_grid)^2+ Im(z2_grid)^2)\nplot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n  add_trace(z = mag_sine_z_new-0.5, type=\"surface\") %>%\n  add_trace(z = mag_z2_grid, type=\"surface\", opacity=0.7) %>%\n  layout(title = \n  \"Kime-Surface, LT(sin()), Height=Magnitude(LT(sin())) \\n Contrast Exact (Continuous) vs. \n         Approximate (Discrete) Laplace Transform\", showlegend = FALSE)\n\nphase_sine_z_new = atan2(Im(sine_z_new), Re(sine_z_new))\nphase_z2_grid = atan2(Im(z2_grid), Re(z2_grid))\nplot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n  add_trace(z = phase_sine_z_new-0.5, type=\"surface\") %>%\n  add_trace(z = phase_z2_grid, type=\"surface\", opacity=0.7) %>%\n  layout(title = \n  \"Kime-Surface, LT(sin()), Height=Phase(LT(sin())) \\n Contrast Exact (Continuous) vs. \n         Approximate (Discrete) Laplace Transform\", showlegend = FALSE)\n\nplot_ly(hoverinfo=\"none\", showscale = FALSE)%>%\n  add_trace(z=mag_sine_z_new-0.5, surfacecolor=phase_sine_z_new, type=\"surface\") %>%\n  add_trace(z=mag_z2_grid, surfacecolor=phase_z2_grid, type=\"surface\", opacity=0.7) %>%\n  layout(title = \n           \"Kime-Surface, LT(sin()), Height=Phase(LT(sin())), Color=Phase \\n Contrast Exact (Continuous) vs. \n         Approximate (Discrete) Laplace Transform\",\n         showlegend = FALSE,\n         scene = list(aspectmode = \"manual\",\n                      aspectratio = list(x=1, y=1, z=1.0),\n                      zaxis = list(range = c(-2,3))\n         )\n  )",
      "line_count": 71
    },
    {
      "section": "Compare the analytical and discrete Inverse Laplace Transforms",
      "code": "# Reconstruct and plot the 1D function f(t) = ILT(LT(sin(x))(z))(t) and compare to sin(t)\n\n\n################ ILT on analytic LT of sine ###########################################################\n##### Time-domain grid (regular equidistant positive real break points)\ntime_points <- seq(0+0.001, 2*pi, length.out = 160)\n\nf20 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f20[t] <- ILT(FUNCT=function(z) Kimesurface_fun(z, array_2D=sine_z_new), \n               t= time_points[t], nterms = 31L,\n               m = 1, gamma=0.5, fail_val = complex(1), msg=TRUE)\n}\n\n# interpolate f(t) to 20 samples in [0 : 2*pi]. Note that 20~2*PI^2\ntvalsn <- seq(0, pi*2, length.out = 20)\nf30 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f30[t] <- f20[ceiling(t/20)]\n}\nf40 <- smooth.spline(time_points, Re(f30), spar = 1)$y; # plot(f4)\n\n\n################ ILT on discrete LT of sine ###########################################################\n##### Time-domain grid (regular equidistant positive real break points)\ntime_points <- seq(0+0.001, 2*pi, length.out = 160)\n\nf2 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f2[t] <- ILT(FUNCT=function(z) Kimesurface_fun(z, array_2D=z2_grid), \n               t= time_points[t], nterms = 31L,\n               m = 1, gamma=0.5, fail_val = complex(1), msg=TRUE)\n}\n\n# interpolate f(t) to 20 samples in [0 : 2*pi]. Note that 20~2*PI^2\ntvalsn <- seq(0, pi*2, length.out = 20)\nf3 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f3[t] <- f2[ceiling(t/20)]\n}\nf4 <- smooth.spline(time_points, Re(f3), spar = 1)$y; # plot(f4)\n\n############## make the comparison plot ###############################################################\ntime_Intensities_ILT_df2 <- as.data.frame(cbind(Re_discrete=Re(f4), Re_analytic=Re(f40),\n                                                Sin=sin(time_points),\n                                                time_points=time_points))\nmin_range_Re_discrete <- range(Re(f4))[1]; max_range_Re_discrete <- range(Re(f4))[2]\ntime_Intensities_ILT_df2$Re_discrete <- time_Intensities_ILT_df2$Re_discrete/(8*max_range_Re_discrete/9)\nmin_range_Re_analytic <- range(Re(f40))[1]; max_range_Re_analytic <- range(Re(f40))[2]\ntime_Intensities_ILT_df2$Re_analytic <- time_Intensities_ILT_df2$Re_analytic/(8*max_range_Re_analytic/9)\n\n# ggplot(time_Intensities_ILT_df2, aes(x=time_points))+\n#   geom_line(aes(y=Re_discrete, color=\"Smooth Reconstruction of Discrete LT\"), lwd=1, lty=\"dashed\") +\n#   geom_line(aes(y=Re_analytic, color=\"Analytic Reconstruction of Analytic LT\"), lwd=2,lty=\"dotted\") +\n#   geom_line(aes(y = Sin, color=\"Original Sin\"), lwd=2) + \n#   scale_color_manual(name=\"Index\",\n#                      values = c(\"Smooth Reconstruction of Discrete LT\"=\"#F8766D\", \n#                                 \"Analytic Reconstruction of Analytic LT\"=\"#00BA38\", \n#                                 \"Original Sin\"=\"#619CFF\"))+\n#   labs(title = \"Comparison among f(t)=sin(t), SplineSmooth(ILT(LT(sin)))(t), \\n\n#        and Analytic ILT(LT(sin))(t); Range [\" ~ 0 ~\":\"~ 2*pi~\"]\") +\n#   xlab(\"Time\") + ylab(\"Function Intensity\") +\n#   theme(legend.title = element_text(size=14, color = \"black\", face=\"bold\"),\n#         legend.position = \"top\",\n#         panel.grid.minor.y = element_blank(),\n#         panel.grid.major.y = element_blank(),\n#         plot.title = element_text(hjust = 0.5),\n#         plot.subtitle = element_text(hjust = 0.5))\n\nplot_ly(time_Intensities_ILT_df2, x=~time_points, y=~Re_discrete, type=\"scatter\", mode=\"lines\", name=\"Smooth Reconstruction of Discrete LT\") %>%\n  add_trace(x=~time_points, y=~Re_analytic, type=\"scatter\", mode=\"markers\", \n            name=\"Analytic Reconstruction of Analytic LT\") %>%\n  add_trace(x=~time_points, y=~sin(time_points), type=\"scatter\", mode=\"lines\", \n            name=\"Original Sine Function\") %>%\n  layout(title=\"Comparison among f(t)=sin(t), SplineSmooth(ILT(LT(sin)))(t), \\n\n       and Analytic ILT(LT(sin))(t); Range=[0,2pi]\", \n         legend = list(orientation = 'h'),\n         xaxis=list(title=\"Time\"), yaxis=list(title=\"Function Intensity\"))\n",
      "line_count": 79
    },
    {
      "section": "fMRI example",
      "code": "\nfMRIURL <- \"https://socr.umich.edu/HTML5/BrainViewer/data/fMRI_FilteredData_4D.nii.gz\"\nfMRIFile <- file.path(tempdir(), \"fMRI_FilteredData_4D.nii.gz\")\ndownload.file(fMRIURL, dest=fMRIFile, quiet=TRUE)\nfMRIVolume <- readNIfTI(fMRIFile, reorient=FALSE)\n# dimensions: 64 x 64 x 21 x 180 ; 4mm x 4mm x 6mm x 3 sec \n\nfMRIVolDims <- dim(fMRIVolume); \n# fMRIVolDims\ntime_dim <- fMRIVolDims[4]; \n# time_dim ## 180\n\n# 2. extract the time-course of 1D mid-axial slice (3D) hypervolume\nxA_fMRI_1D_x20_y20_z11 <- fMRIVolume[20, 20, 11, ]; # length(xA_fMRI_1D_x20_y20_z11)   #  180\n# hist(xA_fMRI_1D_x20_y20_z11)\n\n# Now, combine your two 1D timeseries into one dataframe for joint hist plotting as densities.  \n# First make a new column in each that will be \n# a variable to identify where they came from later.\ntimes <- c(1:180)\n# Smooth noisy f(t)=fMRI\nf <- array(complex(1), dim = length(times)); # length(f)\nf <- smooth.spline(times, xA_fMRI_1D_x20_y20_z11, df = 10)$y # smooth f (fMRI)\n\n# Construct DF for ggplot\nxA_df <- as.data.frame(cbind(times, xA_fMRI_1D_x20_y20_z11, f))\ncolnames(xA_df) <- c(\"time\", \"xA\", \"smooth\")\n\n# ggplot(xA_df, aes(x=times)) + \n#   geom_point(aes(y = scale(xA)), colour = \"darkred\", size = 3)+\n#   geom_line(aes(y = scale(xA)), color=\"steelblue\", lty=1, lwd=1)+\n#   geom_line(aes(y = scale(smooth)), color = \"green\", lwd=2) +  ### , lty=\"dashed\") +\n#   ggtitle(\"Original fMRI Time-series f(t) and Smoothed curve\") +\n#   xlab(\"Time\") + ylab(\"fMRI Image Intensities (f and f')\") +\n#   scale_color_manual(name=\"Index\",labels=c(\"Real\", \"Imaginary\"),\n#                      values = c(\"Re\"=\"darkred\", \"Im\"=\"steelblue\"))+\n#   theme_grey(base_size = 16) +\n#   theme(legend.title = element_text(size=14, color = \"salmon\", face=\"bold\"),\n#         legend.position=\"top\",\n#         axis.text.x = element_blank(),\n#         axis.text.y = element_blank(),\n#         axis.ticks = element_blank())\n\nplot_ly(xA_df, x=~time, y=~scale(xA), type=\"scatter\", mode=\"markers+lines\", name=\"fMRI\") %>%\n  add_trace(x=~time, y=~scale(smooth), type=\"scatter\", mode=\"markers+lines\", \n            name=\"Smooth fMRI\") %>%\n  layout(title=\"Original fMRI Time-series f(t) and Smoothed Interpolation\", \n         legend = list(orientation = 'h'),\n         xaxis=list(title=\"Time\"), yaxis=list(title=\"Function Intensity\"))",
      "line_count": 49
    },
    {
      "section": "fMRI example",
      "code": "time_points <- seq(0+0.001, 2*pi, length.out = 180)\n\nf <- array(complex(1), dim = length(time_points)); # length(f)\n# Instead of using the extremely noisy fMRI data, avoid integration problems, \n# smooth \"f\" and use the **smooth version, f**\nf <- smooth.spline(ceiling((180*time_points)/(2*pi)), xA_fMRI_1D_x20_y20_z11, df = 10)$y # smooth f (fMRI)\n\n# Define the f(t)=smooth(fMRI)(t) signal as a function of real time 0<t<=2*pi\nf_funct <- function(t) {\n  # f <- match.fun(f) # input R-valued FUNCT should be interpreted as f(t)=fMRI(t) time-series function\n  if (t < 0+0.001 || t > 2*pi) {  return ( 0 ) # sprintf(\"Out of Range ...\")\n  } else {\n    return ( f[ceiling((180*t)/(2*pi))] )\n  }\n}\n\n# Evaluate the LT at z, F(z)=LT(f)(z) \nz= 1+1i; \n# LT(f_funct, z)  # Complex-domain value\n\n\n######################## Display the actual kimesurface: F(z)\nrange_limit = 2\nx2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n# drop the first row to avoid real part value of 0\ny2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n  # drop the first column to to avoid imaginary part value of 0\n# \n# # Recompute the LT(sin) discretized on lower-res grid\n# z2_grid = array(dim=c(length(x2), length(y2)))# x2 %o% y2\n\n\n\ncl <- makeCluster(ncor)\nregisterDoParallel(cl)\nF = list()\nfor (i in 1:length(x2) ){\n  F[[i]] = \n    foreach(j = 1:length(y2),\n            .export='cubintegrate', \n            .packages='cubature') %dopar% {\n      F_result = TCIU::LT(f_funct, complex(real=x2[i], imaginary = y2[j]))\n      mag = log(sqrt( Re(F_result)^2+ Im(F_result)^2))  \n      # log-transform the magnitude to temper the kimesurface amplitude\n      phase = atan2(Im(F_result), Re(F_result))\n      mag * exp(1i*phase)#z2_grid[i,j] = \n    }\n}\n  \nstopCluster(cl)\nF_vec = lapply(F, unlist)\nz2_grid = unlist(do.call(rbind, F_vec))\n\nsurf_color <- atan2(Im(z2_grid), Re(z2_grid))\ncolorscale = cbind(seq(0, 1, by=1/(length(x2) - 1)), rainbow(length(x2)))\nmagnitude <- (sqrt( Re(z2_grid)^2+ Im(z2_grid)^2))\n\np <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(z = magnitude, \n              surfacecolor=surf_color, colorscale=colorscale,   #Phase-based color\n              type = 'surface', opacity=1, visible=T) %>%\n    layout(title = \"fMRI Kime-Surface, F=LT(fMRI) \\n Height=Mag(F), Color=Phase(F)\", showlegend = FALSE,\n           scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1.0) ) ) # 1:1:1 aspect ratio\np",
      "line_count": 64
    },
    {
      "section": "fMRI example",
      "code": "# regularize  kimesurface by computing the Stereographic Projection of the LT\nmagnitude <- sqrt((Re(z2_grid))^2+(Im(z2_grid))^2)\nx5 <- Re(z2_grid); y5 <- Im(z2_grid)\nphase <- atan2(y5,x5)\n\n# spherical coordinates   str(phi1); str(theta1)  #  num [1:200, 1:200]\nphi1 <- 2*atan2(1, magnitude)  # zenith\ntheta1 <- phase                # azimuth\n\n# simple 2D plots of the zenith and azimuth values of the regularized LT\n# Mind the tempering of the LT -- no singularities!\n# image(phi1); hist(phi1)\nplot_ly(z=~phi1, type=\"heatmap\") %>% \n    layout(title=\"Heatmap of Zenith Angle (theta)\") %>% hide_colorbar()\nplot_ly(x=~as.vector(phi1), type = \"histogram\", name = \"Zenith Angle\", \n        histnorm = \"probability\") %>%    \n    # add_trace(x =~fit$x, y =~5*fit$y, type = \"scatter\", mode = \"lines\", opacity=0.1,    \n    #           fill = \"tozeroy\", name = \"Normal Density\") %>%    \n    layout(title='Zenith Angle Histogram',   \n           xaxis = list(title = \"Zenith\"), \n           yaxis = list(title = \"relative frequency/density\"),  \n           legend = list(orientation = 'h')) \n\n# image(theta1); hist(theta1)\nplot_ly(z=~theta1, type=\"heatmap\") %>% \n    layout(title=\"Heatmap of Azimuth Angle (theta)\") %>% hide_colorbar()\nplot_ly(x=~as.vector(theta1), type = \"histogram\", name = \"Azimuth Angle\", \n        histnorm = \"probability\") %>%    \n    # add_trace(x =~fit$x, y =~5*fit$y, type = \"scatter\", mode = \"lines\", opacity=0.1,    \n    #           fill = \"tozeroy\", name = \"Normal Density\") %>%    \n    layout(title='Azimuth Angle Histogram',   \n           xaxis = list(title = \"Azimuth\"), \n           yaxis = list(title = \"relative frequency/density\"),  \n           legend = list(orientation = 'h')) \n\n# Spherical to Cartesian coordinate mapping\n\n# plot the regularized kimesurface\nsurf_color <- theta1  # azimuth\nx2new <- seq(from = -pi, to = pi, length.out = 200)\n\ncolorscale = cbind(seq(0, 1, by=1/(length(x2new) - 1)), rainbow(length(x2new)))\n\np <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(z = phi1,   # z = zenith\n              surfacecolor=surf_color, colorscale=colorscale, #Phase-based color (azimuth)\n              type = 'surface', opacity=1, visible=T #,\n              # contour=list(x = list(highlight = FALSE),\n              #              y = list(highlight = FALSE),\n              #              z = list( highlight = TRUE, highlightcolor = \"blue\"),\n              #              color=\"#000\", width=15, lwd=10,\n              #              opacity=1.0, hoverinfo=\"none\")\n              ) %>%\n    layout(title = \n             paste0(\"Regularized fMRI Kime-Surface, F=LT(fMRI) \\n\",\n                    \"Height=Zenith(F), Color=Azimuth(F) \\n\"), \n           showlegend = FALSE,\n           scene = list(aspectmode = \"manual\",\n                            aspectratio = list(x=1, y=1, z=0.5),\n                            zaxis = list(range = c(-2,5))\n              )\n          ) # 1:1:1 aspect ratio\np",
      "line_count": 63
    },
    {
      "section": "fMRI example",
      "code": "##### Time-domain grid (regular equidistant positive real break points)\n# using parallel computing to speed up code\ncl <- makeCluster(ncor)\nregisterDoParallel(cl)\nf2_reuslt <-\n  foreach (t = 1:length(time_points)) %dopar% {\n    TCIU::ILT(FUNCT=function(z) Kimesurface_fun(z, array_2D=z2_grid), \n        t= time_points[t], nterms = 31L,\n        m = 1, gamma=0.5, fail_val = complex(1), msg=TRUE)\n  }\nstopCluster(cl)\n###\nf2 <- array(complex(1), dim = length(time_points))\nfor(t in 1:length(time_points)){\n    f2[t] = ILT(FUNCT=function(z) Kimesurface_fun(z, array_2D=z2_grid),\n                t= time_points[t], nterms = 31L,\n                m = 1, gamma=0.5, fail_val = complex(1), msg=TRUE)}\n###\nf2 <- array(complex(1), dim = length(time_points))# length(f), f=ILT(F)\nf2[1:length(f2)] = unlist(f2_reuslt)\n\n# interpolate f(t) to 20 samples in [0 : 2*pi]. Note that 20~2*PI^2\ntvalsn <- seq(0, pi*2, length.out = 20)\nf3 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f3[t] <- f2[ceiling(t/20)]\n}\nf4 <- smooth.spline(time_points, Re(f3), spar = 1)$y; # plot(f4)\n\n# scale all 3 signals to get congruence ...\n# time_Intensities_ILT_df2 <- as.data.frame(cbind(Re=scale(Re(f4)), Im=scale(Re(f3)),\n#                                                 fMRI=scale(Re(f_funct(time_points))),\n#                                                 time_points=time_points))\nmyFunct <- time_points\nfor (i in 1:length(time_points)) {\n  myFunct[i] <- f_funct(time_points[i])\n}\ntime_Intensities_ILT_df2 <- as.data.frame(cbind(Re=scale(Re(f4)), Im=scale(Re(f3)),\n                                                fMRI=scale(Re(myFunct)),\n                                                time_points=time_points))\n\nmin_range <- range(Re(f4))[1]; max_range <- range(Re(f4))[2]\ncolnames(time_Intensities_ILT_df2) <- \n  c(\"Smooth Reconstruction\", \"Raw Reconstruction\", \"Original fMRI\", \"time_points\")\n\ndf <- reshape2::melt(time_Intensities_ILT_df2, id.var = \"time_points\")\n# ggplot(df, aes(x = time_points, y = value, colour = variable)) + \n#   geom_line(linetype=1, lwd=3)+\n#   ylab(\"Function Intensity\") + xlab(\"Time\") +\n#   theme(legend.position=\"top\")+\n#   labs(title=\"Comparison between f(t)=fMRI(t) and SplineSmooth(ILT(LT(fMRI)))(t); Range [\" ~ 0 ~\":\"~ 2*pi~\"]\")\nplot_ly(df, x =~time_points, y = ~value, color = ~variable, type=\"scatter\", \n        mode=\"lines\", name=~variable) %>%\n  layout(title=\"Comparison between f(t)=fMRI(t) and SplineSmooth(ILT(LT(fMRI)))(t);\n         Range [0,2pi]\", legend = list(orientation = 'h'),\n         xaxis=list(title=\"Time\"), yaxis=list(title=\"Function Intensity\"))",
      "line_count": 56
    }
  ]
}