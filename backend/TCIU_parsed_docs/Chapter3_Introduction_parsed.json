{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.133819",
    "total_sections": 3,
    "total_code_chunks": 6,
    "total_tables": 1,
    "r_libraries": [
      "EBImage",
      "abind",
      "dplyr",
      "imager",
      "plotly"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Introduction\"\nsubtitle: \"[Back To TCIU Contents](https://tciu.predictive.space/)\"\nauthor: \"SOCR Team \"\ndate: \"`r format(Sys.time(),'%m/%d/%Y')`\"\noutput: \n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n      smooth_scroll: true",
      "word_count": 35
    },
    {
      "title": "Figure 3.1: 1D Waves and 2D Waves",
      "content": "Waves of constant wavelength propagate maintaining its shape but shifting its location like in the image below. However, this oversimplified representation does not work well for computing, as adding  wave amplitudes does not work as expected. It simply shifts the wave amplitude up and doesn't move the wave in the direction of motion. Similar problem arises with wave multiplication by a constant. Wave multiplication by a number increases the height of the peaks and valleys without moving them in space.\n\nThese problems are solved by an alternative wave representation where the wave has a complex amplitude, and complex multiplication by a number works well. \n\nThe wave *phase* represents the direction of the wave amplitude in a complex plane. Differences of phases yield interference phenomena. The interference of two waves of amplitude $i$ will produce an increased amplitude of $2i=i + i$. When the second wave is of amplitude $-i$, then their interference destroys the aggregate wave, i.e., produces a zero amplitude wave $i - i = 0$.\n\nLet's start with a wave of  constant wavelength that represents a particle of definite momentum. For simplicity, we'll consider just a one space dimension representing the horizontal axis, i.e.,  the spatial extension of the wave. The remaining two dimensions will represent the phase of the wave complex amplitude. The vertical axis represents the imaginary $+i$ and $-i$ directions, and depth represents the real $+1$ and $-1$ directions. In this representation, the *wave magnitude* is constant, however, the 2D phase determines the uniform distance advancement in space. \n\nAs the wave propagates, the amplitude cycles through all directions in the 2D complex plane perpendicular to the 1D space dimension (x-axis). The result is a wave function represented by a helical (\"corkscrew\") shape.  In the previous example, the illusion that the wave amplitude periodically vanishes is just an artifact of an incomplete representation of the wave. \n\nThe Complex wave representation clarifies this illusion arising by slicing through the 3D \"corkscrew\" wave shape and showing just the 1D values in the space of complex amplitudes.\n\nThis complex wave representation also addresses the above multiplication problem. Multiplying the 3D wave curve by $i$ will relocate the amplitudes yielding spatial propagation of the wave, which explains the basic rule of time evolution of quantum theory. The effect of multiplying the wave amplitude by $i$ at each point is effectively a rotation of the amplitude by one quarter turn around the space of values. Thus, the combination of these point-wise effects results in the wave advancing forward in space (propagation).\n\n\nRecall that for a single particle, the Hamiltonian  operator corresponding to the total energy of the system is defined by:\n\n$$\\hat {H}={\\underbrace{\\frac{\\hat {p}^{2}}{2m}}_{\\text{particle kinetic energy}}}+\n{\\underbrace{\\frac {1}{2} k \\hat {x}^2}_{\\text{particle potential energy}}}=\n{\\frac {{\\hat {p}}^{2}}{2m}}+{\\frac {1}{2}}m\\omega ^{2}{\\hat {x}}^{2} ,$$\n\nwhere $m$ is the particle mass, $k$ is the force constant, $w =\\sqrt {\\frac {k}{m}}$ is the *angular frequency* of the oscillator, $\\hat {x}$ is the position operator (corresponding to the spatial location $x$), and $\\hat {p}$ is the momentum operator (corresponding to the momentum), which is expressed by $\\hat {p}= -i\\hbar \\frac{\\partial}{\\partial x}$. Then, the time-independent Schrodinger equation can be expressed as:\n\n$$\\hat {H}\\left|\\psi \\right\\rangle =E\\left|\\psi \\right\\rangle ,$$\n\nwhere the eigenvalue $E$ denotes a real number specifying a time-independent energy level and the wavefunction $\\psi$ represents the solution corresponding to that level's energy eigenstate. \n\nAnother way of visualizing the propagation of a wavefunction over a 1D space in terms of its complex amplitude ($\\psi =Ae^{i(kx-wt)}$), real and imaginary parts, where $t$ is time, $w = kc$, wave's angular frequency which equals $w=2\\pi/T$, where $T$ is the period of the wave, the position $x$, and momentum $p$ are conjugate variables. The wavefunction magnitude represents the probability of finding the particle at a given point $x\\in R^1$ is spread out like a waveform. There is no unique definite position of the particle. As the amplitude oscillates (increases and decreases), the result is a wave with an alternating amplitude. \n\n$k$ is the wave's radian spatial frequency (angular wave number) measures how rapidly the disturbance changes over a given distance at a particular point in time, $k=2\\pi/\\lambda$, where $\\lambda$ is the wavelength of the wave, and measured in radians per unit distance. Note that $(x,y,z)$, are not part of the equation because the wave's magnitude and phase are the same at every point.",
      "word_count": 719
    },
    {
      "title": "Figure 3.3: Fourier Transform of images",
      "content": "Let's demonstrate the use of R's `fft()` to calculate the 2D FT of images. Information on data \nacquisition frequency and block length (in sec) cannot be included into the `fft()` call.\n\nR generates a single 2D vector of the same dimensions as the data containing a list of complex numbers. The function `Mod(fft())` is used to extract the *magnitudes* of the Fourier coefficients, which are computed by:\n$$magnitude = \\sqrt{(real \\times real + imaginary \\times imaginary)},$$\nwhere the real and imaginary components are extracted by functions `Re(fft())` and `Im(fft())`, respectively.\n\nThe method `fft()` generates only *meaningful frequency* up to half the sampling frequency. The FT returns values of the discrete Fourier transform for both positive and negative frequencies. Although, as sampling a signal in discrete time intervals causes aliasing problems, R yields all frequencies up to the sampling frequency. For instance, sampling a *50 Hz* sine wave and *950 Hz* sine wave with *1000 Hz* will generate identical results, as the FT cannot distinguish between the two frequencies. Hence, the sampling frequency must always be at least twice as high as the expected signal frequency. For each actual frequency in the signal, the FT will give 2 peaks (one at the \"actual\" frequency and one at sampling frequency minus \"actual\" frequency). This will make the second half of the magnitude vector a mirror image of the first half.\n\nAs long as the sampling frequency is at least twice as high as the expected signal frequency, all *meaningful information* will be contained in the first half of the magnitude vector. However, a peak in the low frequency range might be present when high \"noise\" frequency is present in the signal (or image). At this point, the vector of extracted magnitudes is only indexed by the frequencies but has no associated frequencies. To calculate the corresponding frequencies, the FT simply takes (or generates) the index vector (1, 2, 3, ..., length(magnitude vector)) and divides it by the length of the data block (in sec).\n\n\nIn 1D, the phases would represent a vector of the same length as the magnitude vector with the phases (0 to $2\\pi$ or $-\\pi$ to $+\\pi$) of each frequency. Phase shifts are translations in space (e.g., x-axis) for a given wave component that are measured in angles (radians). For instance, shifting a wave $f(x)=0.5\\sin(3wt)+0.25\\sin(10wt)$ by $\\frac{\\pi}{2}$ would produce the following Fourier series:\n\n$$f(t)=0.5\\sin\\left (3wt+\\frac{\\pi}{2}\\right )+0.25\\sin\\left (10wt+\\frac{\\pi}{2}\\right ).$$\n\nIn 2D, The Fourier transform (FT/IFT) for images is defined by:\n$$\\hat{f}(u,v)=F(u,v)=\\int_{-\\infty}^{\\infty}{\\int_{-\\infty}^{\\infty}{f(x,y)e^{-i2\\pi(ux+vy)}dxdy}},$$\n$$f(x,y)=\\hat{\\hat{f}}(x,y)=\\hat{F}(x,y)=\\int_{-\\infty}^{\\infty}{\\int_{-\\infty}^{\\infty}{F(u,v)e^{i2\\pi(ux+vy)}dudv}},$$\nwhere $u$ and $v$ are the spatial frequencies, $F(u,v)=F_R(u,v)+iF_I(u,v)$ is a complex number for each pair of arguments, \n$$|F(u,v)|=\\sqrt{F_R^2(u,v)+F_I^2(u,v)}$$\nis the **magnitude** spectrum, and \n$$\\arctan\\left (\\frac{F_I(u,v)}{F_R(u,v)}\\right )$$\nis the **phase angle** spectrum.\n\nThe complex exponential\n$$e^{-i2\\pi(ux+vy)}=\\cos(2\\pi(ux+vy)) +i\\ \\sin(2\\pi(ux+vy))$$\nrepresents the real and imaginary (complex) sinusoidal terms in the 2D plane. The extrema of its real part ($\\cos(2\\pi(ux+vy))$) occurs at $2\\pi(ux+vy)=n\\pi$. Using vector notation, \n$$2\\pi(ux+vy)=2\\pi \\langle U, X \\rangle =n\\pi,$$\nwhere the extrema points $U=(u,v)^T$ and $X=(x,y)^T$ represent sets of equally spaced parallel lines with normal $U$ and wavelength $\\frac{1}{\\sqrt{u^2+v^2}}$.\n\nLet's define the index *shifting* paradigm associated with the discrete FT, which is simply used for convenience and *better visualization*. It has no other relevance to the actual calculation of the FT and its inverse, IFT.\n\nWhen applying the forward or reverse generalized discrete FT it is possible to shift the transform sampling in time and frequency domain by some real offset values, $a,b$. Symbolically,\n\n$$\\hat{f}(k) = \\sum_{n=0}^{N-1} f(n) e^{-\\frac{2 \\pi i}{N} (k+b) (n+a)} \\quad \\quad k = 0, \\dots, N-1.$$\n\n**Note:** Remember that in `R`, the array indices start with 1, not 0, as in some other languages.\n\nThe function `fftshift()` is useful for visualizing the Fourier transform with the zero-frequency component in the middle of the spectrum. Its inverse counterpart, `ifftshift()`, is needed to rearrange again the indices appropriately after the IFT is employed, so that the image is correctly reconstructed in spacetime. The FT only computes half of the frequency spectrum corresponding to the non-negative (positive and zero if the `length(f)` is odd) frequencies in order to save computation time. To preserve the dimensions of the output $\\hat{f}=FT(f)$, the second half of the frequency spectrum (the complex conjugate of the first half) is just added at the end of this vector. In a 1D setting, the result of `fft()` is:\n\n$0\\ 1\\ 2\\ 3\\ ...\\ (freq\\ bins > 0)\\ ... {\\frac{Fs}{2}}$ and $-{\\frac{Fs}{2}}\\ ... \\ (freq\\ bins < 0)\\ ...\\ -3\\ -2\\ -1.$\n\nwhere $F_s$ is the frequency sample. The `fftshift` method sets the zero-frequency component in the center of the array, i.e., it just shifts (offsets) the second part with the negative frequency bins to the beginning and the first part to the end of the resulting FT vector, or matrix. Thus, the shifted discrete FT can be *nicely* plotted in the center covering the frequency spectrum from $-{\\frac{Fs}{2}}$ on the left to ${\\frac{Fs}{2}}$ on the right. This is not necessary, but is used for better visualization aesthetics. To synthesize back the correct image, after using `fftshift` on the FT signal, we always have to undo that re-indexing by using `ifftshift()` on the inverse-FT.\n\n\nNow we will present the FT and IFT of a pair of synthetic 2D images (a square and a disk).\n\n\n\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 964
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    code_folding: hide\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "knitr::opts_chunk$set(echo = TRUE, warings = FALSE)\nlibrary(plotly)\nlibrary(dplyr)",
      "line_count": 3
    },
    {
      "section": "Figure 3.1: 1D Waves and 2D Waves",
      "code": "t <- seq(-6*pi, 6*pi, length.out=400)\nr <- 3\nx <- r * cos(t)\ny <- r * sin(t)\nz <- 2*t\nc <- t%%(2*pi)\n  \ndata1 <- data.frame(x, y, z)\n\np <- plot_ly(data1, x = ~x, y = ~y, z = ~z, type = 'scatter3d', mode = 'lines', showlegend = F,\n        line = list(width = 12, color = ~c, colorscale = list(c(0,'red'), c(1,'blue')))) %>%\n  # trace the z-axis\n  add_trace(data1, x = 0, y =0, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color = ~c, colorscale = list(c(0,'red'), c(1,'blue'))),\n            name=\"Z\", hoverinfo=\"none\") %>%\n  # add projection on plane x=-3\n  add_trace(data1, x = -3, y = ~y, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 2, dash=\"solid\", color = ~c, \n                          colorscale = list(c(0,'gray'), c(1,'black'))),\n            name=\"Z\", hoverinfo=\"none\") %>%\n  # add projection on plane y=-3\n  add_trace(data1, x = ~x, y = -3, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 2, dash=\"solid\", color = ~c, \n                          colorscale = list(c(0,'gray'), c(1,'black'))),\n            name=\"Z\", hoverinfo=\"none\") %>%\n  # add a z-line at x=-3,y=0\n  add_trace(data1, x = -3, y = 0, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 5, dash=\"solid\", color = \"gray\"),\n            name=\"Z\", hoverinfo=\"none\") %>%\n  # add a z-line at x=0,y=-3\n  add_trace(data1, x = 0, y = -3, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 5, dash=\"solid\", color = \"gray\"),\n            name=\"Z\", hoverinfo=\"none\") %>%\n  # add a x-line at y=0, z=-40\n  add_trace(data1, x = ~x, y = 0, z = -40, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 15, dash=\"solid\", color = \"gray\"),\n            name=\"Z\", hoverinfo=\"none\")\n  # add a few annotations/arrows\np",
      "line_count": 39
    },
    {
      "section": "Figure 3.1: 1D Waves and 2D Waves",
      "code": "t <- seq(-6*pi, 6*pi, length.out=400)\nr <- 3\nx <- r * cos(t)\ny <- r * sin(t)\nz <- 2*t\nc <- t%%(2*pi)\n\ndata1 <- data.frame(x, y, z)\n\nscene = list(camera = list(eye = list(x = -1.25, y = 1.25, z = 1.25)),\n             aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=5))\n# define wave opacity as a parabola\nconst <- 1/(z[400]^2)\nwave_opacity <- 0.3 -(0.7*const)*(z-z[1])*(z-z[400])\n# plot(wave_opacity, type = \"l\")\nplot_ly(x = ~z, y = ~wave_opacity, type = 'scatter', mode = 'lines')\n\n\n# bgcolor = toRGB(\"white\", alpha = 0),\n# cols = sample(grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)], 400)\n# cols_func <- colorRampPalette(c(\"blue\", \"red\")); cols <- cols_func(400)\n                         \n# plot_ly(data1, x = ~x, y = ~y, z = ~z, type = 'scatter3d', mode = 'lines', showlegend = F,\n#         line = list(width = 40, color = toRGB(cols, alpha = wave_opacity)))\n\np <- \n  plot_ly(data1, x = ~x, y = ~y, z = ~z, type = 'scatter3d', mode = 'lines', showlegend = F,\n          line = list(width = 40, color = ~c, colorscale = list(c(0,'red'), c(1,'blue')),\n                    alpha = wave_opacity)) %>%\n  # trace the z-axis\n  add_trace(data1, x = 0, y =0, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color = ~c, colorscale = list(c(0,'red'), c(1,'blue'))),\n            name=\"Z\", hoverinfo=\"none\") %>%\n  # add projection on plane x=-3\n  add_trace(data1, x = -3, y = ~y, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 2, dash=\"solid\", color = ~c, \n                          colorscale = list(c(0,'gray'), c(1,'black'))),\n            name=\"Z\", hoverinfo=\"none\") %>%\n  # add projection on plane y=-3\n  add_trace(data1, x = ~x, y = -3, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 2, dash=\"solid\", color = ~c, \n                          colorscale = list(c(0,'gray'), c(1,'black'))),\n            name=\"Z\", hoverinfo=\"none\") %>%\n  # add a z-line at x=-3,y=0\n  add_trace(data1, x = -3, y = 0, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 5, dash=\"solid\", color = \"gray\"),\n            name=\"Z\", hoverinfo=\"none\") %>%\n  # add a z-line at x=0,y=-3\n  add_trace(data1, x = 0, y = -3, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 5, dash=\"solid\", color = \"gray\"),\n            name=\"Z\", hoverinfo=\"none\") %>%\n  # add a x-line at y=0, z=-40\n  add_trace(data1, x = ~x, y = 0, z = -40, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 15, dash=\"solid\", color = \"gray\"),\n            name=\"Z\", hoverinfo=\"none\") %>%\n  layout(scene = scene)\n  # add a few annotations/arrows\np",
      "line_count": 58
    },
    {
      "section": "Figure 3.3: Fourier Transform of images",
      "code": "# FFT SHIFT\nfftshift <- function(img_ff, dim = -1) {\n  rows <- dim(img_ff)[1]    \n  cols <- dim(img_ff)[2]\n  # planes <- dim(img_ff)[3]\n\n  swap_up_down <- function(img_ff) {\n    rows_half <- ceiling(rows/2)\n    return(rbind(img_ff[((rows_half+1):rows), (1:cols)], img_ff[(1:rows_half), (1:cols)]))\n  }\n\n  swap_left_right <- function(img_ff) {\n    cols_half <- ceiling(cols/2)\n    return(cbind(img_ff[1:rows, ((cols_half+1):cols)], img_ff[1:rows, 1:cols_half]))\n  }\n  \n  #swap_side2side <- function(img_ff) {\n  #  planes_half <- ceiling(planes/2)\n  #  return(cbind(img_ff[1:rows, 1:cols, ((planes_half+1):planes)], img_ff[1:rows, 1:cols, 1:planes_half]))\n  #}\n\n  if (dim == -1) {\n    img_ff <- swap_up_down(img_ff)\n    return(swap_left_right(img_ff))\n  }\n  else if (dim == 1) {\n    return(swap_up_down(img_ff))\n  }\n  else if (dim == 2) {\n    return(swap_left_right(img_ff))\n  }\n  else if (dim == 3) {\n    # Use the `abind` package to bind along any dimension a pair of multi-dimensional arrays\n    # install.packages(\"abind\")\n    library(abind)\n    \n    planes <- dim(img_ff)[3]\n    rows_half <- ceiling(rows/2)\n    cols_half <- ceiling(cols/2)\n    planes_half <- ceiling(planes/2)\n    \n    img_ff <- abind(img_ff[((rows_half+1):rows), (1:cols), (1:planes)], \n                    img_ff[(1:rows_half), (1:cols), (1:planes)], along=1)\n    img_ff <- abind(img_ff[1:rows, ((cols_half+1):cols), (1:planes)], \n                    img_ff[1:rows, 1:cols_half, (1:planes)], along=2)\n    img_ff <- abind(img_ff[1:rows, 1:cols, ((planes_half+1):planes)], \n                    img_ff[1:rows, 1:cols, 1:planes_half], along=3)\n    return(img_ff)\n  }\n  else {\n    stop(\"Invalid dimension parameter\")\n  }\n}\n\nifftshift <- function(img_ff, dim = -1) {\n\n  rows <- dim(img_ff)[1]    \n  cols <- dim(img_ff)[2]    \n\n  swap_up_down <- function(img_ff) {\n    rows_half <- floor(rows/2)\n    return(rbind(img_ff[((rows_half+1):rows), (1:cols)], img_ff[(1:rows_half), (1:cols)]))\n  }\n\n  swap_left_right <- function(img_ff) {\n    cols_half <- floor(cols/2)\n    return(cbind(img_ff[1:rows, ((cols_half+1):cols)], img_ff[1:rows, 1:cols_half]))\n  }\n\n  if (dim == -1) {\n    img_ff <- swap_left_right(img_ff)\n    return(swap_up_down(img_ff))\n  }\n  else if (dim == 1) {\n    return(swap_up_down(img_ff))\n  }\n  else if (dim == 2) {\n    return(swap_left_right(img_ff))\n  }\n  else if (dim == 3) {\n    # Use the `abind` package to bind along any dimension a pair of multi-dimensional arrays\n    # install.packages(\"abind\")\n    library(abind)\n    \n    planes <- dim(img_ff)[3]\n    rows_half <- floor(rows/2)\n    cols_half <- floor(cols/2)\n    planes_half <- floor(planes/2)\n    \n    img_ff <- abind(img_ff[1:rows, 1:cols, ((planes_half+1):planes)], \n                    img_ff[1:rows, 1:cols, 1:planes_half], along=3)\n    img_ff <- abind(img_ff[1:rows, ((cols_half+1):cols), (1:planes)], \n                    img_ff[1:rows, 1:cols_half, (1:planes)], along=2)\n    img_ff <- abind(img_ff[((rows_half+1):rows), (1:cols), (1:planes)], \n                    img_ff[(1:rows_half), (1:cols), (1:planes)], along=1)\n    return(img_ff)\n  }\n  else {\n    stop(\"Invalid dimension parameter\")\n  }\n}",
      "line_count": 101
    },
    {
      "section": "Figure 3.3: Fourier Transform of images",
      "code": "library(imager)\n\n# install EBImage\n# source(\"https://bioconductor.org/biocLite.R\")\n# biocLite(\"EBImage\")\nlibrary(EBImage)",
      "line_count": 6
    },
    {
      "section": "Figure 3.3: Fourier Transform of images",
      "code": "# Define two synthetic images\nsquare_arr <- matrix(nrow=256, ncol=256)\ncircle_arr <- matrix(nrow=256, ncol=256)\n\nfor (i in 1:256) {\n  for (j in 1:256) {\n    if ( abs(i-128) < 30 && abs(j-128) < 30) \n      square_arr[i,j]=1 # sqrt((i-128)^2+(j-128)^2)/30\n    else square_arr[i,j]=0\n    if ( sqrt((i-128)^2 + (j-128)^2)<30) \n      circle_arr[i,j]=1 # 1-sqrt((i-128)^2+(j-128)^2)/30\n    else circle_arr[i,j]=0\n  }\n}\n# image(square_arr); image(circle_arr)\n# display(square_arr, method = \"raster\"); display(circle_arr, method = \"raster\")\n\n# download.file(\"https://wiki.socr.umich.edu/images/e/ea/BrainCortex2.png\",\n#              paste(getwd(),\"./image.png\", sep=\"/\"), mode = 'wb')\t\n# im <- load.image(paste(getwd(),\"./image.png\", sep=\"/\"))\t\n# plot(im)\t\n# Grayscaled\n# img_gray <- im[ , , 1]\n# display(img_gray, title='Image')\n\n\n# FFT\n# img_ff <- fft(img_gray) #fftw2d\nft_square <- fft(square_arr) #fftw2d # Display Re(FT): display(fftshift(ft_square))\nft_circle <- fft(circle_arr)  # display(fftshift(ft_circle))\n\n# Magnitude and Phase\nmag_ft_square <- sqrt(Re(ft_square)^2+Im(ft_square)^2)\nmag_ft_circle <- sqrt(Re(ft_circle)^2+Im(ft_circle)^2)\n\n# Phase  <- atan(Im(img_ff)/Re(img_ff))\nphase_ft_square  <- atan2(Im(ft_square), Re(ft_square))\nphase_ft_circle  <- atan2(Im(ft_circle), Re(ft_circle))\n\n# FFT SHIFT\nshift_ft_square <- fftshift(mag_ft_square)\nshift_ft_circle <- fftshift(mag_ft_circle)\n\n# Display FT\ndisplay(log(shift_ft_square),title=\"FT Magnitude\")\ndisplay(log(shift_ft_circle),title=\"FT Phase\")\n\n\n# Magnitude and Phase\nmag_shift_ft_square <- sqrt(Re(shift_ft_square)^2+Im(shift_ft_square)^2)\n# phase  <- atan(Im(img_ff)/Re(img_ff))\nphase_ft_square  <- atan2(Im(ft_square), Re(ft_square))\ndisplay(fftshift(phase_ft_square))\n\nphase_ft_circle  <- atan2(Im(ft_circle), Re(ft_circle))\ndisplay(fftshift(phase_ft_circle))\n\n# Implicitly invert the FT (IFT)\nfftinv <- function( x ) { fft( x, inverse=TRUE ) / length( x ) }\ndisplay(Re(fftinv(fft(square_arr))),title=\"(IFT o FT) Magnitude\")\ndisplay(Re(fftinv(fft(circle_arr))),title=\"(IFT o FT) Magnitude\")\n\n# FT of Square  # Display the FT with a shift or not: display(fftshift(Re(X1))\nX1 = fft(square_arr); display(fftshift(Re(X1)), method = \"raster\")\nX1_mag <- sqrt(Re(X1)^2+Im(X1)^2); display(fftshift(X1_mag), method = \"raster\") # magnitude only\nX1_phase  <- atan2(Im(X1), Re(X1)); display(fftshift(X1_phase), method = \"raster\") # phase only\n\n#  Implicit Automated IFT\nhat_X1 = Re(fft(X1, inverse = T)/length(square_arr))\ndisplay(hat_X1, method = \"raster\")  \n\n# Manually invert the FT (IFT) using the magnitudes and phases\nReal1 = X1_mag * cos(X1_phase)\nImaginary1 = X1_mag * sin(X1_phase)\nman_hat_X1 = Re(fft(Real1+1i*Imaginary1, inverse = T)/length(X1))\ndisplay(man_hat_X1, method = \"raster\")  \n\n# FT of Circle # No shift applied here (perhaps should be consistent or just show the difference?)\nX2 = fft(circle_arr)\ndisplay(Re(X2), method = \"raster\")\n\nX2_mag <- sqrt(Re(X2)^2+Im(X2)^2)\ndisplay(X2_mag, method = \"raster\") # magnitude only\n\nX2_phase  <- atan2(Im(X2), Re(X2))\ndisplay(X2_phase, method = \"raster\") # phase only\n\n#  Implicit Automated IFT\n# hat_X2 = Re(fft(X2, inverse = T)/length(circle_arr)); display(hat_X2, method = \"raster\") \n# Manually invert the FT (IFT) using the magnitudes and phases\nReal2 = X2_mag * cos(X2_phase)\nImaginary2 = X2_mag * sin(X2_phase)\nman_hat_X2 = Re(fft(Real2+1i*Imaginary2, inverse = T)/length(X1))\ndisplay(man_hat_X2, method = \"raster\")  \n\n# IFT Square-Magnitude and Circle-Phase\nReal = X1_mag * cos(X2_phase)\nImaginary = X1_mag * sin(X2_phase)\nift_X1mag_X2phase = Re(fft(Real+1i*Imaginary, inverse = T)/length(X1))\ndisplay(ift_X1mag_X2phase, method = \"raster\")\n\n# IFT Circle-Magnitude and Square-Phase\nReal = X2_mag * cos(X1_phase)\nImaginary = X2_mag * sin(X1_phase)\nift_X1phase_X2mag = Re(fft(Real+1i*Imaginary, inverse = T)/length(X1))\ndisplay(ift_X1phase_X2mag, method = \"raster\")\n\n# IFT Circle-Magnitude and Nil-Phase\nReal = X2_mag * cos(0)\nImaginary = X2_mag * sin(0)\nift_NilPhase_X2mag = Re(ifftshift(fft(Real+1i*Imaginary, inverse = T)/length(X2)))\ndisplay(ift_NilPhase_X2mag, method = \"raster\")\n\n# IFT Square-Magnitude and Nil-Phase\nReal = X1_mag * cos(0)\nImaginary = X1_mag * sin(0)\nift_NilPhase_X1mag = Re(ifftshift(fft(Real+1i*Imaginary, inverse = T)/length(X1)))\ndisplay(ift_NilPhase_X1mag, method = \"raster\")",
      "line_count": 118
    }
  ]
}