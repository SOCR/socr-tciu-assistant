{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.265567",
    "total_sections": 3,
    "total_code_chunks": 8,
    "total_tables": 1,
    "r_libraries": [
      "abind",
      "arm",
      "circular",
      "doParallel",
      "forecast",
      "glmnet",
      "knitr",
      "magrittr",
      "plotly"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Spacekime Analytics (Time Complexity and Inferential Uncertainty)\"\nsubtitle: \"Exegeneous Feature Time-series analysis\"\nauthor: \"SOCR Team \"\ndate: \"`r format(Sys.time(),'%m/%d/%Y')`\"\noutput: \n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n      smooth_scroll: true",
      "word_count": 41
    },
    {
      "title": "Background",
      "content": "The function `fftshift()` is useful for visualizing the Fourier transform with the zero-frequency component in the middle of the spectrum. Its inverse counterpart, `ifftshift()`, is needed to rearrange again the indices appropriately after the IFT is employed, so that the image is correctly reconstructed in spacetime. The FT only computes half of the frequency spectrum corresponding to the non-negative (positive and zero if the `length(f)` is odd) frequencies in order to save computation time. To preserve the dimensions of the output $\\hat{f}=FT(f)$, the second half of the frequency spectrum (the complex conjugate of the first half) is just added at the end of this vector. In a 1D setting, the result of `fft()` is:\n\n$0\\ 1\\ 2\\ 3\\ ...\\ (freq\\ bins > 0)\\ ... {\\frac{Fs}{2}}$ and $-{\\frac{Fs}{2}}\\ ... \\ (freq\\ bins < 0)\\ ...\\ -3\\ -2\\ -1.$\n\nwhere $F_s$ is the frequency sample. The `fftshift` method sets the zero-frequency component in the center of the array, i.e., it just shifts (offsets) the second part with the negative frequency bins to the beginning and the first part to the end of the resulting FT vector, or matrix. Thus, the shifted discrete FT can be *nicely* plotted in the center covering the frequency spectrum from $-{\\frac{Fs}{2}}$ on the left to ${\\frac{Fs}{2}}$ on the right. This is not necessary, but is used for better visualization aesthetics. To synthesize back the correct image, after using `fftshift` on the FT signal, we always have to undo that re-indexing by using `ifftshift()` on the inverse-FT.",
      "word_count": 249
    },
    {
      "title": "Exegeneous Feature Time-series analysis",
      "content": "We can use the [UCI ML Air Quality Dataset](https://archive.ics.uci.edu/ml/datasets/Air+quality) to demonstrate the effect of kime-direction on the analysis of the longitudinal data. The *Air Quality data* consists of $9358$ hourly-averaged responses from an array of 5 sensors embedded in an Air Quality Chemical Multisensor Device. These measurements were obtained in a significantly polluted area during a one year period (March 2004 to February 2005). The features include Concentrations for CO, Non Metanic Hydrocarbons, Benzene, Total Nitrogen Oxides (NOx), and Nitrogen Dioxide (NO2). \n\nThe attributes in the CSV file include:\n\n* Date (DD/MM/YYYY)\n* Time (HH.MM.SS)\n* True hourly averaged concentration CO in mg/m^3 (reference analyzer)\n* PT08.S1 (tin oxide) hourly averaged sensor response (nominally CO targeted)\n* True hourly averaged overall Non Metanic Hydro-carbons concentration in microg/m^3 (reference analyzer)\n* True hourly averaged Benzene concentration in microg/m^3 (reference analyzer)\n* PT08.S2 (Titania) hourly averaged sensor response (nominally NMHC targeted)\n* True hourly averaged NOx concentration in ppb (reference analyzer)\n* PT08.S3 (tungsten oxide) hourly averaged sensor response (nominally NOx targeted)\n* True hourly averaged NO2 concentration in microg/m^3 (reference analyzer)\n* PT08.S4 (tungsten oxide) hourly averaged sensor response (nominally NO2 targeted)\n* PT08.S5 (indium oxide) hourly averaged sensor response (nominally O3 targeted)\n* Temperature in ?C\n* Relative Humidity (%)\n* AH Absolute Humidity\n\n\nWe can first explore the time-course harmonics of the data.\n\n\n## Kime-Phases Circular distribution plots\n\n\nThere is a key difference between spacekime data analytics and spacetime data modeling and inference. This contrast is based on the fact that in spacetime, statistical results are obtained by aggregating repeated (IID) dataset samples or measuring identical replicate cohorts under identical conditions. In spacekime, reliable inference can be made on a single sample, if the kime direction angles are known. Indeed the latter are generally no observable, however, they can be estimated, inferred, or approximated. As the FT and IFT are linear functionals, addition, averaging and multiplication by constants are preserved by the forward and inverse Fourier transforms. Therefore, if we have a number of phase estimates in k-space, we can aggregate these (e.g., by averaging them) and use the resulting *assemblage phase* to synthesize the data in spacekime. If the composite phases are indeed representative of the process kime orientation, then the reconstructed spacekime inference is expected to be valid even if we used a single sample. In a way, spacekime inference allows a dual representation of the [central limit theorem](http://www.amstat.org/publications/jse/v16n2/dinov.html), which guarantees the convergence of sample averages to their corresponding population mean counterparts.\n\nIn light of this *analytics duality*, we can now perform a [traditional ARIMA modeling](http://www.socr.umich.edu/people/dinov/courses/DSPA_notes/18_BigLongitudinalDataAnalysis.html#17_autoregressive_integrated_moving_average_extended_(arimax)_model) of `CO` concentration (*outcome*: `PT08.S1.CO.`) based on several covariates, e.g., *predictors*: `NMHC.GT.`, `C6H6.GT.`, `PT08.S2.NMHC.`, `NOx.GT.`, `PT08.S3.NOx.`, `NO2.GT.`, `PT08.S4.NO2.`, `PT08.S5.O3.`, `T`, `RH`, and `AH`.\n\n\nAn alternative data analytic approach involves using the Fourier transform applied to the complete 2D data-matrix (rows=time, columns=features), inverting it back in spacetime, and investigating the effect of the timeseries analysis *with* and *without* using the correct kime-directions (phases). Knowing the kime-directions is expected to produce better analytical results (e.g., lower bias and lower dispersion).\n\n\n\n\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"http://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"http://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"http://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 602
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    code_folding: hide\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "knitr::opts_chunk$set(echo = TRUE, warings = FALSE)",
      "line_count": 1
    },
    {
      "section": "Main",
      "code": "\n# Get this figure: fig <- get_figure(\"MattSundquist\", 4064)\n# Get this figure's data: data <- get_figure(\"MattSundquist\", 4064)$data\n# Add data to this figure: p <- add_trace(p, x=c(4, 5), y=c(4, 5), kwargs=list(filename=\"Klein bottle\", fileopt=\"extend\"))\n# Get y data of first trace: y1 <- get_figure(\"MattSundquist\", 4064)$data[[1]]$y\n\nlibrary(plotly)",
      "line_count": 7
    },
    {
      "section": "Background",
      "code": "# FFT SHIFT\nfftshift <- function(img_ff, dim = -1) {\n\n  rows <- dim(img_ff)[1]    \n  cols <- dim(img_ff)[2]\n  # planes <- dim(img_ff)[3]\n\n  swap_up_down <- function(img_ff) {\n    rows_half <- ceiling(rows/2)\n    return(rbind(img_ff[((rows_half+1):rows), (1:cols)], img_ff[(1:rows_half), (1:cols)]))\n  }\n\n  swap_left_right <- function(img_ff) {\n    cols_half <- ceiling(cols/2)\n    return(cbind(img_ff[1:rows, ((cols_half+1):cols)], img_ff[1:rows, 1:cols_half]))\n  }\n  \n  #swap_side2side <- function(img_ff) {\n  #  planes_half <- ceiling(planes/2)\n  #  return(cbind(img_ff[1:rows, 1:cols, ((planes_half+1):planes)], img_ff[1:rows, 1:cols, 1:planes_half]))\n  #}\n\n  if (dim == -1) {\n    img_ff <- swap_up_down(img_ff)\n    return(swap_left_right(img_ff))\n  }\n  else if (dim == 1) {\n    return(swap_up_down(img_ff))\n  }\n  else if (dim == 2) {\n    return(swap_left_right(img_ff))\n  }\n  else if (dim == 3) {\n    # Use the `abind` package to bind along any dimension a pair of multi-dimensional arrays\n    # install.packages(\"abind\")\n    library(abind)\n    \n    planes <- dim(img_ff)[3]\n    rows_half <- ceiling(rows/2)\n    cols_half <- ceiling(cols/2)\n    planes_half <- ceiling(planes/2)\n    \n    img_ff <- abind(img_ff[((rows_half+1):rows), (1:cols), (1:planes)], \n                    img_ff[(1:rows_half), (1:cols), (1:planes)], along=1)\n    img_ff <- abind(img_ff[1:rows, ((cols_half+1):cols), (1:planes)], \n                    img_ff[1:rows, 1:cols_half, (1:planes)], along=2)\n    img_ff <- abind(img_ff[1:rows, 1:cols, ((planes_half+1):planes)], \n                    img_ff[1:rows, 1:cols, 1:planes_half], along=3)\n    return(img_ff)\n  }\n  else {\n    stop(\"Invalid dimension parameter\")\n  }\n}\n\nifftshift <- function(img_ff, dim = -1) {\n\n  rows <- dim(img_ff)[1]    \n  cols <- dim(img_ff)[2]    \n\n  swap_up_down <- function(img_ff) {\n    rows_half <- floor(rows/2)\n    return(rbind(img_ff[((rows_half+1):rows), (1:cols)], img_ff[(1:rows_half), (1:cols)]))\n  }\n\n  swap_left_right <- function(img_ff) {\n    cols_half <- floor(cols/2)\n    return(cbind(img_ff[1:rows, ((cols_half+1):cols)], img_ff[1:rows, 1:cols_half]))\n  }\n\n  if (dim == -1) {\n    img_ff <- swap_left_right(img_ff)\n    return(swap_up_down(img_ff))\n  }\n  else if (dim == 1) {\n    return(swap_up_down(img_ff))\n  }\n  else if (dim == 2) {\n    return(swap_left_right(img_ff))\n  }\n  else if (dim == 3) {\n    # Use the `abind` package to bind along any dimension a pair of multi-dimensional arrays\n    # install.packages(\"abind\")\n    library(abind)\n    \n    planes <- dim(img_ff)[3]\n    rows_half <- floor(rows/2)\n    cols_half <- floor(cols/2)\n    planes_half <- floor(planes/2)\n    \n    img_ff <- abind(img_ff[1:rows, 1:cols, ((planes_half+1):planes)], \n                    img_ff[1:rows, 1:cols, 1:planes_half], along=3)\n    img_ff <- abind(img_ff[1:rows, ((cols_half+1):cols), (1:planes)], \n                    img_ff[1:rows, 1:cols_half, (1:planes)], along=2)\n    img_ff <- abind(img_ff[((rows_half+1):rows), (1:cols), (1:planes)], \n                    img_ff[(1:rows_half), (1:cols), (1:planes)], along=1)\n    return(img_ff)\n  }\n  else {\n    stop(\"Invalid dimension parameter\")\n  }\n}",
      "line_count": 102
    },
    {
      "section": "Exegeneous Feature Time-series analysis",
      "code": "aqi_data <- read.csv(\"https://umich.instructure.com/files/8208336/download?download_frd=1\")\nsummary(aqi_data)\n\naqi_data.ts <- ts(aqi_data, start=c(2004,3), freq=24) # hourly sampling rate\n\ndateTime <- as.POSIXct(paste(aqi_data$Date, aqi_data$Time), format=\"%m/%d/%Y %H:%M:%S\")\n\n# set up training and testing time-periods\nalltrain.ts <- window(aqi_data.ts, end=c(2004,3))\nallvalid.ts <- window(aqi_data.ts, start=c(2005,1))\n\n# Estimate the ARIMAX model\nlibrary(forecast)\nfitArimaX <- auto.arima(aqi_data$CO.GT., xreg= as.matrix(aqi_data[ , \n                                  c(\"PT08.S1.CO.\", \"NMHC.GT.\", \"C6H6.GT.\", \"PT08.S2.NMHC.\",\n                                    \"NOx.GT.\", \"PT08.S3.NOx.\", \"NO2.GT.\", \"PT08.S4.NO2.\",\n                                    \"PT08.S5.O3.\", \"T\", \"RH\", \"AH\")]))\nfitArimaX\n\n# Predict prospective CO concentration\npred_length <- 24*30 # 1 month forward forecasting\npredArrivals <- predict(fitArimaX, n.ahead = pred_length, \n                        newxreg = aqi_data[c((9471-pred_length+1):9471), c(4:15)])\n#plot(predArrivals$pred, main=\"Forward time-series predictions (fitArimaX)\")\nplot(forecast(fitArimaX, xreg = as.matrix(aqi_data[c((9471-pred_length+1):9471), c(4:15)])))\n\nlibrary(plotly)\nlibrary(magrittr)\n# generate date sequence\narimaForecast <- forecast(fitArimaX, xreg = as.matrix(aqi_data[c((9471-pred_length+1):9471), c(4:15)]))\nstr(arimaForecast )\n\nplot_ly(x=~dateTime, y=~arimaForecast$fitted, \n                  name=\"ARIMA Model\", type = \"scatter\", mode='lines+markers')  \n\n# Figure 6.9 ================================================\n# aqi_data[is.na(aqi_data)] <- 0\n# y     <- aqi_data$PT08.S1.CO.\n# t     <- 1:dim(aqi_data)[1]\n# # range <- diff(range(y))\n# \n# # Compute the spectral decomposition (harmonics)\n# ff_harmonicsPlotLy = function(x=NULL, n=NULL, up=10L, plot=TRUE, add=F, main=NULL, ...) {\n#   # The discrete Fourier transformation\n#   dff = fft(x)\n#   # time\n#   t = seq(from = 1, to = length(x))\n#   \n#   # Upsampled time\n#   nt = seq(from = 1, to = length(x)+1-1/up, by = 1/up)\n#  \n#   #New spectrum\n#   ndff = array(data = 0, dim = c(length(nt), 1L))\n#   ndff[1] = dff[1] # mean, DC component\n#   if(n != 0){\n#     ndff[2:(n+1)] = dff[2:(n+1)] # positive frequencies come first\n#     ndff[length(ndff):(length(ndff) - n + 1)] = dff[length(x):(length(x) - n + 1)] # negative frequencies\n#   }\n#   \n#   # Invert the FT\n#   indff = fft(ndff/length(y), inverse = TRUE)\n#   idff = fft(dff/length(y), inverse = TRUE)\n#   if(plot){\n#     plot(x = dateTime, y = x, pch = 16L, xlab = \"Time\", ylab = \"Measurement\", \n#           col = rgb(red = 0.5, green = 0.5, blue = 0.5, alpha = 0.5),\n#           main = ifelse(is.null(main), paste(n, \"harmonics\"), main))\n#       lines(y = Mod(idff), x = dateTime, col = adjustcolor(1L, alpha = 0.5))\n#     \n#       plot_ly(x=~dateTime, y=~x, name=\"ARIMA Model\", type = \"scatter\", mode='lines+markers')  %>%\n#         add_trace(x=~dateTime, y =~ Mod(idff), \n#             name=\"First 3 Harmonics Model\",\n#             type = \"scatter\", mode='lines+markers') %>%\n#         layout(title = \"Air Quality with First 3 Harmonics Model\")\n#   }\n#   ret = data.frame(time = dateTime, y = Mod(indff))\n#   return(ret)\n# }\n# \n# # Apply ff_harmonics to the timeseries as x, specifying the number of harmonics (n) and \n# #      the upsampling (so we plot points in time beside the original ones)\n# result = ff_harmonicsPlotLy(x = y, n = 12L, up = 100L, col = 2L, lwd=3, cex=2)\n",
      "line_count": 82
    },
    {
      "section": "Exegeneous Feature Time-series analysis",
      "code": "aqi_data[is.na(aqi_data)] <- 0\ny     <- aqi_data$PT08.S1.CO.\nt     <- 1:dim(aqi_data)[1]\n# range <- diff(range(y))\n\n# Compute the spectral decomposition (harmonics)\nff_harmonics = function(x=NULL, n=NULL, up=10L, plot=TRUE, add=F, main=NULL, ...) {\n  # The discrete Fourier transformation\n  dff = fft(x)\n  # time\n  t = seq(from = 1, to = length(x))\n  \n  # Upsampled time\n  nt = seq(from = 1, to = length(x)+1-1/up, by = 1/up)\n \n  #New spectrum\n  ndff = array(data = 0, dim = c(length(nt), 1L))\n  ndff[1] = dff[1] # mean, DC component\n  if(n != 0){\n    ndff[2:(n+1)] = dff[2:(n+1)] # positive frequencies come first\n    ndff[length(ndff):(length(ndff) - n + 1)] = dff[length(x):(length(x) - n + 1)] # negative frequencies\n  }\n  \n  # Invert the FT\n  indff = fft(ndff/length(y), inverse = TRUE)\n  idff = fft(dff/length(y), inverse = TRUE)\n  if(plot){\n    if(!add){\n      plot(x = t, y = x, pch = 16L, xlab = \"Time\", ylab = \"Measurement\", \n          col = rgb(red = 0.5, green = 0.5, blue = 0.5, alpha = 0.5),\n          main = ifelse(is.null(main), paste(n, \"harmonics\"), main))\n      lines(y = Mod(idff), x = t, col = adjustcolor(1L, alpha = 0.5))\n    }\n    lines(y = Mod(indff), x = nt, ...)\n  }\n  ret = data.frame(time = nt, y = Mod(indff))\n  return(ret)\n}\n\n# Apply ff_harmonics to the timeseries as x, specifying the number of harmonics (n) and \n#      the upsampling (so we plot points in time beside the original ones)\nresult = ff_harmonics(x = y, n = 12L, up = 100L, col = 2L, lwd=3, cex=2)\n\n# We can add the fourth-to-twelveth harmonics and look at their sum (as a series difference, 12-3)\nadd4to12_harmonics = ff_harmonics(x = y, n = 12L, up = 10L, col = 2L, plot = FALSE)\nadd4to12_harmonics$y <- add4to12_harmonics$y - ff_harmonics(x = y, n = 3L, up = 10L, plot = T, col = 2L, lwd=3)$y\nplot(add4to12_harmonics, pch = 16L, xlab = \"Time\", ylab = \"Measurement\", \n     main = \"Sum of all harmonics up to order 12\", type = \"l\", col = 2)\n\n# Harmonics plot of multiple frequencies (waves) in different colors\ncolors = rainbow(14, alpha = 0.6)\n# ff_harmonics(x = y, n = 28L, up = 100L, col = colors[1], add=T)\nfor(i in 1:14){\n  ad = ifelse(i == 1, FALSE, TRUE)\n  ff_harmonics(x = y, n = i, up = 100L, col = colors[i], add = ad, \n               lwd= 3, main = \"All waves up to 14th harmonic\")\n}\n",
      "line_count": 58
    },
    {
      "section": "Exegeneous Feature Time-series analysis",
      "code": "# install.packages(\"circular\")\nlibrary(\"circular\")\nset.seed(1234)\nx <- rvonmises(n=1000, mu=circular(pi/5), kappa=3)\ny <- rvonmises(n=1000, mu=circular(-pi/3), kappa=5)\nz <- rvonmises(n=1000, mu=circular(0), kappa=10)\nresx <- density(x, bw=25)\nres <- plot(resx, points.plot=TRUE, xlim=c(-1.5,1), ylim=c(-1.1, 1.5), offset=1.1, shrink=1.2, lwd=3)\nresy <- density(y, bw=25)\nlines(resy, points.plot=TRUE, col=2, points.col=2, plot.info=res, offset=1.1, shrink=1.45, lwd=3)\nresz <- density(z, bw=25)\nlines(resz, points.plot=TRUE, col=3, points.col=3, plot.info=res, offset=1.1, shrink=1.2, lwd=3)\n",
      "line_count": 13
    },
    {
      "section": "Exegeneous Feature Time-series analysis",
      "code": "dim(aqi_data)\nepochs_aqi_data <- as.matrix(aqi_data[c(1:9000) , -c(1:3, 16:17)])\nis.matrix(epochs_aqi_data); dim(epochs_aqi_data)\ndim(epochs_aqi_data) <- c(9, 1000, 12)\ndim(epochs_aqi_data); identical(epochs_aqi_data[9, 1000, 12], aqi_data[9000, 12+3])\nepochs_aqi_data_1 <- epochs_aqi_data[1, , ]; dim(epochs_aqi_data_1)\n\n# 1D timeseries FFT SHIFT\nfftshift1D <- function(img_ff) {\n  rows <- length(img_ff)   \n  rows_half <- ceiling(rows/2)\n  return(append(img_ff[(rows_half+1):rows], img_ff[1:rows_half]))\n}\n\n# 1. Transform all 9 signals to k-space (Fourier domain)\nx1 <- c(1:1000)\nFT_epochs_aqi_data <- array(complex(), c(9, 1000, 12))\nmag_FT_epochs_aqi_data <- array(complex(), c(9, 1000, 12))\nphase_FT_epochs_aqi_data <- array(complex(), c(9, 1000, 12))\nfor (i in 1:9) {\n  FT_epochs_aqi_data[i, , ] <- fft(epochs_aqi_data[i, , ])\n  X2 <- FT_epochs_aqi_data[i, , ]\n  # plot(fftshift1D(log(Re(X2)+2)), main = \"log(fftshift1D(Re(FFT(timeseries))))\") \n  mag_FT_epochs_aqi_data[i, , ] <- sqrt(Re(X2)^2+Im(X2)^2); \n  # plot(log(fftshift1D(Re(X2_mag))), main = \"log(Magnitude(FFT(timeseries)))\") \n  phase_FT_epochs_aqi_data[i, , ] <- atan2(Im(X2), Re(X2)); \n  # plot(fftshift1D(X2_phase), main = \"Shift(Phase(FFT(timeseries)))\")\n}\n\n### Test the process to confirm calculations\n# X2<-FT_epochs_aqi_data[1,,];X2_mag<-mag_FT_epochs_aqi_data[1,,];X2_phase<-phase_FT_epochs_aqi_data[1,,]\n# Real2 = X2_mag * cos(X2_phase)\n# Imaginary2 = X2_mag * sin(X2_phase)\n# man_hat_X2 = Re(fft(Real2 + 1i*Imaginary2, inverse = T)/length(X2))\n# ifelse(abs(man_hat_X2[5,10] - epochs_aqi_data[1, 5, 10]) < 0.001, \"Perfect Syntesis\", \"Problems!!!\")\n#######\n\n# 2. Invert back to spacetime the epochs_aqi_data_1 signal with nil phase\nReal = mag_FT_epochs_aqi_data[1, , ] * cos(0)  # cos(phase_FT_epochs_aqi_data[1, , ])\nImaginary = mag_FT_epochs_aqi_data[1, , ] * sin(0)   # sin(phase_FT_epochs_aqi_data[1, , ])\nift_NilPhase_X2mag = Re(fft(Real+1i*Imaginary, inverse = T)/length(FT_epochs_aqi_data[1,,]))\n# display(ift_NilPhase_X2mag, method = \"raster\")\n# dim(ift_NilPhase_X2mag); View(ift_NilPhase_X2mag); # compare to View(epochs_aqi_data[1, , ])\n\n# 3. Perform ARIMAX modeling of ift_NilPhase_X2mag; report (p,d,q) params and quality metrics AIC/BIC\nlibrary(forecast)\nfitArimaX_nil <- auto.arima(ift_NilPhase_X2mag[ , 1], xreg= ift_NilPhase_X2mag[ , 2:12])\nfitArimaX_nil\n\n# Regression with ARIMA(2,0,1) errors \n#Coefficients:\n#         ar1      ar2      ma1  intercept    xreg1   xreg2    xreg3   xreg4   xreg5   xreg6   xreg7   xreg8\n#      1.1141  -0.1457  -0.7892   503.3455  -0.4028  0.1366  -0.5146  1.0961  1.2195  1.3063  1.2087  1.1491\n#s.e.  0.2064   0.1571   0.1821    73.4212   0.1087  0.1123   0.1072  0.1059  0.1029  0.1564  0.1023  0.1101\n#        xreg9  xreg10   xreg11\n#      -0.4823  0.0315  -0.4640\n#s.e.   0.1049  0.1125   0.1076\n# sigma^2 estimated as 30448:  log likelihood=-6573.68 AIC=13179.36   AICc=13179.91   BIC=13257.88\n\n# Predict prospective CO concentration\npred_length <- 24*7 # 1 week forward forecasting\npredArrivals <- predict(fitArimaX_nil, n.ahead = pred_length, newxreg = ift_NilPhase_X2mag[800:1000, 2:12])\n#plot(predArrivals$pred, main=\"Forward time-series predictions (fitArimaX)\")\nplot(forecast(fitArimaX_nil, xreg = ift_NilPhase_X2mag[800:1000, 2:12]), main = \"ARIMAX(2,0,1) Model Forecasting (1,001:1,200)\", ylim = c(500, 6000))\nlines(c(1001:1200), epochs_aqi_data[2, c(1:200), 1], col = \"red\", lwd = 2, lty=2)  \n# overlay original data to show Nil-Phase effects on reconstruction\nlegend(\"top\", bty=\"n\", legend=c(\"Prediction via Nil-Phase Reconstruction\", \"Real Timeseries (CO)\"),\n       col=c(\"blue\", \"red\"), lty=c(1,2), lwd=c(2,2), cex=0.9, x.intersp=0.5)\n\n# 4. Compute the *average phase* across the eight series 2:9\nphase_Avg <- apply(phase_FT_epochs_aqi_data, c(2,3), mean); dim(phase_Avg); phase_Avg[1:5 , 1:5]\n\n# 5. Invert epochs_aqi_data_1 signal to spacetime using average-phase\nReal = mag_FT_epochs_aqi_data[1, , ] * cos(phase_Avg)\nImaginary = mag_FT_epochs_aqi_data[1, , ] * sin(phase_Avg)\nift_AvgPhase_X2mag = Re(fft(Real+1i*Imaginary, inverse = T)/length(FT_epochs_aqi_data[1,,]))\n# display(ift_AvgPhase_X2mag, method = \"raster\")\n# dim(ift_AvgPhase_X2mag); View(ift_AvgPhase_X2mag); # compare to View(epochs_aqi_data[1, , ])\n\n# 6. Perform ARIMAX modeling on ift_AvgPhase_X2mag; report (p, d, q) parameters and quality metrics\nfitArimaX_avg <- auto.arima(ift_AvgPhase_X2mag[ , 1], xreg= ift_NilPhase_X2mag[ , 2:12])\nfitArimaX_avg\n# ARIMA(2,0,3) \n# Coefficients:\n#         ar1     ar2     ma1      ma2     ma3  intercept   xreg1   xreg2    xreg3   xreg4    xreg5   xreg6\n#      0.3295  0.2384  0.2673  -0.0061  0.1573   742.8001  0.5838  0.2809  -0.6497  1.2399  -0.0261  1.0818\n# s.e.  0.1354  0.1150  0.1363   0.0650  0.0451    97.1676  0.1700  0.1776   0.1468  0.1695   0.1710  0.2394\n#       xreg7   xreg8    xreg9  xreg10   xreg11\n#      0.2540  0.3065  -0.4052  0.3511  -0.4577\n# s.e.  0.1706  0.1665   0.1450  0.1791   0.1709\n# sigma^2 estimated as 82982:  log likelihood=-7073.9  AIC=14183.8   AICc=14184.5   BIC=14272.14\n\n# 7. Perform ARIMAX modeling on epochs_aqi_data[1,,]; report (p,d,q) parameters and quality metrics\nfitArimaX_orig <- auto.arima(epochs_aqi_data[1, , 1], xreg= epochs_aqi_data[1, , 2:12])\nfitArimaX_orig\n# Regression with ARIMA(1,1,4) errors \n# Coefficients:\n#         ar1      ma1     ma2     ma3      ma4   xreg1   xreg2   xreg3   xreg4    xreg5    xreg6   xreg7\n#      0.2765  -0.8891  0.1268  0.0304  -0.1766  0.0804  6.1495  0.0986  0.0163  -0.0482  -0.0110  0.1833\n#s.e.  0.1294   0.1272  0.0933  0.0450   0.0384  0.0213  1.6611  0.0554  0.0152   0.0207   0.0257  0.0274\n#       xreg8   xreg9  xreg10    xreg11\n#      0.1765  6.5374  1.7939  -12.0697\n#s.e.  0.0118  0.7141  0.2724    1.8905\n# sigma^2 estimated as 2287:  log likelihood=-5273.65   AIC=10581.29   AICc=10581.92   BIC=10664.71\n\n# 8. Compare the analytics results from #3, #6, and #7\n\n# Generate a table with results\n\n### correlations\ncor_orig_obs <- format(cor(forecast(fitArimaX_orig, xreg = epochs_aqi_data[2, c(801:1000), 2:12])$mean, \n    epochs_aqi_data[2, c(1:200), 1]), digits=3); cor_orig_obs\ncor_orig_nil <- format(cor(forecast(fitArimaX_orig, xreg = epochs_aqi_data[2, c(801:1000), 2:12])$mean, \n    forecast(fitArimaX_nil, xreg = ift_NilPhase_X2mag[801:1000, 2:12])$mean), digits=3); cor_orig_nil\ncor_orig_avg <- format(cor(forecast(fitArimaX_orig, xreg = epochs_aqi_data[2, c(801:1000), 2:12])$mean, \n    forecast(fitArimaX_avg, xreg = ift_AvgPhase_X2mag[801:1000, 2:12])$mean), digits=3); cor_orig_avg\n\n### plots\nplot(forecast(fitArimaX_orig, xreg = epochs_aqi_data[1, 800:1000, 2:12]), \n     main = sprintf(\"ARIMAX Model Forecasting (1,001:1,200): Corr(TrueObs,Orig)=%s\", cor_orig_obs),\n     xlim=c(800, 1200), ylim = c(500, 2000), col=\"black\", lwd = 1, lty=1)\n#lines(c(1001:1200), forecast(fitArimaX_orig, xreg = epochs_aqi_data[2, c(801:1000), 2:12])$mean, \n#      col = \"black\", lwd = 1, lty=1)  # Original=True Phase reconstruction\nlines(c(1001:1200), forecast(fitArimaX_nil, xreg = ift_NilPhase_X2mag[801:1000, 2:12])$mean, \n      col = \"purple\", lwd = 1, lty=1)\nlines(c(1001:1200), forecast(fitArimaX_avg, xreg = ift_AvgPhase_X2mag[801:1000, 2:12])$mean, \n      col = \"red\", lwd = 1, lty=1)\nlines(c(1001:1200), epochs_aqi_data[2, c(1:200), 1], col = \"green\", lwd = 1, lty=1)  \nlegend(\"topleft\", bty=\"n\", legend=c(\n  sprintf(\"Original (Correct Phases): Corr(Orig, TrueObs)=%s\", cor_orig_obs), \n  sprintf(\"Prediction via Nil-Phase Reconstruction: Corr(Orig, Nil)=%s\", cor_orig_nil), \n  sprintf(\"Prediction via Average-Phase Reconstruction: Corr(Orig, Avg)=%s\", cor_orig_avg), \n  sprintf(\"Real CO Timeseries (Epoch 2)\"), \n  \"Orig (True Phase) ARIMA(1,1,4) Model Forecast\"), \n  col=c(\"black\", \"purple\", \"red\", \"green\", \"blue\"), lty=c(1,1,1,1), lwd=c(2,2,2,2), cex=0.9, \n  x.intersp=1, text.width=c(0.085,0.235,0.35, 0.3), xjust=0, yjust=0)\n\n#### Zoom in\nplot(forecast(fitArimaX_orig, xreg = epochs_aqi_data[1, 800:1000, 2:12]), \n     main = sprintf(\"ARIMAX Model Forecasting (1,001:1,200): Corr(TrueObs,Orig)=%s\", cor_orig_obs),\n     xlim=c(950, 1050), ylim = c(500, 2000), col=\"black\", lwd = 1, lty=1)\n#lines(c(1001:1200), forecast(fitArimaX_orig, xreg = epochs_aqi_data[2, c(801:1000), 2:12])$mean, \n#      col = \"black\", lwd = 1, lty=1)  # Original=True Phase reconstruction\nlines(c(1001:1200), forecast(fitArimaX_nil, xreg = ift_NilPhase_X2mag[801:1000, 2:12])$mean, \n      col = \"purple\", lwd = 1, lty=1)\nlines(c(1001:1200), forecast(fitArimaX_avg, xreg = ift_AvgPhase_X2mag[801:1000, 2:12])$mean, \n      col = \"red\", lwd = 1, lty=1)\nlines(c(1001:1200), epochs_aqi_data[2, c(1:200), 1], col = \"green\", lwd = 1, lty=1)  \nlegend(\"topleft\", bty=\"n\", legend=c(\n  sprintf(\"Original (Correct Phases): Corr(Orig, TrueObs)=%s\", cor_orig_obs), \n  sprintf(\"Prediction via Nil-Phase Reconstruction: Corr(Orig, Nil)=%s\", cor_orig_nil), \n  sprintf(\"Prediction via Average-Phase Reconstruction: Corr(Orig, Avg)=%s\", cor_orig_avg), \n  sprintf(\"Real CO Timeseries (Epoch 2)\"), \n  \"Orig (True Phase) ARIMA(1,1,4) Model Forecast\"), \n  col=c(\"black\", \"purple\", \"red\", \"green\", \"blue\"), lty=c(1,1,1,1), lwd=c(2,2,2,2), cex=0.9, \n  x.intersp=1, text.width=c(0.085,0.235,0.35, 0.3), xjust=0, yjust=0)",
      "line_count": 156
    },
    {
      "section": "Exegeneous Feature Time-series analysis",
      "code": "dim(aqi_data)\n\n# 1. Transform the 2D matrix to k-space (Fourier domain)\naqi_data1 <- aqi_data[ , 3:15]   # remove string columns\naqi_data_complete <- as.matrix(aqi_data1[complete.cases(aqi_data1), ])\ndim(aqi_data_complete)    # ; display(aqi_data_complete, method = \"raster\") \nFT_aqi_data <- fft(aqi_data_complete)\nX2 <- FT_aqi_data  # display(FT_aqi_data, method = \"raster\") \nmag_FT_aqi_data <- sqrt(Re(X2)^2+Im(X2)^2) \n  # plot(log(fftshift1D(Re(X2_mag))), main = \"log(Magnitude(FFT(timeseries)))\") \nphase_FT_aqi_data <- atan2(Im(X2), Re(X2)) \n\n### Test the process to confirm calculations\n# X2<-FT_aqi_data; X2_mag <- mag_FT_aqi_data; X2_phase<-phase_FT_aqi_data\n# Real2 = X2_mag * cos(X2_phase)\n# Imaginary2 = X2_mag * sin(X2_phase)\n# man_hat_X2 = Re(fft(Real2 + 1i*Imaginary2, inverse = T)/length(X2))\n# ifelse(abs(man_hat_X2[5,10] - aqi_data1[5, 10]) < 0.001, \"Perfect Syntesis\", \"Problems!!!\")\n#######\n\n# 2. Invert back to spacetime the epochs_aqi_data_1 signal with nil phase\nReal = mag_FT_aqi_data * cos(0)  # cos(phase_FT_aqi_data)\nImaginary = mag_FT_aqi_data * sin(0)   # sin(phase_FT_aqi_data)\nift_NilPhase_X2mag = Re(fft(Real+1i*Imaginary, inverse = T)/length(FT_aqi_data))\n# display(ift_NilPhase_X2mag, method = \"raster\")\n# dim(ift_NilPhase_X2mag); View(ift_NilPhase_X2mag); # compare to View(aqi_data1)\nsummary(aqi_data_complete); summary(ift_NilPhase_X2mag, method = \"raster\")\n\n# 3. Perform 2D modeling of ift_NilPhase_X2mag, e.g., \n###   LASSO \"CO.GT.\" ~ \"PT08.S1.CO.\"+\"NMHC.GT.\"+\"C6H6.GT.\"+\"PT08.S2.NMHC.\"+\"NOx.GT.\"+\"PT08.S3.NOx.\"+ \"NO2.GT.\"+\"PT08.S4.NO2.\"+\"PT08.S5.O3.\"+\"T\"+\"RH\"+\"AH\"\nlibrary(glmnet)\nlibrary(arm)\nlibrary(knitr) \n\ny <- ift_NilPhase_X2mag[ , 1]      # CO as outcome variable\nX <- ift_NilPhase_X2mag[ , 2:13]   # remaining features are predictors\n\nset.seed(1234)\ntrain = sample(1 : nrow(X), round((4/5) * nrow(X)))\ntest = -train\n\n# subset training data\nyTrain = y[train]\nXTrain = X[train, ]\n# subset test data\nyTest = y[test]\nXTest = X[test, ]\n\n#### Model Estimation & Selection ####\n# Estimate models: glmnet automatically standardizes the predictors\nfitRidge = glmnet(XTrain, yTrain, alpha = 0)  # Ridge Regression\nfitLASSO = glmnet(XTrain, yTrain, alpha = 1)  # The LASSO\n\n### Plot Solution Path #### LASSO\nplot(fitLASSO, xvar=\"lambda\", label=\"TRUE\")  # add label to upper x-axis\nmtext(\"(Nil-Phase) LASSO regularizer: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n### Plot Solution Path #### Ridge\nplot(fitRidge, xvar=\"lambda\", label=\"TRUE\") # add label to upper x-axis\nmtext(\"(Nil-Phase) Ridge regularizer: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n#### 10-fold cross validation ##### LASSO\nlibrary(\"glmnet\")\nlibrary(doParallel)\nregisterDoParallel(6)\nset.seed(1234)  # set seed \ncvLASSO = cv.glmnet(XTrain, yTrain, alpha = 1, parallel=TRUE) # (10-fold) cross validation for the LASSO\nplot(cvLASSO); mtext(\"(Nil-Phase) CV LASSO: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n### Predict and Report LASSO MSE \npredLASSO <-  predict(cvLASSO, s = cvLASSO$lambda.1se, newx = XTest)\ntestMSE_LASSO <- mean((predLASSO - yTest)^2); testMSE_LASSO\n\n# LASSO coefficient estimates \nbetaHatLASSO = as.double(coef(fitLASSO, s = cvLASSO$lambda.1se))  # s is lambda\ncoefplot(betaHatLASSO[2:12], sd = rep(0, 11), pch=1, col.pts = \"red\", cex.pts = 2)\nlegend(\"bottomright\", \"(Nil-Phase) LASSO\", col = \"blue\", bty = \"o\", cex = 1)\n\n# 4. Perform LASSO modeling on ift_TruePhase_X2mag \nX2<-FT_aqi_data; X2_mag <- mag_FT_aqi_data; X2_phase<-phase_FT_aqi_data\nReal2 = X2_mag * cos(X2_phase)\nImaginary2 = X2_mag * sin(X2_phase)\nman_hat_X2 = Re(fft(Real2 + 1i*Imaginary2, inverse = T)/length(X2))\n\ny3 <- man_hat_X2[ , 1]      # CO as outcome variable\nX3 <- man_hat_X2[ , 2:13]   # remaining features are predictors\n\n# subset training data\ny3Train = y3[train]\nX3Train = X3[train, ]\n# subset test data\ny3Test = y3[test]\nX3Test = X3[test, ]\n\n#### Model Estimation & Selection ####\n# Estimate models: glmnet automatically standardizes the predictors\nfitRidge3 = glmnet(X3Train, y3Train, alpha = 0)  # Ridge Regression\nfitLASSO3 = glmnet(X3Train, y3Train, alpha = 1)  # The LASSO\n\n### Plot Solution Path #### LASSO\nplot(fitLASSO3, xvar=\"lambda\", label=\"TRUE\")  # add label to upper x-axis\nmtext(\"(True-Phase) LASSO regularizer: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n### Plot Solution Path #### Ridge\nplot(fitRidge3, xvar=\"lambda\", label=\"TRUE\") # add label to upper x-axis\nmtext(\"(True-Phase) Ridge regularizer: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n#### 10-fold cross validation ##### LASSO\nlibrary(\"glmnet\")\nlibrary(doParallel)\nregisterDoParallel(6)\nset.seed(1234)  # set seed \ncvLASSO3 = cv.glmnet(X3Train, y3Train, alpha = 1, parallel=TRUE) # (10-fold) cross validation for the LASSO\nplot(cvLASSO3); mtext(\"(True-Phase) CV LASSO: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n### Predict and Report LASSO MSE \npredLASSO3 <-  predict(cvLASSO3, s = cvLASSO3$lambda.1se, newx = X3Test)\ntestMSE_LASSO3 <- mean((predLASSO3 - y3Test)^2); testMSE_LASSO3\n\n# LASSO coefficient estimates \nbetaHatLASSO3 = as.double(coef(fitLASSO3, s = cvLASSO3$lambda.1se))  # s is lambda\ncoefplot(betaHatLASSO3[2:12], sd = rep(0, 11), pch=1, col.pts = \"red\", cex.pts = 2)\nlegend(\"bottomright\", \"(True-Phase)LASSO\", col = \"blue\", bty = \"o\", cex = 1.5)\n\n# 5. Compare the analytics results from #3, #6, and #7\n\n# Stop local cluster\nstopImplicitCluster()",
      "line_count": 126
    }
  ]
}