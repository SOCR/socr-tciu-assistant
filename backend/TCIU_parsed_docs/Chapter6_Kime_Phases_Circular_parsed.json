{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.299745",
    "total_sections": 8,
    "total_code_chunks": 23,
    "total_tables": 1,
    "r_libraries": [
      "animation",
      "circular",
      "crosstalk",
      "ggplot2",
      "htmlwidgets",
      "mosaic",
      "plot3D",
      "plotly",
      "tidyr"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Spacekime Analytics (Time Complexity and Inferential Uncertainty)\"\nauthor: 'SOCR Team '\ndate: \"`r format(Sys.time(),'%m/%d/%Y')`\"\noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: yes\n    number_sections: yes\n    toc_depth: 2\n    toc_float:\n      collapsed: no\n      smooth_scroll: yes\n    code_folding: hide\n  word_document:\n    toc: yes\n    toc_depth: '2'\n  pdf_document:\n    toc: yes\n    toc_depth: '2'\nalways_allow_html: yes\n\nIn this [TCIU/Spacekime section](https://tciu.predictive.space/), we show some of the parallels between circular kime-phase densities and [electron orbital densities](https://chem.libretexts.org/Bookshelves/General_Chemistry/Map%3A_Chemistry_-_The_Central_Science_(Brown_et_al.)/06%3A_Electronic_Structure_of_Atoms/6.06%3A_3D_Representation_of_Orbitals) depicted as [2D circular or 3D spherical distributions](https://winter.group.shef.ac.uk/orbitron).",
      "word_count": 76
    },
    {
      "title": "Random sampling from a given probability distribution",
      "content": "By definition, experimental science and confirmatory evidence decision-making are based on observations, which are typically assumed to be identically-distributed and independent (IID) *random* samples from an unknown distribution. Observable phenomena (or processes) may be modeled by simple *primary distributions*, or by composite superpositions (or mixtures) of several primary (base) distributions.\n\nThe animation below illustrates the [process of drawing a *random sample* from any univariate distribution](https://wiki.socr.umich.edu/index.php/SOCR_EduMaterials_Activities_GeneralCentralLimitTheorem). Analogous IID sampling applies for drawing random observations from multiple (multivariate) distributions, see [SOCR bivariate and trivariate distribution webapp](https://socr.umich.edu/HTML5/BivariateNormal/BVN2/).\n\n<video autosize:true controls>\n  <source src=\"SOCR_CLT_App_Video.mp4\" type=\"video/mp4\">\n</video>\n\nFundamentally, all *data, information*, and *evidence* is always finite, quantized\nas individual or (order-agnostic) combinations of countable observations that can be indexed, tracked, and referenced one-by-one or as subsets. \n\nIn contrast to observed samples, *distributions* correspond to *observable processes* that can be sampled to obtain *instances of data*. However, distributions are holistic analytic models that cannot be themselves observed as data. Only finite samples drawn from probability distributions are observable. Hence, all evidence-based inference is based on *proxy data* aiming to elucidate the properties of the underlying probability distributions. The first two laws of probability theory explain why functions of *random (IID) samples* (statistics!) yield potent *proxy measures* of the intrinsic properties of the source distribution, e.g., average $\\leftrightarrow$ mean, sample variance $\\leftrightarrow$ population variance, etc.\n\n - *First fundamental law of probability theory*: The [Law of Large Numbers\n (LLN)](https://doi.org/10.1080/10691898.2009.11889499) reflects inference based on repeated IID sampling of a controlled experiment. For instance, if we are interested in the *relative frequency* of occurrence of one event whose *probability* to be observed at each experiment is $p$. Then, the ratio of the observed *sample frequency* of that event relative to the total number of repetitions converges towards $p$ as the number of (identical and independent) experiments increases.\n - *Second fundamental law of probability theory*: The [Central Limit Theorem (CLT)](https://www.tandfonline.com/doi/full/10.1080/10691898.2008.11889560) yields that the (arithmetic) average (of random variables sampled from a process with well-defined and finite first two moments) will follow approximately a normal distribution, as the sample-size increases.\n\n\n<!-- **Note**: Perhaps connect with the *sufficiency & exchangeability* paper notions of random sampling, IID and De Finetti theorem ... -->",
      "word_count": 358
    },
    {
      "title": "Circular Electron Orbit Densities",
      "content": "In many physics systems and chemistry applications, it's important to model the [spatial distribution of elementary particles, such as electrons](https://chem.libretexts.org/Bookshelves/General_Chemistry/Map%3A_Chemistry_-_The_Central_Science_(Brown_et_al.)/06%3A_Electronic_Structure_of_Atoms/6.06%3A_3D_Representation_of_Orbitals). For instance, in photoelectron spectroscopy experiments, we may measure the intensities of electrons to track their angular dependencies, which may be described as electric dipole approximations. These estimates may subsequently be used to study the electron emissions resulting from their interaction with photons. Suppose we measure the electron emission intensity, $I(\\theta)$, the [Cooper-Zare's *Angular Distribution of Photoelectrons* model](https://doi.org/10.1063/1.1668742) suggests that $I(\\theta)$ can be expressed as a differential of the partial cross section:\n\n$$I(\\theta)\\equiv \\frac{d\\sigma}{d \\Omega}=\n\\frac{\\sigma}{4\\pi}\\left ( 1+ \\frac{\\beta}{2}(3\\cos^2(\\theta)-1) \\right ).$$\n\nThis ordinary differential equation describes the angular distribution of the emitted electrons from\na gas-phase sample in a random orientation, excited by $100\\%$ linearly polarized light, see [this reference](https://www.researchgate.net/publication/356920774_Dynamique_electronique_dans_les_molecules_organiques_par_la_spectroscopie_Core-Hole_Clock). The $\\theta$ dependence correspond to spherical harmonics $Y_2^0$.\n\nIn the above *Cooper-Zare model* equation, \n\n - $-\\pi\\leq \\theta<\\pi$ is the angle between the electric field vector and the vector that describes the *direction* (phase) of the electron ejected after the collision of the particle (electron) with a photon. In other words, $\\theta$ measures the *angle between the direction of the ejected electron and the polarization of the incident light*.\n - $\\sigma$ is the angle integrated *total cross-section* of a given particle state, and\n - $-1\\le \\beta\\le 2$ is the [photoelectron asymmetry parameter](https://journals.aps.org/rmp/pdf/10.1103/RevModPhys.54.389), which is independent of $\\theta$, but can depend on the excitation energy or the particle's (electrons’) kinetic energy. The $\\beta$ term derivations are provided in [Introduction to Photoelectron Angular Distributions](https://link.springer.com/book/10.1007/978-3-031-08027-2). For a level $l$ (e.g., $s,p,d$), the range of $\\beta$ is from $-1$, for $\\frac{d\\sigma}{d\\Omega}\\approx \\sin^2\\theta$, to $+2$, for $\\frac{d\\sigma}{d\\Omega}\\approx \\cos^2\\theta$:\n\n$$\\beta=\\frac{l(l-1)\\sigma_{l-1}^2 +(l+1)(l+2)\\sigma_{l+1}^2 -\n6l(l+1)\\sigma_{l+1}\\sigma_{l-1}\\cos(\\delta_{l+1}-\\delta_{l-1})}\n{(2l+1)(l \\sigma _{l-1}^2+(l+1)\\sigma _{l+1}^2 )}\\ ,$$\n\n - the *phase-shift* of the $l^{th}$ partial wave is $\\delta_l$, \n - the *radial momentum* $R_{n\\ l}(r)$ is normalized by $\\int_{0}^{\\infty}{[R_{n\\ l}(r)]^2r^2\\ dr} =1$, \n - the direction of the *photoelectron momentum* is $G_{k\\ l}(r)=\\frac{e^{i\\delta_l} \\sin(kr-l\\pi/2) +e^{-i(kr+i\\pi/2)} e^{-2i\\delta_l}\\sin(\\delta_l)}{kr}$,\n - the *radial dipole integral* is $R_{n}=\\int_{0}^{\\infty}{R_{n\\ l}(r)\\cdot G_{k\\ l}(r)\\cdot r^3\\ dr}$, and\n - the usual *dipole radial matrix element* is \n \n $$\\sigma_{l\\pm 1}=\\int_{0}^{\\infty}{R_{n\\ l}(r) R_{k\\ l\\pm 1}(r)\\ r\\ dr} .$$\n\nThe graph below shows the probabilistic photoelectron differential cross-section showing\nthe photoionization of an atomic $1s$ orbital. An electron in this orbital has angular momentum $l=0$. Upon the electron-photon collision, the angular momentum of the electron increases to $l = 1$, according to the dipole selection rules ($\\Delta l = \\pm 1$). The ejected electron leaves the system as a *p-wave*, corresponding to the case of $\\beta = 2$. In this case, the intensity in the polarization vector plane is maximized and close to zero in the plane perpendicular to the polarization vector. Similar arguments hold for the orbital distributions of electrons with different characters and their relations to the corresponding $\\beta$ parameters.\n\nNote the connections between all four angular distributions (corresponding to $\\beta\\in \\{-1, 0, 1, 2 \\}$) in four symmetrical points, where the angular distributions are independent of the\n$\\beta$-values. For instance, the first point corresponding to $\\theta=54.7^o$ (see black line in the first quadrant, or $0.954695$ radians) is called the *magic angle* of the polarization vector of electromagnetic radiation. This *magic* is due to the intensity distribution being independent of the wave-character of the emitted electron. Assuming a perfect, $100\\%$, linear polarization, for an electron energy detector mounted at the *magic angle*, the angular distribution vanishes and the differential partial cross-section in\nthe above equation is proportional to the integral partial cross-section. When the particle analyzing detector is focused at a different angle, the correction factors (dependencies) need to be accounted for due to angular distribution effects.\n\nThe significance of the $\\beta$ parameter can be explicated in terms of an isolated carbon ($C$) atom. At all energies, an idealized and isolated $C\\ 1s$ photoelectron exhibits angular distribution corresponding to $\\beta = 2$ (green density). The polar angle (phase) represents the angle between the polarization vector (horizontal axis) and the emitted electron. The (green) plot shows that the electrons are preferentially emitted along the polarization vector. At one extreme, when $\\beta = 0$, the angular distribution is completely isotropic (circular, as it's independent of $\\theta$). In the other extreme, when $\\beta = -1$, the maximum of the distribution is mostly vertical, i.e., perpendicular to the horizontal polarization vector. This interpretation is valid only under the dipole approximation assumption when the wavelength of light is much larger than the dimension of the atoms (the wave is not varying inside the atom). For instance, experiments frequently use small radiation wavelengths, around $2\\ nm$, whereas the entire atom may be $10$ times smaller, at about $0.2\\ nm$.\n\nThe *dipole approximation* refers to the *first order* approximation of the complex exponential when the wavelength of electromagnetic radiation, which transitions between different atomic energy levels, is much larger than the typical size of a light atom. Specifically,\n\n$$e^{i(\\omega/c)\\ n\\cdot x} = 1 + i\\frac{\\omega}{c} \\ n\\cdot x + \\cdots \n\\approx  1  ,$$\n\nsince $\\frac{\\omega}{c} =2\\frac{\\pi}{\\lambda}$, i.e., \nthe *wavelength* $\\lambda\\uparrow$ and the *frequency* $\\omega\\downarrow$ are inversely proportional, $\\lambda=2\\pi\\frac{c}{\\omega}$.\n\nThis electron distribution map suggests that in general, experiments are expected to yield more observed electrons when performing a measurement at $0^o$ angle and much fewer electrons when measuring at $90^o$. However, in practice, the difference in the observed electron densities compared to model predictions between the $0^o$ and $90^o$ angles is smaller than expected. This difference is a function of the photon energy. See [this publication demonstrating how the observed intensities can be used to estimate the $\\beta$ parameter](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.106.193009#fulltext) for the *chlorine* substituted carbon and for the *methyl* carbon in a series of chloroethanes. The more chlorine atoms are present in a molecule, the [lower $\\beta$ parameter is, and the deviation $2-\\beta$ is larger at the lowest ionization energies](https://journals.aps.org/rmp/pdf/10.1103/RevModPhys.54.389).\n\nNote that the angular distributions of these particles (electrons) are very structured.\nThey tend to be symmetric and do not come out independently all over the place. Rather, the distributions emerge in just a few directions, as narrow sprays or jets. About $90\\%$ of the time these distributions represent just two polar opposite jets, about $10\\%$ of the time there are three jets, $1\\%$ four jets, and so on progressively less likely.",
      "word_count": 1024
    },
    {
      "title": "Kime-Phases Circular Distributions",
      "content": "<video autosize:true controls>\n  <source src=\"KimeRandomSamplingAnimation.mp4\" type=\"video/mp4\">\n</video>",
      "word_count": 7
    },
    {
      "title": "Kime-Phases Helical (Spherical) Distributions",
      "content": "We can use a spherical representation to visualize a more general case of infinitely-supported kime-phase distributions as helices. This approach does not require transforming the infinite distribution support to $[-\\pi,\\pi)$ and displays the native distribution as a helix embedded in $\\mathbb{R}^3$.",
      "word_count": 41
    },
    {
      "title": "Diffraction Pattern Interpretation of Kime-Phases",
      "content": "This section offers a *loose analogy* intended to provide *intuition* for the problem of the enigmatic kime-phase recovery.\n\nThe figure below illustrates one simple example of why the kime-phases may \nappear to be stochastic. This uncertainty is due to inabilities to visually disambiguate the depth perception\n($3^{rd}$ dimension) from observing projections as proxy measurements tracking the underlying kime-phase density.\n\nLook at the 3D scene from the top down, without using the mouse to change the position of the 3D scene. *Can you determine the actual kime-phase just from the angular appearance of the radial spokes (density heights)?* \n\nThis is not possible, unless you navigate the 3D scene and utilize *zoom, pan*, and *rotation* positioning to associate each radial spoke to a specific spherical coordinate pair $(r, \\theta, \\phi)$. The reason is that the fixed *radius* plays the role of *time*, whereas the different *gray radial projections* correspond to *repeated samples* from the same controlled experiment under identical conditions (e.g., fixed spatiotemporal localization and fixed experimental conditions). In this example, we intentionally use random irregular angular-space sampling, $\\phi\\sim Uniform(a,b)$, which makes the polygonal density curve somewhat irregular, but also illustrates a more pragmatic model for temporal dynamics, $t_o\\leq t\\leq t_1$. Looking from the top, without a depth perception, we can't untangle the axial (transverse plane) containing the gray spoke (density value). Use the mouse to hover over the *gray density radial lines* and read off the corresponding phase values. These angular values should appear very irregular, perhaps not random from this small sample, but certainly oddly unusual. Lower and higher azimuthal planes correspond to phases, $\\phi$, in the lower and higher spectrum of the domain, $\\phi\\in [0.1474376, 38.53021]$. However, in the top down view, they are all superimposed in a 2D flat projection of the 3D scene. This inability to untangle the *azimuthal axial plane* introduces an apparent single degree of freedom. In this case, the uncertainty can be easily resolved simply by exploring the actual 3D space. However, in the complex-time representation, that uncertainty manifests as random sample draws from kime-phase distributions, and is related to the Heisenberg uncertainty principle.\n\nIn practice, we can't directly observe the entire 5D spacekime universe. However, we can measure a number of observable process characteristics in the 4D Minkowski projection space.",
      "word_count": 377
    },
    {
      "title": "Spherical Electron Orbit Densities",
      "content": "In 4D Minkowski spacetime, the electron orbitals are temporally-dynamic covering the 3D spatial domain. In 3D Cartesian coordinates, the position/coordinates of points are described by $\\pmb{r}=(x,y,z)\\in \\mathbb{R}^3$, whereas in spherical coordinates, the same points are described by the displacement magnitude (of the vector, $r$, from the coordinate space origin), and a pair of angles $(\\phi, \\theta)$ between the projection of the vector $r$ into the $(x,y)$ plane and the positive $x$-axis (*azimuthal angle* $\\phi$), and between $r$ and the positive $z$-axis (*polar angle* $\\theta$). Explicitly, the spherical coordinate representation of spatial locations involves $(r, \\theta, \\phi)\\in \\mathbb{R}^3$, where $r\\in[0,\\infty),\\ \\theta \\in \\left [-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right ], \\ \\phi\\in [-\\pi,\\pi)$.\n\nThe bijective forward and inverse (*Descarte*) *Cartesian* to *spherical* coordinate transformations are: \n\n - Spherical to Cartesian transform\n\n$$x=r\\sin\\theta \\cos\\phi\\\\\ny=r \\sin\\theta \\sin\\phi \\\\\nz=r \\cos\\theta \\ .$$\n\n - Cartesian to spherical transform\n\n$$r=\\sqrt{x^2+y^2+z^2} \\\\\n\\phi = \\tan^{-1}\\frac{y}{x} \\\\\n\\theta=\\tan^{-1}\\frac{\\sqrt{x^2+y^2}}{z} \\ .$$\n\n## Angular momentum\n\nIn spherical coordinates, the momentum $p$ of a particle, such as an electron, has two orthogonal (independent) components; a *radial component* $p_r$ corresponding to the particle motion radially outward from the origin, and an *angular component* $L$, corresponding to rotational particle motion along the surface of a sphere of radius $r$ centered at the origin, e.g., atomic nucleus.\nHence, the particle momentum is $p=\\left (p_r,\\frac{L}{r}\\right )$.\nSince, the angular component $L$ is a vector of size $r$, $\\frac{L}{r}$ is a vector in the same direction of length $1$, both tracking the particle motion along the surface of a sphere, according to the azimuthal ($\\theta$) and polar ($\\phi$) angles.\n\nIn Cartesian coordinates, the *angular momentum vector* is the [vector cross product](https://en.wikipedia.org/wiki/Cross_product)\n$$L=\\vec{r}\\times p ,\\ {\\text{note that }} L\\perp \\vec{r} \\ ,$$\nand it's $x,y,z$ components are given in terms of the Cartesian coordinates of $r$ and $p$,\n\n$$L_x=yp_z-zp_y\\\\\nL_y=zp_x-xp_z\\\\\nL_z=xp_y-yp_x \\ .$$\n\nFor simplicity, with a slight abuse of notation, sometimes we may denote *scalar* and *vector* quantities with the same symbol, e.g., the vector $\\vec{r}$ and it's size $|\\vec{r}|=r$ may both be written as $r$.\n\nWhen the potential energy $V$ depends only on $r$, the angular momentum is conserved, i.e., it's constant and has a trivial temporal derivative. Consider for instance\nthe [Coulomb potential](https://en.wikipedia.org/wiki/Coulomb%27s_law) $V(r)=-\\frac{e^2}{4\\pi \\epsilon_o}\\frac{1}{r}$.\n\nRecall that the [Coulomb’s law](https://en.wikipedia.org/wiki/Coulomb%27s_law) implies that the electric field $E$ at point $r=r(x,y,z)$, due to a charge $q$ located at the origin,\nis given by \n$E = k \\frac{q}{r^2}r$. To show this angular momentum conservation, we start with the force \nacting on a classical electron $F=-\\frac{k}{r^3}r$, and it's Cartesian components\n$F_x=-\\frac{k}{r^3}x$, $F_y=-\\frac{k}{r^3}y$, and $F_z=-\\frac{k}{r^3}z$.\n\n[Newton's second law of motion](https://en.wikipedia.org/wiki/Newton%27s_laws_of_motion) is\n\n  $$F=ma=m\\frac{dv}{dt}=\\frac{d(mv)}{dt}=\\frac{dp}{dt}.$$\n\nLet's compute the time-derivative of the first component of the angular momentum\nvector,\n\n$$\\frac{dL_x}{dt}\\equiv \\frac{d (yp_z-zp_y)}{dt} =\\\\\n\\frac{dy}{dt}p_z + y\\frac{dp_z}{dt}-\\frac{dz}{dt}p_y-z\\frac{dp_y}{dt}=\n\\frac{p_y}{m}p_z + yF_z- \\frac{p_z}{m}p_y -zF_y=\\\\\n\\frac{p_y p_z}{m}-\\frac{kyz}{r^3} - \\frac{p_z p_y}{m}+ \\frac{kzy}{r^3}=0 .$$\n\nSimilarly, $\\frac{dL_y}{dt}=\\frac{dL_z}{dt}=0$, and $L^2=L^2_x+L^2_y+L^2_z$, hence $\\frac{dL}{dt}=0$, and therefore, \nthe *energy* and the *angular momentum* are conserved. \nIn quantum mechanics, the energy can have only certain allowed values. \nFor instance, the [Bohr model](https://en.wikipedia.org/wiki/Bohr_model) predicts\nthat all possible energies for the hydrogen atom (electron layers $n=1,2,3,\\cdots$) are in the form\n\n$$E_n =- \\frac{Z^2 e^4 m_e}{8\\epsilon_o^2 h^2}\\frac{1}{n^2} \\ .$$\nThis Cartesian coordinate representation of the angular momentum $L=L(\\theta,\\phi)$ has an\nanalogous *spherical coordinate* representation in terms of the momentum \n$p=\\left (p_r,\\frac{L}{r}\\right )$. In spherical coordinates, since $L=r\\times p$, the classical energy is given by\n\n$$E=\\frac{p^2_r}{2m_e} + \\frac{L^2}{2m_er^2} - \\frac{Ze^2}{4\\pi \\epsilon_o r} =\n\\underbrace{\\frac{p^2_r}{2m_e} - \\frac{Ze^2}{4\\pi \\epsilon_o r}}_{\\epsilon_r,\\ radial\\ energy} +\n\\underbrace{\\frac{L^2}{2m_er^2}}_{angular\\ energy} .$$\n\nThe energy $E$ depends on the nucleus of charge ($+Ze$) and $L^2$, which is conserved along with its three Cartesian components\n$L_x,L_y,L_z$. In general, $L$ has three Cartesian components, however, in really is just a 2D parametric vector modeling the motion of an electron on a 2D manifold, a 2D sphere embedded in \n$\\mathbb{R}^3$, parameterized by the angles $\\theta,\\phi$.\n\nCartesian coordinates in $\\mathbb{R}^3$ require 3 components, but the \nsphere coordinates on $S^2$ have only 2 degrees of freedom, *polar* ($\\theta$) and *azimuthal* ($\\phi$). \nHence, we can parameterize the *angular momentum* ($L$) and the *energy* ($E$)\nusing two parameters, e.g., the *magnitude* $L^2$ and the *angular momentum* \n$z$-component ($L_z$), which describes the particle motion projected in the $(x,y)$ \nplane parameterizing the motion in the azimuthal ($\\phi$) direction.\nAs a result, the wavefunction describing the motion of the particle\nwill have a ring component \n$\\frac{1}{\\sqrt{2\\pi}}e^{im\\phi}, \\ \\forall\\ m\\in\\mathbb{Z}$.\nThis limits the possibilities for the second energy component, the $z$-component,\nonly to $L_z=m\\hbar$.\n\n**Note**: [This video presents the basics of the raising and lowering eigenstates ](https://youtu.be/GLPSxU9I-Ao?list=PL65jGfVh1ilueHVVsuCxNXoxrLI3OZAPI&t=1226) for the [quantum ladder operator](https://en.wikipedia.org/wiki/Ladder_operator).\n\nThe  allowed values for the first component of the energy, the magnitude $L^2$,\nare also discrete (energy levels) $L^2\\to l(l+1)\\hbar, \\ l\\in\\{0, 1,2, \\cdots, (n-1)\\}$\nfor each energy level characterized by $n$. \nNotice that since $L_z\\leq |L|$, $\\forall\\ l$, $m\\leq l$ implies that\n$m\\in \\{-l,-l+1,-l+2,\\cdots, 0, \\cdots,l-2,l-1,l\\}$.\n\n## Schrödinger Equation for a Hydrogen atom\n\nIn 1D, the *time-dependent* [Schrödinger equation](https://en.wikipedia.org/wiki/Schr%C3%B6dinger_equation)\n\n$$i\\hbar \\frac {\\partial }{\\partial t}\\Psi (x,t)=\n\\left[-\\frac {\\hbar ^{2}}{2m}\\frac {\\partial ^{2}}\n{\\partial x^{2}} + V(x,t)\\right ]\\Psi (x,t),$$\n\nwhere $\\Psi(x=space,t=time):\\mathbb{R}\\times \\mathbb{R}^+ \\to\\mathbb{C}$ is a \nwavefunction,\n$m$ is the mass of the particle, $V(x,t)$ is the potential that represents\nthe environment the particle is embedded in, and \n$$\\hbar=\\frac{h}{2\\pi}=1.054571817\\cdots\\times 10^{-34} J\\cdot s\\equiv \t6.582119569\\cdots\\times 10^{-16} eV\\cdot s$$ \nis the [reduced Planck \nconstant](https://en.wikipedia.org/wiki/Planck_constant).\n\nThe above *time-dependent* Schrödinger equation illustrates that wavefunctions can form standing waves, *stationary states* that simplify the general solutions of the time-dependent Schrödinger equation for any state. \n\nStationary states can also be described by the *time-independent* Schrödinger equation (TISE)\n\n$${\\hat {H}} |\\Psi \\rangle = E |\\Psi \\rangle ,$$\nan *eigenvalue equation*, where $E$ is the energy of the system and the Hamiltonian operator ${\\hat {H}}$ is time-independent. The total wavefunction $\\Psi$ is still *time-dependent*, even though the TISE equation is time-agnostic, yet the eigen-solutions (eigenvalue=Energy, eigenfunction=wavefunction) retain their time-dependence. \n\nLet's consider a single-electron Coulomb system and express\nthe [Schrödinger equation](https://en.wikipedia.org/wiki/Schr%C3%B6dinger_equation)\nin spherical coordinates, where we employed the [Laplacian to spherical coordinate conversion](https://mathworld.wolfram.com/LaplacesEquationSphericalCoordinates.html)\n\n$$E |\\psi \\rangle \\equiv E\\psi(r,\\theta,\\phi)=\\\\\n\\underbrace{-\\frac{\\hbar^2}{2m_e r^2}\n\\left [\\frac{\\partial }{\\partial r}r^2\\frac{\\partial }{\\partial r}(\\psi(r,\\theta,\\phi))\n+ \\frac{1}{\\sin\\theta} \\frac{\\partial}{\\partial \\theta} \\sin\\theta \n\\frac{\\partial}{\\partial \\theta} \\psi (r,\\theta,\\phi) +\n\\frac{1}{\\sin^2\\theta} \\frac{\\partial^2}{\\partial \\phi^2} \n\\psi(r,\\theta ,\\phi )\\right]}_{angular\\ energy} -\n\\underbrace{\\frac{Ze^2}{4\\pi\\epsilon_o r} \\psi(r,\\theta,\\phi)}_{\\epsilon_r,\\ radial\\ energy}\n\\equiv\\\\ {\\hat {H}} |\\psi \\rangle\\ .$$\n\nSolutions to this PDE yield the allowed values of the *angular momentum*, $L$, \nand the allowed *energies*, $E_n$.\n\nThe formulation of the Schrödinger equation is based on the classical energy\n\n$$E=\\frac{p^2_r}{2m_e} + \\frac{L^2}{2m_er^2} - \\frac{Ze^2}{4\\pi \\epsilon_o r} =\n\\underbrace{\\frac{p^2_r}{2m_e} - \n\\frac{Ze^2}{4\\pi \\epsilon_o r}}_{\\epsilon_r,\\ radial\\ energy\\ \\perp (\\theta,\\phi)} +\n\\underbrace{\\frac{L^2}{2m_er^2}}_{\\epsilon_{\\theta,\\phi}\\ angular\\ energy,\\ \\perp r} .$$\n\nIn statistical data analysis, this independent component bifurcation of the energy$E$ resembles the classical\n[variance decomposition of ANOVA](https://en.wikipedia.org/wiki/Analysis_of_variance#Algorithm)\ninto *variance between treatments* and an independent part,\n*variance within treatments*, and the [bias and precision tradeoff](https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff) in statistical learning.\n\nThis energy separability into *radial* and *angular* terms facilitates the decomposition of the wavefunction into a *product* of two terms\n\n$$\\psi(r,\\theta,\\phi)=\n\\underbrace{R(r)}_{radial} \\cdot \n\\underbrace{Y(\\theta,\\phi)}_{angular}\\ , $$\n\nwhere $r$ is the radius (in atomic units, $1$ Bohr radius \n$= 52.9\\ pm = 52.9\\times 10^{-12}$) from the atomic center, $0\\leq \\theta\\leq\\pi$\nis the polar spherical coordinate, and $-\\pi\\leq \\phi<\\pi$ is the azimuthal spherical coordinate. \n\nThe solutions $Y_{lm}(\\theta,\\phi),\\ l,m\\in\\mathbb{Z}$ of the angular part,\n$Y(\\theta,\\phi)$, are called *spherical harmonics* and yield the \npossible values of the *angular momentum* $L^2$ and the $z$-component $L_z$. \n\nNote that the [Euler formula](https://en.wikipedia.org/wiki/Euler%27s_formula) explicates the complex exponentials \n\n$$e^{i\\phi}=\\cos\\phi+i\\sin\\phi \\quad \\& \\quad e^{-i\\phi}=\\cos\\phi-i\\sin\\phi. $$\n\nLet's explore a few of the spherical harmonics for some $l,m$ parameters.\n\n - For $l=0$, there is just one possibility for $m$, $m=0$ corresponding to a unique spherical harmonic term (a constant)\n\n$$Y_{00}(\\theta,\\phi)=\\frac{1}{\\sqrt{4\\pi}}. $$\n\n - For $l=1$, there are 3 possible spherical harmonics corresponding to $m=-1,0,1$, \n\n$$Y_{11}(\\theta,\\phi)= -\\sqrt{\\frac{3}{8\\pi}} \\sin \\theta\\ e^{i\\phi}. $$\n\n$$Y_{1\\ -1}(\\theta,\\phi)= -\\sqrt{\\frac{3}{8\\pi}} \\sin \\theta\\ e^{-i\\phi}. $$\n\n$$Y_{1\\ 0}(\\theta,\\phi)= -\\sqrt{\\frac{3}{4\\pi}} \\cos \\theta. $$\n\n - For $l=2$, there are 5 possibilities for $m$, $m\\in\\{-2,-1,0,1,2\\}$ corresponding to 5 spherical harmonics,\n\n$$Y_{2\\ 2}(\\theta,\\phi)=\\sqrt{ \\frac{15}{32\\pi}}\\sin^2 \\theta\\ e^{2i\\phi},$$\n$$Y_{2\\ -2}(\\theta,\\phi)=\\sqrt{\\frac{15}{32\\pi}}\\sin^2 \\theta\\ e^{-2i\\phi},$$\n$$Y_{2\\ 1}(\\theta,\\phi)=-\\sqrt{ \\frac{15}{8\\pi}}\\sin \\theta \\cos \\theta\\ e^{i\\phi},$$\n$$Y_{2\\ -1}(\\theta,\\phi)=\\sqrt{ \\frac{15}{8\\pi}}\\sin \\theta \\cos \\theta\\ e^{-i\\phi},$$\n$$Y_{2\\ 0}(\\theta,\\phi)=\\sqrt{ \\frac{5}{16\\pi}} (3\\cos^2 \\theta - 1).$$\n\nRecall that \n$\\psi(r,\\theta,\\phi)=\\underbrace{R(r)}_{radial} \\cdot \\underbrace{Y(\\theta,\\phi)}_{angular}$ \nand the first factor in the Schrödinger equation, the *radial component* $R_{n\\ l}(r)$,\ndepends on the parameters $n,l\\in\\mathbb{Z}$, whereas the second term, the *angular component*, $Y_{l\\ m}(\\theta,\\phi)$, depends on $l,m\\in\\mathbb{Z}$.\n\n$$E_n\\ R_{nl}(r)=\n-\\frac{\\hbar^2}{2m_e}\\frac{1}{r^2}\n\\frac{d }{d r}r^2\\frac{d }{d r}(R_{n\\ l}(r))\n+ \\frac{l(l+1)\\hbar^2}{2m_e r^2} R_{n\\ l} (r)\n- \\frac{Z e^2}{4\\pi\\epsilon_o r} R_{n\\ l} (r) .$$\n\nThe *angular functions* $Y_{l\\ m}(\\theta,\\phi)$ are independent of the potential \n$V(r)$, whereas the *radial functions* $R_{n\\ l}(r)$ directly\ndepend on the Coulomb potential. Hence, the solutions to the radial Schrödinger\nequation, $R_{n\\ l}(r)$, control the allowed energy levels. \nThe boundary conditions that lead to the quantized energies are \n$\\lim_{r\\to 0}(rR_{n\\ l}(r))=0$ and $\\lim_{r\\to \\infty}(rR_{n\\ l}(r))=0$. \n\nSee the [University of Sheffields *Orbitron* website by Mark Winter](https://winter.group.shef.ac.uk/orbitron/atomic_orbitals/3d/3d_equations.html), which includes interactive content, images, and renditions representing atomic orbitals, radial and angular wavefunctions, animated plots of electron density and distribution functions.\n\nThe atomic orbitals are indexed by the quantum numbers and include \n$\\{Level_1, Level_2, \\cdots, Level_7\\}$ and higher order orbitals\n$\\{g, h, i\\}$ orbitals, hybrid orbitals, and molecular orbitals.\n\nLet's denote the constant\n$$a_o=\\frac{4\\pi\\epsilon_o\\hbar^2}{e^2m_e} =0.529177×10^{-10}, $$\nand determine several radial functions part of the wavefunction solutions \ncorresponding to the first few values of $n,l$\n\n$$R_{1\\ 0}(r)=2\\left (\\frac{Z}{a_o} \\right)^{3/2} e^{\\frac{-Zr}{a_o}},$$\n$$R_{2\\ 0}(r)=\\frac{1}{2\\sqrt{2}}\\left (\\frac{Z}{a_o} \\right)^{3/2}\n\\left (2- \\frac{Zr}{a_o}\\right )e^{\\frac{-Zr}{2a_o}},$$\n\n$$R_{2\\ 1}(r)=\\frac{1}{2\\sqrt{6}}\\left (\\frac{Z}{a_o} \\right)^{3/2}\\frac{Zr}{a_o} e^{\\frac{-Zr}{2a_o}},$$\n\n$$R_{3\\ 0}(r)=\n\\frac{2}{81\\sqrt{3}}\\left (\\frac{Z}{a_o} \\right)^{3/2}\n\\left (27- 18\\frac{Zr}{a_o} +2\\left (\\frac{Zr}{a_o} \\right )^2\\right )\ne^{-\\frac{Zr}{3a_o}}.$$\n\n$$\\underbrace{R_{3\\ 2}(r)}_{3d_{z^2}}=\n\\frac{4}{81\\sqrt{30}} \\left (\\frac{Z}{a_o}\\right )^{3/2} \n\\left (\\frac{Zr}{a_o} \\right)^{2} e^{-\\frac{Zr}{3a_o}}.$$\n\nReconstructing the complete wavefunction solutions from the corresponding\nradial and angular components yields\n\n$$\\psi_{n\\ l\\ m}(r,\\theta,\\phi)=\\underbrace{R_{n\\ l}(r)}_{radial} \\cdot \n\\underbrace{Y_{l\\ m}(\\theta,\\phi)}_{angular}, \\quad n,l,m\\in\\mathbb{Z} .$$\n\nThe 3 parameters $n,l,m\\in\\mathbb{Z}$ characterizing each state are called\nthe *quantum numbers* of the system and each parameter corresponds to a \nconserved quantity \n\n - $n$ is the *principal* quantum number, \n - $l$ is the *angular* quantum number, and \n - $m$ is the *magnetic* quantum number.\n\nThe quantum interpretation of the wavefunction solution\n$\\psi_{n\\ l\\ m}(r,\\theta,\\phi)$ is as probability density amplitude\nfor finding the electron in a particular region of the 3D space.\nThe wavefunciton amplitudes are used to compute actual probabilities \nassociated with measurements of the electron's position just like a CDF\ncan be computed via integration of the probability density function over\na specified domain. The likelihood of the electron being in a small voxel \n(volume element) $dV\\subseteq \\mathbb{R}^3$ around the point \n${\\bf{r}}=(r,\\theta,\\phi)\\in dV$ is\n\n$$P(\\text{electron in } dV\\text{ about location } (r,\\theta,\\phi))\\equiv\n|\\psi_{n\\ l\\ m}(r,\\theta,\\phi)|^2\\ dV=\nR^2_{n\\ l}(r)|Y_{l\\ m}(\\theta,\\phi)|^2\\ dV. $$\n\nIn *Cartesian coordinates*, the small 3D volume element $dV$\nrepresents a small box of dimensions $dx\\cdot dy\\cdot dz$, i.e.,\n$dV=dx\\ dy\\ dz$.\n\nIn spherical coordinates, the volume element $dV$ corresponds \nthe spherical volume of a ball around the point of interest\n\n$$dV=r^2\\sin\\theta\\ dr\\ d\\theta\\ d\\phi.$$\n\nThis can be verified by integrating the volume element $dV$ over a 3D ball and \nconfirming the ball volume. Parameterize the 3D ball, $dV$, by \n\n$$Domain\\equiv\\left[0\\leq \\underbrace{r}_{radius}\\leq R\\right ] \\times\n\\left[0\\leq \\underbrace{\\theta}_{azimuthal}\\leq \\pi\\right ] \\times\n\\left[-\\pi\\leq \\underbrace{\\phi}_{angular}\\leq \\pi\\right ].$$\n\nBy separability,\n$$V_{ball}=\\int_{Domain}{dV}= \\int_{Domain} {r^2\\sin\\theta dr\\ d\\theta\\ d\\phi}=\n\\int_{0}^r {\\int_{0}^{\\pi} {\\int_{-\\pi}^{\\pi} r^2\\sin\\theta dr\\ d\\theta\\ d\\phi}}=\\\\\n\\int_{0}^r { r^2\\int_{0}^{\\pi} { \\sin\\theta\\int_{-\\pi}^{\\pi} dr\\ d\\theta\\ d\\phi}}=\\\\\n\\left (\\frac{r^3}{3}\\left |_{0}^R \\right . \\right )\\times\n\\left (-\\cos \\theta \\left |_{0}^{\\pi} \\right . \\right ) \\times \n\\left (\\phi \\left |_{-\\pi}^{\\pi} \\right .  \\right )=\n\\frac{r^3}{3}\\times 2\\times 2\\pi=\\frac{4}{3}\\pi R^3\\ .$$\n\n\n### Example 1: $n=2, l=1, m=0$ (Trivial)\n\nRemember the constraints on the *quantum troika* $l=0,1,2,\\cdots,n-1$ and \n$m\\in\\{-l,-l+1,\\cdots,0,\\cdots,l-1,l\\}$. Consider the electron \nof a hydrogen atom $(Z=1)$ in a state with quantum numbers $n=2, l=1, m=0$. \nWe'll compute the probability that the electron's position is farther from the nucleus than $a_o$, i.e., $Pr(r\\geq a_o)$.\n\nStart with the general wavefunction formulation\n$$\\psi_{n\\ l\\ m}(r,\\theta,\\phi)=\\underbrace{R_{n\\ l}(r)}_{radial} \\cdot \n\\underbrace{Y_{l\\ m}(\\theta,\\phi)}_{angular}, \\quad n,l,m\\in\\mathbb{Z} .$$\n\nFor the specific quantum triple $(n=2, l=1, m=0)$ we have\n$$\\psi_{n=2\\ l=1\\ m=0}(r,\\theta,\\phi) = \\psi_{2\\ 1\\ 0}(r,\\theta,\\phi) =\n\\underbrace{R_{2\\ 1}(r)}_{radial} \\cdot \n\\underbrace{Y_{1\\ 0}(\\theta,\\phi)}_{angular}=\\\\\n\\frac{1}{2\\sqrt{6}}\\left (\\frac{Z}{a_o} \\right)^{3/2}\\frac{Zr}{a_o} e^{\\frac{-Zr}{2a_o}}\n\\times \\left (-\\sqrt{\\frac{3}{4\\pi}} \\cos \\theta \\right ) \n\\underbrace{=}_{Z=1}\\\\\n-\\frac{1}{4\\sqrt{2\\pi}} \\frac{r}{a_o^{5/2}} e^{\\frac{-r}{2a_o}} \\cos \\theta .$$\n\nIntegrating the amplitude of the wave function \n$|\\psi_{2\\ 1\\ 0}(r,\\theta,\\phi)|^2$ against the volume element, $dV$\nyields the probability $Pr(r\\geq a_o)$, reflecting electron positioned\nfarther from the nucleus than $a_o$.\n\nNext, derive the probability $Pr(r\\geq a_o)$ using the wavefunction\n\n$$\\psi_{n=2\\ l=1\\ m=0}(r,\\theta,\\phi)=R_{n=2\\ l=1}(r) \\cdot Y_{l=1\\ m=0}(\\theta,\\phi)=\\\\\n\\underbrace{\\frac{1}{2\\sqrt{6}}\\left (\\frac{Z}{a_o} \\right)^{3/2}\\frac{Zr}{a_o} e^{\\frac{-Zr}{2a_o}}}_{R_{2\\ 1}(r)} \\cdot\n\\underbrace{\\left (-\\sqrt{\\frac{3}{4\\pi}} \\cos \\theta\\right )}_{Y_{1\\ 0}(\\theta,\\phi)}=\\\\\n-\\frac{e^{-\\frac{r Z}{2 a_o}} r Z^2 \\sqrt{\\frac{Z}{a_o}} \\cos(\\theta)}{4 a_o^2 \\sqrt{2\\pi}} .$$\n\n$$Pr(r\\geq a_o)\\equiv \\int_{a_o}^{\\infty} { \\int_{0}^{\\pi} { \n\\int_{-\\pi}^{\\pi} |\\psi_{2\\ 1\\ 0}(r,\\theta,\\phi)|^2\\ r^3\\sin \\theta\\ dr\\ d\\theta\\ d\\phi}}=\\\\\n\\int_{a_o}^{\\infty} { \\int_{0}^{\\pi} { \n\\int_{-\\pi}^{\\pi} \\left(-\\frac{e^{-\\frac{r Z}{2 a}} r Z^2 \\sqrt{\\frac{Z}{a}} \\cos(\\theta)}{4 a^2 \\sqrt{2\\pi}}\\right )^2 \\ r^3\\sin \\theta\\ dr\\ d\\theta\\ d\\phi}} =\\\\\n\\int_{a_o}^{\\infty} { \\int_{0}^{\\pi} { \n\\int_{-\\pi}^{\\pi} \\left (\\frac{rZ}{a_o}\\right )^5 \\frac{e^{-\\frac{r Z}{a_o}} \\cos^2\\theta\\ \\sin\\theta}{32 \\pi}\\ dr\\ d\\theta\\ d\\phi}} =\n\\cdots =\\frac{1}{24} e^{-Z} (24 + Z (24 + Z (12 + Z (4 + Z)))), \\\\\n\\text{for}\\ Re\\left(\\frac{Z}{a_o}\\right )>0.$$\n\nFor $Z=1$,\n$$Pr(r\\geq a_o)=\n    \\begin{cases}\n        \\frac{65}{24\\ e}\\equiv 0.9963402 & \\text{, if } a_o< 1\\\\\n        1 & \\text{, if } a_o\\geq 1\n    \\end{cases}\n.$$\n\n\n### Example 2: $n=1, l=0, m=0$ (Non-Trivial)\n\nAgain, recall the constraints on the *quantum triple* $\\forall\\ n\\ ,\\ l=0,1,2,\\cdots,n-1$ and \n$m\\in\\{-l,-l+1,\\cdots,0,\\cdots,l-1,l\\}$. This is a non-trivial example for the electron \nof a hydrogen atom $(Z=1)$ in a state with quantum harmonic numbers $(n=1, l=0, m=0)$. \nLet's compute the same the probability that in this case, the electron's position is farther from the nucleus\nthan $a_o$, i.e., $Pr(r\\geq a_o)$.\n\n$$\\psi_{n=1\\ l=0\\ m=0}(r,\\theta,\\phi)=\\underbrace{R_{1\\ 0}(r)}_{radial} \\cdot \n\\underbrace{Y_{0\\ 0}(\\theta,\\phi)}_{angular} =$$\n\n\n$$\\underbrace{2\\left (\\frac{Z}{a_o} \\right)^{3/2} e^{-\\frac{Zr}{a_o}}}_\n{(radial)\\ R_{1\\ 0}(r)} \\times \n\\underbrace{\\left (\\frac{1}{\\sqrt{4\\pi}}  \\right )}_\n{(angular)\\ Y_{0\\ 0}(\\theta,\\phi)}=\n\\frac{e^{-\\frac{rZ}{a_o}}Z \\sqrt{\\frac{Z}{a_o}}}{a_o \\sqrt{\\pi}} .$$\n\nIntegrating the amplitude of the wave function \n$|\\psi_{1\\ 0\\ 0}(r,\\theta,\\phi)|^2$ against the volume element, $dV$\nyields the probability $Pr(r\\geq a_o)$, reflecting electron positioned\nfarther from the nucleus than $a_o$.\n\n$$Pr(r\\geq a_o)\\equiv \\int_{a_o}^{\\infty} { \\int_{0}^{\\pi} { \n\\int_{-\\pi}^{\\pi} |\\psi_{1\\ 0\\ 0}(r,\\theta,\\phi)|\\ r^2\\sin \\theta\\ dr\\ d\\theta\\ d\\phi}}=\\\\\n\\int_{a_o}^{\\infty} { \\int_{0}^{\\pi} { \n\\int_{-\\pi}^{\\pi} \\left(\\frac{e^{-\\frac{-rZ}{a_o}}Z \\sqrt{\\frac{Z}{a_o}}}{a_o \\sqrt{\\pi}}\n\\right )^2 \\ r^2\\sin \\theta\\ dr\\ d\\theta\\ d\\phi}} =\\\\\n\\int_{a_o}^{\\infty} { \\int_{0}^{\\pi} { \n\\int_{-\\pi}^{\\pi} \n\\frac{e^{-\\frac{2r Z}{a}} r^2 Z^3 \\sin\\theta}{a^3 \\pi}\\ dr\\ d\\theta\\ d\\phi}}=\ne^{2Z}(1+2Z(1+Z)), \\ \\text{for}\\ Re\\left(\\frac{Z}{a_o}\\right )>0.$$\n\n\nFor $Z=1$,\n$$Pr(r\\geq a_o)=\n    \\begin{cases}\n        \\frac{5}{e^2}\\approx 0.6766764  & \\text{if } a_o< 1\\\\\n        1 & \\text{if } a_o\\geq 1\n    \\end{cases}\n.$$\n\n**Hence, in the case of the quantum triple $(n=1, l=0, m=0)$, given that $a_o< 1$, we have a relatively large probability, about $\\frac{2}{3}$, that the \nparticle is at least $1$ Bohr radius away from the hydrogen nucleus!**\n\nPreviously, in the case of a different quantum triple $n=2, l=1, m=0$, we had computed the probability $Pr(r\\geq a_o)$ to be $0.9963402\\approx \\frac{3}{3}$, which is much larger than that for this quantum triple $(n=1, l=0, m=0)$.\n\n\n## Radial Probability Distribution Functions\n\nThe following product, part of the above probability, is the \n*radial probability distribution function* \n\n$$P_{n\\ l}(r)=r^2R^2_{n\\ l}(r) . $$\n\nWe interpret $P_{n\\ l}(r)dr$ as the *probability that the \nelectron's position is in a radial shell of thickness $dr$ around a 2-sphere of \nradius $r$*.\n\n\n*Notes*:\n\n - The radial probability distribution quantifies why the electron cannot \n collapse into the nucleus, since $P_{n\\ l}(r=0)\\equiv 0$ in a measure theoretic sense corresponds to the likelihood of such collapse must be zero. Also, shrinking the radial shell rapidly\n reduces the probability of finding the electron in that shell, $\\lim_{r\\to 0}P_{n\\ l}(r)= 0$.\n\n - Since each wavefunction corresponds to a probability distribution quantifying\n the likelihood an electron can be found for each energy, the number of allowed states corresponds to the electron properties and system behavior. For instance, \n \n   + For $n=1$, there is *only 1 energy* $E_1$ and 1 wavefunction $\\psi_{1\\ 0\\ 0}$.\n   + For $n=2$, there is *only 1 energy* $E_2$ with 4 possible states corresponding\n   to the following possible harmonic triples $(n,l,m)$ and the four wavefunctions\n   $\\{\\psi_{2\\ 0\\ 0}; \\psi_{2\\ 1\\ -1}; \\psi_{2\\ 1\\ 0}; \\psi_{2\\ 1\\ 1} \\}$. \n   Recall that $l=0,1,2,\\cdots,n-1$ and $m\\in\\{-l,-l+1,\\cdots,0,\\cdots,l-1,l\\}$.\n\n$$l=0\\quad, \\quad m=0\\\\\nl=1\\quad, \\quad m\\in \\{-1,0,1\\} .$$\n\n - When more than $1$ wavefunctions correspond to a given energy level $E_n$, \n that energy level is called *degenerate*. For the hydrogen atom in this example,\n the energy level, $E_2$ is 4-fold degenerate.\n\n\n### Sharp ($s1$) $l=0$ orbitals\n\nThe wavefunctions $\\psi_{n\\ l\\ m}(r,\\theta,\\phi)$ of the electron are called *orbitals*,\nnot because they represent the static 2D surface shells of orbits, but because they\nquantify the probabilities of the electron occupying certain volume for a specific\nallowable energy. The surface shapes of the orbitals are determined by the \nvalues of *angular momentum*. Let's examine the orbital shapes corresponding \nto the $l=0$ orbitals, called $s$ (*sharp*) orbitals. When $l=0 \\implies m=0$\nand the corresponding wavefunctions are \n\n$$\\psi_{n\\ l=0\\ m=0}(r,\\theta,\\phi)=\\underbrace{R_{n\\ 0}(r)}_{radial} \\cdot \n\\underbrace{Y_{0\\ 0}(\\theta,\\phi)}_{angular} =\nR_{n\\ 0}(r)\\cdot \\left (\\frac{1}{4\\pi}\\right ) .$$\n\nAs $Y_{0\\ 0}$ is a constant, \n$\\psi_{n\\ l=0\\ m=0}(r,\\theta,\\phi)\\equiv \\psi_{n\\ l=0\\ m=0}(r)$, \ni.e., $\\psi_{n\\ l=0\\ m=0}$ is independent of $(\\theta, \\phi)$. \nTherefore, all of these 4 orbitals must be *spherically symmetric*.\n\n\nIn particular, the electron probability density in any plane through the nucleus\n(origin) would appear as concentric circles. Different orbital boundaries, \nalso called *nodes*, correspond to trivial ($0$) probability density values. The contour surface boundaries enclose the largest proportions of places occupied by\nelectrons ($\\sim 90\\%$ of the electron probability), at different $1s$, $2s$, and $3s$\norbitals. Of course, the wave function may be either positive or negative, \nbut its *amplitude* is always non-negative, $|\\psi_{n\\ l=0\\ m=0}(r,\\theta,\\phi)|^2\\geq 0$.\n\nThe density of points decreases exponentially as $r$ increases, \nbecause of the exponential dependence of the functions $R_{n\\ 0}(r)$.\n\nAlso, $n\\to\\infty$ implies exponentials decay more slowly,\n$e^{-r/a_0}$ for $n=1$, $e^{-r/2a_0}$, for $n=2$, and \n$e^{-r/3a_0}$, for $n=3$. The wavefunctions peak at $r=0$, suggesting\nthat the maximum amplitude to find the electron is on top of the nucleus (at the origin)!\nHowever, since the *radial probability* density contains an extra $r^2$ factor\ncorresponding to the volume element $dV$, the probability \n $\\lim_{r\\to 0}P_{n\\ l}(r) =0$.\n\nThe most probable annulus for the hydrogen electron in the ground state. \nThe following plot shows the dependence of 3 functions on the radius, $r$, \n\n - The electron *probability density* $\\psi^2$ smoothly decreasing with $r\\uparrow$.  The density is greatest in the innermost shells of the state space, near the nucleus.\n - The *surface area* (spherical for hydrogen) of each shell, $S=4\\pi r^2$, monotonically increases with $r\\uparrow$. \n - The distribution of dots in each spherical shell, reflecting the *total probability*  of finding the electron at a given value of $r$. With $r\\uparrow$, the surface area of each shell increases faster than the electron probability density decreases. The electron *radial probability* has a peak corresponding to the  *(expected) most probable radius* for the $1s$ electron, $52.9\\ pm$, the radius predicted by Bohr’s model of the hydrogen atom.\n\n\n\nNext, we can compare the *radial probability densities* of the first 3  radial wavefunctions $(n\\in\\{1,2,3\\},\\ l=0,\\ m=0)$, \n$P_{n\\ l}=R_{n\\ l}(r)\\cdot \\left (\\frac{1}{4\\pi}\\right )^2\\cdot r^2$.\nThe electron *radial probability* is a function of distance from the nucleus ($r$) in all radial directions - the most probable radius increases with $n\\uparrow$, however, compared to $1s$,\nthe $2s$ and $3s$ orbitals have regions of significant electron probability at smaller radii.\nNote that the wavefunctions have radial *nodes* where the electron is unlikely to\nappear; $R_{n\\ 0}(r)$ has $n-1$ number of nodes - *shell boundaries.*\n\n\n\n### Principal ($2p$) $l=1$ orbitals\n\nThe Principal $l=1$ orbital are described by the product of the *radial* and *angular* components\n\n$$\\psi_{n\\ l\\ m}(r,\\theta,\\phi)=\\underbrace{R_{n\\ 1}(r)}_{radial} \\cdot \n\\underbrace{Y_{1\\ m}(\\theta,\\phi)}_{angular}.$$\n\nThe angular components are\n\n$$Y_{1\\ 0}(\\theta,\\phi)=\\pm\\left (\\frac{3}{4\\pi}\\right )^{1/2} \\cos\\theta \\ , \\\\\nY_{1\\ \\pm 1}(\\theta,\\phi)=\\pm\\left (\\frac{3}{8\\pi}\\right )^{1/2} \\sin\\theta \\ \ne^{\\pm i\\phi}\\ .$$\n\nThese orbitals are not spherically symmetric, as the sharp $1S$ orbitals, however\nthey exhibit different types of symmetries.\n\nDue to its synergy to the spherical coordinate transformation for $z$, $z=r\\cos\\theta$, the $m=0$ orbital is called $p_z$ *orbital*. This $p_z$ orbital\ndepends on $\\theta$, via the $\\cos\\theta$ function, but is $\\phi$ dependent. \n\nBelow, we visualize the $2p$ in 3D. The *nodal plane* in the $p$\norbital corresponds to $\\theta=\\frac{\\pi}{2}$, since $\\forall \\phi, \\ \\cos(\\pi/2)=0$,\nand the node boundary is a flat $(x,y)$ plane, a *nodal plane*.\n\nThe $\\psi_{n\\ 1\\ 1}(r,\\theta,\\phi)$ and  $\\psi_{n\\ 1\\ -1}(r,\\theta,\\phi)$\norbitals include *complex components*, since $\\psi_{n\\ 1\\ \\pm1}$ depends on\nthe term $e^{\\pm i\\phi}$. Even though these orbitals contain imaginary components, \nsince $\\psi_{n\\ 1\\ \\pm1}$ are solutions of the Schrödinger \nequation with the same energy $E_n$, any linear combination of these two functions\nwill also be a solution of the Schrödinger equation at the same energy level. \nWe can work with two combinations that both yield two real orbitals. For instance,\n$p_x,p_y$,\n\n$$\\tilde{\\psi}_{p_x} = \\frac{1}{\\sqrt{2}}(\\psi_{n\\ 1\\ -1}(r,\\theta,\\phi)-\n\\psi_{n\\ 1\\ 1}(r,\\theta,\\phi))\\ , \\\\\n\\tilde{\\psi}_{p_y} = \\frac{1}{\\sqrt{2}}(\\psi_{n\\ 1\\ -1}(r,\\theta,\\phi)+\n\\psi_{n\\ 1\\ 1}(r,\\theta,\\phi))\\ .$$\n\nThe corresponding spherical harmonics are\n\n$$Y_{p_x}(\\theta,\\phi) = \\frac{1}{\\sqrt{2}}(Y_{\\ 1\\ -1}(r,\\theta,\\phi)-\nY_{1\\ 1}(r,\\theta,\\phi))=\\left (\\frac{3}{4\\pi}\\right )^{1/2}\\sin\\theta\\ \\cos\\phi\\ , \\\\\nY_{p_y}(\\theta,\\phi) = \\frac{i}{\\sqrt{2}}(Y_{\\ 1\\ -1}(r,\\theta,\\phi)+\nY_{1\\ 1}(r,\\theta,\\phi))=\\left (\\frac{3}{4\\pi}\\right )^{1/2}\\sin\\theta\\ \\sin\\phi\\ .$$\n\nSimilarly to the $p_z$ orbital, the $p_x,\\ p_y$ notation reflects the synergies with the spherical coordinate transformations \n$$x=r\\sin\\theta \\ \\cos\\phi \\\\ y=r\\sin\\theta\\ \\sin\\phi\\ .$$\n\nThe $p_x,\\ p_y$ orbitals have the same shape as the $p_z$ orbital, however\nthey are reoriented along the $x$-axis, for the $p_x$, and $y$-axis, for the $p_y$ orbitals.\n\n\n### Diffuse ($3d$) $l=2$ orbitals\n\nThe $l=2$ *diffuse orbitals* also represent combinations of spherical harmonics \nof real orbitals. Corresponding linear combinations of the real orbitals\nare denoted by $Y_{xy}, Y_{xz}, Y_{yz}, Y_{z^2}, Y_{x^2-y^2}$.\nThese five orbitals correspond to quantum numbers with $m\\in \\{-2,-1,0,1,2\\}$. The notation signifies the *angular dependence* corresponding to the second-order\nproducts $\\{xy,\\ xz,\\ yz,\\ z^2,\\ x^2-y^2\\}$.\n\nThe five $3d$ orbitals are shown in the 3D scene below. \nThere are two *nodal surfaces*, i.e., *nodal planes*, in $4$ of the orbitals, \n$p_{xy},\\ p_{xz},\\ p_{yz},\\ p_{x^2-y^2}$.\n\nHowever, the last $3d_{z^2}$ orbital has a *nodal cone* boundary. \nThe number of radial nodes is still $n-l-1$ and the overall number of \nnodes is unchanged. As $l\\uparrow$, *radial nodes* are exchanged for \n*angular nodes.*\n\nFor any of the wavefunctions $\\psi_{n\\ l\\ m}(r,\\theta,\\phi)$, averaging \nmeasurements of the distance between the electron and the origin (atomic nucleus)\nmultiple times yields the *expectation* $r$\n\n$$\\langle r \\rangle=\n\\int_{0}^{\\infty} { \\int_{0}^{\\pi} { \n\\int_{-\\pi}^{\\pi} \n|\\psi_{n\\ l\\ m}(r,\\theta,\\phi)|^2 r^3 \\sin\\theta\\ dr\\ d\\theta\\ d\\phi}}=\\\\\n\\frac{n^2 a_o}{Z}\\left (1+\\frac{1}{2}\\left ( 1-\\frac{l(l+1)}{n^2}\\right ) \\right )\\ .$$\n\n## 3D orbitals\n\n### Sharp ($s$) orbitals, $l=0$\n\n\n\n### Principal orbitals ($p$), $l=1$ \n\nRecall the *quantum triple* $(n,l,m)$ includes $n$, the *principal quantum number*, $l$, the *angular quantum number*, and $m$, the *magnetic quantum number*.\n\n### p1 orbitals: n=2, l=1, m=0\n\n\n\n### p1 orbitals: n=2, l=1, m=1\n\n\n\n\n\n### Diffuse orbitals ($d$), $l=2$ \n\nIn this case, the *quantum triple* $(n,l,m)$ includes the *principal quantum number*,$n$, the *angular quantum number*, $l=2$, and the *magnetic quantum number*, $m\\in\\{-2,-1,0,1,2\\}$.\n\n### n=3,l=2,m=0\n\n\n\n### n=3,l=2,m=1\n\n\n\nThe other orbitals can be obtained similarly through rotation of different axes.\n\n### n=3,l=2,m=2\n\n\n\n\n\n\n\n\n\n\n## Mathematica (Wolfram) script",
      "word_count": 3742
    },
    {
      "title": "3D Scene of Circular Kime-Phase Sampling",
      "content": "The following experiment shows a mock up of 5D spacekime where the three spatial dimensions are compressed into 1D (gray-colored vertical z-axis). The 3D scene shows the cross-product of 1D space and 2D kime. The random *circular kime-phase draws*, $\\{\\varphi_i\\}_{i}^I \\sim \\Phi [-\\pi,\\pi)$ are shown for 3 different processes along with their corresponding pooled (averaged) estimates representing the *observed (measurable) data* reflecting the *observed sampling distribution* of the average phase for each of the 3 independent processes, \n$$\\underbrace{\\overline{\\varphi}}_{measurable\\\\ quantity}=\\frac{1}{I}\\sum_i{\\varphi_i}.$$\nRecall that by [Central Limit Theorem](http://wiki.stat.ucla.edu/socr/index.php/SOCR_EduMaterials_Activities_GeneralCentralLimitTheorem), see [the SOCR CLT papper](https://doi.org/10.1080/10691898.2008.11889560), for all nice phase distributions, $\\Phi [-\\pi,\\pi)$, $\\overline{\\varphi}\\sim N\\left (\\mu_{\\Phi}, \\frac{\\sigma_{\\Phi}^2}{I}\\right )$. As the phase distributions are symmetric, $\\mu_{\\overline{\\varphi}}=\\mathbb{E}(\\overline{\\varphi})=\\mu_{\\Phi}=0$, and \n$$\\sigma_{\\overline{\\varphi}}= \\frac{\\sigma_{\\Phi}^2}{I}\\underbrace{\\longrightarrow}_{I\\to\\infty}0.$$\n\n**Caution**: In the simulation below, to emphasize the differences between different observable processes, we are *artificially offsetting (shifting) the random samples*, and their corresponding mean trajectories (observable patterns). These offsets are both in the vertical (*space*) dimension as well as in the radial (*phase*) space. These offsets are are completely artificial and just intended to enhance the interpretation of the kime-phase sampling process by avoiding significant overlaps of points and observable kime-dynamic trends.\n\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 280
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "subtitle: \"Chapter 6: Circular Kime-Phase and Electron Orbit Densities (Circular Distributions)\"\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "# install.packages(\"circular\")\n# library(crosstalk)\n# crosstalkLibs()\nlibrary(htmlwidgets)\nlibrary(circular)\nlibrary(animation)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(plotly)",
      "line_count": 9
    },
    {
      "section": "Circular Electron Orbit Densities",
      "code": "# Display the electron densities for\ntheta <- seq(-pi, pi, length.out=200)\n\n# beta = is the asymmetry parameter, independent of \\theta, can depend on the excitation\n# energy or the electrons’ kinetic energy\n# theta is the angle integrated cross-section of a given state\nf <- function (theta, beta = -1, sigma=1) {\n    return ( (sigma/(4*pi))*(1 + (beta/2) * (3*cos(theta) * cos(theta) - 1)) )\n}\n\ndf <- data.frame(cbind(theta=theta,\n                       beta_1 = f(theta=theta, beta=-1, sigma=1),\n                       beta0 = f(theta=theta, beta=0, sigma=1),\n                       beta1 = f(theta=theta, beta=1, sigma=1),\n                       beta2 = f(theta=theta, beta=2, sigma=1)))\n\ndf_long <- gather(df, beta, value, c(beta_1,beta0, beta1,beta2), factor_key=TRUE)\n\nplot1 <- ggplot(df_long, aes(x = theta, y = value, colour = beta)) +\n    geom_line() +\n    geom_vline(xintercept=0.954695) +   # 54.7^o = 0.954695 radians\n    labs(title = \"\", x = \"\", y = \"\")+\n    # theme_bw() +\n    geom_label(label=\"54.7 degrees\", x=1.0, y=0.2,\n               label.padding = unit(0.55, \"lines\"), # Rectangle size around label\n               label.size = 0.35,  color = \"black\", fill=\"lightblue\") +\n    ggtitle(\"Electron angular density\") +\n    coord_polar(start = pi/2, direction = -1) +\n    scale_color_manual(labels = c(\"beta=-1\", \"beta=0\", \"beta=1\", \"beta=2\"),\n                       values = c(\"red\", \"gray\", \"blue\", \"green\")) +\n    theme(axis.text.y = element_blank(), plot.title = element_text(hjust=0.5),\n          axis.ticks.y = element_blank(), legend.position=\"bottom\") +\n    guides(color=guide_legend(\"Beta\\nValues\"))\n# ggplotly(plot1)\nplot1",
      "line_count": 35
    },
    {
      "section": "Kime-Phases Circular Distributions",
      "code": "library(animation)\nsaveHTML(\n  {\n  oopt = ani.options(interval = 0.2)\n  set.seed(1234)\n  x <- rvonmises(n=1000, mu=circular(pi/5), kappa=3)\n  y <- rvonmises(n=1000, mu=circular(-pi/3), kappa=5)\n  z <- rvonmises(n=1000, mu=circular(0), kappa=10)\n  r <- runif(n=1000, min=0, max=2)\n  vectorX = as.vector(x)\n  vectorY = as.vector(y)\n  vectorZ = as.vector(z)\n  plotX = c(vectorX[1])\n  plotY = c(vectorY[1])\n  plotZ = c(vectorZ[1])\n  for (i in 2:1000){\n    plotX = c(plotX,vectorX[i])\n    plotY = c(plotY,vectorY[i])\n    plotZ = c(plotZ,vectorZ[i])\n    \n    # Try to \"stack=T the points ....\n    #r1 = sqrt((resx$x)^2+(resx$y)^2)/2; \n    #resx$x = r1*cos(resx$data)\n    #resx$x = r1*cos(resx$data)\n    \n    tempX = circular(plotX)\n    tempY = circular(plotY)\n    tempZ = circular(plotZ)\n    resx <- density(tempX, bw=25, xaxt='n', yaxt='n')\n    resy <- density(tempY, bw=25, xaxt='n', yaxt='n')\n    resz <- density(tempZ, bw=25, xaxt='n', yaxt='n')\n    res <- plot(resx, points.plot=TRUE, xlim=c(-1.1,1.5), ylim=c(-1.5, 1.5), \n                main=\"Trivariate random sampling of\\n kime-magnitudes (times) and kime-directions (phases)\", \n                offset=0.9, shrink=1.0, ticks=T, lwd=3, axes=F, stack=TRUE, bins=150)\n    lines(resy, points.plot=TRUE, col=2, points.col=2, plot.info=res, offset=1.0, shrink=1.45, lwd=3, stack=T)\n    lines(resz, points.plot=TRUE, col=3, points.col=3, plot.info=res, offset=1.1, shrink=1.2, lwd=3, stack=T)\n    segments(0, 0, r[i]*cos(vectorX[i]), r[i]*sin(vectorX[i]), lwd=2, col= 'black')\n    segments(0, 0, r[i]*cos(vectorY[i]), r[i]*sin(vectorY[i]), lwd=2, col= 'red')\n    segments(0, 0, r[i]*cos(vectorZ[i]), r[i]*sin(vectorZ[i]), lwd=2, col= 'green')\n    ani.pause()\n  }\n  \n  \n  # To save animation as MP4 video\n  saveVideo({ \n    oopt = ani.options(interval = 0.2)\n    set.seed(1234)\n    x <- rvonmises(n=1000, mu=circular(pi/5), kappa=3)\n    y <- rvonmises(n=1000, mu=circular(-pi/3), kappa=5)\n    z <- rvonmises(n=1000, mu=circular(0), kappa=10)\n    r <- runif(n=1000, min=0, max=2)\n    vectorX = as.vector(x)\n    vectorY = as.vector(y)\n    vectorZ = as.vector(z)\n    plotX = c(vectorX[1])\n    plotY = c(vectorY[1])\n    plotZ = c(vectorZ[1])\n    for (i in 2:1000){\n      plotX = c(plotX,vectorX[i])\n      plotY = c(plotY,vectorY[i])\n      plotZ = c(plotZ,vectorZ[i])\n      \n      # Try to \"stack=T the points ....\n      #r1 = sqrt((resx$x)^2+(resx$y)^2)/2; \n      #resx$x = r1*cos(resx$data)\n      #resx$x = r1*cos(resx$data)\n      \n      tempX = circular(plotX)\n      tempY = circular(plotY)\n      tempZ = circular(plotZ)\n      resx <- density(tempX, bw=25, xaxt='n', yaxt='n')\n      resy <- density(tempY, bw=25, xaxt='n', yaxt='n')\n      resz <- density(tempZ, bw=25, xaxt='n', yaxt='n')\n      res <- plot(resx, points.plot=TRUE, xlim=c(-1.1,1.5), ylim=c(-1.5, 1.5), \n                  main=\"Trivariate random sampling of\\n kime-magnitudes (times) and kime-directions (phases)\", \n                  offset=0.9, shrink=1.0, ticks=T, lwd=3, axes=F, stack=TRUE, bins=150)\n      lines(resy, points.plot=TRUE, col=2, points.col=2, plot.info=res, offset=1.0, shrink=1.45, lwd=3, stack=T)\n      lines(resz, points.plot=TRUE, col=3, points.col=3, plot.info=res, offset=1.1, shrink=1.2, lwd=3, stack=T)\n      segments(0, 0, r[i]*cos(vectorX[i]), r[i]*sin(vectorX[i]), lwd=2, col= 'black')\n      segments(0, 0, r[i]*cos(vectorY[i]), r[i]*sin(vectorY[i]), lwd=2, col= 'red')\n      segments(0, 0, r[i]*cos(vectorZ[i]), r[i]*sin(vectorZ[i]), lwd=2, col= 'green')\n      ani.pause()\n    }\n    }, \n    video.name = \"C:/Users/Dinov/Desktop/KimeRandomSamplingAnimation.mp4\", \n    other.opts = \"-pix_fmt yuv420p -b:v 500K\",\n    ffmpeg = \"E:/Ivo.dir/Ivo_Tools/ffmpeg-20200218-ebee808-win64-static/bin/ffmpeg.exe\", \n    ani.width = 600, ani.height = 600\n  )\n  },\n  htmlfile  = \"Chapter6_Kime_Phases.html\"\n  \n)",
      "line_count": 93
    },
    {
      "section": "Kime-Phases Helical (Spherical) Distributions",
      "code": "# see these examples: \n#     https://plotly.com/r/3d-line-plots/\n#     https://rpubs.com/daryl-hnl/plotly-3d\n# parabola (as an example of a density model)\na <- 0; b <- 10 # Z-space vertical range of helix\nper <- 2  # helical period\nresol <- 100 # bin points density (resolution)\ns <- seq(from=a, to=b, length.out=resol)\nR <- 50 - 2*(s - (a+b)/2)^2  # parabola open down/inward # plot(s,R)\nbaseline <- 9.5  # radial offset\n\n# A length, s, parameterized Helix equation ( Kime-phase density model)\n# x = R*cos(s), y = R*sin(t), z = s\nx <- R * cos(per*s) + baseline/2\ny <- R * sin(per*s) + baseline/2\nz <- s\n\n# A length, s, parameterized Helix equation (baseline helix)\n# x = cos(s), y = sin(t), z = s\nxb <- 4*cos(per*s)\nyb <- 4*sin(per*s)\n\n# pair start & end indices i <--> i+50\npair_id <- rep(c(1:length(x)), times=2)\n  \ndf <- data.frame(   # concat the x-start and x-end X coordinates\n  X = c(x,xb), Y = c(y,yb), Z = c(z,z), R=R, phi=per*s,\n  color_col = \"lightgray\",pair_id=pair_id)\n\n# plot_ly() %>%\n#   add_trace(x = df$X, y = df$Y, z = df$Z, color = df$color_col, \n#             type = \"scatter3d\", mode = \"markers\") %>%\n#   add_trace(x = df$X, y = df$Y, z = df$Z, split = df$pair_id, \n#             line = list(color = \"red\"), type = \"scatter3d\", \n#             mode = \"lines\", showlegend = FALSE, inherit = FALSE)\n\nplot_ly(x=x, y=y, z=z, type=\"scatter3d\", line=list(width=10, color=\"navy blue\"),\n        mode='markers+lines', name=\"Phase Distribution\") %>%\n  # trace the main Z-axis\n  add_trace(x=0, y=0, z=s, mode=\"lines\",\n              line = list(width = 3, color=\"navy blue\"), name=\"core\") %>%\n              # , hoverinfo=\"none\", showlegend=F) %>%\n  # trace the baseline-helix\n  add_trace(x=xb, y=yb, z=s, mode=\"markers+lines\", \n            marker=list(size = 5, color=\"gray\"),\n            line = list(width = 5, color=\"gray\"), name=\"Phase Domain\") %>%\n  # trace the (radial) density heights\n  add_trace(x=df$X, y=df$Y, z=df$Z, split=df$pair_id, name=\"Phase Density\", \n            line = list(color = df$color_col), type = \"scatter3d\",\n            hovertext = paste(\"PhaseDensity(phi=\", round(df$phi,3), \n                              \")=<br>  \", round(df$R, 3)),\n            mode = \"lines\", showlegend = FALSE, inherit = FALSE) %>%\n  layout(title=\"Helical Kime-Phase Density\",\n         scene = list(xaxis = list(title = 'k1'),\n                      yaxis = list(title = 'k2'),\n                      zaxis = list(title = 'Azimuthal Period')),\n         legend = list(title=\"Functions\", orientation = 'h'))\n\n# test\n# library(plotly)\n# m_x = seq(-2, 2, .01)\n# m_y = seq(-2, 2, .01)\n# df = expand.grid(m_x, m_y)\n# df['matrix'] = exp(-(df$Var1^2+df$Var2^2))\n# m_z = matrix(df$matrix, nrow = length(m_x), ncol = length(m_y))\n# m_df = list(m_x, m_y, m_z)\n# \n# x1 = seq(-2, 0, by=0.0202)\n# y1 = runif(100, min=-0.03,max=0.03)\n# z1 = exp(-(x1^2+y1^2))\n# df = data.frame(x1, y1, z1)\n# names(df) <- c(\"df_x\", \"df_y\", \"df_z\")\n# \n# colors = c( \"Blue\",  \"Cyan\", \"Green\", \"Yellow\", \"Orange\", \"Red\")\n# p1 <- plot_ly(x = m_df[[1]], y = m_df[[2]], z = m_df[[3]],\n#               colors = colors, color = m_df[[3]]) %>% add_surface()  %>%\n#   add_trace(x = ~df_x, y = ~df_y, z = ~df_z, data = df, \n#             type=\"scatter3d\", mode=\"lines\",\n#             line = list(color = \"blue\", width = 4)) %>%\n#   layout(title = \"Hike_Example\",\n#        scene = list(aspectratio = list(x = 4, y = 4, z = 1)))\n# p1",
      "line_count": 82
    },
    {
      "section": "Diffraction Pattern Interpretation of Kime-Phases",
      "code": "# this is a simple modification of the earlier example\n# parabola (as an example of a density model)\na <- 0; b <- 10 # Z-space vertical range of helix\nper <- 4  # helical period\nresol <- 100 # bin points density (resolution)\ns <- sort(runif(resol, min=a, max=b))\nsb <- sort(runif(resol, min=a, max=b))\nR <- 50 # - 2*(s - (a+b)/2)^2  # parabola open down/inward # plot(s,R)\nRb <- 4\nbaseline <- 1  # radial offset\n\n# A length, s, parameterized Helix equation ( Kime-phase density model)\n# x = R*cos(s), y = R*sin(t), z = s\nx <- R * cos(per*s) + baseline/2\ny <- R * sin(per*s) + baseline/2\nz <- s\n\n# A length, s, parameterized Helix equation (baseline helix)\n# x = cos(s), y = sin(t), z = s\nxb <- Rb*cos(per*sb)\nyb <- Rb*sin(per*sb)\n\n# pair start & end indices i <--> i+50\npair_id <- rep(c(1:length(x)), times=2)\n  \ndf <- data.frame(   # concat the x-start and x-end X coordinates\n  X = c(x,xb), Y = c(y,yb), Z = c(z,z), R=c(rep(R,resol),rep(Rb, resol)),\n  phi=c(per*s,per*sb), color_col=\"lightgray\", pair_id=pair_id)\n\nplot_ly(x=x, y=y, z=z, type=\"scatter3d\", line=list(width=10, color=\"navy blue\"),\n        mode='markers+lines', name=\"Phase Distribution\") %>%\n  # trace the main Z-axis\n  add_trace(x=0, y=0, z=s, mode=\"lines\",\n              line = list(width = 3, color=\"navy blue\"), name=\"core\") %>%\n              # , hoverinfo=\"none\", showlegend=F) %>%\n  # trace the baseline-helix\n  add_trace(x=xb, y=yb, z=sb, mode=\"markers+lines\", \n            marker=list(size = 5, color=\"gray\"),\n            line = list(width = 5, color=\"gray\"), name=\"Phase Domain\") %>%\n  # trace the (radial) density heights\n  add_trace(x=df$X, y=df$Y, z=df$Z, split=df$pair_id, name=\"Phase Density\", \n            line = list(color = df$color_col), type = \"scatter3d\",\n            hovertext = paste(\"phi=\", round(df$phi,3), \n                              \"<br>AxialPlane=\", round(df$phi/(2*pi),0), \n                              \"<br>PhaseDensity=\", round(df$R, 3)),\n            mode = \"lines\", showlegend = FALSE, inherit = FALSE) %>%\n  layout(title=\"Diffraction Pattern Interpretation of Kime-Phases\",\n         scene = list(xaxis = list(title = 'k1'),\n                      yaxis = list(title = 'k2'),\n                      zaxis = list(title = 'Azimuthal Period')),\n         legend = list(title=\"Functions\", orientation = 'h'))",
      "line_count": 51
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "# Bohr radius constant\na_o <- 0.529177 * (10^(-10))\n\n# radial parts of the wavefunctions using pm picometer (1×10-¹² of a meter) distance\nR_1_0 <- function (r, a=a_o*(10^(10)), Z=1) {\n  return (2 * ((Z/a))^(3/2) * exp(-Z*r/a))\n}\n\nR_2_0 <- function (r, a=a_o*(10^(10)), Z=1) {\n  return ( (1/(2*sqrt(2))) * (Z/a)^(3/2) * (2- (Z*r)/(a)) * exp(-Z*r/(2*a)) )\n}\n\nR_2_1 <- function (r, a=a_o*(10^(10)), Z=1) {\n  return ( (1/(2*sqrt(6))) * (Z/a)^(3/2) * (Z*r/a) * exp(-Z*r/(2*a)))\n}\n\nR_3_0 <- function (r, a=a_o*(10^(10)), Z=1) {\n  return ( (2/(81*sqrt(3))) * (Z/a)^(3/2) * (27- 18*(Z*r/a) +\n                                                2*(Z*r/a)^2) * exp(-Z*r/(3*a)))\n}\n\npdf_psi2 <- function (r, n, l) {\n  #####  return ( R(r, n, l) * (1/(4*pi)) )\n  if (n==1 & l==0) return ( (R_1_0(r) * (1/(4*pi)))^2 )\n  else if (n==2 & l==0) return ( (R_2_0(r) * (1/(4*pi)))^2 )\n  else if (n==2 & l==1) return ( (R_2_1(r) * (1/(4*pi)))^2 )\n  else if (n==3 & l==0) return ( (R_3_0(r) * (1/(4*pi)))^2 )\n  else { print('Invalid harmonic parameters (n,l) ...')\n    return()\n  }\n} # Test: pdf_psi2(1, 3,0)\n\nsphericalSurfaceArea <- function (r) {\n  return (4*pi*r^2)\n} # Test: sphericalSurfaceArea(1)\n\nradialProbability <- function (r, n, l) {\n  return (pdf_psi2(r, n, l) * r^2)\n} # Test: radialProbability(1, 1, 0)\n\nrad <- seq (from=10^(-5), to=2, length.out=1000)\n\ndf <- data.frame(cbind(radius=rad, probDensity=pdf_psi2(rad, 1,0), \n                       sphericalSurfaceArea=sphericalSurfaceArea(rad),\n                       radialProbability=radialProbability(rad, 1,0)))\nlibrary(plotly)\n\ndf %>% plot_ly() %>%\n  add_trace(x=~rad, y=~probDensity, type=\"scatter\", mode=\"lines\", \n            name=\"Radial Probability Density (Psi^2)\") %>%\n  add_trace(x=~rad, y=~(10^(-2) *sphericalSurfaceArea), type=\"scatter\", mode=\"lines\", \n            name=\"Spherical Surface Area (4 pi r^2)\") %>%\n  add_trace(x=~rad, y=~(10 * radialProbability), type=\"scatter\", mode=\"lines\", \n            name=\"Total Radial Probability (Psi^2 * r^2)\") %>%\n  layout(title=\"Radial Density, Surface Area & Total Probability\",\n           xaxis = list(title = 'Radius (r)'),\n           yaxis = list(title =\"Functional Values\"),\n           legend = list(title=\"Functions\", orientation = 'h'))",
      "line_count": 58
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "rad <- seq (from=10^(-5), to=15, length.out=1000)\n\ndf <- data.frame(cbind(radius=rad, RadProb_1_0=radialProbability(rad, 1,0), \n                       RadProb_2_0=radialProbability(rad, 2,0),\n                       RadProb_3_0=radialProbability(rad, 3,0)))\ndf %>% plot_ly() %>%\n  add_trace(x=~rad, y=~(RadProb_1_0), type=\"scatter\", mode=\"lines\", \n            name=\"Radial Prob 1s\") %>%\n  add_trace(x=~rad, y=~RadProb_2_0, type=\"scatter\", mode=\"lines\", \n            name=\"Radial Prob 2s\") %>%\n  add_trace(x=~rad, y=~RadProb_3_0, type=\"scatter\", mode=\"lines\", \n            name=\"Radial Prob 3s\") %>%\n  layout(title=\"Radial Probabilities (1s, 2s, 3s)\",\n           xaxis = list(title = 'Radius (r)'),\n           yaxis = list(title =\"Electron Probability (Psi^2 * r^2)\"),\n           legend = list(title=\"Functions\", orientation = 'h'))",
      "line_count": 16
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "library(plotly)\n# sweep or define (u,v) spherical coordinate parameter ranges\nresol <- 50\ntheta <- seq(from = 0, to = pi, by = ((pi - 0)/(resol - 1)))\nphi <- seq(from = -pi, to = pi, by = ((2*pi)/(resol - 1)))\n\n#### l=0 Sharp orbitals (s) ####################################\nR_n_0 <- function (r, n=1, a=a_o*(10^(10)), Z=1) {\n  if (n==1) return ( R_1_0(r) )\n  else if (n==2) return ( R_2_0(r) )\n  else if (n==3) return ( R_3_0(r) )\n  else { print('Invalid harmonic parameters (n,l) for R_n_0() ...')\n    return()\n  }\n}\n\npdf_psi_n_0_0 <- function (r, n) {\n  return ( R_n_0(r, n) * (1/(4*pi))^(1/2) )\n} # Test: pdf_psi_n_0_0(1, 1)\n\nshape_names <- c(\"1s\", \"2s\", \"3s\")\n\n# shape==\"1s\")  # Spheres\n    # rendering (u,v) parametric surfaces requires x,y,z arguments to be 2D arrays\n    # In out case, the three coordinates have to be 200*200 parameterized tensors/arrays\n    r1 = 1.4                           # ~90% of RadialProbability  1s\n    x1 = r1 * cos(phi) %o% sin(theta)   # x = r*cos(phi)*sin(psi)\n    y1 = r1 * sin(phi) %o% sin(theta)   # y = r*sin(phi)*sin(psi)\n    z1 = r1 * rep(1, resol) %o% cos(theta) # still need z to be 200*200 parameterized tensor/array\n\n    \n#shape==\"2s\") # Spheres\n    # rendering (u,v) parametric surfaces requires x,y,z arguments to be 2D arrays\n    # In out case, the three coordinates have to be 200*200 parameterized tensors/arrays\n    r2_node1 = 1.3    # ~90% of RadialProbability  2s (node 1)\n    x2_node1 = r2_node1 * cos(phi) %o% sin(theta)    # x = r*cos(phi)*sin(psi)\n    y2_node1 = r2_node1 * sin(phi) %o% sin(theta)      # y = r*sin(phi)*sin(psi)\n    z2_node1 = r2_node1*rep(1, resol) %o% cos(theta)  # z = r*cos(psi)\n    \n    r2_node2 = 3.1    # ~90% of RadialProbability  2s (node 2)\n    x2_node2 = r2_node2 * cos(phi) %o% sin(theta)    # x = r*cos(phi)*sin(psi)\n    y2_node2 = r2_node2 * sin(phi) %o% sin(theta)     # y = r*sin(phi)*sin(psi)\n    z2_node2 = r2_node2*rep(1, resol) %o% cos(theta)  # z = r*cos(psi)\n    \n#shape==\"3s\")  # Spheres\n    # rendering (u,v) parametric surfaces requires x,y,z arguments to be 2D arrays\n    # In out case, the three coordinates have to be 200*200 parameterized tensors/arrays\n    r3_node1 = 0.8    # ~90% of RadialProbability  2s (node 1)\n    x3_node1 = r3_node1 * cos(phi) %o% sin(theta)      # x = r*cos(phi)*sin(psi)\n    y3_node1 = r3_node1 * sin(phi) %o% sin(theta)      # y = r*sin(phi)*sin(psi)\n    z3_node1 = r3_node1*rep(1, resol) %o% cos(theta)  # z = r*cos(psi)\n    \n    r3_node2 = 4    # ~90% of RadialProbability  2s (node 2)\n    x3_node2 = r3_node2 * cos(phi) %o% sin(theta)     # x = r*cos(phi)*sin(psi)\n    y3_node2 = r3_node2 * sin(phi) %o% sin(theta)      # y = r*sin(phi)*sin(psi)\n    z3_node2 = r3_node2*rep(1, resol) %o% cos(theta)  # z = r*cos(psi)\n    \n    r3_node3 = 12    # ~90% of RadialProbability  2s (node 2)\n    x3_node3 = r3_node3 * cos(phi) %o% sin(theta)     # x = r*cos(phi)*sin(psi)\n    y3_node3 = r3_node3 * sin(phi) %o% sin(theta)      # y = r*sin(phi)*sin(psi)\n    z3_node3 = r3_node3*rep(1, resol) %o% cos(theta)  # z = r*cos(psi)\n    \n# updatemenus component\nupdatemenus <- list(\n  list(\n    active = -1,\n    type = 'buttons',\n    buttons = list(\n      list(\n        label = shape_names[1],\n        method = \"update\",\n        args = list(list(visible = c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)),\n                    list(title = shape_names[1]))),\n      list(\n        label = shape_names[2],\n        method = \"update\",\n        args = list(list(visible = c(FALSE, TRUE, TRUE, FALSE, FALSE, FALSE)),\n                    list(title = shape_names[2]))),\n      list(\n        label = shape_names[3],\n        method = \"update\",\n        args = list(list(visible = c(FALSE, FALSE, FALSE, TRUE, TRUE, TRUE)),\n                    list(title = shape_names[3])))\n    )\n  )\n)\n\n# p <- plot_ly(hoverinfo=\"none\", legendshow=FALSE, showscale = FALSE) %>%\n#   add_trace(x = ~x1, y = ~y1, z = ~z1, type = 'surface', opacity=0.3, visible=T,\n#              contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n#                           opacity=1.0, hoverinfo=\"none\", legendshow=F)) %>%\n#   add_trace(x = ~x2_node1, y = ~y2_node1, z = ~z2_node1, type='surface', opacity=0.6, visible=F,\n#              contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n#                           opacity=1.0, hoverinfo=\"none\", legendshow=F)) %>%\n#   add_trace(x = ~x2_node2, y = ~y2_node2, z = ~z2_node2, type='surface', opacity=0.3, visible=F,\n#              contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n#                           opacity=1.0, hoverinfo=\"none\", legendshow=F)) %>%\n#   add_trace(x = ~x3_node1, y = ~y3_node1, z = ~z3_node1, type = 'surface', opacity=0.9, visible=F,\n#              contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n#                           opacity=0.9, hoverinfo=\"none\", legendshow=F)) %>%\n#   add_trace(x = ~x3_node2, y = ~y3_node2, z = ~z3_node2, type = 'surface', opacity=0.4, visible=F,\n#              contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n#                           opacity=0.4, hoverinfo=\"none\", legendshow=F)) %>%\n#   add_trace(x = ~x3_node3, y = ~y3_node3, z = ~z3_node3, type = 'surface', opacity=0.2, visible=F,\n#              contour=list(show=TRUE, color=\"#000\", width=15, lwd=10,\n#                           opacity=0.2, hoverinfo=\"none\", legendshow=F)) %>%\n#   layout(title = \"Choose a Shape\", showlegend = FALSE, updatemenus = updatemenus)\n# p\n\nplot_ly(hoverinfo=\"none\",  showscale = FALSE) %>%\n    add_trace(x = ~x1, y = ~y1, z = ~z1, type = 'surface', opacity=0.3, visible=T) %>%\n    add_trace(x = ~x2_node1, y = ~y2_node1, z = ~z2_node1, type='surface', opacity=0.6, visible=F) %>%\n    add_trace(x = ~x2_node2, y = ~y2_node2, z = ~z2_node2, type='surface', opacity=0.3, visible=F) %>%\n    add_trace(x = ~x3_node1, y = ~y3_node1, z = ~z3_node1, type = 'surface', opacity=0.9, visible=F) %>%\n    add_trace(x = ~x3_node2, y = ~y3_node2, z = ~z3_node2, type = 'surface', opacity=0.4, visible=F) %>%\n    add_trace(x = ~x3_node3, y = ~y3_node3, z = ~z3_node3, type = 'surface', opacity=0.2, visible=F) %>%\n    layout(title = \"Choose a Shape\", updatemenus = updatemenus)",
      "line_count": 117
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "library(plotly)\nY_1_0 <- function (r, l=1, m=0, theta, phi) {\n  return (  cos(theta) )\n}\nY_1_1_mag <- function ( theta, phi) {\n  return (  sin(theta)**2 )\n}\n\nR_2_1 <- function (r, a=a_o*(10^(10)), Z=1) {\n  return ((r) * exp(-r))\n}\npdf_psi_n_l_m <- function (r, n=2, l=1, m=0, theta, phi) {\n  if (n==2 & l==1 & m==0) return ( r**2*R_2_1(r)**2  * Y_1_0(r, l=1, m=0, theta, phi)**2)\n  else if (n==2 & l==1 & m==1) return ( r**2*R_2_1(r)**2  * Y_1_1_mag(theta, phi)**2)\n  else { print('Invalid harmonic parameters (n,l) for pdf_psi_n_l_m() ...')\n    return()\n  }\n}\nmeshgridn = function(L){\n  out = list()\n  n = sapply(L, length)\n  w = 1:length(L)\n  for(i in w){\n    out[[i]] = rep(rep(L[[i]], rep(prod(n[w<i]), n[i])), prod(n[w>i]))\n    # prod(NULL) == 1, so this works.\n  }\n  return(out)\n}\n\ngr <- meshgridn(list(x=seq(from=-5 , to=5, length.out=10), \n               y=seq(from=-5 , to=5, length.out=10),\n               z=seq(from=-5, to=5, length.out=10)))\n\n\n\nr = sqrt(gr[[1]]^2 + gr[[2]]^2 + gr[[3]]^2)\nphi = atan2(gr[[2]],gr[[1]])\ntheta = acos(gr[[3]]/sqrt(gr[[1]]^2 + gr[[2]]^2+gr[[3]]^2))\n# replace Nan with 0\ntheta[is.nan(theta)] <- 0",
      "line_count": 40
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "# n=2,l=1,m=0\np <-plot_ly(type='isosurface', x = gr[[1]], y = gr[[2]], z = gr[[3]],\n  value = as.vector(100*abs(pdf_psi_n_l_m(r, n=2, l=1, m=0, theta, phi))), \n  isomin=6,  isomax=23.7, opacity=0.7, name=\"Psi_{nlm}(r,theta,phi)\",\n  colorscale='RdBu', surface = list(show = TRUE, count =2),\n  slices = list(y = list(show = TRUE, locations = c(0)),\n  x = list(show = TRUE, locations = c(0))))  %>%\n  ### X-Y Plane (z=0)\n  add_mesh(type = 'mesh3d', name=\"pz (m=0)\",\n             # Define all (4) zero-cells (points or vertices)\n             # P_i(x,y,z), 0<=i<4\n             x=c(-5, -5, 5, 5), y=c(-5, 5, -5, 5), z=c(0, 0, 0, 0),\n             # Next define all triples (i,j,k) of vertices that form a 2-cell face.\n             # All Tetrahedra have 4 faces\n             i = c(0, 0), j = c(2, 1), k = c(3, 3),\n             # Define the appearance of the 4 faces (2-cells)\n             intensity = c(0.33, 0.33, 0.33, 0.33),\n             color = \"gray\", opacity=0.6)%>% \n  hide_colorbar()\np",
      "line_count": 20
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "library(plot3D)\nM <- mesh(seq(0, 2,length.out=2000), seq(0, 2*pi,length.out=50))\nr <- exp(M$x)-1;  phi<- M$y\nsurface_para <- 0.1\ncosthe <- sqrt(surface_para/(r**4*exp(-2*r)))\nsinthe <- sqrt(1-surface_para/(r**4*exp(-2*r)))\n# patch the holes\nsinthe[sinthe<0.1] <-0\nx <- r*sinthe*cos(phi)\ny <- r*sinthe*sin(phi)\nz <- r*costhe\nsurface_para <- 0.15\ncosthe <- sqrt(surface_para/(r**4*exp(-2*r)))\nsinthe <- sqrt(1-surface_para/(r**4*exp(-2*r)))\n# patch the holes\nsinthe[sinthe<0.1] <-0\nx1 <- r*sinthe*cos(phi)\ny1 <- r*sinthe*sin(phi)\nz1 <- r*costhe\np <- plot_ly(x = x, y = y, z = z, type = \"surface\",colorscale = list(c(0,1),c(\"rgb(255,107,184)\",\"rgb(128,0,64)\")),showscale = FALSE, opacity=0.6) %>%\n  layout(title = \"Surface plot of the p0 orbital\")%>% add_trace(x = x, y = y, z = -z, type=\"surface\", colorscale = list(c(0,1),c(\"rgb(255,107,184)\",\"rgb(128,0,64)\")),showscale = FALSE, opacity=0.6) %>%add_trace(x = x1, y = y1, z = z1, type=\"surface\",showscale = FALSE, opacity=0.6)%>%add_trace(x = x1, y = y1, z = -z1, type=\"surface\",showscale = FALSE, opacity=0.6)\n\np",
      "line_count": 23
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "r = sqrt(gr[[1]]^2 + gr[[2]]^2 + gr[[3]]^2)\nphi = atan2(gr[[2]],gr[[1]])\ntheta = acos(gr[[3]]/sqrt(gr[[1]]^2 + gr[[2]]^2+gr[[3]]^2))\n# replace Nan with 0\ntheta[is.nan(theta)] <- 0\np <-plot_ly(type='isosurface', x = gr[[1]], y = gr[[2]], z = gr[[3]],\n  value = as.vector(100*abs(pdf_psi_n_l_m(r, n=2, l=1, m=1, theta, phi))), \n  isomin=6,  isomax=25, opacity=0.7, name=\"Psi_{nlm}(r,theta,phi)\",\n  colorscale='RdBu', surface = list(show = TRUE, count =1),\n  slices = list(y = list(show = TRUE, locations = c(0)),\n  x = list(show = TRUE, locations = c(0)),\n  z = list(show = TRUE, locations = c(0))\n  ))  %>%\n  ### X-Y Plane (z=0)\n  add_mesh(type = 'mesh3d', name=\"pz (m=0)\",\n             # Define all (4) zero-cells (points or vertices)\n             # P_i(x,y,z), 0<=i<4\n             x=c(-5, -5, 5, 5), y=c(-5, 5, -5, 5), z=c(0, 0, 0, 0),\n             # Next define all triples (i,j,k) of vertices that form a 2-cell face.\n             # All Tetrahedra have 4 faces\n             i = c(0, 0), j = c(2, 1), k = c(3, 3),\n             # Define the appearance of the 4 faces (2-cells)\n             intensity = c(0.33, 0.33, 0.33, 0.33),\n             color = \"gray\", opacity=0.6)%>% \n  hide_colorbar()\np",
      "line_count": 26
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "library(plot3D)\nM <- mesh(seq(0, 2,length.out=2000), seq(0, 2*pi,length.out=50))\nr <- exp(M$x)-1;  phi<- M$y\nsurface_para <- 0.1\nsinthe <- sqrt(surface_para/(r**4*exp(-2*r)))\ncosthe <- sqrt(1-surface_para/(r**4*exp(-2*r)))\n# patch the holes\n# sinthe[sinthe>0.9] <-1\ncosthe[costhe<0.1] <-0\nx <- r*sinthe*cos(phi)\ny <- r*sinthe*sin(phi)\nz <- r*costhe\nsurface_para <- 0.15\nsinthe <- sqrt(surface_para/(r**4*exp(-2*r)))\ncosthe <- sqrt(1-surface_para/(r**4*exp(-2*r)))\n# patch the holes\ncosthe[costhe<0.1] <-0\nx1 <- r*sinthe*cos(phi)\ny1 <- r*sinthe*sin(phi)\nz1 <- r*costhe\np <- plot_ly(x = x, y = y, z = z, type = \"surface\",colorscale = list(c(0,1),c(\"rgb(255,107,184)\",\"rgb(128,0,64)\")),showscale = FALSE, opacity=0.6) %>%\n  layout(title = \"Surface plot of the p1 orbital\")%>% add_trace(x = x, y = y, z = -z, type=\"surface\", colorscale = list(c(0,1),c(\"rgb(255,107,184)\",\"rgb(128,0,64)\")),showscale = FALSE, opacity=0.6) %>%add_trace(x = x1, y = y1, z = z1, type=\"surface\",showscale = FALSE, opacity=0.6)%>%add_trace(x = x1, y = y1, z = -z1, type=\"surface\",showscale = FALSE, opacity=0.6)\n\np",
      "line_count": 24
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "#### l=3 Diffuse orbitals (d) \nR_n_3 <- function (r, n=3, a=a_o*(10^(10)), Z=1) {\n  if (n==1) { print('Invalid harmonic parameters (n,l) for R_n_0() ...')\n    return()\n  } else if (n==2) { print('Invalid harmonic parameters (n,l) for R_n_0() ...')\n    return()\n  }  else if (n==3) return ( R_3_3(r) )   # default\n  else { print('Invalid harmonic parameters (n,l) for R_n_0() ...')\n    return()\n  }\n}\n\n# Radial Density: P_{n\\ l}(r)=r^2R^2_{n\\ l}(r)\nP_n_l_r <- function (r, n=2, l=0) {\n  return ( r^2 * (R_n_1(r))^2 )\n}\n\n# Y_1_0 <- function (r, l=1, m=0, theta, phi) {\n#   return ( (3/(4*pi))^(1/2) * cos(theta) %o% rep(1, resol) )\n# }\nY_1_0 <- function (r, l=1, m=0, theta, phi) {\n  return ( rep((3/(4*pi))^(1/2), resol) %o% cos(theta) )\n}\n\n# radial parts of the wavefunctions using pm picometer (10^{-12} of a meter) distance\nR_2_0 <- function (r, a=a_o*(10^(10)), Z=1) {\n  return ( (1/(2*sqrt(2))) * (Z/a)^(3/2) * (2- (Z*r)/(a)) * exp(-Z*r/(2*a)) )\n}\n\nR_2_1 <- function (r, a=a_o*(10^(10)), Z=1) {\n  return ( (1/(2*sqrt(6))) * (Z/a)^(3/2) * (Z*r/a) * exp(-Z*r/(2*a)))\n}\n\nR_3_0 <- function (r, a=a_o*(10^(10)), Z=1) {\n  return ( (2/(81*sqrt(3))) * (Z/a)^(3/2) * (27- 18*(Z*r/a) +\n                                                2*(Z*r/a)^2) * exp(-Z*r/(3*a)))\n}\n\nR_3_2 <- function (r, a=a_o*(10^(10)), Z=1) {\n  rho=(2*Z*r)/3\n  #return ( (1/(9*sqrt(30))) * (rho)^2 * Z^(3/2) * exp(-rho/2) )\n  return ( (rho)^2 *exp(-rho/2) )\n}\n\nY_2_0 <- function (r, a=a_o*(10^(10)), Z=1, theta=pi/2, phi=0) { # cone node\n  #return  ( ((sqrt(5/4))) * (3*cos(theta)**2-1) * sqrt(1/(4*pi)) )\n  return  (  (3*cos(theta)**2-1))\n}  # Y_3_z2(r=10, theta=pi/3)\n\nY_2_1 <- function (r, a=a_o*(10^(10)), Z=1, theta=pi/2, phi=0) { # cone node\n  return  (  -sin(theta)*cos(theta)) # ignore the phase phi factor\n}  \nY_2_2 <- function (r, a=a_o*(10^(10)), Z=1, theta=pi/2, phi=0) { # cone node\n  return  (  sin(theta)**2) # ignore the phase phi factor\n}  \n\n# \\psi_{n\\ l\\ m}(r,\\theta,\\phi)=\\underbrace{R_{n\\ l}(r)}_{radial} \\cdot \n# \\underbrace{Y_{l\\ m}(\\theta,\\phi)}_{angular}, \\quad n,l,m\\in\\mathbb{Z}\npdf_psi_n_l_m <- function (r, n=3, l=2, m=0, theta, phi) {\n  if (n==3 & l==2 & m==0) return ( r**2*R_3_2(r)**2  * Y_2_0(r, theta=theta, phi=phi)**2 )\n  else if(n==3 & l==2 & m==1) return ( r**2*R_3_2(r)**2  * Y_2_1(r, theta=theta, phi=phi)**2 )\n  else if(n==3 & l==2 & m==2) return ( r**2*R_3_2(r)**2  * Y_2_2(r, theta=theta, phi=phi)**2 )\n  else { print('Invalid harmonic parameters (n,l) for pdf_psi_n_l_m() ...')\n    return()\n  }\n}   # pdf_psi_n_l_m(r=10, theta=pi/3)\ngr <- meshgridn(list(x=seq(from=-20 , to=20, length.out=20), \n               y=seq(from=-20 , to=20, length.out=20),\n               z=seq(from=-20, to=20, length.out=20)))\n\n\nr = sqrt(gr[[1]]^2 + gr[[2]]^2 + gr[[3]]^2)\nphi = atan2(gr[[2]],gr[[1]])\ntheta = acos(gr[[3]]/sqrt(gr[[1]]^2 + gr[[2]]^2+gr[[3]]^2))\n# replace Nan with 0\ntheta[is.nan(theta)] <- 0\n# n=3,l=2,m=0\n#value = as.vector(abs(pdf_psi_n_l_m(r, n=3, l=2, m=0, theta, phi))),\n\np <-plot_ly(type='isosurface', x = gr[[1]], y = gr[[2]], z = gr[[3]],\n  value = as.vector(abs(pdf_psi_n_l_m(r, n=3, l=2, m=0, theta, phi))), \n  isomin=0.0,  isomax=955, opacity=0.7, name=\"Psi_{nlm}(r,theta,phi)\",\n  colorscale='RdBu', surface = list(show = TRUE, count =1),\n  slices = list(y = list(show = TRUE, locations = c(0)),\n  x = list(show = TRUE, locations = c(0))))  %>%\n  ### X-Y Plane (z=0)\n  add_mesh(type = 'mesh3d', name=\"pz (m=0)\",\n             # Define all (4) zero-cells (points or vertices)\n             # P_i(x,y,z), 0<=i<4\n             x=c(-5, -5, 5, 5), y=c(-5, 5, -5, 5), z=c(0, 0, 0, 0),\n             # Next define all triples (i,j,k) of vertices that form a 2-cell face.\n             # All Tetrahedra have 4 faces\n             i = c(0, 0), j = c(2, 1), k = c(3, 3),\n             # Define the appearance of the 4 faces (2-cells)\n             intensity = c(0.33, 0.33, 0.33, 0.33),\n             color = \"gray\", opacity=0.6)%>% \n  hide_colorbar()\np\n",
      "line_count": 99
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "## Ignore scalar factors\n## (r**2*exp(-r/3))**2*r**2*(3*cos-1)**2\n# Changing the surface_para gives different probability isocontours\nlibrary(plot3D)\nM <- mesh(seq(0, 100,length.out=2000), seq(0, 2*pi,length.out=50))\nr <- M$x;  phi<- M$y\nsurface_para <- 600\ncosthe <- sqrt((sqrt(surface_para/(r**6*exp(-2/3*r)))+1)/3)\nsinthe <- sqrt(1-costhe**2)\n# patch the holes\nsinthe[sinthe<0.1] <-0\nx <- r*sinthe*cos(phi)\ny <- r*sinthe*sin(phi)\nz <- r*costhe\nsurface_para <- 600\ncosthe <- sqrt((-sqrt(surface_para/(r**6*exp(-2/3*r)))+1)/3)\nsinthe <- sqrt(1-costhe**2)\n# patch the holes\ncosthe[costhe<0.1] <-0\nx1 <- r*sinthe*cos(phi)\ny1 <- r*sinthe*sin(phi)\nz1 <- r*costhe\n\np <- plot_ly(x = x, y = y, z = z, type = \"surface\",colorscale = list(c(0,1),c(\"rgb(255,107,184)\",\"rgb(128,0,64)\")),showscale = FALSE, opacity=0.6) %>%\n  layout(title = \"Surface plot of the dz^2 orbital\")%>% add_trace(x = x, y = y, z = -z, type=\"surface\", colorscale = list(c(0,1),c(\"rgb(255,107,184)\",\"rgb(128,0,64)\")),showscale = FALSE, opacity=0.6) %>%add_trace(x = x1, y = y1, z = z1, type=\"surface\",showscale = FALSE, opacity=0.6)%>%add_trace(x = x1, y = y1, z = -z1, type=\"surface\",showscale = FALSE, opacity=0.6)\n\np\n",
      "line_count": 28
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "\nr = sqrt(gr[[1]]^2 + gr[[2]]^2 + gr[[3]]^2)\nphi = atan2(gr[[2]],gr[[1]])\ntheta = acos(gr[[3]]/sqrt(gr[[1]]^2 + gr[[2]]^2+gr[[3]]^2))\n# replace Nan with 0\ntheta[is.nan(theta)] <- 0\n# n=3,l=2,m=0\n#value = as.vector(abs(pdf_psi_n_l_m(r, n=3, l=2, m=0, theta, phi))),\n\np <-plot_ly(type='isosurface', x = gr[[1]], y = gr[[2]], z = gr[[3]],\n  value = as.vector(abs(pdf_psi_n_l_m(r, n=3, l=2, m=1, theta, phi))), \n  isomin=0.0,  isomax=62.2, opacity=0.7, name=\"Psi_{nlm}(r,theta,phi)\",\n  colorscale='RdBu', surface = list(show = TRUE, count =1),\n  slices = list(y = list(show = TRUE, locations = c(0)),x = list(show = TRUE, locations = c(0)),\n  z = list(show = TRUE, locations = c(0))))  %>%\n  ### X-Y Plane (z=0)\n  add_mesh(type = 'mesh3d', name=\"pz (m=0)\",\n             # Define all (4) zero-cells (points or vertices)\n             # P_i(x,y,z), 0<=i<4\n             x=c(-20, -20, 20, 20), y=c(-20, 20, -20, 20), z=c(0, 0, 0, 0),\n             # Next define all triples (i,j,k) of vertices that form a 2-cell face.\n             # All Tetrahedra have 4 faces\n             i = c(0, 0), j = c(2, 1), k = c(3, 3),\n             # Define the appearance of the 4 faces (2-cells)\n             intensity = c(0.33, 0.33, 0.33, 0.33),\n             color = \"gray\", opacity=0.6)%>% \n  hide_colorbar()\np",
      "line_count": 28
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "## Ignore scalar factors\n## (r**2*exp(-r/3))**2*r**2*sin(2*theta)**2\nlibrary(plot3D)\nM <- mesh(seq(0, 50,length.out=2000), seq(0, 2*pi,length.out=50))\nr <- M$x;  phi<- M$y\nsurface_para <- 1\ntheta_d<- pi/2-asin((sqrt(surface_para/(r**6*exp(-2/3*r)))))\ntheta_d[is.nan(theta_d)] <- 0\ntheta_d <- theta_d\n# patch the holes\n# costhe[costhe<0.1] <-0\nx1 <- r*sin(theta_d/2)*cos(phi)\ny1 <- r*sin(theta_d/2)*sin(phi)\nz1 <- r*cos(theta_d/2)\n# clockwise rotation\nx_tran <- cos(pi/4)*x1-sin(pi/4)*z1\nz_tran <- sin(pi/4)*x1+cos(pi/4)*z1\n\np <- plot_ly() %>%add_trace(x = x_tran, y = y1, z = z_tran, type=\"surface\",showscale = FALSE, opacity=0.6)%>%add_trace(x = -x_tran, y = -y1, z = -z_tran, type=\"surface\",showscale = FALSE, opacity=0.6)\n# counter clockwise\nx_tran <- cos(-pi/4)*x1-sin(-pi/4)*z1\nz_tran <- sin(-pi/4)*x1+cos(-pi/4)*z1\np <- p%>%add_trace(x = x_tran, y = y1, z = z_tran, type=\"surface\",showscale = FALSE, opacity=0.6)%>%add_trace(x = -x_tran, y = -y1, z = -z_tran, type=\"surface\",showscale = FALSE, opacity=0.6)%>%\n  layout(title = \"Surface plot of the dxz orbital\")\np\n",
      "line_count": 26
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "\nr = sqrt(gr[[1]]^2 + gr[[2]]^2 + gr[[3]]^2)\nphi = atan2(gr[[2]],gr[[1]])\ntheta = acos(gr[[3]]/sqrt(gr[[1]]^2 + gr[[2]]^2+gr[[3]]^2))\n# replace Nan with 0\ntheta[is.nan(theta)] <- 0\n# n=3,l=2,m=0\n#value = as.vector(abs(pdf_psi_n_l_m(r, n=3, l=2, m=0, theta, phi))),\n\np <-plot_ly(type='isosurface', x = gr[[1]], y = gr[[2]], z = gr[[3]],\n  value = as.vector(abs(pdf_psi_n_l_m(r, n=3, l=2, m=2, theta, phi))), \n  isomin=0.0,  isomax=253.2, opacity=0.7, name=\"Psi_{nlm}(r,theta,phi)\",\n  colorscale='RdBu', surface = list(show = TRUE, count =1),\n  slices = list(y = list(show = TRUE, locations = c(0)),x = list(show = TRUE, locations = c(0)),\n  z = list(show = TRUE, locations = c(0))))  %>%\n  ### X-Y Plane (z=0)\n  add_mesh(type = 'mesh3d', name=\"pz (m=0)\",\n             # Define all (4) zero-cells (points or vertices)\n             # P_i(x,y,z), 0<=i<4\n             x=c(-20, -20, 20, 20), y=c(-20, 20, -20, 20), z=c(0, 0, 0, 0),\n             # Next define all triples (i,j,k) of vertices that form a 2-cell face.\n             # All Tetrahedra have 4 faces\n             i = c(0, 0), j = c(2, 1), k = c(3, 3),\n             # Define the appearance of the 4 faces (2-cells)\n             intensity = c(0.33, 0.33, 0.33, 0.33),\n             color = \"gray\", opacity=0.6)%>% \n  hide_colorbar()\np",
      "line_count": 28
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "## Ignore scalar factors\n## (r**2*exp(-r/3))**2*r**2*sin(theta)**2**2\nlibrary(mosaic)\nM <- mesh(seq(pi/4, 3*pi/4,length.out=20), seq(0, 2*pi,length.out=50))\ntheta <- M$x;  phi<- M$y\nsurface_para <- 24\nf_r <- surface_para/(sin(theta)**4)\nx <- c()\ny <- c()\nz <- c()\nfor (i in 1:c(20*50)){\n  res <- f_r[i]\n  candidates <- findZeros(exp(-2/3*t)*t**6 -res~ t, xlim=c(0,30) )\n  if (length(candidates$t)>0){\n    for (j in candidates$t){\n      if(j>0){\n        x <- c(x, j*sin(theta[i])*cos(phi[i]))\n    y <- c(y, j*sin(theta[i])*sin(phi[i]))\n    z <- c(z, j*cos(theta[i]))\n      }\n    }\n  }\n}\n\n",
      "line_count": 25
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "x <- c()\ny <- c()\nz <- c()\nfor (i in 1:2){\n  res <- f_r[i]\n  candidates <- findZeros(exp(-2/3*t)*t**6 -res~ t, xlim=c(0,30) )\n  if (length(candidates$t)>0){\n    for (j in candidates$t){\n      if(j>0){\n        x <- c(x, j*sin(theta[i])*cos(phi[i]))\n        y <- c(y, j*sin(theta[i])*sin(phi[i]))\n        z <- c(z, j*cos(theta[i]))\n      }\n    }\n  }\n}",
      "line_count": 16
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "# (x**2+y**2+z**2)*exp(-2/3*sqrt(x^2+y^2+z^2))*(x**2-y**2)\nM <- mesh(seq(-30, 30,length.out=30), seq(-29, 31,length.out=30))\nx_g <- M$x;  y_g<- M$y\nsurface_para <- 24\nf_r <- surface_para/(sin(theta)**4)\nx <- c()\ny <- c()\nz <- c()\nfor (i in 1:c(30*30)){\n  x2my2 <- x_g[i]**2-y_g[i]**2\n  x2py2 <- x_g[i]**2+y_g[i]**2\n  candidates <- findZeros( (x2py2+t**2)*exp(-2/3*sqrt(x2py2+t**2))*x2my2**2-surface_para~ t, xlim=c(-30,30) )\n  if (length(candidates)!=0 ){\n    for (j in candidates$t){\n        x <- c(x, x_g[i])\n    y <- c(y, y_g[i])\n    z <- c(z, j)\n    }\n  }\n}\np <- plot_ly(x = x, y = y, z = z, type = \"scatter3d\",colorscale = list(c(0,1),c(\"rgb(255,107,184)\",\"rgb(128,0,64)\")),showscale = FALSE, opacity=0.6) %>%\n  layout(title = \"Scatter plot of the dx2-y2 orbital\")\np",
      "line_count": 23
    },
    {
      "section": "Spherical Electron Orbit Densities",
      "code": "In[1]:= R21[Z_, r_, a_] := (r (Z/a)^(5/2))/(2 Sqrt[6] E^((r Z)/(2 a)))\n\nIn[2]:= Expand[R21[Z, r, a]]\n\nOut[2]= (E^(-((r Z)/(2 a))) r Z^2 Sqrt[Z/a])/(2 Sqrt[6] a^2)\n\nIn[3]:= R21[1, 1, 1]\n\nOut[3]= 1/(2 Sqrt[6 E])\n\nIn[4]:= Y10[theta_, phi_] := -Sqrt[3/(4 Pi)] * Cos[theta]\n\nIn[5]:= Y10[Pi, Pi/3]\n\nOut[5]= Sqrt[3/\\[Pi]]/2\n\nIn[6]:= Psi210[Z_, r_, a_, theta_, phi_] :=\n R21[Z, r, a] * Y10[theta, phi]\n\nIn[7]:= Psi210[1, 1, 1, Pi, Pi/3]\n\nOut[7]= 1/(4 Sqrt[2 E \\[Pi]])\n\nIn[8]:= Expand[Psi210[Z, r, a, theta, phi]]\n\nOut[8]= -((E^(-((r Z)/(2 a))) r Z^2 Sqrt[Z/a] Cos[theta])/(\n 4 a^2 Sqrt[2 \\[Pi]]))\n\nIn[9]:= MyIntegrand[Z_, r_, a_, theta_, phi_] :=\n Psi210[Z, r, a, theta, phi]^2 * r^2 * Sin[theta]\n\nIn[10]:= MyIntegrand[1, 1, 1, Pi/10, Pi/3]\n\nOut[10]= ((5/8 + Sqrt[5]/8) (-1 + Sqrt[5]))/(128 E \\[Pi])\n\nIn[30]:= Integrate[\n MyIntegrand[Z, r, a, theta, phi], {r, a, Infinity}, {theta, 0,\n  Pi}, {phi, -Pi, Pi}]\n\nOut[30]= ConditionalExpression[\n 1/24 E^-Z (24 + Z (24 + Z (12 + Z (4 + Z)))), Re[Z/a] > 0]\n\nIn[31]:= Evaluate[%30, Z = 1]\n\nOut[31]= Sequence[ConditionalExpression[65/(24 E), Re[1/a] > 0], 1]\n\nIn[12]:= Expand[MyIntegrand[Z, r, a, theta, phi]]\n\nOut[12]= (E^(-((r Z)/a)) r^4 Z^5 Cos[theta]^2 Sin[\n  theta])/(32 a^5 \\[Pi])\n\nIn[13]:= Integrate[\n Psi210[Z, r, a, theta, phi]^2  , {r, 1, 10}, {theta, -Pi/2,\n  Pi/2}, {phi, -Pi, Pi}]\n\nOut[13]= (E^(-((10 Z)/\n  a)) \\[Pi] Z^2 (-2 a^2 - 20 a Z - 100 Z^2 +\n   E^((9 Z)/a) (2 a^2 + 2 a Z + Z^2)))/(32 a^4)\n\nIn[14]:= Integrate[\n Psi210[1, r, a, theta, phi], {r, 1, 10}, {theta, -Pi/2,\n  Pi/2}, {phi, -Pi, Pi}]\n\nOut[14]= (1/a)^(3/2) E^(-5/a) (10 + 2 a - (1 + 2 a) E^((9/2)/a)) Sqrt[\n 2 \\[Pi]]\n\nIn[15]:= (* R10 *)\nR10[Z_, r_, a_] := 2 ((Z/a)^(3/2))*( E^((-r Z)/(a)))\n\nIn[16]:= Expand[R10[Z, r, a]]\n\nOut[16]= (2 E^(-((r Z)/a)) Z Sqrt[Z/a])/a\n\nIn[17]:= Y00[theta_, phi_] := Sqrt[1/(4 Pi)]\n\nIn[18]:= Expand[Y00[theta, phi]]\n\nOut[18]= 1/(2 Sqrt[\\[Pi]])\n\nIn[19]:= Expand[R10[Z, r, a] * Y00[theta, phi]]\n\nOut[19]= (E^(-((r Z)/a)) Z Sqrt[Z/a])/(a Sqrt[\\[Pi]])\n\nIn[21]:= MyIntegrand100[Z_, r_, a_, theta_,\n  phi_] := (R10[Z, r, a] * Y00[theta, phi])^2 * r^2 * Sin[theta]\n\nIn[22]:= Expand[MyIntegrand100[Z, r, a, theta, phi]]\n\nOut[22]= (E^(-((2 r Z)/a)) r^2 Z^3 Sin[theta])/(a^3 \\[Pi])\n\nIn[29]:= Integrate[\n MyIntegrand100[Z, r, a, theta, phi], {r, a, Infinity}, {theta, 0,\n  Pi}, {phi, -Pi, Pi}]\n\nOut[29]= ConditionalExpression[E^(-2 Z) (1 + 2 Z (1 + Z)), Re[Z/a] > 0]\n\nIn[32]:= Evaluate[%29, Z = 1]\n\nOut[32]= Sequence[ConditionalExpression[5/E^2, Re[1/a] > 0], 1]",
      "line_count": 99
    },
    {
      "section": "3D Scene of Circular Kime-Phase Sampling",
      "code": "library(animation)\nepsilon <- 0.1\nsampleSize <- 1000   # total number of phases to sample for 3 different processes (x, y, z)\nsizePerTime <- 100   # number of phases to use for each fixed time (must divide sampleSize)\ncircleUniformPhi <- seq(from=-pi, to=pi, length.out=sizePerTime)\n\noopt = ani.options(interval = 0.2)\nset.seed(1234)\n# sample the the kime-phases for all 3 different processes and the r time points\nx <- rvonmises(n=sampleSize, mu=circular(pi/5), kappa=3)\ny <- rvonmises(n=sampleSize, mu=circular(-pi/3), kappa=5)\nz <- rvonmises(n=sampleSize, mu=circular(0), kappa=10)\nr <- seq(from=1, to=sampleSize/sizePerTime, length.out=10)\n\n# Define a function that renormalizes the kime-phase to [-pi, pi)\npheRenormalize <- function (x) {\n  out <- ifelse(as.numeric(x) <= pi, as.numeric(x)+pi, as.numeric(x)-pi)\n  return (out)\n}\n\n# transform Von Mises samples from [0, 2*pi) to [-pi, pi)\nx <- pheRenormalize(x)\ny <- pheRenormalize(y)\nz <- pheRenormalize(z)\n\n# vectorize the samples\nvectorX = as.vector(x)\nvectorY = as.vector(y)\nvectorZ = as.vector(z)\n# Starting phases, set the first phase index=1\nplotX = c(vectorX[1])\nplotY = c(vectorY[1])\nplotZ = c(vectorZ[1])\n\n# # iterate over all time points (outer loop) and all phases (inner loop)\n# for (t in 1:length(r)) {  # loop over time\n#   for (i in 2:100) {      # loop over kime-phases\n#     plotX = c(plotX,vectorX[i])\n#     plotY = c(plotY,vectorY[i])\n#     plotZ = c(plotZ,vectorZ[i])\n# \n#     # Try to \"stack=T the points ....\n#     #r1 = sqrt((resx$x)^2+(resx$y)^2)/2;\n#     #resx$x = r1*cos(resx$data)\n#     #resx$x = r1*cos(resx$data)\n# \n#     tempX = circular(plotX[[1]])\n#     tempY = circular(plotY[[1]])\n#     tempZ = circular(plotZ[[1]])\n#     resx <- density(tempX, bw=25, xaxt='n', yaxt='n')\n#     resy <- density(tempY, bw=25, xaxt='n', yaxt='n')\n#     resz <- density(tempZ, bw=25, xaxt='n', yaxt='n')\n#     res <- plot(resx, points.plot=TRUE, xlim=c(-1.1,1.5), ylim=c(-1.5, 1.5),\n#                 main=\"Trivariate random sampling of\\n kime-magnitudes (times) and kime-directions (phases)\",\n#                 offset=0.9, shrink=1.0, ticks=T, lwd=3, axes=F, stack=TRUE, bins=150)\n#     lines(resy, points.plot=TRUE, col=2, points.col=2, plot.info=res, offset=1.0, shrink=1.45, lwd=3, stack=T)\n#     lines(resz, points.plot=TRUE, col=3, points.col=3, plot.info=res, offset=1.1, shrink=1.2, lwd=3, stack=T)\n#     segments(0, 0, r[i]*cos(vectorX[i]), r[i]*sin(vectorX[i]), lwd=2, col= 'black')\n#     segments(0, 0, r[i]*cos(vectorY[i]), r[i]*sin(vectorY[i]), lwd=2, col= 'red')\n#     segments(0, 0, r[i]*cos(vectorZ[i]), r[i]*sin(vectorZ[i]), lwd=2, col= 'green')\n#     ani.pause()\n#   }\n# }\n####################################################\n\n# pl_list <- list()\npl_scene <- plot_ly(type='scatter3d', mode=\"markers\")\nplotX <- list() \nplotY <- list() \nplotZ <- list() \n\nplotX_df <- list()   # need separate dataframes to store all time foliations\nplotY_df <- list()\nplotZ_df <- list()\n\nfor (t in 1:length(r)) {  # loop over time\n  # loop over kime-phases\n  plotX[[t]] <- as.numeric(x[c(( (t-1)*length(r) + 1):((t-1)*length(r) + sizePerTime))])\n  plotY[[t]] <- as.numeric(y[c(( (t-1)*length(r) + 1):((t-1)*length(r) + sizePerTime))])\n  plotZ[[t]] <- as.numeric(z[c(( (t-1)*length(r) + 1):((t-1)*length(r) + sizePerTime))])\n  \n    # Try to \"stack=T the points ....\n    #r1 = sqrt((resx$x)^2+(resx$y)^2)/2;\n    #resx$x = r1*cos(resx$data)\n    #resx$x = r1*cos(resx$data)\n\n  tempX = circular(unlist(plotX[[t]]))\n  tempY = circular(unlist(plotY[[t]]))\n  tempZ = circular(unlist(plotZ[[t]]))\n  \n  resx <- density(tempX, bw=25, xaxt='n', yaxt='n')\n  resy <- density(tempY, bw=25, xaxt='n', yaxt='n')\n  resz <- density(tempZ, bw=25, xaxt='n', yaxt='n')\n  # res <- plot(resx, points.plot=TRUE, xlim=c(-1.1,1.5), ylim=c(-1.5, 1.5),\n  # main=\"Trivariate random sampling of\\n kime-magnitudes (times) and kime-directions (phases)\",\n  # offset=0.9, shrink=1.0, ticks=T, lwd=3, axes=F, stack=TRUE, bins=150)\n  # pl_list[[t]] \n  unifPhi_df <- as.data.frame(cbind(t=t, circleUniformPhi=circleUniformPhi))\n  plotX_df[[t]] <- as.data.frame(cbind(t=t, plotX=unlist(plotX[[t]])))\n  plotY_df[[t]] <- as.data.frame(cbind(t=t, plotY=unlist(plotY[[t]])))\n  plotZ_df[[t]] <- as.data.frame(cbind(t=t, plotZ=unlist(plotZ[[t]])))\n  \n  pl_scene <- pl_scene %>% add_trace(data=unifPhi_df, showlegend=FALSE,\n                      x = ~((t-epsilon)*cos(circleUniformPhi)), \n                      y = ~((t-epsilon)*sin(circleUniformPhi)), z=0,\n                      name=paste0(\"Time=\",t), line=list(color='gray'),\n                      mode = 'lines', opacity=0.3) %>%\n    add_markers(data=plotX_df[[t]], x=~(t*cos(plotX)), y=~(t*sin(plotX)), z=0,\n                      type='scatter3d', name=paste0(\"X: t=\",t), \n                      marker=list(color='green'), showlegend=FALSE,\n                      mode = 'markers', opacity=0.3) %>%\n    add_markers(data=plotY_df[[t]], x=~((t+epsilon)*cos(plotY)),\n                    y=~((t+epsilon)*sin(plotY)), z=0-epsilon, showlegend=FALSE,\n                    type='scatter3d', name=paste0(\"Y: t=\",t), \n                    marker=list(color='blue'),\n                    mode = 'markers', opacity=0.3) %>%\n    add_markers(data=plotZ_df[[t]], x=~((t+2*epsilon)*cos(plotZ)),\n                y=~((t+2*epsilon)*sin(plotZ)), z=0+epsilon, showlegend=FALSE,\n                type='scatter3d', name=paste0(\"Z: t=\",t), \n                marker=list(color='red'),\n                mode = 'markers', opacity=0.3)\n} \n\nmeans_df <- as.data.frame(cbind(t = c(1:length(r)),\n                                plotX_means=unlist(lapply(plotX, mean)),\n                                plotY_means=unlist(lapply(plotY, mean)),\n                                plotZ_means=unlist(lapply(plotZ, mean))))\npl_scene <- pl_scene %>% \n  # add averaged (donoised) phase trajectories\n  add_trace(data=means_df, x=~(t*cos(plotX_means)), \n        y=~(t*sin(plotX_means)), z=0,\n        type='scatter3d', showlegend=FALSE, mode='lines', name=\"Expected Obs X\", \n        line=list(color='green', width=15), opacity=0.8) %>%\n  add_trace(data=means_df, x=~(t*cos(plotY_means)), \n        y=~(t*sin(plotY_means)), z=0-epsilon,\n        type='scatter3d', showlegend=FALSE, mode='lines', name=\"Expected Obs X\", \n        line=list(color='blue', width=15), opacity=0.8) %>%\n  add_trace(data=means_df, x=~(t*cos(plotZ_means)), \n        y=~(t*sin(plotZ_means)), z=0+epsilon,\n        type='scatter3d', showlegend=FALSE, mode='lines', name=\"Expected Obs X\", \n        line=list(color='red', width=15), opacity=0.8) %>%\n  add_trace(x=0, y=0, z=c(-2,2), name=\"Space\", showlegend=FALSE,\n             line=list(color='gray', width=15), opacity=0.8) %>%\n  layout(title=\"Pseudo Spacekime (1D Space, 2D Kime) Kime-Phase Sampling and Foliation\",\n          scene = list(xaxis=list(title=\"Kappa1\"), yaxis=list(title=\"Kappa2\"),\n                        zaxis=list(title=\"Space\"))) %>% hide_colorbar()\npl_scene\n\n# pl_list %>%\n#   subplot(nrows = length(pl_list)) %>%\n#      layout(title=\"Integral Approximations by Riemann Sums\", legend = list(orientation = 'h'))",
      "line_count": 151
    }
  ]
}