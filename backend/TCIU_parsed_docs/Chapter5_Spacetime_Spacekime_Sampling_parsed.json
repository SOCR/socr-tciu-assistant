{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.260377",
    "total_sections": 2,
    "total_code_chunks": 33,
    "total_tables": 1,
    "r_libraries": [
      "EBImage",
      "beanplot",
      "brainR",
      "ggplot2",
      "kSamples",
      "plotly",
      "reshape2",
      "rstanarm",
      "spatstat"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Spacekime Analytics (Time Complexity and Inferential Uncertainty)\"\nsubtitle: \"Spacetime IID vs. Spacekime Sampling\"\nauthor: \"SOCR Team \"\ndate: \"`r format(Sys.time(),'%m/%d/%Y')`\"\noutput: \n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n      smooth_scroll: true",
      "word_count": 42
    },
    {
      "title": "IID Spacetime Sampling vs. Spacekime Sampling",
      "content": "For all natural spacetime processes, various population characteristics like the mean, variance, range, and quantiles can be estimated by collecting *independent and identically distributed (IID)* samples. These samples represent observed data that is traditionally used to obtain sample-driven estimates of the specific population characteristics via standard formulas like the *sample* arithmetic average, variance, range, quantiles, etc. The latter approximate their population counterparts and form the basis for classical parametric and non-parametric statistical inference. \n\nTypically, reliable *spacetime* statistical inference is conditional on the distribution of the native process as well as a sample-size reflecting the characteristics of the phenomenon. We will demonstrate that *spacekime* analytics can be equally effective with measuring a single spacetime observation and having a reasonable estimates of the unobserved process kime-phases.\n\nWithout loss of generality, suppose we have a pair of cohorts $A$ and $B$ and we obtain a series of measurements $\\{X_{A,i}\\}_{i=1}^{n_A}$ and $\\{X_{B,i}\\}_{i=1}^{n_B}$, respectively. Obviously the relations between the cohorts could widely vary, from being samples of the same process, to being related or completely independent.\n\nTo allow us to examine the extreme cases of pairing (1) IID cohorts ($A$ and $B$), and (2) independent but differently distributed cohorts ($A$ and $C$). The latter case may be thought of as a split of the first cohort ($A$) into training ($C$) and testing ($D$) groups. This design allows us to compare the classical spacetime-derived population characteristics of cohort $A$ to their spacekime-reconstructed counterparts obtained using a single random kime-magnitude observation from $A$ and kime-phases estimates derived from cohorts $B$, $C$ or $D$.\n\n\n\n## fMRI timeseries\n\nThe demonstration below is based on a functional magnetic resonance imaging (fMRI) data, which is a 4D hypervolume with intensities representing the blood oxygenation level dependence at a specific spacetime location $(x,y,z,t)$. For simplicity, we will only focus on two fixed spatial locations with varying intensity distributions.\n\n\nClearly the intensities of cohorts $A$ and $B$ are independent and follow different distribution. We'll split the first cohort ($A$) into *training* ($C$) and *testing* ($D$) subgroups. Then we will:\n\n - transform all four cohorts into Fourier k-space, \n - iteratively randomly sample single observations from cohort $C$,\n - reconstruct the data into spacetime using alternative kime-phase estimates derived from cohorts $B$ and $D$, and \n - compute and compare the *classical spacetime-derived* population characteristics of cohort $A$ to their counterparts obtained using a single $C$ kime-radial measurements paired with $B$ and $D$ kime-phases.\n\n\n\n### Data Visualization \n\n\n\n\n#### Violin Plot\n\n\n#### Empirical CDF\n\n\n#### Beanplot\n\n\n\n## IID Simulation\n\nThe following simulation example generates two mixture distribution random samples each of $n=10,000$ observations, $\\{X_{A,i}\\}_{i=1}^{n_A}$, where $X_{A,i} = 0.3U_i + 0.7V_i$, $U_i \\sim N(0,1)$ and $V_i \\sim N(5,3)$, and $\\{X_{B,i}\\}_{i=1}^{n_B}$, where $X_{B,i} = 0.4P_i + 0.6Q_i$, $P_i \\sim N(20,20)$ and $Q_i \\sim N(100,30)$.\n\n\nFigure 5.2\n\n\nClearly the intensities of cohorts $A$ and $B$ are independent and follow different distributions. We'll split the first cohort ($A$) into *training* ($C$) and *testing* ($D$) subgroups, and then:\n\n - transform all four cohorts into Fourier k-space, \n - iteratively randomly sample single observations from cohort $C$,\n - reconstruct the data into spacetime using a single kime-magnitude value and alternative kime-phase estimates derived from cohorts $B$, $C$, and $D$, and \n - compute and compare the *classical spacetime-derived* population characteristics of cohort $A$ to their spacekime counterparts obtained using a single $C$ kime-magnitude paired with $B$, $C$, or $D$ kime-phases.\n\n\n\n\n### Data Visualization \n\nFigure 5.3\n\n\n\n\nFigure 5.4\n\n\n\n\n\n\n#### Violin Plot\n\n#### Empirical CDF\n\n#### Beanplot\n\n\n## Bayesian Inference Simulation\n\nHere we relate to `Bayesian inference` to `Spacekime analytics` based on a single (cohort ($A$) spacetime observation $x_{i_o}$ and some prior `kime-phases` (obtained from cohorts $A$, $B$, or $C$). This is accomplished by computing the `prior` or `posterior predictive distribution`.\n\n### Canned academic example (using the `cars` dataset)\n\n\n\n### Example of spacekime-analytics as a Bayesian Inference problem (using the fMRI dataset)\n\nRecall that we have:\n\n* Original data `ift_ft_xC_fMRI`\n* IFT of the data using C-Phases `ift_ft_xC_fMRI_1sampleN_PhaseC` for all samples of $N=30$\n* IFT of the data using B-Phases `ift_ft_xC_fMRI_1sampleN_PhaseB` for all samples of $N=30$, and\n* IFT of the data using D-Phases `ift_ft_xC_fMRI_1sampleN_PhaseD` for all samples of $N=30$\n \n\n\n\n\n\n\n\n\n\n\n\n\n### Example of spacekime-analytics as a Bayesian Inference problem (using the `bimodal` simulated dataset)\n\nRecall that we have:\n\n* Original data `xC`\n* IFT of the data using C-Phases `ift_ft_xC_1sampleN_PhaseC` for all samples of $N=30$\n* IFT of the data using B-Phases `ift_ft_xC_1sampleN_PhaseB` for all samples of $N=30$, and\n* IFT of the data using D-Phases `ift_ft_xC_1sampleN_PhaseD` for all samples of $N=30$\n \n\nFigure 5.5\n\n\n\n\n\n\n\nFor the [MCSI data analytics](https://data.sca.isr.umich.edu/), see the separate script: `UM_Michigan_Consumer_Sentiment_Index.R`.\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"http://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"http://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"http://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 852
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    code_folding: hide\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "knitr::opts_chunk$set(echo = TRUE, warings = FALSE)",
      "line_count": 1
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "library(EBImage)\nrequire(brainR)\nlibrary(spatstat) \nlibrary(ggplot2)\nlibrary(kSamples)\nlibrary(reshape2)\nlibrary(beanplot)\nlibrary(rstanarm)\n\nfMRIURL <- \"http://socr.umich.edu/HTML5/BrainViewer/data/fMRI_FilteredData_4D.nii.gz\"\nfMRIFile <- file.path(tempdir(), \"fMRI_FilteredData_4D.nii.gz\")\ndownload.file(fMRIURL, dest=fMRIFile, quiet=TRUE)\nfMRIVolume <- readNIfTI(fMRIFile, reorient=FALSE)\n# dimensions: 64 x 64 x 21 x 180 ; 4mm x 4mm x 6mm x 3 sec \n\nfMRIVolDims <- dim(fMRIVolume); # fMRIVolDims\n# time_dim <- fMRIVolDims[4]; time_dim ## 180\n\n# 2. extract the time-corse of 1D mid-axial slice (3D) hypervolume\nxA_fMRI_1D_x20_y20_z11 <- fMRIVolume[20, 20, 11, ]; # length(xA_fMRI_1D_x20_y20_z11)   #  180\n# hist(xA_fMRI_1D_x20_y20_z11)\nlibrary(plotly)\nplot_ly(x = ~xA_fMRI_1D_x20_y20_z11, type = \"histogram\") %>%\n  layout(bargap=0.1)\n  \nxB_fMRI_1D_x30_y30_z13 <- fMRIVolume[30, 30, 13, ]; # length(xB_fMRI_1D_x30_y30_z13)   #  180\n# hist(xB_fMRI_1D_x30_y30_z13)\n\n# Now, combine your two 1D timeseries into one dataframe for joint hist plotting as densities.  \n# First make a new column in each that will be \n# a variable to identify where they came from later.\nxA_df <- as.data.frame(xA_fMRI_1D_x20_y20_z11)\ncolnames(xA_df) <- \"value\"; xA_df$cohort <- \"xA\"\nxB_df <- as.data.frame(xB_fMRI_1D_x30_y30_z13)\ncolnames(xB_df) <- \"value\"; xB_df$cohort <- \"xB\"\n\n# and combine into your new data frame vegLengths\nxA_xB_df <- rbind(xA_df, xB_df)\n\n# ggplot(xA_xB_df, aes(value, fill = cohort)) + \n#   geom_density(alpha = 0.5, size=1.2) +\n#   theme(text = element_text(size=20)) +\n#   xlim(c(10200, 12000))\n\ndensity_xA <- density(xA_xB_df[ which(xA_xB_df$cohort==\"xA\"), ]$value)\ndensity_xB <- density(xA_xB_df[ which(xA_xB_df$cohort==\"xB\"), ]$value)\ndf_xA <- as.data.frame(cbind(x=density_xA$x, y=density_xA$y))\ndf_xB <- as.data.frame(cbind(x=density_xB$x, y=density_xB$y))\n\nplot_ly(df_xA, x = ~x, y = ~y, type = 'scatter', \n        mode = 'lines', name = \"xA\", fill = 'tozeroy') %>% \n  add_trace(x = ~df_xB$x, y = ~df_xB$y, type = 'scatter', \n        mode = 'lines', name = \"xB\", fill = 'tozeroy') %>% \n  layout(title=\"Cohort A and B Distributions\",\n         xaxis = list(title = 'value'), yaxis = list(title = 'Density'))",
      "line_count": 55
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "# Generic function to Transform Data to/from k-space (Space/Fourier domain)\nkSpaceTransform <- function(data, inverse = FALSE, reconPhases = NULL) {\n  # ForwardFT (rawData, FALSE, NULL)\n  # InverseFT(magnitudes, TRUE, reconPhasesToUse) or InverseFT(FT_data, TRUE, NULL)\n  FT_data <- array(complex(), length(data))\n  mag_FT_data <- array(complex(), length(data))\n  phase_FT_data <- array(complex(), length(data))\n  IFT_reconPhases_data <- array(complex(), length(data))\n\n  if (inverse == FALSE | is.null(reconPhases)) {\n      FT_data <- fft(data, inverse)\n      X2 <- FT_data\n      mag_FT_data <- sqrt(Re(X2)^2+Im(X2)^2) \n      phase_FT_data <- atan2(Im(X2), Re(X2)) \n  }\n  else {  # for IFT synthesis using user-provided Phases, typically from kime-phase aggregators\n      Real <- data * cos(reconPhases)  \n      Imaginary <- data * sin(reconPhases) \n      IFT_reconPhases_data <- \n          Re(fft(Real+1i*Imaginary, inverse = TRUE)/length(data))\n  }\n\n    ######### Test the FT-IFT analysis-synthesis back-and-forth transform process \n    #         to confirm calculations\n    # X2 <- FT_data[ , 1]; mag_FT_data[ , 1] <- sqrt(Re(X2)^2+Im(X2)^2); \n    # phase_FT_data[ , 1] <- atan2(Im(X2), Re(X2)); \n    # Real2 = mag_FT_data[ , 1] * cos(phase_FT_data[ , 1])\n    # Imaginary2 = mag_FT_data[ , 1] * sin(phase_FT_data[ , 1])\n    # man_hat_X2 = Re(fft(Real2 + 1i*Imaginary2, inverse = T)/length(X2))\n    # ifelse(abs(man_hat_X2[5] - data[5, 1]) < 0.001, \"Perfect Syntesis\", \"Problems!!!\")\n    #########\n  \n    if (inverse == FALSE | is.null(reconPhases)) {\n      return(list(\"magnitudes\"=mag_FT_data, \"phases\"=phase_FT_data))\n      # Use kSpaceTransform$magnitudes & kSpaceTransform$phases to retrieve teh Mags and Phases\n    }\n    else {\n      return(IFT_reconPhases_data)\n      # Use Re(kSpaceTransform) to extract spacetime Real-valued reconstructed data\n    }\n}\n\n# 1. Split the first cohort ($A$) into *training* ($C$) and *testing* ($D$) subgroups.\nsubset_int <- sample(length(xA_df$value),floor(length(xA_df$value)*0.8))  \n# 80% training + 20% testing\nxC_fMRI_train <- xA_df$value [subset_int]; # length(xC_fMRI_train) # 144\nxD_test <- xA_df$value [-subset_int]; # length(xD_test)  # 36\n\n# 2. Transform all four cohorts into Fourier k-space\n# xA, xB, xC_fMRI_train; xD_test\nxA <- xA_fMRI_1D_x20_y20_z11; # length(xA)   #  180\nxB <- xB_fMRI_1D_x30_y30_z13; # length(xB)   #  180\n\nft_xA <- fft(xA); ft_xB <- fft(xB)\nft_xC_fMRI_train <- fft(xC_fMRI_train); ft_xD_test <- fft(xD_test); \n\n# Magnitudes and Phases: Phase  <- atan(Im(img_ff)/Re(img_ff))\nmag_ft_xA <- sqrt(Re(ft_xA)^2+Im(ft_xA)^2)\nmag_ft_xB <- sqrt(Re(ft_xB)^2+Im(ft_xB)^2)\nmag_ft_xC_fMRI_train <- sqrt(Re(ft_xC_fMRI_train)^2+Im(ft_xC_fMRI_train)^2)\nmag_ft_xD_test <- sqrt(Re(ft_xD_test)^2+Im(ft_xD_test)^2)\n\nphase_ft_xA <- atan2(Im(ft_xA), Re(ft_xA))\nphase_ft_xB <- atan2(Im(ft_xB), Re(ft_xB))\nphase_ft_xC_fMRI_train <- atan2(Im(ft_xC_fMRI_train), Re(ft_xC_fMRI_train))\nphase_ft_xD_test <- atan2(Im(ft_xD_test), Re(ft_xD_test))\n\n# Double-Check FT-IFT==I   ImplicitlyInvert the FT (IFT)\nfftinv <- function( x ) { fft( x, inverse=TRUE ) / length( x ) }\n# head(Re(fftinv(ft_xA))); head(xA)\n\n# 3. Iteratively randomly sample single observations from cohort $C$,\nN <- 30 # to 30 simulations\n# take a random sample of size N (without replacement) from $C$\nN_sampleIndx <- sample(1:length(xC_fMRI_train), N, replace=FALSE)\nxC_fMRI_sampleN <- xC_fMRI_train[N_sampleIndx]\nft_xC_fMRI_sampleN_mag <- mag_ft_xC_fMRI_train[N_sampleIndx]\n\n# 4. reconstruct the $C$ data into spacetime using a single ft_xC_fMRI_sampleN_mag value and alternative kime-phase estimates derived from cohorts $B$ and $D$ \n# for each ft_xC_fMRI_sampleN_mag[i] value, use $B$ and $D$ phases to reconstruct ift_ft_xC_fMRI_sampleN_PhaseB ift_ft_xC_fMRI_sampleN_PhaseD\nift_ft_xC_fMRI_1sampleN_PhaseB <- \n      array(dim=c(length(xC_fMRI_train), length(xC_fMRI_sampleN)))\nift_ft_xC_fMRI_1sampleN_PhaseD <-\n      array(dim=c(length(xC_fMRI_train),length(xC_fMRI_sampleN)))\nift_ft_xC_fMRI_1sampleN_PhaseC <-\n      array(dim=c(length(xC_fMRI_train),length(xC_fMRI_sampleN)))\nift_ft_xC_fMRI <- array(dim=length(xC_fMRI_train))\n# dim(ift_ft_xC_fMRI_1sampleN_PhaseB) # [1] Time=144 Samples_N=30\n\nfor (i in 1:N) {\n  ift_ft_xC_fMRI_1sampleN_PhaseB[ , i] <- \n    Re(kSpaceTransform(rep(ft_xC_fMRI_sampleN_mag[i], length(xC_fMRI_train)),\n                       TRUE, phase_ft_xB[1:length(xC_fMRI_train)]))\n  ift_ft_xC_fMRI_1sampleN_PhaseD[ , i] <- \n    Re(kSpaceTransform(rep(ft_xC_fMRI_sampleN_mag[i],\n                           length(phase_ft_xD_test)), TRUE,\n                       phase_ft_xD_test[1:length(phase_ft_xD_test)]))\n  ift_ft_xC_fMRI_1sampleN_PhaseC[ , i] <- \n    Re(kSpaceTransform(rep(ft_xC_fMRI_sampleN_mag[i], length(xC_fMRI_train)),\n                       TRUE, phase_ft_xC_fMRI_train[1:length(xC_fMRI_train)]))\n}\nift_ft_xC_fMRI <- Re(kSpaceTransform(mag_ft_xC_fMRI_train, TRUE,\n                       phase_ft_xC_fMRI_train[1:length(xC_fMRI_train)]))\n# head(xC_fMRI_train) == head(ift_ft_xC_fMRI)\n\n# 5.  compute and compare the *classical spacetime-derived* population characteristics of cohort $A$ to their counterparts obtained using a single $C$ kime-radial measurements paired with $B$ and $D$ kime-phases.\n# Data = xC_fMRI_train, ift_ft_xC_fMRI_1sampleN_PhaseB, ift_ft_xC_fMRI_1sampleN_PhaseD\n# length(xC_fMRI_train) == length(ift_ft_xC_fMRI_1sampleN_PhaseB[ , 1])\n\nsummary(scale(xC_fMRI_train))\nsummary(scale(ift_ft_xC_fMRI_1sampleN_PhaseC[ , 15]))\nsummary(scale(ift_ft_xC_fMRI_1sampleN_PhaseB[ , 15]))\nsummary(scale(ift_ft_xC_fMRI_1sampleN_PhaseD[ , 15]))\n",
      "line_count": 114
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "# Plot all histograms as densities\nift_ft_xC_fMRI_1sampleN_PhaseC_df <- \n  as.data.frame(scale(ift_ft_xC_fMRI_1sampleN_PhaseC))\n# colnames(xA_df) <- \"value\"; xA_df$cohort <- \"xA\"\n#  xA_scale_df <- as.data.frame(scale(xA_df$value))\n#  colnames(xA_scale_df) <- \"value\"; xA_scale_df$cohort <- \"xA\"\nxB_df <- as.data.frame(scale(xB_fMRI_1D_x30_y30_z13))\ncolnames(xB_df) <- \"value\"; xB_df$cohort <- \"xB\"\n\n# \n# and combine into your new data frame Lengths\nxA_xB_df <- rbind(xA_df, xB_df)\n\n# ggplot(xA_xB_df, aes(value, fill = cohort)) + \n#   geom_density(alpha = 0.5, size=1.2) +\n#   theme(text = element_text(size=20)) +\n#   xlim(c(10200, 12000))\n\ndensity_xA <- density(xA_df$value)\ndf_xA <- as.data.frame(cbind(x=density_xA$x, y=density_xA$y))\n\nplot_ly(df_xA, x = ~x, y = ~y, type = 'scatter', \n        mode = 'lines', name = \"xA\", fill = 'tozeroy') %>% \n  layout(title=\"Cohort A Distribution\",\n         xaxis = list(title = 'value'), yaxis = list(title = 'Density'))\n\n# length(xC_fMRI_train); dim(ift_ft_xC_fMRI_1sampleN_PhaseB)\n# dim(ift_ft_xC_fMRI_1sampleN_PhaseC); dim(ift_ft_xC_fMRI_1sampleN_PhaseD)\n\n# Compute the averages accross all N=30 experiments for the B, C & D reconstructions\nift_ft_xC_fMRI_1sampleN_PhaseB_avg <- apply(ift_ft_xC_fMRI_1sampleN_PhaseB, 1, mean)\nift_ft_xC_fMRI_1sampleN_PhaseC_avg <- apply(ift_ft_xC_fMRI_1sampleN_PhaseC, 1, mean)\nift_ft_xC_fMRI_1sampleN_PhaseD_avg <- apply(ift_ft_xC_fMRI_1sampleN_PhaseD, 1, mean)\n\n# Plot 4 density curves (orig=xC_fMRI and 3 reconstructions from B, C and D)\nxC_fMRI_train_scale_df <- as.data.frame(scale(xC_fMRI_train))\ncolnames(xC_fMRI_train_scale_df) <- \"value\"; xC_fMRI_train_scale_df$series <- \"xC_fMRI_original\"\n\nift_ft_xC_fMRI_1sampleN_PhaseB_avg_scale_df <- as.data.frame(scale(ift_ft_xC_fMRI_1sampleN_PhaseB_avg))\ncolnames(ift_ft_xC_fMRI_1sampleN_PhaseB_avg_scale_df) <- \"value\"\nift_ft_xC_fMRI_1sampleN_PhaseB_avg_scale_df$series <- \"SK_PhaseB\"\n\nift_ft_xC_fMRI_1sampleN_PhaseC_avg_scale_df <- as.data.frame(scale(ift_ft_xC_fMRI_1sampleN_PhaseC_avg))\ncolnames(ift_ft_xC_fMRI_1sampleN_PhaseC_avg_scale_df) <- \"value\"\nift_ft_xC_fMRI_1sampleN_PhaseC_avg_scale_df$series <- \"SK_PhaseC\"\n\nift_ft_xC_fMRI_1sampleN_PhaseD_avg_scale_df <- as.data.frame(scale(ift_ft_xC_fMRI_1sampleN_PhaseD_avg))\ncolnames(ift_ft_xC_fMRI_1sampleN_PhaseD_avg_scale_df) <- \"value\"\nift_ft_xC_fMRI_1sampleN_PhaseD_avg_scale_df$series <- \"SK_PhaseD\"\n\n# and combine into your new data frame vegLengths\nxC_fMRI_SK_Phases_B_C_D_df <- rbind(xC_fMRI_train_scale_df, ift_ft_xC_fMRI_1sampleN_PhaseB_avg_scale_df, \n             ift_ft_xC_fMRI_1sampleN_PhaseC_avg_scale_df, ift_ft_xC_fMRI_1sampleN_PhaseD_avg_scale_df)\n\n# library(ggplot2)\n# ggplot(xC_fMRI_SK_Phases_B_C_D_df, aes(value, fill = series)) + \n#   geom_density(aes(color=series, linetype = series), alpha=0.4, size=1.2) +  # position = \"stack\"\n#   theme(text = element_text(size=20)) +\n#   scale_fill_manual( values = c(\"yellow\", \"red\", \"blue\", \"green\")) +\n#   geom_line(data=xC_fMRI_train_scale_df, stat = \"density\", color=\"purple\", lty=4, lwd=2) +\n#   ## guides(color = guide_legend(order=1)) +\n#   theme(axis.title.x=element_blank(),axis.text.x=element_blank(), axis.ticks.x=element_blank())\n#   # theme(legend.position=\"bottom\")\n\ndensity_xC_fMRI_orig <- density(xC_fMRI_SK_Phases_B_C_D_df[ \n  which(xC_fMRI_SK_Phases_B_C_D_df$series==\"xC_fMRI_original\"), ]$value)\ndensity_SK_PhaseB <- density(xC_fMRI_SK_Phases_B_C_D_df[ \n  which(xC_fMRI_SK_Phases_B_C_D_df$series==\"SK_PhaseB\"), ]$value)\ndensity_SK_PhaseC <- density(xC_fMRI_SK_Phases_B_C_D_df[ \n  which(xC_fMRI_SK_Phases_B_C_D_df$series==\"SK_PhaseC\"), ]$value)\ndensity_SK_PhaseD <- density(xC_fMRI_SK_Phases_B_C_D_df[ \n  which(xC_fMRI_SK_Phases_B_C_D_df$series==\"SK_PhaseD\"), ]$value)\n\ndf_xC_fMRI_orig <- as.data.frame(cbind(\n  x=density_xC_fMRI_orig$x, y=density_xC_fMRI_orig$y))\ndf_SK_PhaseB <- as.data.frame(cbind(\n  x=density_SK_PhaseB$x, y=density_SK_PhaseB$y))\ndf_SK_PhaseC <- as.data.frame(cbind(\n  x=density_SK_PhaseC$x, y=density_SK_PhaseC$y))\ndf_SK_PhaseD <- as.data.frame(cbind(\n  x=density_SK_PhaseD$x, y=density_SK_PhaseD$y))\n\nplot_ly(df_xC_fMRI_orig, x = ~x, y = ~y, type = 'scatter', \n        mode = 'lines', name = \"xC_fMRI_orig\", fill = 'tozeroy') %>% \n  add_trace(x = ~df_SK_PhaseB$x, y = ~df_SK_PhaseB$y, type = 'scatter', \n        mode = 'lines', name = \"SK_PhaseB\", fill = 'tozeroy') %>% \n  add_trace(x = ~df_SK_PhaseC$x, y = ~df_SK_PhaseC$y, type = 'scatter', \n        mode = 'lines', name = \"SK_PhaseC\", fill = 'tozeroy') %>% \n  add_trace(x = ~df_SK_PhaseD$x, y = ~df_SK_PhaseD$y, type = 'scatter', \n        mode = 'lines', name = \"SK_PhaseD\", fill = 'tozeroy') %>% \n  layout(title=\"Cohort Distribuitions - xC_fMRI_orig, SK_PhaseB, SK_PhaseC and SK_PhaseD\", \n         legend = list(orientation = 'h'),\n         xaxis = list(title = 'value'), yaxis = list(title = 'Density'))\n",
      "line_count": 94
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "# ggplot(xC_fMRI_SK_Phases_B_C_D_df,aes(x=series, y=value, fill=series)) + \n#   geom_violin(trim=FALSE) +\n#   geom_boxplot(width=0.1) + \n#   theme_bw()\n\nxC_fMRI_SK_Phases_B_C_D_df %>%\n  plot_ly(x = ~series, y = ~value , split = ~series, type = 'violin',\n    box = list(visible = T), meanline = list(visible = T)) %>%\n  layout(xaxis = list(title = \"series\"), \n         yaxis = list(title = \"density\", zeroline = F))",
      "line_count": 10
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "# ggplot(xC_fMRI_SK_Phases_B_C_D_df,aes(x=value, color=series)) +\n#   stat_ecdf(size = 0.5)\n\ndf <- dplyr::arrange(xC_fMRI_SK_Phases_B_C_D_df, value)\n\npl <- ggplot(df, aes(x=value, color=series)) +\n  stat_ecdf(size = 0.5)\n\nggplotly(pl) ",
      "line_count": 9
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "boxplot(xC_fMRI_SK_Phases_B_C_D_df$value ~ xC_fMRI_SK_Phases_B_C_D_df$series)\nbeanplot(xC_fMRI_SK_Phases_B_C_D_df$value ~ xC_fMRI_SK_Phases_B_C_D_df$series,\n         border = \"#CAB2D6\",\n         col = c(\"#CAB2D6\", \"#33A02C\", \"#B2DF8A\"),\n         side=\"second\",add = T)",
      "line_count": 5
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "n=10000\nmu1 <- 0; mu2 <- 5\nsig1 <- 1; sig2 <- 3\nweight <- 0.7   \n\nmixedDistFunc <- function (n, weight, mu1, mu2, sig1, sig2) {\n    set.seed(1234); U <- rnorm(n, mean=mu1, sd = sig1)\n    set.seed(1234); V <- rnorm(n,mean=mu2, sd = sig2)\n    # randomly choose U or V\n    set.seed(1234); wght <- rbinom(n, size=1, prob=weight) \n    X <- U*(1 - wght) + V*wght \n}\n\nxA <- mixedDistFunc(n=n, weight, mu1, mu2, sig1, sig2)\nhist(xA, freq = F)\n# length(xA)   #  n=10,000\n\nxB <- mixedDistFunc(n=n, 0.6, 20, 100, 20, 30)\nhist(xB, freq = F)\n# length(xB) \n\n# Now, combine your two univariate sets into one dataframe for joint hist plotting as densities.  \n# First make a new column in each that will be \n# a variable to identify where they came from later.\nxA_df <- as.data.frame(xA); colnames(xA_df)<-\"value\"; xA_df$cohort<-\"xA\"\nxB_df <- as.data.frame(xB); colnames(xB_df)<-\"value\"; xB_df$cohort<-\"xB\"\n\n# and combine into your new data frame vegLengths\nxA_xB_df <- rbind(xA_df, xB_df)",
      "line_count": 29
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "ggplot(xA_xB_df, aes(value, fill = cohort)) + \n  geom_density(alpha = 0.5, size=1.2) +\n  theme(text = element_text(size=20))",
      "line_count": 3
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "# Generic function to Transform 1D Data to/from k-space (Space/Fourier domain)\nkSpaceTransform <- function(data, inverse = FALSE, reconPhases = NULL) {\n  # ForwardFT (rawData, FALSE, NULL)\n  # InverseFT(magnitudes, TRUE, reconPhasesToUse) or InverseFT(FT_data, TRUE, NULL)\n  FT_data <- array(complex(), length(data))\n  mag_FT_data <- array(complex(), length(data))\n  phase_FT_data <- array(complex(), length(data))\n  IFT_reconPhases_data <- array(complex(), length(data))\n\n  if (inverse == FALSE | is.null(reconPhases)) {\n      FT_data <- fft(data, inverse)\n      X2 <- FT_data\n      mag_FT_data <- sqrt(Re(X2)^2+Im(X2)^2) \n      phase_FT_data <- atan2(Im(X2), Re(X2)) \n  }\n  else {  # for IFT synthesis using user-provided Phases, typically from kime-phase aggregators\n      Real <- data * cos(reconPhases)  \n      Imaginary <- data * sin(reconPhases) \n      IFT_reconPhases_data <- \n          Re(fft(Real+1i*Imaginary, inverse = TRUE)/length(data))\n  }\n\n    ######### Test the FT-IFT analysis-synthesis back-and-forth transform process \n    #         to confirm calculations\n    # X2 <- FT_data[ , 1]; mag_FT_data[ , 1] <- sqrt(Re(X2)^2+Im(X2)^2); \n    # phase_FT_data[ , 1] <- atan2(Im(X2), Re(X2)); \n    # Real2 = mag_FT_data[ , 1] * cos(phase_FT_data[ , 1])\n    # Imaginary2 = mag_FT_data[ , 1] * sin(phase_FT_data[ , 1])\n    # man_hat_X2 = Re(fft(Real2 + 1i*Imaginary2, inverse = T)/length(X2))\n    # ifelse(abs(man_hat_X2[5] - data[5, 1]) < 0.001, \"Perfect Syntesis\", \"Problems!!!\")\n    #########\n  \n    if (inverse == FALSE | is.null(reconPhases)) {\n      return(list(\"magnitudes\"=mag_FT_data, \"phases\"=phase_FT_data))\n      # Use kSpaceTransform$magnitudes & kSpaceTransform$phases to retrieve teh Mags and Phases\n    }\n    else {\n      return(IFT_reconPhases_data)\n      # Use Re(kSpaceTransform) to extract spacetime Real-valued reconstructed data\n    }\n}\n\n# 1. Split the first cohort ($A$) into *training* ($C$) and *testing* ($D$) subgroups.\nsubset_int <- sample(length(xA_df$value),floor(length(xA_df$value)*0.8))  \n# 80% training + 20% testing\nxC <- xA_df$value [subset_int]; # length(xC) # 8000\nxD <- xA_df$value [-subset_int]; # length(xD)  # 2000\n\n# 2. Transform all four cohorts into Fourier k-space\n# xA, xB, xC (train), xD (test)\nft_xA <- fft(xA); ft_xB <- fft(xB)\nft_xC <- fft(xC); ft_xD <- fft(xD)\n\n# Magnitudes and Phases: Phase  <- atan(Im(img_ff)/Re(img_ff))\nmag_ft_xA <- sqrt(Re(ft_xA)^2+Im(ft_xA)^2)\nmag_ft_xB <- sqrt(Re(ft_xB)^2+Im(ft_xB)^2)\nmag_ft_xC <- sqrt(Re(ft_xC)^2+Im(ft_xC)^2)\nmag_ft_xD <- sqrt(Re(ft_xD)^2+Im(ft_xD)^2)\n\nphase_ft_xA <- atan2(Im(ft_xA), Re(ft_xA))\nphase_ft_xB <- atan2(Im(ft_xB), Re(ft_xB))\nphase_ft_xC <- atan2(Im(ft_xC), Re(ft_xC))\nphase_ft_xD <- atan2(Im(ft_xD), Re(ft_xD))\n\n# Double-Check FT-IFT==I   ImplicitlyInvert the FT (IFT)\nfftinv <- function( x ) { fft( x, inverse=TRUE ) / length( x ) }\n# head(Re(fftinv(ft_xA))); head(xA)\n\n# 3. Iteratively randomly sample single observations from cohort $C$,\nN <- 30 #  30 simulations\n# take a random sample of size N (without replacement) from $C$\nset.seed(1234); N_sampleIndx <- sample(1:length(xC), N, replace=FALSE)\nxC_sampleN <- xC[N_sampleIndx]\nft_xC_mag <- mag_ft_xC[N_sampleIndx]\n\n# 4. reconstruct the $C$ data into spacetime using a single ft_xC_sampleN_mag value and alternative kime-phase estimates derived from cohorts $B$ and $D$ \n# for each ft_xC_sampleN_mag[i] value, use $B$ and $D$ phases to reconstruct ift_ft_xC_sampleN_PhaseB ift_ft_xC_sampleN_PhaseD\nift_ft_xC_1sampleN_PhaseB <- \n      array(dim=c(length(xC), length(xC_sampleN)))\nift_ft_xC_1sampleN_PhaseD <-\n      array(dim=c(length(xC), length(xC_sampleN)))\nift_ft_xC_1sampleN_PhaseC <-\n      array(dim=c(length(xC), length(xC_sampleN)))\nift_ft_xC <- array(dim=length(xC))\n# dim(ift_ft_xC_1sampleN_PhaseB) # [1] Size=8000 Samples_N=30\n\nfor (i in 1:N) {\n  ift_ft_xC_1sampleN_PhaseB[ , i] <- \n    Re(kSpaceTransform(rep(ft_xC_mag[i], length(xC)),\n                       TRUE, phase_ft_xB[1:length(xC)]))\n  ift_ft_xC_1sampleN_PhaseD[ , i] <- \n    Re(kSpaceTransform(rep(ft_xC_mag[i], length(phase_ft_xD)), \n                       TRUE, phase_ft_xD[1:length(phase_ft_xD)]))\n  ift_ft_xC_1sampleN_PhaseC[ , i] <- \n    Re(kSpaceTransform(rep(ft_xC_mag[i], length(xC)),\n                       TRUE, phase_ft_xC[1:length(xC)]))\n}\nift_ft_xC <- Re(kSpaceTransform(mag_ft_xC, TRUE,phase_ft_xC[1:length(xC)]))\n# head(xC) - head(ift_ft_xC) # roundoff should be ~ 0\n\n# 5.  compute and compare the *classical spacetime-derived* population characteristics of cohort $A$ to their counterparts obtained using a single $C$ kime-radial measurements paired with $B$ and $D$ kime-phases.\n# Data = xC_train, ift_ft_xC_1sampleN_PhaseB, ift_ft_xC_1sampleN_PhaseD\n# length(xC) == length(ift_ft_xC_1sampleN_PhaseB[ , 1])\n\nsummary(scale(xC))\nsummary(scale(ift_ft_xC_1sampleN_PhaseC[ , 15]))\nsummary(scale(ift_ft_xC_1sampleN_PhaseB[ , 15]))\nsummary(scale(ift_ft_xC_1sampleN_PhaseD[ , 15]))\n",
      "line_count": 109
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "# Plot all histograms as densities\nift_ft_xC_1sampleN_PhaseC_df <- \n  as.data.frame(scale(ift_ft_xC_1sampleN_PhaseC))\n# colnames(xA_df) <- \"value\"; xA_df$cohort <- \"xA\"\n#  xA_scale_df <- as.data.frame(scale(xA_df$value))\n#  colnames(xA_scale_df) <- \"value\"; xA_scale_df$cohort <- \"xA\"\nxB_df <- as.data.frame(scale(xB))\ncolnames(xB_df) <- \"value\"; xB_df$cohort <- \"xB\"\n\n# \n# and combine into your new data frame Lengths\nxA_xB_df <- rbind(xA_df, xB_df)\n\n\nggplot(xA_xB_df, aes(value, fill = cohort)) + \n  geom_density(alpha = 0.5, size=1.2) +\n  theme(text = element_text(size=20))\n\n# length(xC); dim(ift_ft_xC_1sampleN_PhaseB)\n# dim(ift_ft_xC_1sampleN_PhaseC); dim(ift_ft_xC_1sampleN_PhaseD)\n\n# Compute the averages accross all N=30 experiments for the B, C & D spacekime (IFT) reconstructions\nift_ft_xC_1sampleN_PhaseB_avg <- apply(ift_ft_xC_1sampleN_PhaseB, 1, mean)\nift_ft_xC_1sampleN_PhaseC_avg <- apply(ift_ft_xC_1sampleN_PhaseC, 1, mean)\nift_ft_xC_1sampleN_PhaseD_avg <- apply(ift_ft_xC_1sampleN_PhaseD, 1, mean)\n\n# Plot 4 density curves (orig=xC and 3 reconstructions from B, C and D)\nxC_scale_df <- as.data.frame(xC)\ncolnames(xC_scale_df) <- \"value\"; xC_scale_df$series <- \"xC_original\"\n\nift_ft_xC_1sampleN_PhaseB_avg_scale_df <- \n    as.data.frame(ift_ft_xC_1sampleN_PhaseB_avg)\ncolnames(ift_ft_xC_1sampleN_PhaseB_avg_scale_df) <- \"value\"\nift_ft_xC_1sampleN_PhaseB_avg_scale_df$series <- \"SK_PhaseB\"\n\nift_ft_xC_1sampleN_PhaseC_avg_scale_df <- \n    as.data.frame(ift_ft_xC_1sampleN_PhaseC_avg)\ncolnames(ift_ft_xC_1sampleN_PhaseC_avg_scale_df) <- \"value\"\nift_ft_xC_1sampleN_PhaseC_avg_scale_df$series <- \"SK_PhaseC\"\n\nift_ft_xC_1sampleN_PhaseD_avg_scale_df <- \n      as.data.frame(ift_ft_xC_1sampleN_PhaseD_avg)\ncolnames(ift_ft_xC_1sampleN_PhaseD_avg_scale_df) <- \"value\"\nift_ft_xC_1sampleN_PhaseD_avg_scale_df$series <- \"SK_PhaseD\"\n\n# Combine into a new data frame xC_SK_Phases_B_C_D_df\nxC_SK_Phases_B_C_D_df <- rbind(xC_scale_df, ift_ft_xC_1sampleN_PhaseB_avg_scale_df, \n             ift_ft_xC_1sampleN_PhaseC_avg_scale_df, ift_ft_xC_1sampleN_PhaseD_avg_scale_df)\n\n# library(ggplot2)\nggplot(xC_SK_Phases_B_C_D_df, aes(value, fill = series)) + \n  geom_density(aes(color=series, linetype = series), alpha=0.4, size=1.2) +  # position = \"stack\"\n  theme(text = element_text(size=20)) +\n  scale_fill_manual( values = c(\"yellow\", \"red\", \"blue\", \"green\")) +\n  geom_line(data=xC_scale_df, stat = \"density\", color=\"purple\", lty=4, lwd=2) +\n  ## guides(color = guide_legend(order=1)) +\n  theme(axis.title.x=element_blank(),axis.text.x=element_blank(), axis.ticks.x=element_blank()) # +\n  # xlim(c(-1, 1))\n  # theme(legend.position=\"bottom\")\n\n#ggplot(xC_SK_Phases_B_C_D_df, aes(value, fill = series)) + \n#  theme(text = element_text(size=20)) +\n#  scale_fill_manual( values = c(\"yellow\", \"red\", \"blue\", \"green\")) +\n#  geom_line(stat = \"density\", lty=4, lwd=2) +\n#  ## guides(color = guide_legend(order=1)) +\n#  theme(axis.title.x=element_blank(),axis.text.x=element_blank(), #axis.ticks.x=element_blank())\n\nggplot(xC_SK_Phases_B_C_D_df, aes(value, fill = series)) + \n     geom_line(aes(colour=series, lty=series), stat = \"density\", lwd=1.5) +\n  theme(axis.title.x=element_blank(),axis.text.x=element_blank(),\n        axis.ticks.x=element_blank())\n\n# Are the xC (original training) and ift_ft_xC_1sampleN_PhaseC_avg (reconstructed) CORRELATED?\n# cor(xC, ift_ft_xC_1sampleN_PhaseC_avg)  # [1] 0.8872053\n# Are the xC (original training) and ift_ft_xC_1sampleN_PhaseD_avg (reconstructed) CORRELATED?\n# cor(xC, ift_ft_xC_1sampleN_PhaseD_avg)  # [1] 0.005248561\n# Are the xC (original training) and ift_ft_xC_1sampleN_PhaseB_avg (reconstructed) CORRELATED?\n# cor(xC, ift_ft_xC_1sampleN_PhaseB_avg)  # [1] -0.001070121",
      "line_count": 78
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "# Plot xC vs. ift_ft_xC_1sampleN_PhaseC_avg\nplot(xC, ift_ft_xC_1sampleN_PhaseC_avg, xlab = \"Original\", ylab = \"Reconstructed\",\n     main = \"Spacekime signal reconstruction using \\n a single spacetime observation and perfect kime-phases\",\n     cex=1.4)\nabline(lm(ift_ft_xC_1sampleN_PhaseC_avg ~ xC), col=\"red\", lwd=2)\ntext(0, 9, sprintf(\"Corr(Orig, Rec)=%s\", \n                    format(cor(scale(ift_ft_xC_1sampleN_PhaseC_avg), scale(xC)), digits=2)))",
      "line_count": 7
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "#Additional quantitative measures quantifying the differences between distribution (original signal and spacekime reconstructions) include two-sample Kolmogorov-Smirnov (KS) test and the correlation coefficient. The KS test statistic (D) is the maximum distance between the estimated cumulative distribution functions and the corresponding p-value is the probability of seeing a test statistic as high or higher than the one observed given that the two samples were drawn from the same distribution.  In our case, comparing the distributions of the original data and its reconstruction using a single kime magnitude and the correct kime-phases yields a KS statistics D = 0.053875, and p_value= 1.647?e^(-10). This suggests very strong statistical evidence (due to the large sample size) and marginal practical difference between the real and reconstructed signals. Comparing a pair of reconstructions using a single kime-magnitude value and two independent kime-phase estimates (cohorts C and D) yields D = 0.017375, and p_value= 0.1786.\n\nks.test(scale(xC), scale(ift_ft_xC_1sampleN_PhaseC_avg))\n#      D = 0.053875, p-value = 1.647e-10, alternative hypothesis: two-sided\nks.test(scale(ift_ft_xC_1sampleN_PhaseC_avg), scale(ift_ft_xC_1sampleN_PhaseD_avg))\n#      D = 0.017375, p-value = 0.1786, alternative hypothesis: two-sided\n# wilcox.test(scale(xC), scale(ift_ft_xC_1sampleN_PhaseC_avg)) # insignificant because of scaling\n#null_distribution <- function (x) {\n#  if (!is.na(approxfun(density(scale(xC)))(x))) {\n#    return (approxfun(density(scale(xC)))(x))\n#  } else { return (0) }\n#}\n# Cramer-Von Mises Test of Goodness-of-Fit\n#cvm.test(scale(ift_ft_xC_1sampleN_PhaseC_avg), null_distribution) # omega2 = 1854.8, p-value = 0.2955\n# Anderson-Darling Test of Goodness-of-Fit\n#ad.test(scale(ift_ft_xC_1sampleN_PhaseC_avg), null_distribution) # \n\n# Anderson-Darling Test of Goodness-of-Fit\n\nad.test(scale(ift_ft_xC_1sampleN_PhaseC_avg), scale(xC)) # T.AD=19.18; asympt. P-value=8.578e-09",
      "line_count": 20
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "plot(density(scale(xC)), col=\"black\", lty=1, lwd=3, xaxt=\"n\", xlab = \"Range\",\n     main=\"Spacetime Original vs. Spacekime (SK) Reconstructed Distributions\")\nlines(density(scale(ift_ft_xC_1sampleN_PhaseC_avg)), col=\"green\", lwd=2, lty=2)\nlines(density(scale(ift_ft_xC_1sampleN_PhaseD_avg)), col=\"blue\", lwd=2, lty=10)\nlines(density(scale(ift_ft_xC_1sampleN_PhaseB_avg)), col=\"red\", lwd=2, lty=20)\nlegend(\"topright\", legend=c(\"Original (Mixture of N(0,1) & N(5,3))\", \"SK Synthesis (1 Mag, Phase=True)\",\n      \"SK Synthesis (1 Mag, Phase=Indep)\", \"SK Synthesis (1 Mag, Phase=Diff.Proc.)\",\n      paste0(sprintf(\"\\nKS.test(Original, SK(1Mag,Phase=True)), D=%s, p=%s\\n\",\n                    format(ks.test(scale(xC), scale(ift_ft_xC_1sampleN_PhaseC_avg))$statistic[[1]], digits=2),\n                    format(ks.test(scale(xC), scale(ift_ft_xC_1sampleN_PhaseC_avg))$p.value, digits=2)),\n          sprintf(\"KS.test(SK(1Mag,Phase=Indep), SK(1Mag,Phase=True)), p=%s\\n\",\n                    format(ks.test(scale(ift_ft_xC_1sampleN_PhaseD_avg),\n                                   scale(ift_ft_xC_1sampleN_PhaseC_avg))$p.value, digits=2)),\n          sprintf(\"Corr(Original, SK(1Mag,Phase=True))=%s\", \n                    format(cor(scale(ift_ft_xC_1sampleN_PhaseC_avg), scale(xC)), digits=2)))),\n       col=c(\"black\", \"green\", \"blue\", \"red\", \"black\"), lty=c(1, 2, 10, 20, 0), lwd=2, bty = \"n\", cex=0.75,\n       y.intersp=0.0, title=\"Scaled Densities\")\n",
      "line_count": 18
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "# Skewness\n# e1071::skewness(xC); e1071::skewness(ift_ft_xC_1sampleN_PhaseC_avg); e1071::skewness(ift_ft_xC_1sampleN_PhaseB_avg); e1071::skewness(ift_ft_xC_1sampleN_PhaseD_avg)\n\n# Kurtosis\n# e1071::kurtosis(xC); e1071::kurtosis(ift_ft_xC_1sampleN_PhaseC_avg); e1071::kurtosis(ift_ft_xC_1sampleN_PhaseB_avg); e1071::kurtosis(ift_ft_xC_1sampleN_PhaseD_avg)\nraw_data <- \n  data.frame(Original=scale(xC),\n             Phase_True=scale(ift_ft_xC_1sampleN_PhaseB_avg),\n             Phase_Diff.Proc=scale(ift_ft_xC_1sampleN_PhaseC_avg),\n             Phase_Indep=scale(ift_ft_xC_1sampleN_PhaseD_avg))\n",
      "line_count": 11
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "melted_data = melt(raw_data)\n\nggplot(melted_data,aes(x=variable, y=value, fill=variable)) + \n  geom_violin(trim=FALSE) +\n  geom_boxplot(width=0.1) + \n  theme_bw()",
      "line_count": 6
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "ggplot(melted_data,aes(x=value, color=variable)) +\n  stat_ecdf(size = 0.5)\n",
      "line_count": 3
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "boxplot(melted_data$value ~ melted_data$variable)\nbeanplot(melted_data$value ~ melted_data$variable,\n         border = \"#CAB2D6\",\n         col = c(\"#CAB2D6\", \"#33A02C\", \"#B2DF8A\"),\n         side=\"second\", add = T)\n",
      "line_count": 6
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "#install.packages(\"rstanarm\")\n#library(\"rstanarm\")\n\n# Docs: https://rdrr.io/cran/rstanarm/man/posterior_predict.stanreg.html\n\n# 1. Canned example\n# if (!exists(\"example_model\")) example(example_model)\n# yrep <- posterior_predict(example_model)\n# table(yrep)\n\n# 2. Example using sample data (n=10): counts ~ outcome + treatment\n# counts <- c(18,17,15,20,10,20,25,13,12,15)\n# outcome <- gl(5,2,10)\n# treatment <- gl(2,5)\n# model_fit <- stan_glm(counts ~ outcome + treatment, \n#                  family = poisson(link=\"log\"),\n#                  prior = normal(0, 1), prior_intercept = normal(0, 5))\n# new_data <- data.frame(treatment = factor(rep(1,5)), outcome = factor(1:5))\n# Draw from the posterior predictive distribution of the outcome.\n# ytilde <- posterior_predict(model_fit, new_data, draws = 500)\n# print(dim(ytilde))  # 500 by 5 matrix (draws by nrow(new_data))\n# ytilde <- data.frame(count = c(ytilde),\n#                      outcome = rep(new_data$outcome, each = 500))\n# ggplot2::ggplot(ytilde, ggplot2::aes(x=outcome, y=count)) +\n#   ggplot2::geom_boxplot() +\n#   ggplot2::ylab(\"predicted count\")\n# ytilde <- posterior_predict(model_fit, draws = 500)\n# bayesplot::color_scheme_set(\"brightblue\")\n# bayesplot::ppc_dens_overlay(counts, ytilde[1:100, ])\n\n# Using the CARS data (mpg ~ wt)\nmtcars2 <- mtcars   # dim(mtcars2) # [1] 32(Automakers) 11(Features)\n# mtcars2$log_mpg <- log(mtcars2$mpg)   # Define outcome of interest\nmodel_fit <- stan_glm(mpg ~ wt, data = mtcars2)\n\n# Get the posterior predictive distribution as a matrix:\n# D(number of draws posterior predictive distribution)=500 by \n# N(number of data points being predicted per draw)\nytilde <- posterior_predict(model_fit, draws = 500)\n# dim(ytilde) # Outcome=mpg, [1] 500(MCMC draws)  32(automakers)\nhead(ytilde)\nbayesplot::color_scheme_set(\"brightblue\")\nbayesplot::ppc_dens_overlay(mtcars2$mpg, ytilde[1:100, ])\n\nbayesplot::ppc_hist(mtcars2$mpg, ytilde[1:100, ])\n\n# Plot a histogram of the distribution of various test statistics (e.g., mean, sd) across MCMC draws.\n# The distributions are computed by applying the statistics to each dataset (draw=row) in *ytilde*.\n# The blue vertical line overlays the value of the same statistic in the observed data, stat(y=mtcars2$mpg)\nbayesplot::ppc_stat(mtcars2$mpg, ytilde[1:100, ], stat = \"mean\")\nbayesplot::ppc_stat(mtcars2$mpg, ytilde[1:100, ], stat = \"sd\")\n#bayesplot::ppc_stat(mtcars2$mpg, ytilde[1:100, ], stat = \"range\")\nbayesplot::ppc_stat(mtcars2$mpg, ytilde[1:100, ], stat = \"min\")\nbayesplot::ppc_stat(mtcars2$mpg, ytilde[1:100, ], stat = \"max\")\n# 2D (mean, sd) plot\nbayesplot::ppc_stat_2d(mtcars2$mpg, ytilde[1:100, ], stat=c(\"mean\", \"sd\"), size=2.5, alpha=0.7)",
      "line_count": 56
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "#install.packages(\"rstanarm\")\n#library(\"rstanarm\")\n\n# xC_fMRI_scaled <- scale(xC_fMRI)[ , 1]\n# length(ift_ft_xC_fMRI)    # [1] 8000\n\n\n\n# dim(ift_ft_xC_fMRI_1sampleN_PhaseC)  # [1] 8000   30\n# dim(ift_ft_xC_fMRI_1sampleN_PhaseB) \n# dim(ift_ft_xC_fMRI_1sampleN_PhaseD) \n\n# Get the posterior predictive distribution as a matrix:\n# D(number of draws posterior predictive distribution)=30 by \n# N(number of data time points being predicted per draw)=8000\n# Inspect the first few spacekime reconstructed draws: Mind the transposition of the tensor!\n# t(ift_ft_xC_fMRI_1sampleN_PhaseC)[ , 1:7]  # 30(draws)  7(first timepoints ony) \n# the spacekime estimates represent the posterior predictive distribution\n# ytilde <- t(ift_ft_xC_fMRI_1sampleN_PhaseC + mean(xC_fMRI))  # all 8000 timepoints (columns)\n# Center/Offset the spacekime estimates to the center of the original data (xC_fMRI)\nytilde <- rbind(t(ift_ft_xC_fMRI_1sampleN_PhaseC+mean(ift_ft_xC_fMRI)-apply(ift_ft_xC_fMRI_1sampleN_PhaseC,2,mean)),\n                t(ift_ft_xC_fMRI_1sampleN_PhaseB+mean(ift_ft_xC_fMRI)-apply(ift_ft_xC_fMRI_1sampleN_PhaseB,2,mean)),\n                t(ift_ft_xC_fMRI_1sampleN_PhaseD+mean(ift_ft_xC_fMRI)-apply(ift_ft_xC_fMRI_1sampleN_PhaseD,2,mean))) \n# dim(ytilde) # Outcome=bimodal process (xC_fMRI), [1] 30(MCMC draws)  8000(timepoints)\n\nbayesplot::color_scheme_set(\"brightblue\")",
      "line_count": 26
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "bayesplot::ppc_dens_overlay(ift_ft_xC_fMRI, ytilde) + xlim(10300,10800) + ylim(0,0.01)",
      "line_count": 1
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "bayesplot::ppc_hist(ift_ft_xC_fMRI, ytilde[1:11, ])\n\n# Plot a histogram of the distribution of various test statistics (e.g., mean, sd) across MCMC draws.\n# The distributions are computed by applying the statistics to each dataset (draw=row) in *ytilde*.\n# The blue vertical line overlays the value of the same statistic in the observed data, stat(y=mtcars2$mpg)\nbayesplot::ppc_stat(ift_ft_xC_fMRI, ytilde, stat = \"mean\")\nbayesplot::ppc_stat(ift_ft_xC_fMRI, ytilde, stat = \"sd\")",
      "line_count": 7
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "bayesplot::ppc_stat(ift_ft_xC_fMRI, ytilde, stat = IQR)",
      "line_count": 1
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "bayesplot::ppc_stat(ift_ft_xC_fMRI, ytilde, stat = \"min\")",
      "line_count": 1
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "bayesplot::ppc_stat(ift_ft_xC_fMRI, ytilde, stat = \"max\")",
      "line_count": 1
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "# bayesplot::ppc_stat(xC_fMRI_scaled, ytilde, stat = e1071::skewness)\n# bayesplot::ppc_stat(xC_fMRI_scaled, ytilde, stat = e1071::kurtosis)\n# 2D (mean, sd) plot\nbayesplot::ppc_stat_2d(ift_ft_xC_fMRI, ytilde, stat=c(\"mean\", \"sd\"), size=2.5, alpha=0.7)",
      "line_count": 4
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "# xC_scaled <- scale(xC)[ , 1]\n# length(xC)                      # [1] 8000\n# dim(ift_ft_xC_1sampleN_PhaseC)  # [1] 8000   30\n# dim(ift_ft_xC_1sampleN_PhaseB) \n# dim(ift_ft_xC_1sampleN_PhaseD) \n\n# Get the posterior predictive distribution as a matrix:\n# D(number of draws posterior predictive distribution)=30 by \n# N(number of data time points being predicted per draw)=8000\n# Inspect the first few spacekime reconstructed draws: Mind the transposition of the tensor!\n# t(ift_ft_xC_1sampleN_PhaseC)[ , 1:7]  # 30(draws)  7(first timepoints ony) \n# the spacekime estimates represent the posterior predictive distribution\n# ytilde <- t(ift_ft_xC_1sampleN_PhaseC + mean(xC))  # all 8000 timepoints (columns)\n# Center/Offset the spacekime estimates to the center of the original data (xC)\nytilde <- rbind(t(ift_ft_xC_1sampleN_PhaseC+mean(xC)-apply(ift_ft_xC_1sampleN_PhaseC,2,mean)),\n                t(ift_ft_xC_1sampleN_PhaseB+mean(xC)-apply(ift_ft_xC_1sampleN_PhaseB,2,mean)),\n                t(ift_ft_xC_1sampleN_PhaseD+mean(xC)-apply(ift_ft_xC_1sampleN_PhaseD,2,mean))) \n# dim(ytilde) # Outcome=bimodal process (xC), [1] 30(MCMC draws)  8000(timepoints)\n\nbayesplot::color_scheme_set(\"brightblue\")",
      "line_count": 20
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "bayesplot::ppc_dens_overlay(xC, ytilde) + xlim(-22,25) + ylim(0,0.3)",
      "line_count": 1
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "bayesplot::ppc_hist(xC, ytilde[1:11, ])\n# Plot a histogram of the distribution of various test statistics (e.g., mean, sd) across MCMC draws.\n# The distributions are computed by applying the statistics to each dataset (draw=row) in *ytilde*.\n# The blue vertical line overlays the value of the same statistic in the observed data, stat(y=mtcars2$mpg)\nbayesplot::ppc_stat(xC, ytilde, stat = \"mean\")\nbayesplot::ppc_stat(xC, ytilde, stat = \"sd\")",
      "line_count": 6
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "bayesplot::ppc_stat(xC, ytilde, stat = IQR)",
      "line_count": 1
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "bayesplot::ppc_stat(xC, ytilde, stat = \"min\")",
      "line_count": 1
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "bayesplot::ppc_stat(xC, ytilde, stat = \"max\")",
      "line_count": 1
    },
    {
      "section": "IID Spacetime Sampling vs. Spacekime Sampling",
      "code": "# bayesplot::ppc_stat(xC_scaled, ytilde, stat = e1071::skewness)\n# bayesplot::ppc_stat(xC_scaled, ytilde, stat = e1071::kurtosis)\n# 2D (mean, sd) plot\nbayesplot::ppc_stat_2d(xC, ytilde, stat=c(\"mean\", \"sd\"), size=2.5, alpha=0.7)",
      "line_count": 4
    }
  ]
}