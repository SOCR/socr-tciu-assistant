{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.403680",
    "total_sections": 8,
    "total_code_chunks": 21,
    "total_tables": 1,
    "r_libraries": [
      "EBImage",
      "RNifti",
      "brainR",
      "cubature",
      "doParallel",
      "ggplot2",
      "plotly",
      "pracma",
      "spatstat"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"TCIU: The Laplace Transform of Longitudinal Data: Analytic Duality of Time-series and Kimesurfaces\"\noutput: \n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 5\n    toc_float:\n      collapsed: false\n<!-- \noutput: word_document\n-->\n\n\nThe [Laplace Transform](https://en.wikipedia.org/wiki/Laplace_transform), $\\mathcal{L}$, allows us to examine the relations between the space-time and space-kime representations of longitudinal data. The Fourier transformation is a linear operator that maps complex-valued functions of real variables (e.g., space, time domains) to complex valued functions of other real variables (e.g., frequency domain). The Laplace transform is similar, however, it sends complex-valued functions of positive real variables (e.g., time) to complex-valued functions defined on complex variables (e.g., kime).",
      "word_count": 110
    },
    {
      "title": "*Continuous* Forward and Inverse Laplace Transforms (LT)",
      "content": "The *forward* and *inverse* (continuous) Laplace transforms are defined below.\n\n* For a given function function (of time) $f(t): R^+ \\longrightarrow C$, the **Laplace transform** is the function of a complex frequency argument, $F(z)={\\mathcal {L}}(f)(z):C \\longrightarrow C$:\n\n$$ {\\mathcal {L}}(f)(z)=F(z)=\\int_{0}^{\\infty} {f(t)e^{-z t} dt}.$$\n\n* For a given function function of a complex frequency argument, $F(z)$, the **Inverse Laplace transform** (ILT) is the function of a positive real (time-like) argument $f(t)={\\mathcal {L}}^{-1}(F)(t):R^+ \\longrightarrow C$, which is defined in terms of a complex path integral (a.k.a. Bromwich integral or Fourier–Mellin integral):\n\n$$f(t)={\\mathcal {L}}^{-1}(F)(t)={\\frac {1}{2\\pi i}} \\lim_{T\\to \\infty }\n\\int_{\\gamma -iT}^{\\gamma +iT} { e^{z t}F(z) dz},$$\n\t\nwhere the parameter $\\gamma\\in R$ is chosen so that the entire complex contour path of the integral is inside of the region of convergence of $F(z)$.\n\nThe Laplace transform plays in interesting role as an expected value in the field of probability and statistics. If $X$ is a random variable, then its Laplace transform, i.e., the LT of its probability density function $f_X$, is given by the expectation of an exponential:\n\n$${\\mathcal {L}}(X)={\\mathcal {L}}(f)(z)= E\\left ( e^{-zX}\\right ).$$\n\nNote that when $z=−t\\in R$, then the ${\\mathcal {L}}(X)=E\\left ( e^{tX}\\right )$ is just the *moment generating function* of $X$. \n\nAnother application of LT involves recovering the *cumulative distribution function* of a continuous random variable $X$, $F_{X}(x)=\\int_{y<x}{f_X(y) dy}$:\n\n$$ F_{X}(x)={\\mathcal {L}}^{-1} \\left \\{ {\\frac {1}{z}} \nE \\left[e^{-zX}\\right]\\right \\}\\!(x)= \n{\\mathcal {L}}^{-1} \\left \\{ {\\frac {1}{z}} {\\mathcal {L}}(f)(z)\n \\right \\}\\!(x).$$",
      "word_count": 239
    },
    {
      "title": "*Discrete* Laplace Transforms",
      "content": "## *Discrete Forward* Laplace Transforms\n\nThe *discrete* Forward and Inverse Laplace Transforms are computed by numerically estimating the corresponding continuous transformation integrals.\nThe numerical approximation of the LT is defined by the `LT()` method below.\n\n\nNow we can test and compare the discrete and continuous LT ($\\mathcal{L}$) on a pair of functions that have closed-form analytical expressions.\n\n$$f_1(t)=\\mathcal{L}^{-1}(F_1)(t)=t\\ \\underset{ILT}{\\overset{LT}{\\longleftrightarrow}} \\ F_1(z)=\\mathcal{L}(f_1)(z)=\\frac{1}{z^2}.$$\nAnd\n$$ f_2(t)=\\mathcal{L}^{-1}(F_2)(t)=e^{-5t} \\ \n\\underset{ILT}{\\overset{LT}{\\longleftrightarrow}}\\  F_2(z)=\\mathcal{L}(f_2)(z)=\\frac{1}{z+5}.$$\n\n\n## *Discrete Inverse* Laplace Transform\n\n### Basic functions\n\nLet's start by defining some basic functions that transform between *Cartesian* and *Polar* coordinates.\n\n\n### Contour paths in $C$\n\nNext we will define alternative contour paths in the complex plane, $C$, the *optimal* contour `optimContour()`, the Bromwich contour, and their corresponding numerical derivatives along contour paths, `analyticalPathDerivative()` and `bromwichPathDerivative()` functions.\n\n\n### Define the discrete Inverse Laplace Transform (ILT)\n\nNext, we will define the discrete `ILT()` function, which inverts the Laplace Transform, $\\mathcal{L}^{-1}$.\n\n\nLet's test the `ILT()` function using some [simple functions](https://en.wikipedia.org/wiki/Laplace_transform#Table_of_selected_Laplace_transforms). For instance, we can use the same 2 functions we defined above:\n\n$$f_1(t)=\\mathcal{L}^{-1}(F_1)(t)=t\\ \\underset{ILT}{\\overset{LT}{\\longleftrightarrow}} \\ F_1(z)=\\mathcal{L}(f_1)(z)=\\frac{1}{z^2},$$\nand\n$$ f_2(t)=\\mathcal{L}^{-1}(F_2)(t)=e^{-5t} \\ \n\\underset{ILT}{\\overset{LT}{\\longleftrightarrow}}\\  F_2(z)=\\mathcal{L}(f_2)(z)=\\frac{1}{z+5}.$$\n\n\nFor longitudinal data, the Laplace transform provides one explicit mapping of the *duality* between functions of time (time-series) and functions of kime (kimesurfaces). The next sections illustrate that dichotomy.",
      "word_count": 207
    },
    {
      "title": "Laplace Transform Applications",
      "content": "## ILT of Kimesurfaces $(F(z))$ to Time-series $(f(t))$\n\n### Example 1: $F(z)=F_1(z)+F_2(z)\\times F_3(z) +F_4(z)$\n\nSuppose we want to apply the ILT ($\\mathcal{L}^{-1}$ ) to reconstruct a time-series, $\\hat{f}(t)=\\mathcal{L}^{-1}(F)(t)$, corresponding to a given a *composite kimesurface*:\n$$F(z)=\\mathcal{L}(f)=\\underbrace{\\frac{1}{z+1} }_{F_1(z)=\\mathcal{L}\\left( f_1(t)=e^{-t}\\right )} + \n\\underbrace{\\frac{1}{z^2 + 1}}_{F_2(z)=\\mathcal{L}\\left( f_2(t)=\\sin(t)\\right )} \\times \n\\underbrace{\\frac{z}{z^2 + 1}}_{F_3(z)=\\mathcal{L}\\left( f_3(t)=\\cos(t)\\right )} + \n\\underbrace{\\frac{1}{z^2}}_{F_4(z)=\\mathcal{L}\\left( f_4(t)=t\\right )} .$$\n\nMind the decomposition of the compound (*time* and *kime*) functions in terms their building blocks, i.e., simpler functions. Using the linearity and convolution-to-product properties of the Laplace transform, we have:\n\n$$F(z)=F_1(z)+F_2(z)\\times F_3(z) +F_4(z)$$\nTherefore, \n$$f(t)=\\mathcal{L}^{-1}\\left ( F \\right ) = \n\\mathcal{L}^{-1}\\left ( F_1+F_2\\times F_3 +F_4) \\right )=$$\n$$\\mathcal{L}^{-1}( F_1) + \\left ( \\underbrace{\\mathcal{L}^{-1}(F_2) * \n\\mathcal{L}^{-1} (F_3)}_{\\text{convolution}}\\right )(t)  + \\mathcal{L}^{-1}(F_4)=$$\n\n$$ \\mathcal{L}^{-1}(\\mathcal{L}(f_1))(t) + \\left ( \\mathcal{L}^{-1}(\\mathcal{L}(f_2)) * \n\\mathcal{L}^{-1}(\\mathcal{L}(f_3))\\right )(t) + \\mathcal{L}^{-1}(\\mathcal{L}(f_4))(t).$$\n\n<!-- https://www.wolframalpha.com/input/?i=integral+%28sin%28r%29cos%28t-r%29dr+r+from+0+to+t%29+ -->\n\nFinally,\n\n$$f(t)=\\mathcal{L}^{-1}(F)(t)=f_1(t) + \\left ( f_2 * f_3\\right )(t) + f_4(t)=e^{-t}+ \\int_{0}^{t}{\\sin(\\tau) \\times \\cos(t-\\tau)d\\tau} +t=t+e^{-t}+\\frac{t\\sin(t)}{2}. $$\n\nLet's validate this analytical derivation by using the discrete LT.\n\n\nRecall that kimesurfaces are defined over complex-time (Complex-pane) and have complex-value ranges. The plot below shows the original kimesurface as a 2D manifold whose *height* (vertical dimension) is represented by the *Real* part of the kimesurface intensity, `Re(fMRI_Kimesurface)`, and the *surface color* encodes the *Imaginary* part of the kimesurface intensity, `Im(fMRI_Kimesurface)`.\n\n\nWe can also render the kimesurface as a manifold whose *height* (vertical dimension) is represented by the *Magnitude* and *color* encodes the *Phase* of the kimesurface.\n\n\nLet's now reconstruct and plot the 1D function $f(t)=\\mathcal{L}^{-1}(F)(t)$.\n\n\n### Example 2: $F(z)=|z|$\n\nAnother example is finding the time-series Laplace dual to the kimesurface \n$$F(z)=|z| .$$\n\n\n\n\n### Example 3: $F(z)=\\frac{w}{z^2+w^2}$\n\n$$f(t)=\\mathcal{L}^{-1}(F_1)(t)=\\sin(w t)\\ \\underset{ILT}{\\overset{LT}{\\longleftrightarrow}} \\ F_1(z)=\\mathcal{L}(f_1)(z)=\\frac{w}{z^2+w^2}.$$\n\nWe can choose $w=2$ without lost of generosity.\n\n\n\n\n## Laplace Transformation of Time-series $(f(t))$ to Kimesurfaces $(F(z))$\n\nNext, we will demonstrate the reverse operation - finding the Laplace-dual kimesurface corresponding to a given time-series. Starting with the time-series:\n\n### Discrete Representation of $\\mathcal{L}^{-1}(\\mathcal{L}(sin(x)))$\n\nLet's see explore the duality of the LT, ($\\mathcal{L}^{-1}(\\mathcal{L})=I?$), using $f(t)=sin(t)$.",
      "word_count": 321
    },
    {
      "title": "ILT on Explicit definition of the Kimesurface function $F(z)=\\mathcal{L}(\\sin)(z)$",
      "content": "Next, we will compare the original time-signal $f(t)=sin(t)$ against a spline-smoothed $f_1(t)=\\mathcal{L}^{-1}(\\mathcal{L}(\\sin))(t)$ over the range $t\\in [0 : 2\\pi]$.",
      "word_count": 19
    },
    {
      "title": "Compare the analytical and discrete Laplace transforms",
      "content": "Using the function $f(t)=sin(t)$ and its closed-form LT, $F(z)=\\mathcal{L}(f)(z)=\\frac{1}{z^2 + 1}$, we will compare the analytical and discrete kime-surface reconstructions.\n\n\nIn the these 3D displays, we intentionally offset vertically the two kimesurfaces to illustrate their identical geometric, topological, and shape characteristics. This validates that the theoretical and the pragmatic implementation of the Laplace Transform agree on the example function, $f(t)=sin(t)$.",
      "word_count": 60
    },
    {
      "title": "Compare the analytical and discrete Inverse Laplace Transforms",
      "content": "We can also similarly validate the agreement between the exact (continuous) theoretical and the approximate (discrete) Inverse Laplace Transforms using the kimesurface, $F(z)=\\mathcal{L}(f)(z)=\\frac{1}{z^2 + 1}$, corresponding to the original function $f(t)=sin(t)$.",
      "word_count": 31
    },
    {
      "title": "fMRI example",
      "content": "Let's demonstrate the Laplace dual of single time-series representing the real-valued intensity of a functional magnetic resonance imaging (fMRI) data at a fixed spatial location (single voxel in the brain). The entire fMRI data is a 4D hypervolume with intensities encoding the blood oxygenation level dependence at a specific spacetime location $(x,y,z,t)$. For simplicity, we are only focusing on one fixed spatial voxel location $(x_o,y_o,z_o)$. Start by loading and plotting the original fMRI data, $f_{(x_o,y_o,z_o)}(t)$.\n\nAs the fMRI series is extremely noisy (almost nowhere differentiable), we need to apply preprocess filtering (smoothing) to ensure the LT is well-defined, i.e., the fMRI time-series is integrable against the exponential kernel.  \n\n## Load the fMRI data\n\n\n## Compute the LT $\\mathcal{L}(fMRI)(z)$\n\nNext, we will compute and display in 3D the Laplace-dual, $F_{(x_o,y_o,z_o)}(z)=\\mathcal{L}(f_{(x_o,y_o,z_o)}(z)$ and display the kimesurface as a complex-valued, complex-time, analytic (holomorphic) function.\n\n*Warning*: This $\\mathcal{L}(fMRI)(z)$ kimesurface calculation is intensive. To ensure near-real-time computation, below we only show a low-resolution $49\\times49$ kimesurface representation where the kime-manifold height and color represent the kimesurface magnitude and phase, respectively.\n\n\n## Invert the LT $\\mathcal{L}^{-1}(\\mathcal{L}(fMRI))(t)$\n\nFinally, we can invert the fMRI kimesurface back in the time-domain and compare it to the original fMRI time-series.\n\n\nThe observed discrepancy between the smoothed original fMRI time-series and the raw and smoothed reconstructions, ILT(LT(fMRI)), is due to the over-simplified coarse representation of the kimesurface and the discrete transform approximation to the continuous Laplace transform (forward and inverse).\n\nThis example illustrates the foundation of [spacekime analytics](https://spacekime.org/), where we derive statistical inference by lifting the observed time-series into kime-surfaces, which contain additional geometric and topological information that can then be modeled, interrogated, analyzed to obtain robust prediction or forecasting.\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"http://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img src=\"http://counter.digits.net/?counter=SOCR\"\n\t \t\t\talign=\"middle\" border=\"0\" height=\"20\" hspace=\"4\" vspace=\"2\" width=\"60\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"http://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"http://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 372
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "      smooth_scroll: true\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "knitr::opts_chunk$set(echo = TRUE)\noptions(warn = -1)\nrequire(pracma)\nrequire(cubature)\nrequire(plotly)\nlibrary(doParallel)\nncor = 8 # number of cores for parallel computing",
      "line_count": 7
    },
    {
      "section": "*Discrete* Laplace Transforms",
      "code": "# Numerical Laplace Transform (LT) and its Inverse (ILT)\n\n################## 1. (forward) Laplace Transform\n#' @title Laplace Transform\n#' @description numerically compute the Laplace Transform\n#'\n#' @param FUNCT Input function f(t)\n#' @param z complex domain value to evaluate the F(z)=LT(FUNCT)(z)\n#' \n#' @examples\n#' f <- function(t) { t }; z= 1+1i; LT(f, z); F <- function (z) { 1/z^2 }; F(z)\n#'\nLT <- function(FUNCT, z){\n  FUNCT <- match.fun(FUNCT) # input R-domain FUNCT should be interpreted as a function\n  # define the integrand function (complex-valued)\n  # Note that cubic numeric integration is used (Unified Cubature Integration Interface),\n  # Integral limits are exact [0, Inf)\n  integrand <- function(t) {   return(FUNCT(t) * exp(-z*t)) }\n  return(cubintegrate(f = function(t) Re(integrand(t)), \n                      lower = 0, upper = Inf, method = \"pcubature\")$integral +\n           1i * cubintegrate(f = function(t) Im(integrand(t)), \n                             lower = 0, upper = Inf, method = \"pcubature\")$integral)\n}",
      "line_count": 23
    },
    {
      "section": "*Discrete* Laplace Transforms",
      "code": "### 2. Tests the LT\nz= 1+1i # Complex-domain value\nf <- function(t) { t }  # test function, F(z)=L(f)(z)=1/z^2\nLT(f, z); 1/z^2\nf <- function(t) { exp(-5*t) }  # test function, F(z)=L(f)(z)=1/(z+5)\nLT(f, z); 1/(z+5)",
      "line_count": 6
    },
    {
      "section": "*Discrete* Laplace Transforms",
      "code": "################ Cartesian to Polar Coordinate Transform ##############################################\n#' Cartesian to Polar Coordinate Transform\n#' @title Cartesian to Polar Coordinate Transform\n#' @description In r.xy Returns polar coordinate r from a pair of Cartesian coordinates (x, y)\n#'\n#' @param x x co-ordinate\n#' @param y y co-ordinate\n#' @return r or phi respectively from x and y\nr.xy <- function(x, y){\n  return(sqrt(x^2 + y^2))\n}\n\n#' @description In r.xy Returns polar coordinate phi from a pair of Cartesian coordinates (x, y).\nphi.xy <- function(x, y){\n  return(atan2(y, x)) \n}\n\n################ Polar to Cartesian Coordinate Transform ##############################################\n#' Polar to Cartesian Coordinate Transform\n#' @title Polar to Cartesian Coordinate Transform\n#' @description In x.rphi Returns cartesian coordinate x from a pair of polar coordinates (r, phi)\n#'\n#' @param r distance from origin (Time)\n#' @param phi phase\n#' @return x or y respectively from r and phi\nx.rphi <- function(r, phi){\n  return(r*cos(phi))\n}\n\n#' @description In y.rphi eturns cartesian coordinate y from a pair of polar coordinates (r, phi)\ny.rphi <- function(r, phi){\n  return(r*sin(phi))\n}",
      "line_count": 33
    },
    {
      "section": "*Discrete* Laplace Transforms",
      "code": "################## 3. Optimum contour path in Complex plane (needed for ILT) ##########################\n# Uses Evans, Chung (2000) method\n#'\n#' @title Optimum Contour Path\n#' @description The optimum contour path in polar co-ordinates (r,phi)\n#'\n#' @param phi phi (polar phase) value\n#' @param m contour width; small values may lead to singularities on negative x-axis; \n#' large values may lead to instabilities on the positive x-axis\n#' @param t time (R^+ domain) variable, interdependent with the contour width, m\n#'\n#' @references Evans, Chung, 2000: Laplace transform inversions using optimal contours \n#' in the complex plane, International Journal of Computer Mathematics, v73, pp531-543.\n#'\noptimContour <- function(phi, m=1, t=5){\n  if(identical(t, 0)){ t <- 5 } # reset t=0 to avoid singularities\n  return(m*phi/(t*sin(phi)))\n}\n\n#' Numerical derivative of contour path length with respect to phi\n#' return(((m*phi/(t*sin(phi)))^2 + (1/sin(phi) - phi/(tan(phi)*sin(phi)))^2)^0.5) \n#' s as magnitude: real\n#' s as dx and dy components: complex\n#' @param phi phi (polar phase) value\n#' @param m contour width; small values may lead to singularities on negative x-axis; \n#' large values may lead to instabilities on the positive x-axis\n#' @param t time value\nanalyticalPathDerivative <- function(phi, m=1, t=5) {\n  if(identical(t, 0)) { t <- 100 } # reset t = 0 to avoid singularities\n  if(identical(phi, 0)) { dx_dphi <- 0 } # avoid small phi value singularities\n  else{ dx_dphi <- (m/t)*((sin(phi) - phi*cos(phi))*cos(phi)/(sin(phi))^2 - phi) }\n  dy_dphi <- (m/t) \n  return( complex(real=dx_dphi, imaginary = dy_dphi) )\n}\n\n\n\n#' @title Bromwich contour path\n#' @description Bromwich contour path - a straight vertical line through x=gamma\n#' @param phi phi (polar phase) value\n#' @param gamma value on the positive x-axis for the vertical line representing the countour\n#' @param t time value\nbromwichContour = function(phi, gamma = 0.5) {\n  return(gamma/cos(phi))\n}\n\n# Numerical derivative of Bromwich contour\n#' @param phi phi (polar phase) value\n#' @param gamma value on the positive x-axis for the vertical line representing the countour\nbromwichPathDerivative=function (phi, gamma = 0.5) {\n  return((0+1i) * (bromwichContour(phi, gamma)^2 + (gamma * tan(phi)/cos(phi))^2)^0.5)\n}",
      "line_count": 52
    },
    {
      "section": "*Discrete* Laplace Transforms",
      "code": "################## 4. Inverse Laplace Transform #######################################################\n#' @title Inverse Laplace Transform\n#' @description Numerical inverse of the Laplace Transform (ILT)\n#'\n#' @param FUNCT the function F(z), typically a Laplace-Transform of a function f(t)\n#' @param t time domain value to evaluate the ILT(F)(t)\n#' @param nterms number of terms to use in the numerical inversion (odd number)\n#' @param m width of the contour path in C; too small values may lead to singularities on the negative x-axis; \n#' too large valued may lead to numerical instability for large positive x-axis\n#' @param fail_val value to return in event of failure to converge\n#' @param gamma value on the positive x-axis for the vertical line representing the countour\n#' @msg Boolean to show/hide warnings\n#'\nILT <- function(FUNCT, t, nterms = 31L, m=1, gamma=0.5, fail_val = complex(0+0i), msg=TRUE){\n  FUNCT <- match.fun(FUNCT)           # input C-valued FUNCT should be interpreted as a function\n  if(identical(t, 0)) { t <- 10^-50 } # accurate for very low values of t>0\n  n_attempts <- 10\n  \n  for (attempt in 1:n_attempts) {  # repeated numerical integration attempts\n    dphi <- 2*pi/nterms\n    phi <- -pi + (1:nterms - 1/2)*dphi\n    z <- optimContour(phi, m, t)*cos(phi) + optimContour(phi, m, t)*sin(phi)*1i\n    # Plot optimal contour   # plot(Re(z), Im(z))\n    L <- vapply(z, FUNCT, 1i) # Specify the rerurn Function type must be a single C-value!\n    # L <- sapply(z, FUNCT)  # Funct returns array or list, not a single C-value!\n    \n    if(any(!is.finite(L))){\n      if(msg==TRUE & identical(attempt, as.integer(n_attempts))) { \n        # if original method fails, construct ILT ob bromwich contour\n        sprintf(\"Laplace Transform inversion failed after %s attempts.\\n\", n_attempts)\n        # Note: Try alternative Bromwich contour in C, which may not be very stable\n        nterms = 1000L\n        tot <- 0\n        dphi <- pi/nterms\n        for (n in 1:nterms) {\n          phi <- -pi/2 + (n - 1/2) * dphi\n          ds <- dphi * bromwichPathDerivative(phi, gamma)\n          x <- x.rphi(bromwichContour(phi, gamma), phi)\n          y <- y.rphi(bromwichContour(phi, gamma), phi)\n          tot <- tot + exp((x + y*(0+1i)) * t) * FUNCT(x + y*(0+1i)) * ds\n        }\n        return(tot/(2 * pi * (0+1i)))\n      }\n      m <- m*2   # contour path increment\n      nterms <- round(nterms*1.378, 0) # random irregular number to avoid sampling same point again\n      next\n    }\n    em <- exp(z*t)\n    ds_dphi <- vapply(phi, analyticalPathDerivative, 1i, m, t)\n    break\n  }\n  return(sum(em*L*ds_dphi)*dphi/(2i*pi))\n}",
      "line_count": 53
    },
    {
      "section": "*Discrete* Laplace Transforms",
      "code": "### 5. Tests the ILT\nt = 1/5 # R-domain value\nf <- function(z) { 1/(z^2) }  # test function, F(z)=L(f)(z)=1/z^2 ==> f(t)=t\nILT(f, t); t\nf <- function(z) { 1/(z+5) }  # test function, F(z)=L(f)(z)=1/(z+5) ==> f(t)=e^-{5t}\nILT(f, t); exp(-5*t)",
      "line_count": 6
    },
    {
      "section": "Laplace Transform Applications",
      "code": "library(ggplot2)\nlibrary(plotly)\n\n### Analytical-Model-based ILT: F(z) =  1/(z+1) + (1/(z^2 + 1))*(z/(z^2 + 1)) + 1/(z^2)\nfMRI_Kimesurface <- function (z) {\n  return ( 1/(z+1) + (1/(z^2 + 1))*(z/(z^2 + 1)) + 1/(z^2) )  # F(z)\n}\n\n# Test F=fMRI_kimesurface\nfMRI_Kimesurface(0.5+ 0.5i) \n\n######### Display the actual kimesurface: F(z)\nx2 <- seq(from = -2, to = 2, length.out = 200)\ny2 <- seq(from = -2, to = 2, length.out = 200)\nz2_grid = array(complex(), dim=c(length(x2), length(y2)))\n\nfor (i in 1:dim(z2_grid)[1]) {\n  for (j in 1:dim(z2_grid)[2]) {\n    z2_grid[i,j] = fMRI_Kimesurface(complex(real=x2[i], imaginary = y2[j]))\n  }\n}\n\nimage(Im(z2_grid), axes=FALSE); contour(Im(z2_grid), add=T, col=\"red\", lwd=2, drawlabels=FALSE, axes=FALSE);\ncontour(Re(z2_grid), add=T, col=\"blue\", lwd=2, drawlabels=F, \n        main = \"Im(f) Image with Re(f) and Im(f) Contours in red and blue\", axes=F); \ntitle(\"Re(f) Image with Re(f) and Im(f) Contours in red and blue\", font = 5)",
      "line_count": 26
    },
    {
      "section": "Laplace Transform Applications",
      "code": "# Surface height= Re(fMRI_Kimesurface); Surface color = Im(fMRI_Kimesurface)\nz3 <- Im(z2_grid)\nsurf_color <- z3\nfor (i in 1:200) {\n  for (j in 1:200) {\n    if (z3[i,j]>0)  surf_color[i,j] <- min(z3[i,j], 5)\n    else surf_color[i,j] <- max(z3[i,j], -5)\n  }\n}\n\ncolorscale = cbind(seq(0, 1, by=1/(length(x2) - 1)), rainbow(length(x2)))\n\np <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(z = Re(z2_grid),   # z = Im(z2_grid),  # Real or Imaginary part of f(t)\n              surfacecolor=surf_color, colorscale=colorscale,   #Phase-based color\n              type = 'surface', opacity=1, visible=T,\n              contour=list(x = list(highlight = FALSE),\n                           y = list(highlight = FALSE),\n                           z = list( highlight = TRUE, highlightcolor = \"blue\"),\n                           color=\"#000\", width=15, lwd=10,\n                           opacity=1.0, hoverinfo=\"none\")\n              ) %>%\n    layout(title = \n           paste0(\"Kime-Surface, Height=Re(F), Color=Im(F) \\n\", \n           \"F=LT(f)=1/(z+1) + (1/(z^2 + 1))*(z/(z^2 + 1)) + 1/(z^2)\"), \n           showlegend = FALSE,\n           scene = list(aspectmode = \"manual\",\n                            aspectratio = list(x=1, y=1, z=0.5),\n                            zaxis = list(range = c(-5,5))\n              )\n          ) # 1:1:1 aspect ratio\np",
      "line_count": 32
    },
    {
      "section": "Laplace Transform Applications",
      "code": "magnitude <- sqrt((Re(z2_grid))^2+(Im(z2_grid))^2)\nx5 <- Re(z2_grid); y5 <- Im(z2_grid)\nphase <- atan2(y5,x5)\nsurf_color <- phase\nfor (i in 1:200) {\n  for (j in 1:200) {\n    if (phase[i,j]>0)  surf_color[i,j] <- min(phase[i,j], 5)\n    else surf_color[i,j] <- max(phase[i,j], -5)\n  }\n}\n\ncolorscale = cbind(seq(0, 1, by=1/(length(x2) - 1)), rainbow(length(x2)))\n\np <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(z = magnitude,   # z = Magnitude\n              surfacecolor=surf_color, colorscale=colorscale,   #Phase-based color\n              type = 'surface', opacity=1, visible=T,\n              contour=list(x = list(highlight = FALSE),\n                           y = list(highlight = FALSE),\n                           z = list( highlight = TRUE, highlightcolor = \"blue\"),\n                           color=\"#000\", width=15, lwd=10,\n                           opacity=1.0, hoverinfo=\"none\")\n              ) %>%\n    layout(title = \n             paste0(\"Kime-Surface, Height=Magnitude(F), Color=Phase(F) \\n\", \n                    \"F=LT(f)=1/(z+1) + (1/(z^2 + 1))*(z/(z^2 + 1)) + 1/(z^2)\"), \n           showlegend = FALSE,\n           scene = list(aspectmode = \"manual\",\n                            aspectratio = list(x=1, y=1, z=0.5),\n                            zaxis = list(range = c(-2,5))\n              )\n          ) # 1:1:1 aspect ratio\np",
      "line_count": 33
    },
    {
      "section": "Laplace Transform Applications",
      "code": "##### f(t): 1D version #############################################\ntime_points <- seq(0+0.001, 2*pi, length.out = 160)\n\n# Apply ILT to recover f=ILT(F) and evaluate f(time_points)\n# using parallel computing to improve coding speed\ncl <- makeCluster(4)\nregisterDoParallel(cl)\nf_result <- foreach(t=1:length(time_points))  %dopar% { \n  ILT(FUNCT=fMRI_Kimesurface, t=time_points[t], \n      nterms = 31L, m = 1, fail_val = complex(1))\n}\nstopCluster(cl)\nf <- array(complex(1), dim = length(time_points)) # length(f)\nf[1:length(f)] = unlist(f_result)\n\n\n# Convert f=ILT(F) to a data-frame for ggplot\nfMRI_time_Intensities_ILT_df <- as.data.frame(cbind(Re=Re(f),Im=Im(f),time_points=time_points))\nggplot(fMRI_time_Intensities_ILT_df, aes(x=Re(time_points))) + \n  geom_line(aes(y = Im, colour=\"Imaginary\"), lwd=3)+\n  geom_line(aes(y = Re, colour = \"Real\"), lwd=3) +\n  scale_color_manual(\"Index\",\n                     breaks=c(\"Imaginary\", \"Real\"),\n                     values = c(\"steelblue\", \"darkred\")) +\n  xlab(\"Time\") + ylab(\"fMRI Image Intensities (f)\") + \n  # ggtitle(\"Real (Re) and Imaginary (Im) parts \\n of the original fMRI Time-series, f=ILT(F)\") +\n  labs(title = \n         \"ILT Reconstructed fMRI Time-series, f=ILT(F)\") +\n  scale_y_continuous() +\n  theme_grey(base_size = 16) +\n  theme(legend.title = element_text(size=14, color = \"black\", face=\"bold\"),\n        panel.grid.minor.y = element_blank(),\n        panel.grid.major.y = element_blank(),\n        plot.title = element_text(hjust = 0.5))",
      "line_count": 34
    },
    {
      "section": "Laplace Transform Applications",
      "code": "### F(z)= ABS(z) ==>  f(t) ~= -1/t\nF <- function (z) {\n  return (abs(z))\n}\n\n\nneg_reciprocal <- array(complex(1), dim = length(time_points));\nfor (t in 1:length(time_points)) {\n  neg_reciprocal[t] <- ILT(FUNCT=F, t=time_points[t], nterms = 31L, m = 1, fail_val = complex(1))\n}\n\n# Convert f=ILT(F) to a data-frame for ggplot\nfMRI_time_Intensities_ILT_df <- as.data.frame(cbind(Re=Re(neg_reciprocal),\n                                                    Im=Im(neg_reciprocal),time_points=time_points))\nggplot(fMRI_time_Intensities_ILT_df, aes(x=time_points), ylim=c(-10,10)) + \n  geom_line(aes(y = Im, color=\"Imaginary\"), linetype=1, lwd=3)+\n  geom_line(aes(y = Re, color = \"Real\"), lwd=2) + \n  ggtitle(\"Original Time-series, f=ILT(F), F=|z|\") +\n  xlab(\"Time\") + ylab(\"Intensities (f)\") +\n  scale_color_manual(name=\"Index\",\n                     breaks=c(\"Imaginary\", \"Real\"),\n                     values = c(\"steelblue\", \"darkred\"))+\n  scale_y_continuous(limits = c(-5, 1)) +\n  theme_grey(base_size = 16) +\n  theme(legend.title = element_text(size=14, color = \"black\", face=\"bold\"),\n        panel.grid.minor.y = element_blank(),\n        panel.grid.major.y = element_blank(),\n        plot.title = element_text(hjust = 0.5))",
      "line_count": 28
    },
    {
      "section": "Laplace Transform Applications",
      "code": "###### f(t)=sin(w t)*u(t) <--> F(z)=\tw/(z^2+w^2)\n# https://en.wikipedia.org/wiki/Laplace_transform\n\n################## Analytical-Model-based ILT: F(z) =  2/(z^2+2^2); w=2\nfMRI_Kimesurface <- function (z) {\n  return (2/(z^2+4))\n}\n# Test F=fMRI_kimesurface\n#    fMRI_Kimesurface(1+ 1i) # 1.04-0.78i\nfMRI_Kimesurface(0.5+ 0.5i) # [1] 0.4923077-0.0615385i\n\n######################## Display the actual kimesurface: F(z)\nx2 <- seq(from = -2, to = 2, length.out = 200)\ny2 <- seq(from = -2, to = 2, length.out = 200)\nz2_grid = array(complex(), dim=c(length(x2), length(y2)))\n\nfor (i in 1:dim(z2_grid)[1]) {\n  for (j in 1:dim(z2_grid)[2]) {\n    z2_grid[i,j] = fMRI_Kimesurface(complex(real=x2[i], imaginary = y2[j]))\n  }\n}\nz3 <- Im(z2_grid)\nsurf_color <- z3\nfor (i in 1:200) {\n  for (j in 1:200) {\n    if (z3[i,j]>0) {surf_color[i,j] <- min(z3[i,j], 5) }\n    else{surf_color[i,j] <- max(z3[i,j], -5)}\n  }\n}\n\ncolorscale = cbind(seq(0, 1, by=1/(length(x2) - 1)), rainbow(length(x2)))\n\np <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(z = Re(z2_grid),   # z = Im(z2_grid),  # Real or Imaginary part of f(t)\n              surfacecolor=surf_color, colorscale=colorscale,   #Phase-based color\n              type = 'surface', opacity=1, visible=T) %>%\n    layout(title = \"Kime-Surface, Height=Re(F), Color=Im(F) \\n F=LT(f)=2/(z^2+4)\", showlegend = FALSE,\n           scene = list(aspectmode = \"manual\",\n                            aspectratio = list(x=1, y=1, z=0.5),\n                            zaxis = list(range = c(-2,5))\n              )\n          ) # 1:1:1 aspect ratio\np",
      "line_count": 43
    },
    {
      "section": "Laplace Transform Applications",
      "code": "##### f(t): 1D version #############################################\ntime_points <- seq(0+0.001, 2*pi, length.out = 160)\n\nf <- array(NA, dim = length(time_points));\n\n# using parallel computing to speed up the code\ncl <- makeCluster(ncor)\nregisterDoParallel(cl)\nILT_F_result <-\n  foreach(t = 1:length(time_points)) %dopar% {\n    ILT(FUNCT=fMRI_Kimesurface, t=time_points[t], nterms = 31L, m = 1, fail_val = complex(1))\n  }\nstopCluster(cl)\nILT_F <- array(NA, dim = length(time_points)) # length(f)\nILT_F[1:length(ILT_F)] = unlist(ILT_F_result)\n\nfor (t in 1:length(time_points)) {\n  f[t] = sin(2*time_points[t])   # f(t)=sin(w t)*u(t)\n}\n\n# Convert f=ILT(F) to a data-frame for ggplot\nfMRI_time_Intensities_ILT_df <- as.data.frame(cbind(time_points=time_points, Re_f=Re(f),Im_f=Im(f),\n                                                    Re_ILT_F=Re(ILT_F),Im_ILT_F=Im(ILT_F)))\n\nggplot(fMRI_time_Intensities_ILT_df, aes(x=time_points)) + \n  geom_line(aes(y = Re_f, color = \"Sin\"), lwd=1, lty=\"dashed\") +\n  geom_line(aes(y = Re_ILT_F+0.01, color = \"Real f'\"), lwd=2, lty=\"dotted\") +\n  geom_line(aes(y = Im_ILT_F, color=\"Imaginary f'\"), linetype=1, lwd=2) +\n  scale_color_manual(\"Index\", \n                     values = c(\"Sin\"=\"darkred\",\"Real f'\"=\"darkgreen\", \"Imaginary f'\"=\"steelblue\")) + \n  # ggtitle(\"Real (Re) and Imaginary (Im) parts \\n of the original fMRI Time-series, f=ILT(F)\")\n  labs(title = \"Original fMRI Time-series f(t)=sin(2t) and \\n Reconstructed f'(t)=ILT(F)=ILT(LT(f))\",\n       subtitle = bquote(\"F\" ~ \"=\" ~ \"LT(f)\" ~ \"=\" ~ 2/(z^2+2^2))) +#\"F=LT(f)=2/(z^2+2^2)\")\n  xlab(\"Time\") + ylab(\"fMRI Image Intensities (f and f')\") +\n  theme_grey(base_size = 16) +\n  theme(legend.title = element_text(size=14, color = \"black\", face=\"bold\"),\n        panel.grid.minor.y = element_blank(),\n        panel.grid.major.y = element_blank(),\n        plot.title = element_text(hjust = 0.5),\n        plot.subtitle = element_text(hjust = 0.5))\n",
      "line_count": 41
    },
    {
      "section": "Laplace Transform Applications",
      "code": "#######################################################################\n###### ILT on discrete laplace transform of sine (analytical form) ####\n#######################################################################\nf_sin <- function(t) { sin(t) }\n# Define the LT(sin) as a C-valued functione \nlt_func = function(z) LT(f_sin, z)# LT(FUNCT, z), not LT(z, FUNCT) # discrete Laplace Transform of sine\n\ntvalsn <- seq(0, pi*2, length.out = 20)\n# using parallel computing to improve coding speed\ncl <- makeCluster(ncor)\nregisterDoParallel(cl)\nsinvalsn <- foreach(t=1:length(tvalsn),\n                    .export='cubintegrate', \n                    .packages='cubature')  %dopar% { \n  ILT(FUNCT=lt_func, t=tvalsn[t])\n}\nstopCluster(cl)\nsinvalsn = unlist(sinvalsn)\nsinvalsn_df2 <- as.data.frame(cbind(Re=Re(sinvalsn),Im=Im(sinvalsn), Sin=sin(tvalsn), time_points=tvalsn))\nggplot(sinvalsn_df2, aes(x=time_points))+\n  geom_line(aes(y=Re, color=\"Real\"), linetype=1, lwd=2) +\n  geom_line(aes(y = Sin, color=\"Sin\"), linetype=2, lwd=1) + \n  scale_color_manual(name=\"Index\",\n                     values = c(\"Real\"=\"steelblue\", \"Sin\"=\"darkred\"))+\n  labs(title = \"Original fMRI Time-series f(t)=sin(t) and \\n Reconstructed f'(t)=ILT(F)=ILT( discrete LT(f))\",\n       subtitle = bquote(\"F\" ~ \"=\" ~ \"discrete LT(f)\")) + #\"F=LT(f)=2/(z^2+2^2)\"\n  xlab(\"Time\") + ylab(\"fMRI Image Intensities (f and f')\") +\n  theme_grey(base_size = 16) +\n  theme(legend.title = element_text(size=14, color = \"black\", face=\"bold\"),\n        panel.grid.minor.y = element_blank(),\n        panel.grid.major.y = element_blank(),\n        plot.title = element_text(hjust = 0.5),\n        plot.subtitle = element_text(hjust = 0.5))",
      "line_count": 33
    },
    {
      "section": "ILT on Explicit definition of the Kimesurface function $F(z)=\\mathcal{L}(\\sin)(z)$",
      "code": "# reduce the grid-resolution from 200*200 down to (50-1)*(50-1)\nrange_limit = 2\nx2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n  # drop the first row to avoid real part value of 0\ny2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n  # drop the first column to to avoid imaginary part value of 0\n\n# Recompute the LT(sin) discretized on lower-res grid\nz2_grid = array(dim=c(length(x2), length(y2)))# x2 %o% y2\n\nf_sin <- function(t) { sin(t) }\n\n# kime surface transform\n# use parallel computing to speed up code\ncl <- makeCluster(ncor)\nregisterDoParallel(cl)\nF = list()\nfor (i in 1:length(x2) ){\n  F[[i]] = \n    foreach(j = 1:length(y2),\n            .export='cubintegrate', \n            .packages='cubature') %dopar% {\n      F_result = LT(FUNCT=f_sin, complex(real=x2[i], imaginary = y2[j]))# LT(FUNCT, z), not LT(z, FUNCT)\n      mag = log(sqrt( Re(F_result)^2+ Im(F_result)^2))   \n      # log-transform the magnitude to temper the kimesurface amplitude\n      phase = atan2(Im(F_result), Re(F_result))\n      mag * exp(1i*phase)#z2_grid[i,j] = \n    }\n}\n  \nstopCluster(cl)\nF_vec = lapply(F, unlist)\nz2_grid = unlist(do.call(rbind, F_vec))\n\n\n#### define Kimesurface_fun #####\nKimesurface_fun <- function (z, array_2D) {\n  # array_2D <- z2_grid\n  # convert z in C to Cartesian (x,y) coordinates\n  x1 <- ceiling(Re(z))-1; # if (x1<2 || x1>dim(array_2D)[1]) x1 <- 2\n  y1 <- ceiling(Im(z))-1; # if (y1<2 || y1>dim(array_2D)[2]) y1 <- 2\n  # if exceed the domain use the default 1\n  if(!is.na(x1)){\n    if((x1 < 1) || (x1 > dim(array_2D)[1])){ x1 <- 1 }\n  }\n  if(!is.na(y1)){\n    if((y1 < 1) || (y1 > dim(array_2D)[2])){ y1 <- 1 }\n  }\n  \n  # Exponentiate to Invert the prior (LT) log-transform of the kimesurface magnitude\n  val1 = complex(length.out=1, real=Re(array_2D[x1, y1]), imaginary = Im(array_2D[x1, y1]))\n  mag = exp(sqrt( Re(val1)^2+ Im(val1)^2))\n  # mag = sqrt( Re(val1)^2+ Im(val1)^2)\n  phase = atan2(Im(val1), Re(val1))\n  value <- complex(real=Re(mag * exp(1i*phase)), imaginary = Im(mag * exp(1i*phase))) \n  return ( value )\n}\n\nKimesurface_fun(5+5i, z2_grid)\n\n##### Time-domail grid (regular equidistant positive real break points)\ntime_points <- seq(0+0.001, 2*pi, length.out = 160)\n\nf2 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f2[t] <- ILT(FUNCT=function(z) Kimesurface_fun(z, array_2D=z2_grid), \n               t= time_points[t], nterms = 31L,\n               m = 1, gamma=0.5, fail_val = complex(1), msg=TRUE)\n}\n\n# interpolate f(t) to 20 samples in [0 : 2*pi]. Note that 20~2*PI^2\ntvalsn <- seq(0, pi*2, length.out = 20)\nf3 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f3[t] <- f2[ceiling(t/20)]\n}\nf4 <- smooth.spline(time_points, Re(f3), spar = 1)$y; # plot(f4)\n\ntime_Intensities_ILT_df2 <- as.data.frame(cbind(Re=Re(f4), Im=Re(f3),\n                                                Sin=sin(time_points),\n                                                time_points=time_points))\nmin_range <- range(Re(f4))[1]; max_range <- range(Re(f4))[2]\ntime_Intensities_ILT_df2$Re <- time_Intensities_ILT_df2$Re/(8*max_range/9)\ntime_Intensities_ILT_df2$Im <- time_Intensities_ILT_df2$Im/(8*max_range/9)\ncolnames(time_Intensities_ILT_df2) <- \n  c(\"Smooth Reconstruction\", \"Raw Reconstruction\", \"Original sin()\", \"time_points\")\n\ndf <- reshape2::melt(time_Intensities_ILT_df2, id.var = \"time_points\")\nggplot(df, aes(x = time_points, y = value, colour = variable)) + \n  geom_line(linetype=1, lwd=3)+\n  ylab(\"Function Intensity\") + xlab(\"Time\") +\n  theme(legend.position=\"top\")+\n  labs(title=\n         \"Comparison between f(t)=sin(t) and SplineSmooth(ILT(LT(sin)))(t); Range [0 : 2Pi]\")",
      "line_count": 94
    },
    {
      "section": "Compare the analytical and discrete Laplace transforms",
      "code": "# range_limit = 2\n# x2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n#   # drop the first row to avoid real part value of 0\n# y2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n#   # drop the first column to to avoid imaginary part value of 0\n\n#############################################################################\n### Explicit (continuous-funciton) form of laplace transformation of sine ###\n#############################################################################\nXY = expand.grid(X=x2,Y=y2)       \n# XY\nlaplace_sine = function(p) { 1/(p^2 + 1) } # Exact laplace transform of sin(x), continuous function\ncomplex_xy = mapply(complex, real=XY$X,imaginary=XY$Y)\nsine_z =laplace_sine(complex_xy)\ndim(sine_z) = c(length(x2), length(y2)); dim(sine_z)  # [1] 49 49\n\n# Log-transform the Intensity of the Kime surface (to make a better-looking surface plot, not a big deal)\nmag_sine_z = log(sqrt( Re(sine_z)^2+ Im(sine_z)^2))\n# log-transform the magnitude to temper the kimesurface amplitude\nphase_sine_z = atan2(Im(sine_z), Re(sine_z))\nsine_z_new = mag_sine_z * exp(1i*phase_sine_z)\n\n\n# draw the surface whose heigh are based on real, imaginary, \n# magnitude and phase of the both results respectively\n# the two kinds of result are from closed-formed LT and discrete LT of sine\nplot_ly(hoverinfo=\"none\", showscale = FALSE)%>%\n  add_trace(z=Re(sine_z_new)-0.5, type=\"surface\", surfacecolor=phase_sine_z)  %>%\n  add_trace(z = Re(z2_grid), type=\"surface\", opacity=0.7, surfacecolor=Im(z2_grid) )%>%\n  layout(title = \n  \"Kime-Surface, LT(sin()), Height=Re(LT(sin())), Color=Re(LT(sin())) \\n Contrast Exact (Continuous) vs. \n         Approximate (Discrete) Laplace Transform\", showlegend = FALSE)\n\nplot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n  add_trace(z=Im(sine_z_new)-0.5, type=\"surface\")  %>%\n  add_trace(z = Im(z2_grid), type=\"surface\", opacity=0.7)%>%\n  layout(title = \n  \"Kime-Surface, LT(sin()), Height=Im(LT(sin())) \\n Contrast Exact (Continuous) vs. \n         Approximate (Discrete) Laplace Transform\", showlegend = FALSE)\n\nmag_sine_z_new = sqrt(Re(sine_z_new)^2 + Im(sine_z_new)^2)\nmag_z2_grid = sqrt( Re(z2_grid)^2+ Im(z2_grid)^2)\nplot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n  add_trace(z = mag_sine_z_new-0.5, type=\"surface\") %>%\n  add_trace(z = mag_z2_grid, type=\"surface\", opacity=0.7) %>%\n  layout(title = \n  \"Kime-Surface, LT(sin()), Height=Magnitude(LT(sin())) \\n Contrast Exact (Continuous) vs. \n         Approximate (Discrete) Laplace Transform\", showlegend = FALSE)\n\nphase_sine_z_new = atan2(Im(sine_z_new), Re(sine_z_new))\nphase_z2_grid = atan2(Im(z2_grid), Re(z2_grid))\nplot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n  add_trace(z = phase_sine_z_new-0.5, type=\"surface\") %>%\n  add_trace(z = phase_z2_grid, type=\"surface\", opacity=0.7) %>%\n  layout(title = \n  \"Kime-Surface, LT(sin()), Height=Phase(LT(sin())) \\n Contrast Exact (Continuous) vs. \n         Approximate (Discrete) Laplace Transform\", showlegend = FALSE)\n\nplot_ly(hoverinfo=\"none\", showscale = FALSE)%>%\n  add_trace(z=mag_sine_z_new-0.5, surfacecolor=phase_sine_z_new, type=\"surface\") %>%\n  add_trace(z=mag_z2_grid, surfacecolor=phase_z2_grid, type=\"surface\", opacity=0.7) %>%\n  layout(title = \n           \"Kime-Surface, LT(sin()), Height=Phase(LT(sin())), Color=Phase \\n Contrast Exact (Continuous) vs. \n         Approximate (Discrete) Laplace Transform\",\n         showlegend = FALSE,\n         scene = list(aspectmode = \"manual\",\n                      aspectratio = list(x=1, y=1, z=1.0),\n                      zaxis = list(range = c(-2,3))\n         )\n  )\n",
      "line_count": 71
    },
    {
      "section": "Compare the analytical and discrete Inverse Laplace Transforms",
      "code": "# Reconstruct and plot the 1D function f(t) = ILT(LT(sin(x))(z))(t) and compare to sin(t)\n\n\n################ ILT on analytic LT of sine ###########################################################\n##### Time-domail grid (regular equidistant positive real break points)\ntime_points <- seq(0+0.001, 2*pi, length.out = 160)\n\nf20 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f20[t] <- ILT(FUNCT=function(z) Kimesurface_fun(z, array_2D=sine_z_new), \n               t= time_points[t], nterms = 31L,\n               m = 1, gamma=0.5, fail_val = complex(1), msg=TRUE)\n}\n\n# interpolate f(t) to 20 samples in [0 : 2*pi]. Note that 20~2*PI^2\ntvalsn <- seq(0, pi*2, length.out = 20)\nf30 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f30[t] <- f20[ceiling(t/20)]\n}\nf40 <- smooth.spline(time_points, Re(f30), spar = 1)$y; # plot(f4)\n\n\n################ ILT on discrete LT of sine ###########################################################\n##### Time-domail grid (regular equidistant positive real break points)\ntime_points <- seq(0+0.001, 2*pi, length.out = 160)\n\nf2 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f2[t] <- ILT(FUNCT=function(z) Kimesurface_fun(z, array_2D=z2_grid), \n               t= time_points[t], nterms = 31L,\n               m = 1, gamma=0.5, fail_val = complex(1), msg=TRUE)\n}\n\n# interpolate f(t) to 20 samples in [0 : 2*pi]. Note that 20~2*PI^2\ntvalsn <- seq(0, pi*2, length.out = 20)\nf3 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f3[t] <- f2[ceiling(t/20)]\n}\nf4 <- smooth.spline(time_points, Re(f3), spar = 1)$y; # plot(f4)\n\n############## make the comparison plot ###############################################################\ntime_Intensities_ILT_df2 <- as.data.frame(cbind(Re_discrete=Re(f4), Re_analytic=Re(f40),\n                                                Sin=sin(time_points),\n                                                time_points=time_points))\nmin_range_Re_discrete <- range(Re(f4))[1]; max_range_Re_discrete <- range(Re(f4))[2]\ntime_Intensities_ILT_df2$Re_discrete <- time_Intensities_ILT_df2$Re_discrete/(8*max_range_Re_discrete/9)\nmin_range_Re_analytic <- range(Re(f40))[1]; max_range_Re_analytic <- range(Re(f40))[2]\ntime_Intensities_ILT_df2$Re_analytic <- time_Intensities_ILT_df2$Re_analytic/(8*max_range_Re_analytic/9)\n\nggplot(time_Intensities_ILT_df2, aes(x=time_points))+\n  geom_line(aes(y=Re_discrete, color=\"Smooth Reconstruction of Discrete LT\"), lwd=1, lty=\"dashed\") +\n  geom_line(aes(y=Re_analytic, color=\"Analytic Reconstruction of Analytic LT\"), lwd=2,lty=\"dotted\") +\n  geom_line(aes(y = Sin, color=\"Original Sin\"), lwd=2) + \n  scale_color_manual(name=\"Index\",\n                     values = c(\"Smooth Reconstruction of Discrete LT\"=\"#F8766D\", \n                                \"Analytic Reconstruction of Analytic LT\"=\"#00BA38\", \n                                \"Original Sin\"=\"#619CFF\"))+\n  labs(title = \"Comparison among f(t)=sin(t), SplineSmooth(ILT(LT(sin)))(t), \\n\n       and Analytic ILT(LT(sin))(t); Range [0 : 2Pi]\") +\n  xlab(\"Time\") + ylab(\"Function Intensity\") +\n  theme(legend.title = element_text(size=14, color = \"black\", face=\"bold\"),\n        legend.position = \"top\",\n        panel.grid.minor.y = element_blank(),\n        panel.grid.major.y = element_blank(),\n        plot.title = element_text(hjust = 0.5),\n        plot.subtitle = element_text(hjust = 0.5))\n",
      "line_count": 69
    },
    {
      "section": "fMRI example",
      "code": "library(EBImage)\nlibrary(brainR)\n# library(RNifti)\nlibrary(spatstat) \n\nfMRIURL <- \"http://socr.umich.edu/HTML5/BrainViewer/data/fMRI_FilteredData_4D.nii.gz\"\nfMRIFile <- file.path(tempdir(), \"fMRI_FilteredData_4D.nii.gz\")\ndownload.file(fMRIURL, dest=fMRIFile, quiet=TRUE)\nfMRIVolume <- readNIfTI(fMRIFile, reorient=FALSE)\n# dimensions: 64 x 64 x 21 x 180 ; 4mm x 4mm x 6mm x 3 sec \n\nfMRIVolDims <- dim(fMRIVolume); fMRIVolDims\n# time_dim <- fMRIVolDims[4]; time_dim ## 180\n\n# 2. extract the time-corse of 1D mid-axial slice (3D) hypervolume\nxA_fMRI_1D_x20_y20_z11 <- fMRIVolume[20, 20, 11, ]; # length(xA_fMRI_1D_x20_y20_z11)   #  180\n# hist(xA_fMRI_1D_x20_y20_z11)\n\n# Now, combine your two 1D timeseries into one dataframe for joint hist plotting as densities.  \n# First make a new column in each that will be \n# a variable to identify where they came from later.\ntimes <- c(1:180)\n# Smooth noisy f(t)=fMRI\nf <- array(complex(1), dim = length(times)); # length(f)\nf <- smooth.spline(times, xA_fMRI_1D_x20_y20_z11, df = 10)$y # smoth f (fMRI)\n\n# Construct DF for ggplot\nxA_df <- as.data.frame(cbind(times, xA_fMRI_1D_x20_y20_z11, f))\ncolnames(xA_df) <- c(\"time\", \"xA\", \"smooth\")\n\nlibrary(ggplot2)\nggplot(xA_df, aes(x=times)) + \n  geom_point(aes(y = scale(xA)), colour = \"darkred\", size = 3)+\n  geom_line(aes(y = scale(xA)), color=\"steelblue\", lty=1, lwd=1)+\n  geom_line(aes(y = scale(smooth)), color = \"green\", lwd=2) +  ### , lty=\"dashed\") +\n  ggtitle(\"Original fMRI Time-series f(t) and Smoothed curve\") +\n  xlab(\"Time\") + ylab(\"fMRI Image Intensities (f and f')\") +\n  scale_color_manual(name=\"Index\",labels=c(\"Real\", \"Imaginary\"),\n                     values = c(\"Re\"=\"darkred\", \"Im\"=\"steelblue\"))+\n  theme_grey(base_size = 16) +\n  theme(legend.title = element_text(size=14, color = \"salmon\", face=\"bold\"),\n        legend.position=\"top\",\n        axis.text.x = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank())",
      "line_count": 45
    },
    {
      "section": "fMRI example",
      "code": "time_points <- seq(0+0.001, 2*pi, length.out = 180)\n\nf <- array(complex(1), dim = length(time_points)); # length(f)\n# Instead of using the extremely noisy fMRI data, avoid integration problmes, \n# smooth \"f\" and use the **smooth version, f**\nf <- smooth.spline(ceiling((180*time_points)/(2*pi)), xA_fMRI_1D_x20_y20_z11, df = 10)$y # smoth f (fMRI)\n\n# Define the f(t)=smooth(fMRI)(t) signal as a function of real time 0<t<=2*pi\nf_funct <- function(t) {\n  # f <- match.fun(f) # input R-valued FUNCT should be interpreted as f(t)=fMRI(t) time-series function\n  if (t < 0+0.001 || t > 2*pi) {  return ( 0 ) # sprintf(\"Out of Range ...\")\n  } else {\n    return ( f[ceiling((180*t)/(2*pi))] )\n  }\n}\n\n# Evaluate the LT at z, F(z)=LT(f)(z) \nz= 1+1i; LT(f_funct, z)  # Complex-domain value\n\n\n######################## Display the actual kimesurface: F(z)\n# range_limit = 2\n# x2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n#   # drop the first row to avoid real part value of 0\n# y2 = seq(from = 0, to = range_limit, length.out = range_limit*25)[2:50]\n#   # drop the first column to to avoid imaginary part value of 0\n# \n# # Recompute the LT(sin) discretized on lower-res grid\n# z2_grid = array(dim=c(length(x2), length(y2)))# x2 %o% y2\n\n# x2 <- seq(from = -2, to = 2, length.out = 200)\n# y2 <- seq(from = -2, to = 2, length.out = 200)\n# z2_grid = array(complex(), dim=c(length(x2), length(y2)))\n\ncl <- makeCluster(ncor)\nregisterDoParallel(cl)\nF = list()\nfor (i in 1:length(x2) ){\n  F[[i]] = \n    foreach(j = 1:length(y2),\n            .export='cubintegrate', \n            .packages='cubature') %dopar% {\n      F_result = LT(f_funct, complex(real=x2[i], imaginary = y2[j]))\n      mag = log(sqrt( Re(F_result)^2+ Im(F_result)^2))  \n      # log-transform the magnitude to temper the kimesurface amplitude\n      phase = atan2(Im(F_result), Re(F_result))\n      mag * exp(1i*phase)#z2_grid[i,j] = \n    }\n}\n  \nstopCluster(cl)\nF_vec = lapply(F, unlist)\nz2_grid = unlist(do.call(rbind, F_vec))\n\nsurf_color <- atan2(Im(z2_grid), Re(z2_grid))\ncolorscale = cbind(seq(0, 1, by=1/(length(x2) - 1)), rainbow(length(x2)))\nmagnitude <- (sqrt( Re(z2_grid)^2+ Im(z2_grid)^2))\n\np <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(z = magnitude, \n              surfacecolor=surf_color, colorscale=colorscale,   #Phase-based color\n              type = 'surface', opacity=1, visible=T) %>%\n    layout(title = \"fMRI Kime-Surface, F=LT(fMRI) \\n Height=Mag(F), Color=Phase(F)\", showlegend = FALSE,\n           scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1.0) ) ) # 1:1:1 aspect ratio\np",
      "line_count": 65
    },
    {
      "section": "fMRI example",
      "code": "##### Time-domail grid (regular equidistant positive real break points)\n# using parallel computing to speed up code\ncl <- makeCluster(ncor)\nregisterDoParallel(cl)\nf2_reuslt <-\n  foreach (t = 1:length(time_points)) %dopar% {\n    ILT(FUNCT=function(z) Kimesurface_fun(z, array_2D=z2_grid), \n        t= time_points[t], nterms = 31L,\n        m = 1, gamma=0.5, fail_val = complex(1), msg=TRUE)\n  }\nstopCluster(cl)\nf2 <- array(complex(1), dim = length(time_points))# length(f), f=ILT(F)\nf2[1:length(f2)] = unlist(f2_reuslt)\n\n# interpolate f(t) to 20 samples in [0 : 2*pi]. Note that 20~2*PI^2\ntvalsn <- seq(0, pi*2, length.out = 20)\nf3 <- array(complex(1), dim = length(time_points)); # length(f), f=ILT(F)\nfor (t in 1:length(time_points)) {\n  f3[t] <- f2[ceiling(t/20)]\n}\nf4 <- smooth.spline(time_points, Re(f3), spar = 1)$y; # plot(f4)\n\n# scale all 3 signals to get congruency ...\ntime_Intensities_ILT_df2 <- as.data.frame(cbind(Re=scale(Re(f4)), Im=scale(Re(f3)),\n                                                fMRI=scale(Re(f_funct(time_points))),\n                                                time_points=time_points))\nmin_range <- range(Re(f4))[1]; max_range <- range(Re(f4))[2]\ncolnames(time_Intensities_ILT_df2) <- \n  c(\"Smooth Reconstruction\", \"Raw Reconstruction\", \"Original fMRI\", \"time_points\")\n\ndf <- reshape2::melt(time_Intensities_ILT_df2, id.var = \"time_points\")\nggplot(df, aes(x = time_points, y = value, colour = variable)) + \n  geom_line(linetype=1, lwd=3)+\n  ylab(\"Function Intensity\") + xlab(\"Time\") +\n  theme(legend.position=\"top\")+\n  labs(title=\"Comparison between f(t)=Smooth(fMRI)(t) and Smooth(ILT(LT(fMRI)))(t);\\n Range [0 : 2Pi]\")\n",
      "line_count": 37
    }
  ]
}