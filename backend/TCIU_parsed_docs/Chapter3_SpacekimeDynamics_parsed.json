{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.241870",
    "total_sections": 5,
    "total_code_chunks": 11,
    "total_tables": 1,
    "r_libraries": [
      "extraDistr",
      "geometry",
      "gplots",
      "plotly",
      "pracma",
      "scales"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Spacekime Analytics (Time Complexity and Inferential Uncertainty)\"\nsubtitle: \"Kime Dynamics (kynamics)\"\nauthor: \"SOCR Team (Ivo Dinov)\"\ndate: \"`r format(Sys.time(),'%m/%d/%Y')`\"\noutput: \n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n      smooth_scroll: true",
      "word_count": 41
    },
    {
      "title": "Foundations of Dynamical System in Spacekime",
      "content": "## Kime-based dynamical system\n\nA spacekime dynamical (*kynamical*) system describes the evolution of a process or a phenomenon over a specific trajectory (path curve) in the kime plane. Describing a kynamical system requires (1) a specific simple (non-intersecting) parametric curve (could be closed) $\\gamma :\\mathbb{R} → \\mathbb{C}$; (2) formulation of the process that is evolving over $\\gamma$; and (3) a rule indicating how the process evolves over kime $κ=\\gamma(s)=(κ_1 (s),κ_2 (s))\\in \\mathbb{C}$, where the curve parameter $s\\in \\mathbb{R}$. The resulting kynamical system represents a mathematical model describing the dynamic kime evolution of the system. Let’s examine each of the three components of a kynamical system.\n\n## The kime trajectory\n\nThe kime curve describes the path along which we are tracking, exploring, following, or modeling the dynamical changes of the process of interest. Planar curves in $\\mathbb{C}$ can be represented in different coordinates, including Cartesian and Polar coordinates. For instance, implicit paths may be defined by *implicit* analytical equations such as $f(x,y)=0$, for some specific function $f:\\mathbb{C}→\\mathbb{R}$. Most of the time, implicit equations are not separable and do not permit explicit solutions for one of the variables. Occasionally, such equations may allow explicit solutions such as $y=g(x)$, for some specific function $g$. An alternative *parametric* representation of a plane curve in Cartesian coordinates uses $\\gamma(s)=(κ_1 (s),κ_2 (s)): \\mathbb{R}→\\mathbb{R}^2$ for some specific functions $κ_1,κ_2: \\mathbb{R}→\\mathbb{R}$. \n\nPolar coordinate representation of plane curves is another alternative that expresses the location of each point in terms of a phase-angle and a radial-distance from the origin, $\\gamma(A,ϕ)=Ae^{iϕ},A∈\\mathbb{R}^+,ϕ∈[-π,π)$.\n\n## The state space\n\nKynamical systems also require the special formulation of the process that evolves over kime trajectories. This formulation is based on a set of variables that give a complete description of the system at any particular kime point in C. These descriptor variables describe the mathematical state of the process system. A kynamical system evaluated at a specific numerical vector representing an instance observation of these variables at a particular kime, would provide a complete picture of the state of the entire system at that kime. To model a specific kynamical system, the investigator has to identify the number, type, and interactions between all variables to form the complete description for the mathematical kynamics model. These variables that completely describe the state of the kynamical system are called the state variables, and the corresponding space covering the set of all the possible values of the state variables is the state space. The state space can be discrete, consisting of isolated points, e.g., when a state variable could only take on integer values, continuous, consisting of a contiguous set of points, e.g., when a state variable could take on any real value, or mixed, when some state variables are continuous and some are discrete. The special case of continuous-and-finite-dimensional state spaces are called the phase spaces, and the finite number of state variables represents the dimension of the kynamical system. Note that state spaces can also be infinite-dimensional.\n\n## The kime evolution rule\n\nThe last component of a kynamical system requires specific rules for the kime evolution of the process. The rule must be defined to ensure that the state variables represent a holistic description of the complete state space. In other words, the state variable vector at a particular kime must completely determine the system evolution to all future states. For instance, if the kime evolution depends on some extraneous variable not included in the state space, then the rule combined with the state space would not represent the complete process kynamics. This situation would necessitate a change in the rule, reformulation of the state space, or augmentation of the necessary state variables describing the kynamical system.\n\nTypically, kime evolution rules involve either *discrete* or *continuous* kime increments (not mixed discrete-and-continuous changes). In the *case of discrete* kime increments and using parametric kime trajectory representation, then the system evolves in kime steps that can be indexed by the natural numbers $s=0,1,2,\\cdots \\in \\mathbb{N}$, and the state of the system at kime $κ(s)=(κ_1 (s),κ_2 (s))$ can be expressed as $X_κ$. In other cases, the kime evolution rule may be based on a function $κ(s+1)=f(κ(s))$, i.e., a function transforming the state of the system at one kime, $κ(s)$, into the state of the system at the next kime, $κ(s+1)$. Initial constraints or boundary conditions, such as $κ_o=κ(s=0)$ provide a recipe for determining the state at subsequent kime points, i.e., $κ_1=κ(s=1)=f(κ(0))=f(κ_o)$, $κ_2=κ(s=2)=f(κ(1))=f(f(κ_o))$, and so forth for all future states. In such discrete kynamical systems, the states along the curve $\\gamma(s)=(κ_1 (s),κ_2 (s))$ are determined by the state-transition function $f(∙)$ and the initial state $κ_o=κ(s=0)$.\n\nIn *continuous kynamical systems*, states evolve continuously, as a smooth flow, over the kime trajectory path $\\gamma(s)=(κ_1 (s),κ_2 (s))$. As the curve parameter $s\\in\\mathbb{R}$ increases (think of $s$ as the curve-length parameter), we traverse the simple curve in kime and the state $X_κ=X_{κ(s)}$ evolution at kime $κ=k(s)$ can be thought of as a point navigating through the state space. In continuous kynamical systems, the evolution rule needs to specify the motion of the point $X_κ$ along $\\gamma$ in terms of the motion velocity, e.g., $v(κ)=F(X_κ)$ at $κ=k(s)$. Assuming that the initial starting state at kime $κ_o=κ(s=0)$ is $X_o$ and we have specified a kime-trajectory $κ=\\gamma(s)=(κ_1 (s),κ_2 (s))\\in\\mathbb{C}$, then the kynamics along $\\gamma$ would represent a path through state space, $X_{κ(s)}$ starting with $X_o$.",
      "word_count": 888
    },
    {
      "title": "Examples of kynamical systems",
      "content": "## Simulation example 1\n\nLet’s define \n$$κ(s)=\\left (κ_1 (s)=\\frac{1}{2} s^2+1,\\ \\ κ_2 (s)=2+6(s-\\frac{1}{3})(s-\\frac{1}{2})(s-1) \\right )$$\nand the state\n$$X_κ^{(1)}= \\begin{pmatrix}\n  x_1 (κ) \\\\ \n  x_2 (κ) \\\\ \n  x_3 (κ)\n\\end{pmatrix}\n =\n\\begin{pmatrix}\nκ_2^2 - κ_1 κ_2^2 \\\\\nκ_1 - κ_2 \\\\\nκ_1 + κ_2 \n\\end{pmatrix},$$\n\nwhere $0≤s≤1, \\ 1<κ_1<3/2, \\ 1<κ_2<2.1$. \n\nThe graphs below show a kime plane curve $\\gamma(s)=(κ_1 (s),κ_2 (s))$ and the kime-surface $X_κ^{(1)}$. This 1D Parameterization of the kime-dynamics (kynamics) simulation example illustrates a parametric complex-plane curve and a corresponding kime-surface defined in terms of kime. \n\nNote that visualization of kime-surfaces is generally difficult and can be confused with the graphs of functions that have 2D input (domain) and a 1D output (range), which can be drawn as surfaces embedded in $\\mathbb{R}^3$. In reality, parameterized kime-functions have a different flavor as they have a 2D input $κ\\in \\mathbb{C}$ and a 3D output $X_κ^{(1)}$, which implies that plotting them requires 5D coordinates. Note that the thick blue tube curling through the kime-surface represents the kynamics along $\\gamma$ as a path through the state space, $X_κ^{(1)}$. The three thinner curves embedded in the three cardinal projection planes illustrate the silhouettes of the dynamical system.\n\n\n## Simulation example 2\n\nLet’s define $κ=(κ_1,κ_2)$ and the state \n$$X_κ^{(2)}=\\begin{pmatrix}\n  x_1 (κ) \\\\\n  x_2 (κ) \\\\\n  x_3 (κ)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n   κ_2^3 - κ_1 κ_2 \\\\\n   κ_1-κ_2 \\\\\n   κ_1+κ_2\n\\end{pmatrix},$$\n\nwhere $-2≤κ_1≤2; -1≤κ_2≤1$. Note that the pair of arguments in this example are independent.\n\n - *Input*: 2D kime-space parameterization $\\gamma (κ)=(κ_1,κ_2 )$  of a simple closed curve; rectangular parametric boundary $∂D$, where $D=\\{-2≤κ_1≤2 ∩ -1≤κ_2≤1\\}$.\t\t\n - *Output*: $X_κ^{(2)}=(κ_2^3-κ_1  κ_2,\\ κ_1+κ_2,\\ κ_1-κ_2 )'$. Left 3D display shows a checkerboard surface texture-mapping providing cues of surface curvature. The right 3D rendering depicts the embedding within the 3D manifold of the curvy-linear representation of the initial kime-region boundary as a simple-closed curve representation $\\partial D\\subset \\mathbb{C}$.\n \n \nThe graphs below show a generic 2D Parameterization of the kime-dynamics over a two-parameter complex-plane curve representing the boundary $∂D$ of a rectangle $D⊂\\mathbb{C}$ and a corresponding kime-surface. These show the corresponding 3D surface kime-parameterized by $(κ_1,κ_2 )$ and a checkerboard shading as a proxy of the surface geodesic metric. The second plot depicts the corresponding transformed boundary embedded in the manifold. Just like in the earlier single-parameter case, the thick blue tube curling through the kime-manifold represents the kynamics along \n$\\gamma=\\gamma(κ_1,κ_2 )$, as a path through the state space, $X_κ^{(2)}$. The three thinner curves embedded in the three cardinal projection planes illustrate the silhouettes of the dynamical system.\n\n\n\n## Torus example 3\n\nLet’s define $κ=(κ_1,κ_2 )$,  $-π≤κ_1<π$,  $-π≤κ_2<π$ and the state\n$$X_κ^{(3)}=\\begin{pmatrix}\n  x_1 (κ) \\\\\n  x_2 (κ) \\\\\n  x_3 (κ)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n  (6+2 \\cos(κ_2))\\cos(κ_1) \\\\\n   (6+2 \\cos(κ_2))\\sin(κ_1) \\\\\n  \\sin(κ_2)\n\\end{pmatrix}.$$\n\n - *Input*: 2D kime-space parameterization $\\gamma (κ)=(κ_1,κ_2 )$, $κ_1=s-π$,\n$κ_2=(1/10)((κ_1-1)^3+5(κ_1-1)^2+2(κ_1-5)- 8)$ representing a simple kime-curve.\t\t\n - *Output*: $X_κ^{(3)}$. 3D display shows the torus surface rendered in 3D along with the curvy-linear representation of the initial kime-curve representation.\n \nThe figures below show the  2D Torus Parametrization and the kime-dynamics over a two-parameter complex-plane curve and the corresponding 2D kime-surface. The second graph illustrates the corresponding 3D torus surface parameterized by $(κ_1,κ_2 )$ the corresponding transformed kime-curve embedded in the torus manifold. The thick red tube curling through the torus surface represents the kynamics along $\\gamma=\\gamma(κ_1,κ_2 )$, as a path through the state space, $X_κ^{(3)}$. The three thinner curves embedded in the three cardinal projection planes illustrate the silhouettes of the dynamical system.\n\n\n\n\n## fMRI example\n\n[See this TCIU Section (Kime-series/kime-surfaces reconstruction, visualization, and predictive analytics)](https://www.socr.umich.edu/TCIU/HTMLs/Chapter4_TCIU_Predictive_Analytics.html).\n\n## Kynamics example of bacteria growth and decay\n\nWe will demonstrate a kime dynamical system modeling the growth/decay of a specific population. Denote the bacteria population size at time $t$ by $f(t)$. As each bacterium divides into two bacteria, the entire population grows. Generally speaking not all bacteria would divide at the same time and some will die; hence the process is stochastic. For simplicity, assume that the kime radial growth of the bacteria colony is modeled by an exponential growth model, $f(t)=A_o a^t$, where $a > 1$ is the (growth) parameter and the constant $A_o$ represents the initial starting population at $t=0$.\n\nThe overall kynamic growth or decay will be modeled by a bivariate joint distribution that depends on time $t$ and the random kime-phase $\\phi \\sim \\Phi[-\\pi, \\pi)$, for some symmetric finitely supported kime-phase distribution $\\Phi$. For a fixed time $t$, the bacteria population size is controlled by the marginal phase function \n$$g(\\phi)=\\left ( \\frac{1}{2a}\\right )^{\\frac{\\phi}{\\pi}}:[-\\pi, \\pi) \\to \\left [ \\frac{1}{2a}, 2a \\right ].$$\nNow that we have the individual marginal distributions for the kime-magnitude (time) and the kime-phase, we can formulate the joint distribution for bacteria growth with respect to complex-time (kime).\n\n \n### Multivariate Joint Probability Distribution Copula Modeling\n\nIn special cases where the components $\\{X_i\\}$ are independent, ${{\\bf{X}}=\\{X_1,X_2,\\cdots,X_n\\}}$, computing the joint multivariate distribution involves simply the multiplication of the individual marginal probability distributions, $f_{X_i}(x_i)$, i.e., $f_{{\\bf{X}}}({\\bf{x}})=\\prod_{i=1}^n{f_{X_i}(x_i)}$. \n\nHowever, in general, there are intricate inter-dependencies between variables that need to be accounted for when computing the joint probability distribution $f_{{\\bf{X}}}({\\bf{x}})$ from the corresponding marginal univariate distribution models, $f_{X_i}(x_i)$. There are alternative strategies to express the joint probability distribution in terms of the marginals. A common approach requires *linking* the marginal distributions via connecting **copula function models**. Copula functions enable the formulation of multivariate probability distributions in terms of a set of given univariate marginal densities subject to some interdependence. \n\nFor a pair of density functions, $f_X (x)$ and $f_Y (y)$, and their corresponding cumulative probability distribution functions, $F_X (x)$ and $F_Y (y)$, the joint bivariate cumulative distribution function model, $F_{XY} (x,y)$ can be expressed via a distribution copula $C(∙,∙)$ function. Similarly, the bivariate copula density function model, $f_{XY} (x,y)$ can be explicated in terms of some appropriate probability density copula function, $c(∙,∙)$: \n\n$$F_{XY} (x,y)=F_X (x)\\times F_Y (y)\\times C(F_X (x),F_Y (y)),$$\t\n$$f_{XY} (x,y)=f_X (x)\\times f_Y (y)\\times c(f_X (x),f_Y (y)).$$\t\n\nSpecifying different copula function models yields certain types of joint probability distribution reconstructions. Some copula methods are only applicable to the continuous distributions; others are only limited to certain ranges. Let's consider three alternative copula models.\n\n * The [Farlie–Gumbel–Morgenstern (FGM) copula](https://en.wikipedia.org/wiki/Copula_(probability_theory)#List_of_copula_density_functions_and_applications). For a given constant $K$, the FGM model is commonly used for the bivariate normal cases:\n\n$$C_{XY}^{FGM} (x,y)= 1+K[1-2\\times F_X(x)][1-2\\times F_Y(y)].$$\n\n * The [Exponential copula](https://en.wikipedia.org/wiki/Copula_(probability_theory)#List_of_copula_density_functions_and_applications) represents an alternative copula model type that is more stable with departures from normality of the marginal distributions:\n\n$$C_{XY}^{Exp} (x,y)=\\frac{1}{1-ρ} \\times \\exp \\left ( \\frac{ρ[\\ln⁡(1-F_X (x))+ \\ln(1-F_Y(y))]}{1-ρ} \\right ).$$\n\n * The (bivariate) [Gaussian copula](https://en.wikipedia.org/wiki/Copula_(probability_theory)#List_of_copula_density_functions_and_applications) is an alternative which provides stable, consistent and reasonable estimates of the joint distribution model.\n\n$$C_{XY}^{Gauss} (x,y)=\\frac{1}{\\sqrt{1-ρ^2}} \\times \\exp \\left (-\\frac{ρ^2 (a^2+b^2 )-2abρ}{2(1-ρ^2 )} \\right ),$$\nwhere the pairwise correlation $-1 < \\rho < 1$ and\n\n$$a(x)= \\sqrt{2}\\times erf^{-1} (2\\times F_X (x)-1),$$\n$$b(y)= \\sqrt{2}\\times erf^{-1} (2\\times F_Y (y)-1),$$\nand the *error function* is\n$$erf(s)= \\frac{2}{\\sqrt{\\pi}}\\int_{0}^{\\infty}{e^{-t^2}dt}.$$    \n\n\nSimilarly for the [copula blend of the pair of marginal density functions](https://en.wikipedia.org/wiki/Copula_(probability_theory)#Mathematical_derivation_of_copula_density_function):\n\n$$f_{XY}(x,y) = {\\partial^2 F_{XY}(x,y) \\over\\partial x\\,\\partial y }= {\\partial^2 C(F_X(x),F_Y(y)) \\over\\partial x\\,\\partial y} =\\\\\n{\\partial^2 C(u,v) \\over\\partial u\\,\\partial v} \\times {\\partial F_X(x) \\over\\partial x} \\times {\\partial F_Y(y) \\over\\partial y} =\nc(u,v) f_X(x) f_Y(y)  \\\\ \\Longrightarrow \n\\frac{f_{XY}(x,y)}{f_X(x) f_Y(y) } =  c(u,v).$$\n\n\n### Kynamic Modeling of Bacterial Growth using Gaussian Copula\n\nLet's now return to the kime dynamical system of bacteria growth/decay of a specific bio-population. Recall that for some (growth) parameter $a > 1$, the kime radial growth of the bacteria colony is modeled by an exponential function $f(t)=A_o a^t$. The kime-phase population change can be modeled as a stochastic process, $\\phi \\sim \\Phi[-\\pi, \\pi)$, for some symmetric kime-phase distribution, $\\Phi$. Let's assume for a fixed time point, $t$, the population size kynamics in phase-space is controlled by the function \n$$g(\\phi)=\\left ( \\frac{1}{2a}\\right )^{\\frac{\\phi}{\\pi}}:[-\\pi, \\pi) \\to \\left [ \\frac{1}{2a}, 2a \\right ].$$\nNote that the effect of this phase-model function is random ranging from shrinking by half to doubling the population. Of course, this phase-space dynamics corresponds to a fixed kime-magnitude (time) and depends on the phase distribution $\\Phi[-\\pi, \\pi)$.\n\nTherefore, the kynamics of the bacteria population can be expressed via a (Gaussian) copula:\n\n$$F(t,\\phi)= f(t)\\ g(\\phi)\\ C_{T \\Phi}^{Gauss} (t,\\phi) \\Longrightarrow$$\n$$F(t,\\phi)= \n\\underbrace{A_o a^t}_{f(t)} \\times \n\\underbrace{\\left ( \\frac{1}{2a}\\right )^{\\frac{\\phi}{\\pi}}}_{g(\\phi)} \\times\n\\underbrace{\\frac{1}{\\sqrt{1-ρ^2}} \\times \\exp \\left (-\\frac{ρ^2 (a^2+b^2 )-2abρ)}{2(1-ρ^2 )} \\right )}_{\\text{Gaussian copula}}.$$\n\nWe can now illustrate alternative trajectories of the dynamics of the bacteria population:\n\n - Classical Time Dynamics: $\\phi=0$.\n - Path Kynamics over curves $\\gamma:\\mathbb{R}\\to \\mathbb{C}$.\n - Full kime-dynamics as kime-surfaces over the entire complex time domain.\n\nLet's examine each of these three progressively more complex models, starting with the classical time dynamics: $\\phi=0$.\n\nThe interactive plot below shows the shapes of the main model functions: $f(s)$, $g(\\phi)$, $C_{S \\Phi}^{Gauss} (s,\\phi)$, and $F(s,\\phi)$, over time $s\\sim S$ and kime-phase $\\phi\\sim\\Phi$. As the radial growth is exponential, we display the logarithm of the joint distribution, $\\ln(F(s,\\phi))$, which appears linear in this plot.\n\n\nNext we can display the raw and smoothed versions of the joint distribution of bacteria growth in kime as flat 2D images.\n\n\nThe next plot may be somewhat counter-intuitive, as it intentionally renders the joint distribution in *Cartesian coordinates*, $\\ln(F(s,\\phi))$, instead of poloar coordinates. However, it shows the individual marginal density dynamics over time $s$ (steady growth) and over kime-phase $\\phi$ (stochastic). The surface display also includes overlays of a pair of canonical curves corresponding to time-dynamics for a fixed phase $\\phi=0$ (orange), and phase-dynamics for a fixed time $s=s(t=50)=5$ (green).\n\n\n2D image representations of the full kynamics are not particularly useful, other than illustrating the natural polar representation of complex-time in terms of radial time and angular phase.\n\n\nThe ultimate kime-surface representation of the bacteria kynamics in kime can be visualized as a raw (not very useful) or a (heavily) smoothed (more intuitive) surface.\n\n\nNow let's superimpose the canonical *time* and *phase* curves. The *canonical time curve* represents one typical instantiation of the observed temporal process (for a fixed phase, e.g., $\\phi=0$). The *canonical phase curve* depicts repeated IID random sampling, in a controlled experiment, for one fixed time point, e.g., $time=7$, where different phase arguments correspond to independent sampling instances of the bacteria population at that time.",
      "word_count": 1670
    },
    {
      "title": "Symmetries, Generators and Operators",
      "content": "## Symmetry\n\nSymmetry relates to the action of various transformations (e.g., linear operators), which plays a key role in physics and quantum mechanics. The identity transformation $I$ on a space $V$ is a mapping $I:V\\to V$ that changes nothing\nat all, $I(v)=v,\\ \\forall v\\in V$. Heuristically, symmetry can be explained as a transformation that leaves the object unchanged, e.g., you can't tell that a circle in the plane, or a perfect ball in 3D, is rotated as these have angular symmetries. On the other hand, a square in 2D, or a cube in 3D, have very specific rotational symmetries (related to multiples of $90^o$ spherical coordinate rotations).\n\n### Groups\n\nА symmetry transformation leaves the object of interest unchanged. Group theory is important for representing, modeling, and computing symmetries. А group, $G$, is а set of elements (e.g., transformations) along with an group-operation\n(element product, e.g., rotation composition) subject to some group axioms:\n\n - Closure: for each pair of elements $a,b\\in G$, $a\\cdot b \\in G$,\n - Associativity: $\\forall a,b,c\\in G$, $(a\\cdot b)\\cdot c=a\\cdot (b\\cdot c)$,\n - Identity element: $\\exists! I \\in G$, such that $\\forall a \\in G$, $I\\cdot a=a \\cdot I = a$,\n - Inverse element: $\\forall a \\in G$,  $\\exists a^{−1}\\in G$, such that $a^{-1}\\cdot a= a\\cdot a^{-1} =I$ (identity element).\n\nNote that there are *continuous* symmetries, such as rotations of а 3D ball, and a *discrete* symmetries, such mirror-imaging and integer rotations by $90^o$ for a 3D cube. A special property of continuous symmetries makes them especially important - they have elements that approximate arbitrarily close to the identity element $I$. For instance, all rotational symmetries of а perfect 3D Ball. We can get as close and precise to an identity rotation, $I=0^o$, of a 3D ball, by small but non-trivial rotations $I\\approx \\epsilon 1^o$, where $\\epsilon\\to 0^+$. This is not the case for discrete symmetries, e.g., thе set rotational transformations that leave а 2D square unchanged (*invariant*) include the 4 rotations by $0^o,90^0, 180^o, 270^o$, along with mirror-imaging. \n\n### Infinitesimal transformations and generators\n\nA group element $g\\in G$ is close to the identity $I$ when $g(\\epsilon) = I + \\epsilon \\mathcal{G}$, where $\\epsilon >0$ and $\\mathcal{G}$ is a *generator*. These group elements represent *infinitesimal transformations* and in isolation, they change very little the objects they act on. However, repeating the application of an infinitesimal transformation multiple times would represent another element in the group \n$$g^n(\\epsilon)=\\underbrace{g(\\epsilon)\\cdot g(\\epsilon)\\cdot \\ ...\\  \\cdot g(\\epsilon)}_{n} = (I + \\epsilon \\mathcal{G})^n,$$\nwhose effect may be much more pronounced. For instance, repeating a tiny rotation several times (in the same direction) results in a *large* rotation.\n\nSUppose we are given some fixed finite transformation parameter, $\\theta$, e.g., $\\theta= 55^o$, then we can choose a large $n\\in \\mathbb{N}$ so that $\\epsilon = \\frac{\\theta}{n}\\to 0^+$. \n\nRecalling the definition of the Euler number $e$ and the corresponding exponential function, $e^x$, we have:\n\n$$h(\\theta) =\\lim_{n\\to\\infty} {\\left (I+\\underbrace{\\frac{\\theta}{n}}_{\\epsilon}\\mathcal{G}\\right )^n} \\equiv e^{\\theta\\mathcal{G}}.$$\n\nТhе *generator* $\\mathcal{G}$ effectively creates in the limit the new finite transformation $h\\in G$. \n\nWe will examine 3 types of generators:\n\n - *Spatial translation*: $\\mathcal{G}_x^{trans}=\\partial_x \\equiv \\frac{\\partial}{\\partial x}$,\n - *Temporal translation* (kime-magnitude): $\\mathcal{G}_t^{trans}=\\partial_t \\equiv \\frac{\\partial}{\\partial t}$, and\n - *Phase translation* (kime-phase): $\\mathcal{G}_{\\phi}^{trans}=\\partial_{\\phi} \\equiv \\frac{\\partial}{\\partial \\phi}$.\n \nLet's start with а function \n$$f=f\\left (\\overbrace{x}^{space}, \\overbrace{\\underbrace{\\kappa}_{(t,\\phi)}}^{kime}\\right )=f(x,t,\\phi).$$\n\n### Spatial translation\n\nWe aim to prove that to generate а *spatial translation* $T$, such that $Т f(x,t,\\phi) = f(x+a,t,\\phi)$, we need to use the *spatial translation generator* \n$G_x^{trans}=\\partial_x$. Given any translation parameter $\\theta\\equiv a\\in \\mathbb{R}$, we can use the Taylor series expansion of the exponential function, $e^x = \\sum_{n=0}^{\\infty}{\\frac{x^n}{n!}}$, to expand right hand size for $\\mathcal{G}\\equiv \\mathcal{G}_x^{trans}$:\n\n$$e^{\\theta\\mathcal{G}_x^{trans}} f(x,t,\\phi) \\equiv e^{a\\mathcal{G}_x^{trans}} f(x,t,\\phi)=$$\n\n$$\n\\left ( 1 + a\\mathcal{G}_x^{trans} +\\frac{a^2}{2!}(\\mathcal{G}_x^{trans})^2 + \\cdots \n\\frac{a^k}{k!}(\\mathcal{G}_x^{trans})^k + \\cdots \\right ) f(x,t,\\phi)=\n$$\n\n$$\\left ( 1 + a\\partial_x +\\frac{a^2}{2!}(\\partial_x)^2 + \\cdots \n\\frac{a^k}{k!}(\\partial_x)^k + \\cdots \\right ) f(x,t,\\phi)\\equiv\nf(x + a,t,\\phi).$$\n\nThe last equation is just the Taylor expansion of $f$ at $(x+a,t,\\phi)$. Note that $(\\partial_x)^k f(x,t,\\phi)\\equiv \\frac{\\partial^k}{\\partial x^k}f$ is the *rate of change* of $f(x,t,\\phi)$ in the $x$-direction.\n\nHence, multiplying this rate of change by a constant distance parameter $a$ propagates the function forward in the $x$-direction. To a first (linear) approximation, the total corresponding change\nof $f(x,t,\\phi)$ is $a \\partial_x f(x,t,\\phi)$ and the value of $f$ at the location $(x+a,t,\\phi)$ is (approximately) $f(x,t,\\phi)+a \\partial_x f(x,t,\\phi)$.\n\n\n### Temporal translation\n\nSimilarly, to generate а *temporal translation* $Т f(x,t,\\phi) = f(x,t+b,\\phi)$, we need to use the *temporal translation generator* \n$\\mathcal{G}_t^{trans}=\\partial_t$. For a translation parameter $b\\in \\mathbb{R}^+$ we expand right hand size for $\\mathcal{G}\\equiv \\mathcal{G}_t^{trans}$:\n\n$$e^{b\\mathcal{G}_t^{trans}}=\n\\left ( 1 + b\\mathcal{G}_t^{trans} +\\frac{b^2}{2!}(\\mathcal{G}_t^{trans})^2 + \\cdots \n\\frac{b^k}{k!}(\\mathcal{G}_t^{trans})^k + \\cdots \\right ) f(x,t,\\phi)=\n$$\n$$\\left ( 1 + b\\partial_t +\\frac{b^2}{2!}(\\partial_t)^2 + \\cdots \n\\frac{b^k}{k!}(\\partial_t)^k + \\cdots \\right ) f(x,t,\\phi)\\equiv\nf(x ,t+b,\\phi).\n$$\n\nThe last equation is the Taylor expansion of $f$ at $(x,t+b,\\phi)$. Note that $(\\partial_t)^k f(x,t,\\phi)\\equiv \\frac{\\partial^k}{\\partial t^k}f$ is the *rate of change* of $f(x,t,\\phi)$ in *time* (kime-magnitude).\n\nMultiplying this rate of change by a constant time increment $b$ propagates the function forward in time and an approximation to the total corresponding change\nof $f(x,t,\\phi)$ is $b \\partial_t f(x,t,\\phi)$.\n\n### Kime-Phase translation\n\nFinally, we generate а *kime (phase) translation* $Т f(x,t,\\phi) = f(x,t,\\phi +c)$ using the *phase translation generator* \n$\\mathcal{G}_{\\phi}^{trans}=\\partial_{\\phi}$. For a fixed phase-translation parameter $c\\in [\\pi,\\pi)$, we expand right hand size for $\\mathcal{G}\\equiv \\mathcal{G}_{\\phi}^{trans}$:\n\n$$e^{c\\mathcal{G}_{\\phi}^{trans}}=\n\\left ( 1 + c\\mathcal{G}_{\\phi}^{trans} +\\frac{c^2}{2!}(\\mathcal{G}_{\\phi}^{trans})^2 + \\cdots \n\\frac{c^k}{k!}(\\mathcal{G}_{\\phi}^{trans})^k + \\cdots \\right ) f(x,t,\\phi)=\n$$\n$$\\left ( 1 + c\\partial_{\\phi} +\\frac{c^2}{2!}(\\partial_{\\phi})^2 + \\cdots \n\\frac{c^k}{k!}(\\partial_{\\phi})^k + \\cdots \\right ) f(x,t,\\phi)\\equiv\nf(x ,t,\\phi +c).\n$$\n\nAgain, the last equation is just the Taylor expansion of $f$ at $(x,t,\\phi +c)$ and $(\\partial_{\\phi})^k f(x,t,\\phi)\\equiv \\frac{\\partial^k}{\\partial {\\phi}^k}f$ is the *rate of change* of $f(x,t,\\phi)$ in kime-phase direction.\n\nSummarizing, multiplying this rate of change by a constant phase increment $c$ propagates the function forward in the kime-phase direction and an approximation to the total corresponding change\nof $f(x,t,\\phi)$ is $c \\partial_{\\phi} f(x,t,\\phi)$.\n\nIn essence, we describe all continuous symmetries by acting iteratively, with infinitesimal transformations corresponding to a specific generator, $\\mathcal{G}_{(\\cdot)}^{trans}$, on the wavefunction, $f(x,t,\\phi)$.\n\n## Operators\n\n### Bra-Kets\n\nThe *state vector*, **ket**, has the mathematical notation $|\\Psi\\rangle$, which represents all information (tractable, measurable quantities we can observe) about a system. For each observable quantity (e.g., energy, momentum, position, spin, etc.), every different possible state of the system corresponds to а\ndifferent ket $\\{\\ |\\Psi_{\\alpha}\\rangle\\ \\}_{\\alpha}$.\nAs an example, an electron rotating around an atomic nucleus can have different observable *energies*; from the ground state with the lowest energy, $|\\Psi_1^e\\rangle$, to excited higher-energy states, $|\\Psi_2^e\\rangle$, $|\\Psi_3^e\\rangle$, etc. The same electron has observable *positions* which can be tracked by $\\{\\ |\\Psi_{\\alpha}^x\\rangle\\ \\}$; from initial position at $x= О$, $|\\Psi_{0}^x\\rangle$, to other positions such as $x= 0.123$, $|\\Psi_{0.123}^x\\rangle$ and $x= 5$, $|\\Psi_{5}^x\\rangle$. Note that some observable quantities may have discrete, finite, countably, or uncountably many possible states.\n\nThe *bra* is the *Hermitian conjugate* (equivalent to transposed, $(\\cdot)^t$, complex conjugate, $(\\cdot)^*$) of the *ket* \n$\\langle \\Phi | \\equiv |\\Phi\\rangle^{\\dagger} \\equiv (|\\Phi\\rangle^{*})^{t}$.\n\nThe *ket* notation allows us to extract/compute/represent specific information about the state of the system. As an example, consider the system *momentum* (product of mass and velocity, $p=m\\ v$) of our system. The momentum states can be expressed as eigenvalues of the momentum operator and the momentum eigenvector kets\n\n$$\\overbrace{\\underbrace{\\hat{p}}_{\\text{operator}}}^{\\text{momentum}}|\\Psi^{p}\\rangle = \\underbrace{p}_{\\mathbb{R}\\ \\text{eigenvalue}} \n\\overbrace{|\\Psi^{p}\\rangle}^{\\text{eigenvector}}$$\nAs the problem context identifies the observable quantity we are interested in, going forward, we will be suppressing the superindex and writing these as $\\hat{p}|\\Psi\\rangle = {p}|\\Psi\\rangle$.\n\nThe corresponding momenta at momentum state configurations $|\\Psi_1\\rangle$ and $|\\Psi_2\\rangle$ are $p_1,p_2\\in \\mathbb{R}$, i.e., the two possible observable momenta, $\\hat{p}|\\Psi_1\\rangle = {p_1}|\\Psi_1\\rangle$ and\n$\\hat{p}|\\Psi_2\\rangle = {p_2}|\\Psi_2\\rangle$. \n\nIn practice, due to Heisenberg uncertainty, the system\nis rarely in a single *base state*. Rather it's mostly in superposition (linear combinations) of *base states*. The intrinsic system uncertainty suggests that the momentum changes every time we measure\nposition and vice-versa, the position changes each time we measure the momentum. This implies that the order of measuring certain quantities matters; just like washing and drying our hands come in a natural order (the reverse order yields a different outcome). Specifically,\n\n$$\\hat{p}\\hat{x} |\\Psi \\rangle - \\hat{x}\\hat{p} |\\Psi \\rangle =\\overbrace{\\underbrace{(\\hat{p}\\hat{x}-\\hat{x}\\hat{p})}_{[\\hat{x},\\hat{p}]}}^{\\text {commutator}}|\\Psi \\rangle  =$$\n$$-i\\hbar\\partial_x \\hat{x}|\\Psi \\rangle+ \\hat{x}i\\hbar\\partial_x |\\Psi \\rangle =\n\\underbrace{-(i\\hbar\\partial_x \\hat{x})|\\Psi \\rangle\n-\\hat{x}(i\\hbar\\partial_x |\\Psi \\rangle )}_{\\text{product diff rule}}\n+ \\hat{x}i\\hbar\\partial_x |\\Psi \\rangle\n=$$\n$$-i\\hbar|\\Psi \\rangle\n\\not=0.$$\n\nNote that in principle, $\\hat{p}_i\\hat{x}_j |\\Psi \\rangle =-i\\hbar\\delta_{i,j}|\\Psi \\rangle \\not=0$ , as $i,j\\in\\{1,2,3\\}$. Also, the rate of change of the system with respect to space $x$, time $t$ or kime-phase $\\phi$ is defined as $\\partial_{\\alpha}|\\Psi \\rangle$, where $\\alpha\\in\\{x,t,\\phi\\}$.\n\n### Schrodinger equation\n\nAs we showed above, $\\partial_t$ is a multiple of the quantum energy operator $\\hat{E}\\equiv -i\\hbar\\partial_t$, i.e., $\\hat{E}|\\Psi \\rangle \\equiv -i\\hbar\\partial_t |\\Psi \\rangle =E|\\Psi \\rangle.$\n\nTotal energy in classical mechanics is the total sum of\n*kinetic energy* $T$ and *potential energy* $V$, $E = T + V$. The kinetic energy is $T= \\frac{1}{2}mv^2 =\\frac{p^2}{2m}$, where the momentum $р = mv$, $m$ is the mass, and $v$ is the velocity. By replacing the momentum $p$ by the momentum operator, $\\hat{p}=-i\\hbar\\partial_t$,we transform the classical kinetic energy into а quantum operator $\\hat{T}=\\frac{\\hat{p}^2}{2m}\\equiv \\frac{(-i\\hbar\\partial_t)^2}{2m}=-\\frac{\\hbar^2 \\partial_t^2}{2m}$.\n\nSimilarly, we can express the classical potential energy, which usually only depends on the spatial position $x$ (not time or kime-phase), $V = V(x)$, as an operator $\\hat{V}=V(\\hat{x})$.\n\nTo derive the [Shrodinger equation](https://en.wikipedia.org/wiki/Schr%C3%B6dinger_equation), we transform the total energy equation, $E=T+V$, to an operator equation, $\\hat{E} = \\hat{T} + \\hat{V}$. Starting with $\\hat{E}\\equiv -i\\hbar\\partial_t$, we can expand the terms as follows:\n\n$$\\hat{E}|\\Psi \\rangle \\equiv -i\\hbar\\partial_t |\\Psi \\rangle =E|\\Psi \\rangle =(\\hat{T} + \\hat{V})|\\Psi \\rangle=$$\n$$\\left (\\overbrace{\\underbrace{-\\frac{\\hbar^2 \\partial_t^2}{2m} +V(\\hat{x})}_{\\hat{H}}}^{\\text{Hamiltonian operator}}\n\\right )|\\Psi \\rangle=\n-\\frac{\\hbar^2 \\partial_t^2}{2m}|\\Psi \\rangle +V(\\hat{x})|\\Psi \\rangle .$$\n\nMany problems require solving the Schrodinger equation for a specific potential $V(x)$ under some given boundary conditions.\n\n\n### Operator moments\n\nDesigning a controlled experiment involving a system of a pair of particles we may sometimes measure a\nmomentum value $p_1$ and other times a value $p_2$. The superposition of the 2 base states is expressed as\n\n$$|\\Psi\\rangle = \\underbrace{a_1}_{\\in\\mathbb{C}}|\\Psi_1\\rangle + \\underbrace{a_2}_{\\in\\mathbb{C}}|\\Psi_2\\rangle,$$\nwhere $|a_1|^2,|a_2|^2\\in\\mathbb{R}$ represent the probability distribution (odds) of measuring momenta $p_1$ and $p_2$, respectively. In the general *discrete case*,\n\n$$|\\Psi\\rangle = \\sum_{i} {\\left ( \\underbrace{\\langle \\Psi_i | \\Psi\\rangle}_{\\text{coeff}\\ \\in\\mathbb{C}}\n\\overbrace{|\\Psi_i\\rangle}^{\\text{base}} \\right )}.$$\n\nSimilarly, in the *continuous case*, the summation transforms to integration\n$$|\\Psi\\rangle = \\int_{\\mathbb{R}} {\\left ( \\underbrace{\\langle p | \\Psi\\rangle}_{\\text{coeff}\\ \\in\\mathbb{C}}\n|p\\rangle dp \\right )}\\equiv \n\\int_{\\mathbb{R}} {\\Psi(p) |p\\rangle dp }.$$\n\nIn our simple Bernoulli experiment, the momentum operator $\\hat{p}$ acting on the momentum state $|\\Psi\\rangle$ will be expressed as a linear operator acting on this superposition:\n\n$$\\hat{p}|\\Psi\\rangle =\\hat{p}\\left ( \na_1|\\Psi_1\\rangle + a_2|\\Psi_2\\rangle \\right )=\na_1\\hat{p}|\\Psi_1\\rangle + a_2\\hat{p}|\\Psi_2\\rangle=\na_1p_1|\\Psi_1\\rangle + a_2p_2|\\Psi_2\\rangle.$$\n\nThis representation makes sense in a statistical framework. Once an observation is made, the system yields a stochastic measure of the momentum - in this case one of two possible momentum values $p_1$ or $p_2$. In general, there may be infinitely many, or even continuous, state outcomes. \n\nExtending the [notions of statistical moments](https://wiki.socr.umich.edu/index.php/AP_Statistics_Curriculum_2007_Distrib_MeanVar) (e.g., first moment is the *mean* and the second moment is the *variance*), we can define *operator moments*:\n\n - *Operator mean*: Weighted average of the possible observable momenta. For our simple momentum Bernoulli experiment, $\\langle \\hat{p}\\rangle \\equiv \\langle p\\rangle =\\underbrace{|a_1|^2}_{\\text {probability}} \\overbrace{p_1}^{\\text {momentum}} + |a_2|^2 p_2$.\n \n - *Operator variance*: Weighted average of the squared deviations of the possible observable momenta from the mean. For our simple momentum Bernoulli experiment,\n\n$$(\\Delta{p})^2\\equiv \\langle \\hat{p}^2\\rangle -\\langle \\hat{p}\\rangle^2 \\equiv \\left ( \\underbrace{|a_1|^2}_{\\text {probability}} \\overbrace{p_1^2}^{\\text {momentum}} + |a_2|^2 p_2^2 \n\\right )\n-\\left (|a_1|^2 p_1 + |a_2|^2 p_2 \\right ).$$\n\nBased on *orthonormality* assumptions, $\\langle \\Psi_i | \\Psi_j\\rangle =\\delta_{i,j}=\\left\\{ \\begin{array}{ll} 1, i=j\\\\ 0, {\\text{otherwise}} \\end{array} \\right .$, given a concrete basis $|\\Psi\\rangle$, e.g., momentum $|\\Psi^p\\rangle$ or position $|\\Psi^x\\rangle$, the operator moments are computed as follows:\n\n$$\\underbrace{\\langle\\Psi |}_{\\text{bra}} \\overbrace{\\hat{p}}^{\\text{operator}} \n\\underbrace{| \\Psi \\rangle}_{\\text{ket}} \\equiv\n(a_1^*\\langle \\Psi_1 | +a_2^*\\langle \\Psi_2 |)\n\\ \\hat{p}\\ (a_1 | \\Psi_1\\rangle +a_2 | \\Psi_2 \\rangle)=$$\n\n$$(a_1^*\\langle \\Psi_1 | +a_2^*\\langle \\Psi_2 |)\n(a_1 \\hat{p}| \\Psi_1\\rangle +a_2 \\hat{p}| \\Psi_2 \\rangle)=$$\n\n$$(a_1^*\\langle \\Psi_1 | +a_2^*\\langle \\Psi_2 |)\n(a_1 p_1| \\Psi_1\\rangle +a_2 p_2| \\Psi_2 \\rangle)=$$\n\n$$|a_1|^2 \\underbrace{\\langle \\Psi_1 | \\Psi_1\\rangle}_{\\text{1}} +\na_1^*a_2\\overbrace{\\langle \\Psi_1 | \\Psi_2\\rangle}^{0} +\na_2^*a_1\\langle \\Psi_2 | \\Psi_1\\rangle +\n|a_2|^2\\langle \\Psi_2 | \\Psi_2\\rangle=$$\n\n$$|a_1|^2 p_1 + |a_2|^2 p_2.$$",
      "word_count": 2001
    },
    {
      "title": "Curvature",
      "content": "One approach to capture the change of a function, such as a real or complex valued surface, that depends on two or more parameters is to track the curvature of the surface, which depends on the metric defining the manifold.\n\nThere are [different types of curvatures](https://en.wikipedia.org/wiki/Curvature) that capture the various properties of manifolds. Here, we will focus on surfaces (2-manifolds) and illustrate the relation between function changes with respect to kime and the [Gaussian curvature](https://en.wikipedia.org/wiki/Gaussian_curvature), which the product of the two *principal curvatures* $Κ = \\kappa_1\\times \\kappa_2$. Given a point on the surface $\\mathcal{S}=\\{(t,\\phi,f(t,\\phi))\\ | \\ t>0, -\\pi\\leq\\phi<\\pi \\}$, the surface normal vector is perpendicular (orthogonal) to the surface. The intersections of the surface and any normal plane containing the normal vector generates normal-section curves on the surface whose curvature represents the *normal curvature*. The extrema of all normal curvatures (min and max) corresponding to different normal sections lead to the principal curvatures ($\\kappa_1$ for min and $\\kappa_2$ for max). \n\n\nFor a fixed point $\\bf{p}\\in\\mathcal{S}$, the two surface principal curvatures $\\kappa_1$ and $\\kappa_2$ represent the eigenvalues of the [shape operator](https://en.wikipedia.org/wiki/Shape_operator). By tracking the min/max bending of the surface along different directions the *curvature* captures the \"change\" of the surface parameterized by kime. The Gaussian curvature of the surface at $\\bf{p}$ can also be expressed as the determinant of the [Hessian matrix](https://en.wikipedia.org/wiki/Hessian_matrix) of the second order derivatives of the implicit function $f(t,\\phi)$, or the product of the eigenvalues of the Hessian.\n\n## First and second fundamental forms\n\nGiven a surface metric $g$, the *first fundamental form* is \n\n$$\\mathbb{I}\\equiv (g_{{ij}})={\\begin{pmatrix}g_{{11}}&g_{{12}}\\\\g_{{21}}&g_{{22}}\\end{pmatrix}}={\\begin{pmatrix}E&F\\\\F&G\\end{pmatrix}},$$\nwhere the tensor components are calculated as scalar product of tangent vectors $X_1$ and $X_2$:\n\n$$g_{ij}=\\langle X_{i} | X_{j}\\rangle \\equiv X_{i}\\cdot X_{j}, \\ i,j\\in\\{1,2\\}.$$\n\nIn Cartesian $(u,v)$ or polar $(t,\\phi)$ coordinates, the (linear distance) *line element* $ds$ may be expressed in terms of the first fundamental form coefficients:\n\n$$ds^{2}=E du^{2}+2Fdu\\ dv+Gdv^{2},$$\n$$ds^2 = dt^2 + G(t,\\phi) d\\phi^2.$$\n\nThe (quadratic) *area element* is $dA = |Xu \\times Xv| du dv$ is:\n\n$$dA=|X_{u}\\times X_{v}|\\ du\\ dv={\\sqrt {\\langle X_{u}|X_{u}\\rangle \\langle X_{v}|X_{v}\\rangle -\\left\\langle X_{u}|X_{v}\\right\\rangle ^{2}}}\\,du\\,dv={\\sqrt {EG-F^{2}}}\\,du\\,dv.$$\n\nFor example, consider a parametric curve on a unitary 2D sphere parameterized (in spherical coordinates) by:\n\n$$X(u,v)={\\begin{bmatrix}\n\\cos u\\sin v\\\\\\sin u\\sin v\\\\\\cos v\\end{bmatrix}}\\equiv \n\\left (\\cos u\\sin v\\ {\\bf{i}} + \\sin u\\sin v\\ {\\bf{j}} + \\cos v \\ {\\bf{k}} \\right ) ,\\ \n0\\leq u \\lt 2\\pi,\\ 0\\leq v\\lt \\pi\\ ,$$\n\nwhere the unitary base vectors are:\n\n$$\\bf{i}={\\begin{bmatrix} 1\\\\ 0 \\\\ 0 \\end{bmatrix}},\\ \n\\bf{j}={\\begin{bmatrix} 0\\\\ 1 \\\\ 0 \\end{bmatrix}},\\ \n\\bf{k}={\\begin{bmatrix} 0\\\\ 0 \\\\ 1 \\end{bmatrix}}\\ .$$\n\nThe plot below shows the spherical surface along with several curves, including geodesics (shortest paths between two points on the manifold).\n\n\nThe coefficients of the first fundamental form are computed as inner-products of the first-order partial derivatives with respect to $u$ and $v$:\n\n$${\\begin{aligned}\n\\frac{\\partial X}{\\partial u}=X_{u}&={\\begin{bmatrix}-\\sin u\\sin v\\\\\\cos u\\sin v\\\\0\\end{bmatrix}},\\\\\n\\frac{\\partial X}{\\partial v}=X_{v}&={\\begin{bmatrix}\\cos u\\cos v\\\\\\sin u\\cos v\\\\-\\sin v\\end{bmatrix}}.\\end{aligned}}$$\n\nHence,\n\n$${\\begin{aligned}\nE&=\\langle X_{u}| X_{u}\\rangle=\\sin ^{2}v\\\\F&=\\langle X_{u} | X_{v}\\rangle=0\\\\G&=\\langle X_{v} | X_{v}\\rangle=1\\end{aligned}}.$$\n\nAnd the first fundamental form is:\n$$\\mathbb{I}\\equiv {\\begin{bmatrix}E&F\\\\F&G\\end{bmatrix}}={\\begin{bmatrix}\\sin ^{2}v&0\\\\0&1\\end{bmatrix}}.$$ \n\nFor the same general parametric surface $X(u,v)$, the *second fundamental form* $\\mathbb{II}$ is defined in terms of the linearly independent first order partial derivatives, $X_u$ and $X_v$, and the field of surface unitary normal vectors $n\\equiv \\frac{X_u \\times X_v}{||X_u \\times X_v ||}$:\n\n$$\\mathbb{II} =L\\ du^{2}+2M\\ du\\ dv + N\\ dv^{2}\\ = \n{\\begin{bmatrix}du & dv \\end{bmatrix}}\\ \n{\\begin{bmatrix}L&M\\\\M&N\\end{bmatrix}}{\\begin{bmatrix}du\\\\ dv\\end{bmatrix}}\\ ,$$\n\nwhere the three coefficients $L, M, N$ are defined at a given point represent the projections of the second partial derivatives of $X$ at that point onto the normal line to $S$:\n\n$$L=\\langle {X}_{uu} | \\mathbf {n} \\rangle \\equiv -\\langle {X}_{u} | {\\mathbf {n}}_u \\rangle \n\\quad M=\\langle X_{uv} | \\mathbf {n} \\rangle \\equiv -\\langle {X}_{u} | {\\mathbf {n}}_v \\rangle\n\\quad N=\\langle X_{vv} | \\mathbf {n} \\rangle\\ \\equiv -\\langle {X}_{v} | {\\mathbf {n}}_v \\rangle.$$\n\nThe equivalences above are true since the normal $\\mathbf {n}$ is perpendicular to the surface tangent plane containing the tangent vectors ${X}_{u},{X}_{v}$. Thus, $\\langle {X}_{u} | \\mathbf {n} \\rangle = 0 =\\langle {X}_{v} | \\mathbf {n} \\rangle$, and \n$$\\langle {X}_{uu} | \\mathbf {n} \\rangle + \\langle {X}_{u} | {\\mathbf {n}}_u \\rangle=0,$$\n$$\\langle {X}_{vv} | \\mathbf {n} \\rangle + \\langle {X}_{v} | {\\mathbf {n}}_v \\rangle=0,$$\nand\n$$\\langle {X}_{uv} | \\mathbf {n} \\rangle + \\langle {X}_{u} | {\\mathbf {n}}_v \\rangle=0.$$\n\nIn the spherical example above, $X(u,v)=(\\cos u\\sin v,\\sin u\\sin v,\\cos v)'$, $R=1$, the second order derivatives are:\n\n$${\\begin{aligned}\n\\frac{\\partial^2 X}{\\partial u^2}=X_{uu}&={\\begin{bmatrix}-\\cos u\\sin v\\\\ -\\sin u\\sin v\\\\0\\end{bmatrix}},\\\\\n\\frac{\\partial^2 X}{\\partial u \\partial v}=X_{uv}&\n={\\begin{bmatrix}-\\sin u\\cos v\\\\ -\\cos u\\cos v\\\\0\\end{bmatrix}},\\\\\n\\frac{\\partial^2 X}{\\partial v^2}=X_{vv}&={\\begin{bmatrix}-\\cos u\\sin v\\\\ -\\sin u\\sin v\\\\-\\cos v\\end{bmatrix}}.\\end{aligned}}$$\n\nFor a sphere of radius $R$, the second fundamental form is the product of $R$ times the first fundamental form, $\\mathbb{II} = R\\times \\mathbb{I}$. This is because the normal ${\\bf{n}}=\\frac{1}{R}X$, and thus, $\\frac{\\partial \\bf{n}}{\\partial u}\\equiv n_u=\\frac{1}{R} X_u$ and \n$\\frac{\\partial \\bf{n}}{\\partial v}\\equiv n_v=\\frac{1}{R} X_v$. This yields that \n$L=\\langle {X}_{uu} | \\mathbf {n} \\rangle$\n\nThus, we can compute the second fundamental form components:\n\n$$\\mathbb{II}\\equiv {\\begin{bmatrix}L&M\\\\M&N\\end{bmatrix}}=\n{\\begin{bmatrix}\n\\overbrace{\\langle {X}_{uu} | \\mathbf {n} \\rangle}^{-\\langle {X}_{u} | {\\mathbf {n}}_u \\rangle} & \n\\overbrace{\\langle {X}_{uv} | \\mathbf {n} \\rangle}^{-\\langle {X}_{u} | {\\mathbf {n}}_v \\rangle} \\\\\n\\\\\n\\underbrace{\\langle {X}_{uv} | \\mathbf {n} \\rangle}_{-\\langle {X}_{u} | {\\mathbf {n}}_v \\rangle} & \n\\underbrace{\\langle {X}_{vv} | \\mathbf {n} \\rangle}_{-\\langle {X}_{v} | {\\mathbf {n}}_v \\rangle}\n\\end{bmatrix}}\n= \\frac{1}{R} \\mathbb{I}\\equiv \n\\frac{1}{R}{\\begin{bmatrix}E&F\\\\F&G\\end{bmatrix}}=\n\\frac{1}{R}{\\begin{bmatrix}\\sin ^{2}v&0\\\\0&1\\end{bmatrix}}\n.$$ \n\nThe Gaussian curvature of a surface embedded in $\\mathbb{R}^3$ is the ratio of the determinants of the second and first fundamental forms:\n\n$$\\frac {\\det(\\mathbb {II} )}{\\det(\\mathbb {I} )}={\\frac {LN-M^{2}}{EG-F^{2}}}.$$\n\nIn the spherical example, as the radius $R=1$, the surface Gaussian curvature is constant, $\\frac {\\det(\\mathbb {II} )}{\\det(\\mathbb {I} )}= 1$.\n\nThe [Brioschi formula](https://en.wikipedia.org/wiki/Gaussian_curvature#Alternative_formulas) expresses the Gaussian curvature purely in terms of the first fundamental form:\n\n$$K={\\frac {{\\begin{vmatrix}-{\\frac {1}{2}}E_{vv}+F_{uv}-{\\frac {1}{2}}G_{uu}&{\\frac {1}{2}}E_{u}&F_{u}-{\\frac {1}{2}}E_{v}\\\\F_{v}-{\\frac {1}{2}}G_{u}&E&F\\\\{\\frac {1}{2}}G_{v}&F&G\\end{vmatrix}}-{\\begin{vmatrix}0&{\\frac {1}{2}}E_{v}&{\\frac {1}{2}}G_{u}\\\\{\\frac {1}{2}}E_{v}&E&F\\\\{\\frac {1}{2}}G_{u}&F&G\\end{vmatrix}}}{\\left(EG-F^{2}\\right)^{2}}}.$$\n\nFor any orthogonal parametrization, including polar coordinates in complex-time, the mixed term $F = 0$ and the Gaussian curvature is simplified to:\n\n$$K=-{\\frac {1}{2{\\sqrt {EG}}}}\\left({\\frac {\\partial }{\\partial u}}{\\frac {G_{u}}{\\sqrt {EG}}}+{\\frac {\\partial }{\\partial v}}{\\frac {E_{v}}{\\sqrt {EG}}}\\right) .$$\n\nIn the case of explicit surface definition via a function $z = J(x,y)$, the Gaussian curvature is:\n\n$$K={\\frac {\\langle J_{xx} | J_{yy}\\rangle -J_{xy}^{2}}{\\left(1+J_{x}^{2}+J_{y}^{2}\\right)^{2}}}.$$\n\nThis differential geometric framework allows us to represent, model, understand, track, and analyze system dynamics with respect to complex time (kime). The basic idea is that the kime-surface metric tensor and different types of curvature measures provide mechanisms to capture *change with respect to kime magnitude and kime phase*.\n\nAlso [Gauss' Theorema Egregium](https://en.wikipedia.org/wiki/Theorema_egregium) indicates that the surface Gaussian curvature can be computed by measuring length along surface geodesics via the first fundamental form and its first and second order partial derivatives. Furthermore, the Gaussian curvature is determined by the intrinsic surface metric tensor irrespective of the ambient space the surface is embedded in. Hence, the Gaussian curvature is an *intrinsic invariant* that is preserved under isometric deformations of the surface. \n\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 1220
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    code_folding: hide\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "knitr::opts_chunk$set(echo = TRUE, warings = FALSE, error = TRUE)",
      "line_count": 1
    },
    {
      "section": "Examples of kynamical systems",
      "code": "library(plotly)\n# Define curve parameter\ns <- seq(0, 1, length.out=400)\n\n# define kime functions\n# k1 <- 2*s^2 + 1\n# k2 <- 2 + 12*(s-1/3)*(s-1/2)*(s-1)\nk1 <- (1/2)*s^2 + 1\nk2 <- 2 + 6*(s-1/3)*(s-1/2)*(s-1)\n\n# Define state space X_{\\kappa}\nx <- k1^2 - k1*k2^2\ny <- k1 - k2\nz <- k1 + k2\n\ndata1 <- data.frame(x, y, z)\n\n# define axes labels\nf <- list(family = \"Courier New, monospace\", size = 18, color = \"black\")\nxlab <- list(title = \"k1\", titlefont = f)\nylab <- list(title = \"k2\", titlefont = f)\nzlab <- list(title = \"Kime-surface\", titlefont = f)\n\n# define kime-surface\nxsurf <- k1\nysurf <- k2\nz_fun <- function(x,y) { x + y }\nzsurf <- outer(xsurf, ysurf, FUN=\"z_fun\")\n\n# 2D Gamma Kime-space plot\n# k1 <- (1/2)*s^2 + 1\n# k2 <- 2 + 6*(s-1/3)*(s-1/2)*(s-1)\n# Define state space X_{\\kappa}\n# x <- k1^2 - k1*k2^2\n# y <- k1 - k2\nplot_ly(x = ~k1, y = ~k2, type = 'scatter', mode = 'lines', line = list(width = 4)) %>%\n    layout(xaxis = list(title = \"k1\", range = c(0.95, 1.55)),\n           yaxis = list(title = \"k2\", range = c(0.95, 2.05)))\n\n# 3D Kime-surface Plot\n# plot_ly(x = ~k1, y = ~k2, z = ~t(zsurf), type=\"surface\", opacity=0.7)\np <- plot_ly(data1, x = ~x, y = ~y, z = ~z, type = 'scatter3d', \n             mode = 'lines', # name=\"Kime-space curve projection on Kime-surface\",\n             line = list(width = 22, color = ~c, colorscale = list(c(0,'red'), c(1,'blue')))) %>%\n    # add kime-surface\n    add_trace(z = ~zsurf, type = 'surface', opacity=0.4) %>%\n    # trace the z-axis\n    add_trace(data1, x = 0, y =0, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color = ~c , colorscale = list(c(0,'red'), c(1,'blue'))),\n              name=\"Z\", hoverinfo=\"none\") %>%\n    # add projection on plane x=0.2\n    add_trace(data1, x = 0.2, y = ~y, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 2, dash=\"solid\", color = ~c, \n                          colorscale = list(c(0,'gray'), c(1,'black'))),\n              name=\"Z\", hoverinfo=\"none\") %>%\n    # add projection on plane y=0.2\n    add_trace(data1, x = ~x, y = 0.2, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 2, dash=\"solid\", color = ~c, \n                          colorscale = list(c(0,'gray'), c(1,'black'))),\n              name=\"Z\", hoverinfo=\"none\") %>%\n    # add projection on plane z=1.8\n    add_trace(data1, x = ~x, y = ~y, z = 1.8, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, dash=\"solid\", color = ~c, \n                          colorscale = list(c(0,'gray'), c(1,'black'))),\n              name=\"Z\", hoverinfo=\"none\") %>%\n    layout(title = \"Kynamical System Simulation Example\", showlegend = FALSE,\n           scene = list(aspectmode = \"manual\",\n                        xaxis = xlab, yaxis = ylab, zaxis = zlab,\n                        aspectratio = list(x=1, y=1, z=1))) # 1:1:1 aspect ratio\np",
      "line_count": 70
    },
    {
      "section": "Examples of kynamical systems",
      "code": "# Kime domain rectangle\n\nkime_grid_length <- 100\nkime_k1_range <- seq(-2,2, length=kime_grid_length)\nkime_k2_range <- seq(-1,1,length=kime_grid_length)\n\nkime_grid <- expand.grid(kime_k1_range,kime_k2_range)\n# dim(kime_grid) # [1] 900   2\n# head(kime_grid)\n#        Var1 Var2\n# 1 -2.000000   -1\n# 2 -1.862069   -1\n# 3 -1.724138   -1\n# 4 -1.586207   -1\n# 5 -1.448276   -1\n# 6 -1.310345   -1\n\n# Plot Input Grid\nplot_ly(type=\"scatter\", mode = 'lines', xaxis =\"k1\", yaxis =\"k2\") %>%\n    layout(xaxis = list(gridcolor = \"black\", range = c(-3.1, 3.1)),\n           yaxis = list(gridcolor = \"black\", range = c(-2.1, 2.1)),\n           shapes = list(\n               list(type = \"rect\",\n                    fillcolor = \"lightblue\", line = list(width = 4, color = \"blue\"), opacity = 0.3,\n                    x0 = -2, x1 = 2,  xref = \"k1\",\n                    y0 = -1, y1 = 1,  yref = \"k2\"))\n           )\n\n# ax <- list(zeroline = TRUE, showline = TRUE, mirror = \"ticks\", gridcolor = toRGB(\"gray50\"),\n#            gridwidth = 2, zerolinecolor = toRGB(\"red\"), zerolinewidth = 4,\n#            linecolor = toRGB(\"black\"),linewidth = 2)\n# s <- seq(-1, 4, length=10)\n# plot_ly() %>%\n#   layout(xaxis = ax, yaxis = ax)\n\n# Define 3D Manifold\nx <- kime_grid$Var1^3 - kime_grid$Var1*kime_grid$Var2\ny <- kime_grid$Var1 - kime_grid$Var2\nz <- kime_grid$Var1 + kime_grid$Var2\n\n# Define manifold colors\n# Create an empty array of strings with the same shape as the meshgrid\n# storing alternating two colors in a checkerboard pattern.\ncolorPair <- c(rep('white', 5), rep('black',5))\n#colorPair <- c('white','black')\nsurf_colors <- array(\"\", dim = c(kime_grid_length,kime_grid_length))\n# Check checkerboard pattern\nfor (j in 1:kime_grid_length) {\n    for (i in 1:kime_grid_length) {\n        surf_colors[j,i] <- colorPair[1+ (i+j) %% length(colorPair)]\n        # surf_colors[j,i] <- colorPair[1+ ((-1+i+(j)/2) %% 10)]\n    }\n}\n\n# Check checkerboard pattern\n# image(matrix(unclass(as.factor(surf_colors)), nrow=kime_grid_length))\nplot_ly(z= data.matrix(data.frame(unclass(surf_colors))) , type=\"heatmap\") %>%\n  hide_colorbar()\n# %>% hide_colorbar()\n\nkime_plot <- plot_ly()\nkime_plot <- add_trace(kime_plot, x=x, y=y, z=z, type=\"mesh3d\",\n                       name=\"3D Surface (kime)\", showlegend=FALSE, showscale = FALSE,\n                       intensity = unclass(as.factor(surf_colors)),  #y\n                       colors = colorRamp(rainbow(8)), opacity=0.95) %>% \n                       # colors = colorRamp(surf_colors), opacity=0.9) %>% \n    layout(scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1)))\nkime_plot\n\ndim(matrix(unclass(as.factor(surf_colors)), nrow=kime_grid_length))\n\ns <- seq(0, 1, length.out=400)\n\n# define kime BOUNDARY (\\partial D) CURVE (rectangular region D)\nk1 <- k2 <- s\nfor (i in 1:4) {\n  if (i==1) {   # 0<=s<1/4\n    k1[1:100] <- 16*s[1:100] -2      # (-2,-1) --> (2,-1)\n    k2[1:100] <- -1\n  } else if (i==2) {   # 1/4<=s<1/2\n    k1[101:200] <- 2\n    k2[101:200] <- 8*s[101:200] - 3  # (2,-1) --> (2,1)\n  } else if (i==3) {   # 1/2<=s<3/4\n    k1[201:300] <- 10-16*s[201:300]  # (2,1) --> (-2,1)\n    k2[201:300] <- 1\n  } else {   # if (i==4)   # 3/4<=s<1\n    k1[301:400] <- -2\n    k2[301:400] <- 7 - 8*s[301:400]  # (-2,1) --> (-2,-1)\n  }\n}\n\n# Plot Input kime ROI boundary Grid\nplot_ly(x=~k1, y=~k2, type=\"scatter\", mode = 'lines', xaxis =\"k1\", yaxis =\"k2\", \n        line = list(width = 10, color = \"black\")) %>%\n    layout(xaxis = list(gridcolor = \"black\", range = c(-3.1, 3.1)),\n           yaxis = list(gridcolor = \"black\", range = c(-2.1, 2.1)),\n           shapes = list(\n               list(type = \"rect\",\n                    fillcolor = \"lightblue\", line = list(width = 4, color = \"blue\"), opacity = 0.3,\n                    x0 = -2, x1 = 2,  xref = \"k1\",\n                    y0 = -1, y1 = 1,  yref = \"k2\"))\n           )\n\n# Define state space X_{\\kappa}\nx <- k1^3 - k1*k2\ny <- k1 - k2\nz <- k1 + k2\n\ndata1 <- data.frame(x, y, z)\n\n# define axes labels\nf <- list(family = \"Courier New, monospace\", size = 18, color = \"black\")\nxlab <- list(title = \"k1\", titlefont = f)\nylab <- list(title = \"k2\", titlefont = f)\nzlab <- list(title = \"Kime-surface\", titlefont = f)\n\n# define kime-surface\nxsurf <- k1\nysurf <- k2\nz_fun <- function(x,y) { x + y }\nzsurf <- outer(xsurf, ysurf, FUN=\"z_fun\")\n\n# 3D Kime-surface Plot\np <- plot_ly(x = ~x, y = ~y, z = ~z, type = 'scatter3d', \n             mode = 'lines', # name=\"Kime-space curve projection on Kime-surface\",\n             line = list(width = 22, color = ~c, colorscale = list(c(0,'red'), c(1,'blue')))) %>%\n    # add tube over boundary of kime-region\n    add_trace(z = ~zsurf, type = 'surface', opacity=0.4) %>%\n    # # trace the z-axis\n    # add_trace(x = 0, y =0, z = ~z, type=\"scatter3d\", mode=\"lines\", \n    #           line = list(width = 10, color = ~c , colorscale = list(c(0,'red'), c(1,'blue'))),\n    #           name=\"Z\", hoverinfo=\"none\") %>%\n    # add projection on plane x=10.1\n    add_trace(data1, x = 10.1, y = ~y, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 2, dash=\"solid\", color = ~c, \n                          colorscale = list(c(0,'gray'), c(1,'black'))),\n              name=\"Z\", hoverinfo=\"none\") %>%\n    # add projection on plane y=3.1\n    add_trace(data1, x = ~x, y = 3.1, z = ~z, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 2, dash=\"solid\", color = ~c, \n                          colorscale = list(c(0,'gray'), c(1,'black'))),\n              name=\"Z\", hoverinfo=\"none\") %>%\n    # add projection on plane z=3.1\n    add_trace(data1, x = ~x, y = ~y, z = 3.1, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, dash=\"solid\", color = ~c, \n                          colorscale = list(c(0,'gray'), c(1,'black'))),\n              name=\"Z\", hoverinfo=\"none\") %>%\n    layout(title = \"Kynamical System Simulation Example\", showlegend = FALSE,\n           scene = list(aspectmode = \"manual\",\n                        xaxis = xlab, yaxis = ylab, zaxis = zlab,\n                        aspectratio = list(x=1, y=1, z=1))) # 1:1:1 aspect ratio\np",
      "line_count": 152
    },
    {
      "section": "Examples of kynamical systems",
      "code": "# Kime domain rectangle\nlibrary(plotly)\nkime_grid_length <- 100\nkime_k1_range <- seq(-pi, pi, length=kime_grid_length)\nkime_k2_range <- seq(-pi, pi,length=kime_grid_length)\n\nkime_grid <- expand.grid(kime_k1_range,kime_k2_range)\n# Plot Input Grid\nplot_ly(type=\"scatter\", mode = 'lines', xaxis =\"k1\", yaxis =\"k2\") %>%\n    layout(xaxis = list(gridcolor = \"black\", range = c(-4.1, 4.1), dtick = 0.2),\n           yaxis = list(gridcolor = \"black\", range = c(-4.1, 4.1), dtick = 0.2),\n           #shapes = lapply(x0=-3, x1=3, y=(-9:9)/5, hline),\n           shapes = list(\n               list(type = \"rect\",\n                    fillcolor = \"lightblue\", line = list(width = 4, color = \"blue\"), opacity = 0.3,\n                    x0 = -pi, x1 = pi,  xref = \"k1\",\n                    y0 = -pi, y1 = pi,  yref = \"k2\"))\n           ) \n\n# Define 3D Manifold\nx <- 5 + 2*cos(kime_grid$Var2)*cos(kime_grid$Var1)\ny <- 5 + 2*cos(kime_grid$Var2)*sin(kime_grid$Var1)\nz <- 2*sin(kime_grid$Var2)\n\n# Define manifold colors\n# Create an empty array of strings with the same shape as the meshgrid\n# storing alternating two colors in a checkerboard pattern.\n#colorPair <- c(rep('white', 5), rep('black',5))\ncolorPair <- c('white','black')\nsurf_colors <- array(\"\", dim = c(kime_grid_length,kime_grid_length))\n# Check checkerboard pattern\nfor (j in 1:kime_grid_length) {\n    for (i in 1:kime_grid_length) {\n        surf_colors[j,i] <- colorPair[1+ (i+j) %% length(colorPair)]\n        # surf_colors[j,i] <- colorPair[1+ ((-1+i+(j)/2) %% 10)]\n    }\n}\n\n# Check checkerboard pattern\n# image(data.matrix(data.frame(unclass(surf_colors))))\nplot_ly(z= data.matrix(data.frame(unclass(surf_colors))) , type=\"heatmap\") %>%\n  hide_colorbar()\n\nkime_plot <- plot_ly()\nkime_plot <- add_trace(kime_plot, x=x, y=y, z=z, type=\"mesh3d\",\n                       name=\"3D Surface (kime)\", showlegend=FALSE, showscale = FALSE,\n                       intensity = unclass(as.factor(surf_colors)),  #y\n                       colors = colorRamp(rainbow(8)), opacity=0.95) %>% \n                       # colors = colorRamp(surf_colors), opacity=0.9) %>% \n    layout(scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1)))\nkime_plot\n\ndim(matrix(unclass(as.factor(surf_colors)), nrow=kime_grid_length))\n\n# s <- seq(0, 1, length.out=400)\n# \n# # define kime BOUNDARY (\\partial D) CURVE (rectangular region D)\n# k1 <- k2 <- s\n# for (i in 1:4) {\n#   if (i==1) {   # 0<=s<1/4\n#     k1[1:100] <- 16*s[1:100] -2      # (-2,-1) --> (2,-1)\n#     k2[1:100] <- -1\n#   } else if (i==2) {   # 1/4<=s<1/2\n#     k1[101:200] <- 2\n#     k2[101:200] <- 8*s[101:200] - 3  # (2,-1) --> (2,1)\n#   } else if (i==3) {   # 1/2<=s<3/4\n#     k1[201:300] <- 10-16*s[201:300]  # (2,1) --> (-2,1)\n#     k2[201:300] <- 1\n#   } else {   # if (i==4)   # 3/4<=s<1\n#     k1[301:400] <- -2\n#     k2[301:400] <- 7 - 8*s[301:400]  # (-2,1) --> (-2,-1)\n#   }\n# }\n# \n# # Plot Input kime ROI boundary Grid\n# plot_ly(x=~k1, y=~k2, type=\"scatter\", mode = 'lines', xaxis =\"k1\", yaxis =\"k2\", \n#         line = list(width = 10, color = \"black\")) %>%\n#     layout(xaxis = list(gridcolor = \"black\", range = c(-3.1, 3.1)),\n#            yaxis = list(gridcolor = \"black\", range = c(-2.1, 2.1)),\n#            shapes = list(\n#                list(type = \"rect\",\n#                     fillcolor = \"lightblue\", line = list(width = 4, color = \"blue\"), opacity = 0.3,\n#                     x0 = -2, x1 = 2,  xref = \"k1\",\n#                     y0 = -1, y1 = 1,  yref = \"k2\"))\n#            )\n# \n# # Define state space X_{\\kappa}\n# x <- k1^3 - k1*k2\n# y <- k1 - k2\n# z <- k1 + k2\n# \n# data1 <- data.frame(x, y, z)\n# \n# # define axes labels\n# f <- list(family = \"Courier New, monospace\", size = 18, color = \"black\")\n# xlab <- list(title = \"k1\", titlefont = f)\n# ylab <- list(title = \"k2\", titlefont = f)\n# zlab <- list(title = \"Kime-surface\", titlefont = f)\n# \n# # define kime-surface\n# xsurf <- k1\n# ysurf <- k2\n# z_fun <- function(x,y) { x + y }\n# zsurf <- outer(xsurf, ysurf, FUN=\"z_fun\")\n# \n# # 3D Kime-surface Plot\n# p <- plot_ly(x = ~x, y = ~y, z = ~z, type = 'scatter3d', \n#              mode = 'lines', showlegend = F, # name=\"Kime-space curve projection on Kime-surface\",\n#              line = list(width = 22, color = ~c, colorscale = list(c(0,'red'), c(1,'blue')))) %>%\n#     # add tube over boundary of kime-region\n#     add_trace(z = ~zsurf, type = 'surface', opacity=0.4) %>%\n#     # # trace the z-axis\n#     # add_trace(x = 0, y =0, z = ~z, type=\"scatter3d\", mode=\"lines\", \n#     #           line = list(width = 10, color = ~c , colorscale = list(c(0,'red'), c(1,'blue'))),\n#     #           name=\"Z\", hoverinfo=\"none\") %>%\n#     # add projection on plane x=10.1\n#     add_trace(data1, x = 10.1, y = ~y, z = ~z, type=\"scatter3d\", mode=\"lines\", \n#               line = list(width = 2, dash=\"solid\", color = ~c, \n#                           colorscale = list(c(0,'gray'), c(1,'black'))),\n#               name=\"Z\", hoverinfo=\"none\") %>%\n#     # add projection on plane y=3.1\n#     add_trace(data1, x = ~x, y = 3.1, z = ~z, type=\"scatter3d\", mode=\"lines\", \n#               line = list(width = 2, dash=\"solid\", color = ~c, \n#                           colorscale = list(c(0,'gray'), c(1,'black'))),\n#               name=\"Z\", hoverinfo=\"none\") %>%\n#     # add projection on plane z=3.1\n#     add_trace(data1, x = ~x, y = ~y, z = 3.1, type=\"scatter3d\", mode=\"lines\", \n#               line = list(width = 10, dash=\"solid\", color = ~c, \n#                           colorscale = list(c(0,'gray'), c(1,'black'))),\n#               name=\"Z\", hoverinfo=\"none\") %>%\n#     layout(title = \"Kynamical System Simulation Example\", showlegend = FALSE,\n#            scene = list(aspectmode = \"manual\",\n#                         xaxis = xlab, yaxis = ylab, zaxis = zlab,\n#                         aspectratio = list(x=1, y=1, z=1))) # 1:1:1 aspect ratio\n# p\n\n\n\n############ Torus\na <- 6   # Torus radius\nr <- 2 # Tube radius\n\n###### Delaunay Triangulation\nlibrary(geometry)\n# Parameter defining how many points to take. \ngrid.df <- expand.grid(\n  u = seq(0, 2*pi, length.out = 20),\n  v = seq(0, 2*pi, length.out = 20)\n)\n\n# Define a Torus parametrization (see Wikipedia)\nmat <- matrix(\n    c(x<- (a + r*cos(grid.df$u))*cos(grid.df$v), # x\n      y <- (a + r*cos(grid.df$u))*sin(grid.df$v), # y\n      z <- r*sin(grid.df$u)  # z\n    ), \n    ncol = 3, dimnames = list(NULL, c(\"x\", \"y\", \"z\"))\n)\n\nDelaunay.mat <- delaunayn(grid.df)  #, options=\"Qcc Qc Qt Qz\", output.options=TRUE)\n# Delaunay.mat.t <- t(Delaunay.mat)\n#  Use mat to plot (not the 2D grid grid.df)\n \n# Plotly layout \naxs <- list(\n  backgroundcolor=\"rgb(200,200,200)\", # gray\n  gridcolor=\"rgb(255,255,255)\",       # white\n  showbackground=TRUE,\n  zerolinecolor=\"rgb(255,255,255)\"     # white\n)\n \n#  Apply the colormap\n#  Compute the mean of z for each row of the Delaunay vertices\nzmean <- apply(Delaunay.mat, MARGIN=1, function(row){mean(mat[row,3])})\n \nlibrary(scales)\n# Determine the 2-cell face's colors\n# plotted color result will be slightly different\n#  since colour_ramp uses CIELAB instead of RGB\n#  could use colorRamp for exact replication\nfacecolor = colour_ramp(\n  # brewer_pal(palette=\"RdBu\")(10); # brewer_pal(\"div\")(10)\n  colorRampPalette(c(\"pink\", \"purple\"))(10))  #  (rescale(x=zmean))\n \nscene = list(camera = list(eye = list(x = 2, y = 1, z = 1)),\n              aspectmode = \"manual\", aspectratio = list(x=2, y=2, z=1))\nplot_ly(\n  # x = x, y = y, z = z,  # vertex (0-cell) coordinates\n  # i = i, j = j, k = k,  # indices to the vertices, which describe a 2-cell (face or a simplex) of dimension dim\n  # see docs: https://plot.ly/r/3d-mesh-plots/\n  x = mat[, 1], y = mat[, 2], z = mat[, 3],\n  # JavaScript is 0 based index so subtract 1\n  i=Delaunay.mat[, 1]-1, j=Delaunay.mat[, 2]-1, k=Delaunay.mat[, 3]-1,\n  # facecolor = facecolor, # mat[, 3],\n  type = \"mesh3d\",\n  opacity = 0.5,\n  contour=list(show=TRUE, color=\"#000\", width=15)\n) %>%\n  # add_trace(x=mat[, 1], y=mat[, 2], z=0, type=\"scatter3d\", mode=\"lines\", line = list(color=\"rgb(0, 255, 0)\")) %>%\n  layout(title=\"Torus Triangulation\", scene=scene)\n\n#### Parametric curve on torus\nk1 <- grid.df$u -pi\nk2 <- ((k1-1)^3 + 5*(k1-1)^2 + 2*(k1-5) - 8)/10\nmatCurve <- matrix(\n    c(xCurve<- grid.df$u -pi, # x\n      yCurve <- ((xCurve-1)^3 + 5*(xCurve-1)^2 + 2*(xCurve-5) - 8)/10, # y\n      zCurve <- r*sin(grid.df$u)  # z\n    ), \n    ncol = 3\n)\n\n# 3D Torus with Curve-Tube Plot\np <- plot_ly(x = ~x, y = ~y, z = ~z, type = 'scatter3d', \n             mode = 'lines', showlegend = F, # name=\"Kime-space curve projection on Kime-surface\",\n             line = list(width = 22, color = ~c, colorscale = list(c(0,'red'), c(1,'blue')))) %>%\n    # add tube over boundary of kime-region\n    add_trace(z = ~zsurf, type = 'surface', opacity=0.4) # %>%\n    # # trace the z-axis\n    # add_trace(x = 0, y =0, z = ~z, type=\"scatter3d\", mode=\"lines\", \n    #           line = list(width = 10, color = ~c , colorscale = list(c(0,'red'), c(1,'blue'))),\n    #           name=\"Z\", hoverinfo=\"none\") %>%\n\nplot_ly(\n  # x = x, y = y, z = z,  # vertex (0-cell) coordinates\n  # i = i, j = j, k = k,  # indices to the vertices, which describe a 2-cell (face or a simplex) of dimension dim\n  # see docs: https://plot.ly/r/3d-mesh-plots/\n  x = mat[, 1], y = mat[, 2], z = mat[, 3],\n  # JavaScript is 0 based index so subtract 1\n  i=Delaunay.mat[, 1]-1, j=Delaunay.mat[, 2]-1, k=Delaunay.mat[, 3]-1,\n  facecolor = facecolor,\n  type = \"mesh3d\",\n  opacity = 0.5,\n  contour=list(show=TRUE, color=\"#000\", width=15)) %>%\n  add_trace(x=matCurve[, 1], y=matCurve[, 2], z=matCurve, type=\"scatter3d\", mode=\"lines\", line = list(color=\"rgb(0, 255, 0)\")) %>%\n  layout(title=\"Torus Triangulation\", scene=scene)\n\n\nkime_grid_length <- 20\nkime_k1_range <- seq(-pi,pi, length=kime_grid_length)\nkime_k2_range <- seq(-pi,pi, length=kime_grid_length)\n\nkime_grid <- expand.grid(kime_k1_range,kime_k2_range)\n\n# Plot 2D Input Grid + kime curve\nplot_ly(type=\"scatter\", mode = 'lines', xaxis =\"k1\", yaxis =\"k2\") %>%\n  add_lines(x=matCurve[, 1], y=matCurve[, 2], mode=\"lines\", \n            line = list(color=\"rgb(255, 0, 0)\", width=5)) %>%\n  layout(showlegend=FALSE,\n         xaxis = list(gridcolor = \"black\", range = c(-4, 4), dtick = 0.2),\n         yaxis = list(gridcolor = \"black\", range = c(-4, 4), dtick = 0.2),\n        shapes = list(\n               list(type = \"rect\",\n                    fillcolor = \"lightblue\", line = list(width = 4, color = \"blue\"), opacity = 0.3,\n                    x0 = -pi, x1 = pi,  xref = \"k1\",\n                    y0 = -pi, y1 = pi,  yref = \"k2\"))\n        )\n\n# Checkerboard Torus + kime-curve\nx<- (a + r*cos(grid.df$u))*cos(grid.df$v)  # x\ny <- (a + r*cos(grid.df$u))*sin(grid.df$v) # y\nz <- r*sin(grid.df$u)                      # z\n\n# Define manifold colors\n# Create an empty array of strings with the same shape as the meshgrid\n# storing alternating two colors in a checkerboard pattern.\n#colorPair <- c(rep('white', 5), rep('black',5))\ncolorPair <- c('white','black')\nsurf_colors <- array(\"\", dim = c(length(grid.df$u), length(grid.df$v)))\n# Check checkerboard pattern\nfor (j in 1:length(grid.df$u)) {\n    for (i in 1:length(grid.df$v)) {\n        surf_colors[j,i] <- colorPair[1+ (i+j) %% length(colorPair)]\n        # surf_colors[j,i] <- colorPair[1+ ((-1+i+(j)/2) %% 10)]\n    }\n}\n\n# Check checkerboard pattern\n# image(matrix(unclass(as.factor(surf_colors)), nrow=kime_grid_length))\nplot_ly(z= data.matrix(data.frame(unclass(surf_colors))) , type=\"heatmap\") %>%\n  hide_colorbar()\n\nkime_plot <- plot_ly()\nkime_plot <- add_trace(kime_plot, x=x, y=y, z=z, type=\"mesh3d\",\n                       name=\"3D Surface (kime)\", showlegend=FALSE, \n                       intensity = unclass(as.factor(surf_colors)),  #y\n                       colors = colorRamp(rainbow(8)), opacity=0.95) %>% \n                       # colors = colorRamp(surf_colors), opacity=0.9) %>% \n    layout(scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1)))\nkime_plot\n\n\n\n###################################### TEST\n# shape==\"complex\")\n# phi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(200 - 1)))\n# psi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(200 - 1)))\n# # rendering (u,v) parametric surfaces requires x,y,z arguments to be 2D arrays\n# # In out case, the three coordinates have to be 200*200 parameterized tensors/arrays\n# r1 = 2 + sin(3 * phi + 5 * psi)    # r = 2 + sin(7phi+5psi)\n# x1 = (r1 * cos(phi)) %o% sin(psi)    # x = r*cos(phi)*sin(psi)\n# y1 = (r1 * sin(phi)) %o% sin(psi)     # y = r*sin(phi)*sin(psi)\n# z1 = r1 %o% cos(psi)  # z = r*cos(psi)\n#     \n# p <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n#   add_trace(x = ~x1, y = ~y1, z = ~z1, type = 'surface', opacity=1, visible=T) %>%\n#   layout(title = \"Torus\", showlegend = FALSE)\n# p\n\n# Checkerboard TORUS\nphi <- grid.df$u  #  seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(200 - 1)))\npsi <- grid.df$v  #  seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(200 - 1)))\n\nxOuter <- outer(phi, psi, function(phi, psi) { cos(phi)*(a+r*cos(psi)) })\nyOuter <- outer(phi, psi, function(phi, psi) { sin(phi)*(a+r*cos(psi)) })\nzOuter <- outer(phi, psi, function(phi, psi) { r*sin(psi) })\n\nplot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n    add_trace(x=~xOuter, y=~yOuter, z=~zOuter, type='surface', opacity=1.0, visible=T) %>%\n    layout(title = \"Torus\", showlegend = FALSE,\n          scene = list(aspectmode = \"manual\", aspectratio = list(x=2, y=2, z=1)))\n\n################ checkerboard color pattern\na <- 6   # Torus radius (from torus gravitational center)\nr <- 2   # Tube radius (from torus circular core)\n\n# phi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(20 - 1)))\n# psi <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(20 - 1)))\n\nxOuter <- outer(phi, psi, function(phi, psi) { cos(phi)*(a+r*cos(psi)) })\nyOuter <- outer(phi, psi, function(phi, psi) { sin(phi)*(a+r*cos(psi)) })\nzOuter <- outer(phi, psi, function(phi, psi) { r*sin(psi) })\n\n# checkerboard color pattern\ncolorPair <- c('white','black')\nsurf_colors <- array(\"\", dim = c(length(phi), length(phi)))\n# Check checkerboard pattern\nfor (j in 1:length(phi)) {\n    for (i in 1:length(phi)) {\n        surf_colors[j,i] <- colorPair[1+ (i+j) %% length(colorPair)]\n        # surf_colors[j,i] <- colorPair[1+ ((-1+i+(j)/2) %% 10)]\n    }\n}\n# Check checkerboard pattern\n# image(matrix(unclass(as.factor(surf_colors)), nrow=length(phi)))\nplot_ly(z= data.matrix(data.frame(unclass(surf_colors))) , type=\"heatmap\") %>%\n  hide_colorbar()\n\n### Kime tube on torus\n#### Parametric curve on torus\n# k1 <- phi -pi\n# k2 <- ((phi-1)^3 + 5*(phi-1)^2 + 2*(phi-5) - 8)/10\nxCurveOuter <- outer(phi, psi, function(phi, psi) { \n  cos(phi -pi)*(a+r*cos(((phi -pi-1)^3 + 5*(phi -pi-1)^2 + 2*(phi -pi-5) - 8)/10)) })\nyCurveOuter <- outer(phi, psi, function(phi, psi) { \n  sin(phi -pi)*(a+r*cos(((phi -pi-1)^3 + 5*(phi -pi-1)^2 + 2*(phi -pi-5) - 8)/10)) })\nzCurveOuter <- outer(phi, psi, function(phi, psi) { \n  r*sin(((phi -pi-1)^3 + 5*(phi -pi-1)^2 + 2*(phi -pi-5) - 8)/10) })\n\nplot_ly(x=~as.vector(xCurveOuter), y=~as.vector(yCurveOuter), \n        z=~as.vector(zCurveOuter), type=\"scatter3d\", mode=\"markers+lines\",\n        line=list(color='red', width=15))\n\nplot_ly(hoverinfo=\"none\") %>%\n  add_trace(x=~xOuter, y=~yOuter, z=~zOuter, type='surface', \n            opacity=0.01, visible=TRUE, showlegend= FALSE, showscale = FALSE) %>%\n  add_trace(x=~as.vector(xCurveOuter), y=~as.vector(yCurveOuter), z=~as.vector(zCurveOuter),\n            name=\"Tube\", type='scatter3d', mode='markers+lines', showscale = FALSE,\n            hoverinfo = 'Tube', line=list(color='red', width=15), showlegend = FALSE) %>%\n  # add projection on plane x=8.5\n  add_trace(x = 8.5, y = ~as.vector(yCurveOuter), z=~as.vector(zCurveOuter), \n            type=\"scatter3d\", mode=\"lines\", line = list(width = 2, dash=\"solid\", color = ~c, \n            colorscale = list(c(0,'gray'), c(1,'black'))), name=\"Z\", hoverinfo=\"none\") %>%\n  # add projection on plane y=-8.5\n  add_trace(x = ~as.vector(xCurveOuter), y = -8.5, z = ~as.vector(xCurveOuter), \n            type=\"scatter3d\", mode=\"lines\", line = list(width = 2, dash=\"solid\", color = ~c,\n            colorscale = list(c(0,'gray'), c(1,'black'))), name=\"Z\", hoverinfo=\"none\") %>%\n  # add projection on plane z=-2.5\n  add_trace(x = ~as.vector(xCurveOuter), y = ~as.vector(yCurveOuter), z = ~-2.5, \n            type=\"scatter3d\", mode=\"lines\", line = list(width = 2, dash=\"solid\", color = ~c,\n            colorscale = list(c(0,'gray'), c(1,'black'))), name=\"Z\", hoverinfo=\"none\") %>%\n  layout(title = \"Torus\", showlegend = FALSE,\n          scene = list(aspectmode = \"manual\", aspectratio = list(x=2, y=2, z=1)))\n",
      "line_count": 384
    },
    {
      "section": "Examples of kynamical systems",
      "code": "library(extraDistr)\nlibrary(pracma)\n\n# set parameters\na <- 2      # base of population exponential growth/decay w.r.t. time, a>0\nAo <- 100   # initial bacterial colony size at time t=0, Ao >0\nrho <- 0.3  # initial dependence (correlation), -1 < rho = Corr(t,phi) < 1\n\nlen <- 100\ns <- seq(0, 10, length=len)       # Time parameter grid\nphi <- seq(-pi, pi, length=len)   # Phase parameter grid\n\n# Base function definitions\n\n# f(t)\nf <- function (t=0) { # input is argument-value (s[t]), not argument-index (t)\n  # if (t < s[1]) {  val = 0   } \n  # else if (t > s[len]) {  val = 0  } \n  # else {  val=Ao * a^t  }\n  return ( Ao * a^t )\n} # f(-1); f(s[1]); f(s[len]); f(s[len]+10)\n\n# Note: since \"integral\" expects a vectorized smooth function, which our densities\n# are not, we need a work around, piece-wise integration?\nF1 <- function (x) { # inputs are arguments-indices\n                     # CDF as an abstract function\n  # message(paste('input to F1 =',x))\n  if (x < 1) {  val = 0   } \n  else if (x > len) {  val = 1  } \n  else {  # normalize the CDF to integral(f)\n    val=\n      integral(f, xmin=s[1], xmax=s[x], reltol=1e-12, method=\"Kronrod\")/147588\n  }\n  return(val)\n}  # F1(-1); F1(1); F1(len); F1(len+10)\n\n# g(phi)\ng <- function (ph=0) { # input is argument-value (phi[t])\n  # Any other symmetric distribution over a finite domain can be used, see\n  # https://en.wikipedia.org/wiki/Symmetric_probability_distribution#Partial_list_of_examples \n  # draw random Phases: phiNew ~ Phi[-pi, pi)\n  #  l = rlaplace(1000, mu=0, sigma=0.5)\n  # hist(l)\n  # Laplace Distribution\n  phiNew = rlaplace(length(phi), mu=0, sigma=0.5)\n  phi <- phiNew\n  return ( (1/(2*a))^(ph/pi) )\n}  # g(-1); f(phi[1]); f(phi[len]); f(phi[len]+10)\ngMax <- max(abs(g(phi)))\nfMax <- max(abs(f(s)))\n\nG1 <- function (x) { # inputs are arguments-indices\n                     # CDF as an abstract function\n  if (x < 1) {  val = 0   } \n  else if (x > len) {  val = 1  } \n  else {  # normalize the CDF to integral(f)\n    val=\n      integral(g, xmin=phi[1], xmax=phi[x], reltol=1e-12, method=\"Kronrod\")/903678\n  }\n  return(val)\n}  # G1(-1); G1(1); G1(len); G1(len+10)\n\n# Gauss-copula\n# C_{XY}^{Gauss} (x,y)=\\frac{1}{\\sqrt{1-ρ^2}} \\times \\exp \\left (-\\frac{ρ^2 (a^2+b^2 )-2abρ)}{2(1-ρ^2 )} \\right ),\n# where the pairwise correlation $-1 < \\rho < 1$ and\n# a(x)= \\sqrt{2}\\times erf^{-1} (2\\times F_X (x)-1),\n# b(y)= \\sqrt{2}\\times erf^{-1} (2\\times F_Y (y)-1),\n# and the error function is\n# $$erf^{-1}(s)= \\frac{2}{\\sqrt{\\pi}}\\int_{0}^{\\infty}{e^{-t^2}dt}.$$  \nCGauss <- function (t=len/2, s=len/2) {  # arguments are indices!\n  if (t < 1) { A= -1e+7 }\n  else if (t >= len) { A= 1e+7 } \n  else { A = sqrt(2) * erfinv(2*(F1(t))-1) }\n  \n  if (s < 1) { B= -1e+7 }\n  else if (s > len) { B= 1e+7 } \n  else { B = sqrt(2) * erfinv(2*(G1(s))-1) }\n  \n  # message(paste('A=', A, 'B=', B))\n  val = (1/(sqrt(1-rho^2))) * \n             exp(-(rho^2*(A^2+B^2) - 2*A*B*rho)/(2*(1-rho^2)))\n  if (is.finite(val)) return (val)   \n  else return (0)  \n}  # CGauss(50, 50)\n\n# F(t)\nfJoint <- function (t=len/2, ph=len/2, rho = rho) {\n  return ( f(s[t]) * g(phi[ph]) * CGauss(t, ph) )\n}  # fJoint(50, 50)\n\ny1 <- f(s)     # f: first marginal\ny2 <- g(phi)   # g: second marginal\ny3 <- c()         # Gaussian Copula (. , s=sMax/2)\nfor (i in 1:len) y3[i]=CGauss(i, 55)   \ny4 <- c()        # joint density f(t,t)\nfor (i in 1:len) y4[i] <- fJoint(t=i, ph=55, rho)\n\nplot_ly() %>%\n  add_trace(x=~s, y=~log(y1), type='scatter', mode='markers+lines',\n            name=\"log(f): log(Longitudinal marginal)\") %>%\n  add_trace(x=~s, y=~y2, type='scatter', mode='markers+lines',\n            name=\"g: Kime-phase marginal\", opacity=1) %>%\n  add_trace(x=~s, y=~y3, type='scatter', mode='markers+lines',\n            name=\"C_Gauss(t,s): Gaussian Copula\", opacity=0.5) %>%\n  add_trace(x=~s, y=~log(y4), type='scatter',\n            mode='markers+lines',\n            name=\"log(f(t,s, rho)): Joint Kime-time and Kime-phase Effects\") %>%\n  layout(title = \"Copula-based Modeling of Joint Distribution\", \n         xaxis = list(title = \"time\"), \n         yaxis = list(title = \"Functional Value\"), # showlegend = FALSE, \n         legend = list(orientation = 'h'),\n         scene = list(aspectmode = \"manual\",\n                      aspectratio = list(x=1, y=1)))",
      "line_count": 113
    },
    {
      "section": "Examples of kynamical systems",
      "code": "#### Path Kynamics over curves \\gamma:\\mathbb{R}\\to \\mathbb{C}\n### Part 2: Path Kynamics over curves \\gamma:\\mathbb{R}\\to \\mathbb{C}\n### Kime tube gamma(k1,k2) on torus   ########## CARTESIAN\n#### Parametric curve on torus\n# define kime-surface\ns <- seq(0, 10, length=100)       # Time parameter grid\nphi <- seq(-pi, pi, length=100)   # Phase parameter grid\n\nxsurf <- s    # longitudinal trajectory\nysurf <- phi    # phase trajectory\n\nzsurf <- mat<-matrix(0, nrow=len, ncol=len)      # joint density f(t,s)\nfor (i in 1:len) {\n  for (j in 1:len) {\n    zsurf[i,j] <- (fJoint(t=i, ph=j, rho))/(10^4)\n  }\n  if (i %% 30 ==0) message(paste0('Progress: ... ', round((100*i)/len, 0), '%'))\n}\n# image(zsurf)\nplot_ly(z=~zsurf, type=\"heatmap\") # %>% hide_colorbar()\n# image(zsurf)",
      "line_count": 21
    },
    {
      "section": "Examples of kynamical systems",
      "code": "# 3D Kime-surface Plot\n# 3D Kime-surface Plot\nfnt <- list(family = \"Courier New, monospace\", size = 18, color = \"black\")\nxlab <- list(title = \"time\", titlefont = fnt)\nylab <- list(title = \"phase\", titlefont = fnt)\nzlab <- list(title = \"Kime-surface\", titlefont = fnt)\n\nplot_ly(x=~xsurf, y=~ysurf, z=~t(zsurf), type=\"surface\", opacity=0.95,\n        showlegend=FALSE, name=\"Joint Kime-Density-Surface\") %>%\n    # add vital days after surgery projection curve, for a fixed BMI=22\n    add_trace(x=~xsurf, y=ysurf[22], z=~zsurf[, 22], type=\"scatter3d\",\n              mode=\"lines\", line=list(width=20), name=\"Phi=-1.8\") %>%\n    # add BMI projection curve vital days after surgery=1000\n    add_trace(x=xsurf[70], y=~ysurf, z=~zsurf[70,], type=\"scatter3d\",\n              mode=\"lines\", line=list(width=20), name=\"Time=7\") %>%\n    hide_colorbar() %>%\n    layout(title = \n           \"Joint Kynamical System Simulation\\n (Gaussian copula, Rho=0.3)\", \n           scene = list(aspectmode = \"manual\",\n                    xaxis = xlab, yaxis = ylab, zaxis = zlab,\n                    aspectratio = list(x=1, y=1, z=1))) # 1:1:1 aspect ratio",
      "line_count": 21
    },
    {
      "section": "Examples of kynamical systems",
      "code": "#### Full kime-dynamics as kime-surfaces over the entire complex time domain.\n###### POLAR Coordinates ...\n# Change basis from from polar coordinates to Cartesian coordinates\nmatrix_ON <- matrix(0, nrow = 101, ncol = 101) \nfor (t in 1:length(s)) {\n  for (p in 1:length(phi)) {\n    x = as.integer(51+5*s[t]*cos(phi[p]))\n    y = as.integer(51+5*s[t]*sin(phi[p]))\n    if (x>100) x=100\n    if (x<1) x=1\n    if (y>100) y=100\n    if (y<1) y=1\n    matrix_ON[x,y]  <- zsurf[t,p] \n    # zsurfSmooth3$z # zsurfSmooth2[t,p] # zsurfSmooth  # zsurf\n  }\n}\ndim(matrix_ON) # 101 * 101\n# image(t(matrix_ON), col = hcl.colors(100, \"terrain\"), axes = FALSE)\nplot_ly(z= matrix_ON, type=\"heatmap\")\n\n# Inspect visually matrix_ON\n# library(gplots)\n# heatmap.2(matrix_ON, Rowv=FALSE, Colv=FALSE, dendrogram='none', cellnote=matrix_ON, notecol=\"black\", trace='none', key=FALSE, lwid = c(.01, .99), lhei = c(.01, .99), margins = c(5, 15 ))\n\n# smooth/blur the matrices\nlibrary (spatstat)\nmatrix_ON_smooth <- as.matrix(blur(as.im(matrix_ON), sigma=1.5))\n# heatmap.2( matrix_ON_smooth, Rowv=FALSE, Colv=FALSE, dendrogram='none', cellnote=matrix_ON, notecol=\"black\", trace='none', key=FALSE, lwid = c(.01, .99), lhei = c(.01, .99), margins = c(5, 15 ))",
      "line_count": 28
    },
    {
      "section": "Examples of kynamical systems",
      "code": "#library(plotly)\nplot_ly(z = ~matrix_ON_smooth, type = \"surface\", showscale=FALSE) %>%\n    hide_colorbar() %>% layout(title = \"Smoothed Surface\")\nplot_ly(z = ~matrix_ON, type = \"surface\") %>%\n    hide_colorbar() %>% layout(title = \"Raw Surface\")",
      "line_count": 5
    },
    {
      "section": "Examples of kynamical systems",
      "code": "# Plot matrix_ON_smooth\nmatToPlot <- matrix_ON_smooth   # matrix_ON\n\n# Generate Time-curve (phi=0)\nt <- 1:length(s)\ncurveS_x <- as.integer(51+5*s[t]*cos(phi[1]))\ncurveS_y <- as.integer(51+5*s[t]*sin(phi[1]))\ncurveS_z <- (matToPlot[curveS_x, curveS_y])[ , 1]\n# plot_ly( x=~curveS_x, y=~curveS_y, z=~curveS_z,\n#          type=\"scatter3d\", mode=\"lines\")\n\n# Generate phase trajectory (t=7)\ncurveP_x <- as.integer(51+5*s[70]*cos(phi))\ncurveP_y <- as.integer(51+5*s[70]*sin(phi))\ncurveP_z <- (matToPlot[curveP_x, curveP_y])[ , 1]\n# plot_ly( x=~curveP_x, y=~curveP_y, z=~curveP_z,\n#          type=\"scatter3d\", mode=\"lines\")\n\n# Project Curves/paths onto 3D Kime-surface Plot\n# add projection curve phi=0. Plot matrix_ON_smooth? , \n# opacity=0.1, showscale=FALSE\nplot_ly(z = ~t(matToPlot), type = \"surface\", opacity=0.2) %>% \n    # Add time-series (phi=0)\n    add_trace(x=~curveS_x, y=~curveS_y, z=~curveS_z+0.2,\n         type=\"scatter3d\", mode=\"lines\", line=list(width=20), \n         name=\"Phi=0\") %>%\n    # Add phase trajectory (time=5)\n    add_trace(x=~curveP_x, y=~curveP_y, z=~curveP_z+0.2,\n         type=\"scatter3d\", mode=\"lines\", line=list(width=20, \n                                  color=\"blue\"), name=\"Time=5\") %>%\n    hide_colorbar() %>% layout(title = \"Canonical Kime Curves (Smooth Surface)\")\n\n# Plot matrix_ON?\nmatToPlot <- matrix_ON    # matrix_ON_smooth\n\n# Generate Time-curve (phi=0)\nt <- 1:length(s)\ncurveS_x <- as.integer(51+5*s[t]*cos(phi[1]))\ncurveS_y <- as.integer(51+5*s[t]*sin(phi[1]))\ncurveS_z <- (matToPlot[curveS_x, curveS_y])[ , 1]\n# plot_ly( x=~curveS_x, y=~curveS_y, z=~curveS_z,\n#          type=\"scatter3d\", mode=\"lines\")\n\n# Generate phase trajectory (t=7)\ncurveP_x <- as.integer(51+5*s[70]*cos(phi))\ncurveP_y <- as.integer(51+5*s[70]*sin(phi))\ncurveP_z <- (matToPlot[curveP_x, curveP_y])[ , 1]\n# plot_ly( x=~curveP_x, y=~curveP_y, z=~curveP_z,\n#          type=\"scatter3d\", mode=\"lines\")\n\n# Project Curves/paths onto 3D Kime-surface Plot\n# add projection curve phi=0. Plot matrix_ON_smooth? , \n# opacity=0.1, showscale=FALSE\nplot_ly(z = ~matToPlot, type = \"surface\", opacity=0.2) %>% \n    # Add time-series (phi=0)\n    add_trace(x=~curveS_x, y=~curveS_y, z=~curveS_z+0.2,\n         type=\"scatter3d\", mode=\"lines\", line=list(width=20), \n         name=\"Phi=0\") %>%\n    # Add phase trajectory (time=5)\n    add_trace(x=~curveP_x, y=~curveP_y, z=~curveP_z+0.2,\n         type=\"scatter3d\", mode=\"lines\", line=list(width=20, \n                                  color=\"blue\"), name=\"Time=7\") %>%\n    hide_colorbar() %>% layout(title = \"Canonical Kime Curves (Raw Surface)\")\n              \n# # fix the Plot_Ly Text Labels\n# x <- vector()\n# y <- vector()\n# i <- 1\n# for (t in 1:length(s)) {\n#   for (p in 1:length(phi)) {\n#     x = as.integer(51+5*t*cos(phi[p]))\n#     y = as.integer(51+5*t*sin(phi[p]))\n#     i <- i+1\n#   }\n# }\n# \n# hoverText <- cbind(x=1:101, y=1:101, height=as.vector(t(matrix_ON_smooth))) # tail(mytext)\n# custom_txt <- matrix(NA, nrow=101, ncol=101)\n# hoverTextON <- cbind(x=1:101, y=1:101, height=as.vector(t(matrix_ON_smooth))) # tail(mytext)\n# custom_txtON <- matrix(NA, nrow=101, ncol=101)\n# \n# for (x in 1:101) {\n#    for (y in 1:101) {\n#      t = sqrt((x-51)^2 + (y-51)^2)\n#      p = atan2(y-51, x-51)\n#      custom_txt[x,y]<-paste(' fMRI: ', round(hoverText[(x-1)*101+y, 3], 3),\n#                     '\\n time: ', round(t, 0),\n#                     '\\n phi: ', round(p, 2)) \n#      custom_txtON[x,y]<-paste(' fMRI: ',\n#                               round(hoverTextON[(x-1)*101+y,3],3),\n#                     '\\n time: ', round(t, 0),\n#                     '\\n phi: ', round(p, 2)) \n#    }\n# }\n# dim(custom_txt); custom_txt[10:12,10:12]; custom_txtON[10:12,10:12]\n# \n# xx2 <- 51 + c(-50:50) %o% cos(seq(-pi, pi, 2*pi/20))\n# yy2 <- 51 + c(-50:50) %o% sin(seq(-pi, pi, 2*pi/20))\n# #zz2 <- as.vector(matrix_ON_smooth) %o% rep(1, 21*21)\n# zz2 <- matrix_ON_smooth\n# \n# #plot 2D into 3D and make the text of the diameter (time), height (r), and phase (phi)\n# f <- list(family = \"Courier New, monospace\", size = 18, color = \"black\")\n# x <- list(title = \"k1\", titlefont = f)\n# y <- list(title = \"k2\", titlefont = f)\n# z <- list(title = \"fMRI Kime-series\", titlefont = f)\n# \n# # Plot ON kime-surface\n# plot_ly(x = ~xx2, y = ~yy2, z = ~zz2, type = \"surface\",  # scatterpolar\n#         text = custom_txt, hoverinfo = \"text\", showlegend = FALSE) %>% \n#   #add_trace(x=~xx2, y=~yy2, z=~ww2, colors = c(\"blue\", \"yellow\"),\n#   #          type=\"surface\", text = custom_txtOFF, hoverinfo = \"text\",\n#   #          opacity=0.3, showscale = FALSE, showlegend = FALSE) %>%\n#   # trace the main Z-axis\n#   # add_trace(x=51, y=51, z=0:5, type=\"scatter3d\", mode=\"lines\", \n#   #             line = list(width = 10, color=\"red\"), name=\"Space(x)\", \n#   #           hoverinfo=\"none\", showlegend = FALSE) %>%\n#   layout(dragmode = \"turntable\", title = \"ON Kime-Surface/Kime-Series at a fixed voxel location\",\n#          scene = list(xaxis = x, yaxis = y, zaxis = z), showlegend = FALSE)",
      "line_count": 119
    },
    {
      "section": "Curvature",
      "code": "u <- seq(from = 0, to = 2*pi, by = ((2*pi - 0)/(200 - 1)))\nv <- seq(from = 0, to = pi, by = ((pi - 0)/(200 - 1)))\n# rendering (u,v) parametric surfaces requires x,y,z arguments to be 2D arrays\n# In out case, the three coordinates have to be 200*200 parameterized tensors/arrays\nx1 = cos(u) %o% sin(v)     # x = \\cos u\\sin v \ny1 = sin(u) %o% sin(v)     # y = \\sin u\\sin v\nz1 = rep(1,length(u)) %o% cos(v)  # z = 1*cos(v)\n\n# p <- plot_ly(hoverinfo=\"none\", showscale = FALSE) %>%\n#   add_trace(x = ~x1, y = ~y1, z = ~z1, type = 'surface', opacity=0.5, visible=T) %>%\n#   layout(title = \"Spherical Surface Example\", showlegend = FALSE)\n# p\n\n\nt <- 1:length(u)\n# Curve 1\ncurveS_x <- cos(u[t]) * sin(v[t])\ncurveS_y <- sin(u[t]) * sin(v[t])\ncurveS_z <- cos(v[t])\n# plot_ly( x=~curveS_x, y=~curveS_y, z=~curveS_z,\n#           type=\"scatter3d\", mode=\"lines\")\n# Curve 2\ncurveP_x <- tanh(t/5) * cos(t/5)\ncurveP_y <- tanh(t/5) * sin(t/5)\ncurveP_z <- 1/cosh(t/5)\n\n## Meridian\ncurveMer_x = cos(0) * sin(v)     # x = \\cos u\\sin v \ncurveMer_y = sin(0) * sin(v)     # y = \\sin u\\sin v\ncurveMer_z = cos(v)  # z = 1*cos(v)\n\n## Parallel\ncurvePar_x = cos(u) * sin(1)     # x = \\cos u\\sin v \ncurvePar_y = sin(u) * sin(1)     # y = \\sin u\\sin v\ncurvePar_z = cos(1)              # z = 1*cos(v)\n\n# Project Curves/paths onto 3D Kime-surface Plot\nplot_ly(x = ~x1, y = ~y1, z = ~z1, type = 'surface', opacity=0.5, visible=T) %>% \n    # Add Curve 1 \n    add_trace(x=~curveS_x, y=~curveS_y, z=~curveS_z,\n         type=\"scatter3d\", mode=\"lines\", line=list(width=20), name=\"Curve 1\") %>%\n    # Add Curve 2\n    add_trace(x=~curveP_x, y=~curveP_y, z=~curveP_z,\n         type=\"scatter3d\", mode=\"lines\", line=list(width=20), name=\"Curve 2\") %>%\n    # Add Meridian\n    add_trace(x=~curveMer_x, y=~curveMer_y, z=~curveMer_z,\n         type=\"scatter3d\", mode=\"lines\", line=list(width=20), name=\"Meridian\") %>%\n    # Add Parallel\n    add_trace(x=~curvePar_x, y=~curvePar_y, z=~curvePar_z,\n         type=\"scatter3d\", mode=\"lines\", line=list(width=20), name=\"Meridian\") %>%\n  layout(title = \"Spherical Surface Example\", showlegend = FALSE)",
      "line_count": 51
    }
  ]
}