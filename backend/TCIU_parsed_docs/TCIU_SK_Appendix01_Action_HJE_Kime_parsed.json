{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.417170",
    "total_sections": 11,
    "total_code_chunks": 11,
    "total_tables": 1,
    "r_libraries": [
      "dplyr",
      "ggplot2",
      "grid",
      "gridExtra",
      "patchwork",
      "plotly",
      "purrr",
      "tidyr",
      "viridis"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Time Complexity, Inferential uncertainty and Spacekime Analytics\"\nsubtitle: \"Action Principles, Hamiltonian-Jacobi Equation, and Kime Representation\"\nauthor: \"SOCR Team\"\ndate: \"`r format(Sys.time(),'%m/%d/%Y')`\"\noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 3\n    toc_float:\n      collapsed: false\n      smooth_scroll: true\n    code_folding: hide\n  word_document:\n    toc: true\n    toc_depth: '3'\nheader-includes:\n  - \\usepackage{amsmath}\n  - \\usepackage{amssymb}\n  - \\usepackage{physics}\n  - \\usepackage{mathrsfs}\n\n\nLet's explore the connections between mathematical and physical interconnections \nbetween several fundamental concepts in theoretical physics: the action principle,\nfunctional derivatives, group generators, distribution actions, analytic continuation,\nand energy conservation laws.",
      "word_count": 90
    },
    {
      "title": "The Action Principle in Classical Mechanics",
      "content": "The *action* $S$ is defined as the time integral of the Lagrangian $L$ over the\npath of a system from an initial time $t_1$ to a final time $t_2$\n\n$$S[q] = \\int_{t_1}^{t_2} L(q(t), \\dot{q}(t), t) \\, dt ,$$\n\nwhere $q(t)$ represents generalized coordinates and $\\dot{q}(t)$ represents their time derivatives.\n\nFor a classical mechanical system with $n$ degrees of freedom, the Lagrangian is\n\n$$L(q_1, \\ldots, q_n, \\dot{q}_1, \\ldots, \\dot{q}_n, t) = T(\\dot{q}_1, \\ldots, \\dot{q}_n) - V(q_1, \\ldots, q_n, t)$$\n\nwhere $T$ is the kinetic energy and $V$ is the potential energy of the system.\n\n## Hamilton's Principle of Least Action\n\nHamilton's principle states that the actual path taken by a physical system between\ntwo fixed configurations is the one that makes the action *stationary* (typically a minimum), i.e., $\\delta S[q] = 0$,\nwhere $\\delta$ denotes a *variation* of the path while keeping the endpoints fixed.\n\n## Euler-Lagrange Equations\n\nThe condition $\\delta S = 0$ leads to the Euler-Lagrange equations, i.e.,\nthe equations of motion for the system\n\n$$\\frac{\\partial L}{\\partial q_i} - \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}_i}\\right) = 0, \\quad i = 1, \\ldots, n .$$\n\nFor a particle of mass $m$ moving in a potential $V(\\vec{r})$, with $\\vec{r} = (x, y, z)$, the Lagrangian is\n\n$$L = \\frac{1}{2}m(\\dot{x}^2 + \\dot{y}^2 + \\dot{z}^2) - V(x, y, z) .$$\n\nApplying the Euler-Lagrange equations yields Newton's second law $m\\ddot{\\vec{r}} = -\\vec{\\nabla}V(\\vec{r})$.",
      "word_count": 225
    },
    {
      "title": "Functional Derivatives of the Action",
      "content": "The *functional derivative* $\\frac{\\delta S}{\\delta q(t)}$ generalizes the \nconcept of partial derivatives to functionals and measures how the action \nchanges when the path $q(t)$ is perturbed by an infinitesimal amount $\\delta q(t)$.\nGIven a *functional* $F[q] = \\int_{t_1}^{t_2} f(q(t), \\dot{q}(t), t) \\, dt$, the functional derivative is \n\n$$\\frac{\\delta F}{\\delta q(t)} = \\frac{\\partial f}{\\partial q} - \\frac{d}{dt}\\left(\\frac{\\partial f}{\\partial \\dot{q}}\\right)$$\n\nThe Euler-Lagrange equations can be rewritten in terms of functional derivatives\n\n$$\\frac{\\delta S}{\\delta q_i(t)} = 0, \\quad i = 1, \\ldots, n ,$$\n\nwhich is a compact form emphasizing that the physical path is one where the action is stationary with respect to all possible variations.\n\nThe functional derivative of the action is related to the generalized force $Q_i$ \nacting on the system $Q_i = \\frac{\\delta S}{\\delta q_i(t)}$.\nWhen the system follows the physical path, these generalized forces vanish, \nindicating equilibrium in the variational sense.",
      "word_count": 143
    },
    {
      "title": "Conservation Laws and Noether's Theorem",
      "content": "Noether's theorem establishes that each continuous symmetry of the action corresponds\nto a conservation law. For time-translation symmetry, the conserved quantity is energy.\nWhen the Lagrangian does not explicitly depend on time \n($\\frac{\\partial L}{\\partial t} = 0$), the energy (Hamiltonian) $H$ is conserved, i.e.,\n\n$$H = \\sum_{i=1}^{n} \\dot{q}_i \\frac{\\partial L}{\\partial \\dot{q}_i} - L = \\text{constant} .$$\n\nThe Hamiltonian is obtained from the Lagrangian via a *Legendre transformation*\n\n$$H(q, p, t) = \\sum_{i=1}^{n} p_i \\dot{q}_i - L(q, \\dot{q}, t) ,$$\n\nwhere the generalized momenta are $p_i = \\frac{\\partial L}{\\partial \\dot{q}_i}$.\n\n## Hamilton's Equations of Motion\n\nFrom the Hamiltonian, we can derive Hamilton's canonical equations\n\n$$\\dot{q}_i = \\frac{\\partial H}{\\partial p_i}, \\quad \\dot{p}_i = -\\frac{\\partial H}{\\partial q_i},$$\nwhich represent an alternative formulation to the *Euler-Lagrange equations.*\n\n## The Energy-Time Relation\n\nFor systems with time-translation symmetry, the Hamiltonian generates time evolution via\n\n$$\\frac{d}{dt}f(q, p, t) = \\{f, H\\} + \\frac{\\partial f}{\\partial t},$$\n\nwhere $\\{f, H\\}$ is the *Poisson bracket*,\n\n$$\\{f, H\\} = \\sum_{i=1}^{n} \\left(\\frac{\\partial f}{\\partial q_i}\\frac{\\partial H}{\\partial p_i} - \\frac{\\partial f}{\\partial p_i}\\frac{\\partial H}{\\partial q_i}\\right) .$$",
      "word_count": 171
    },
    {
      "title": "Group Theory and Generators in Physics",
      "content": "A *Lie group* $G$ is a continuous group that is also a differentiable manifold \nwhere the *tangent space* at the *identity element* forms a Lie algebra $\\mathfrak{g}$.\nFor a one-parameter subgroup $g(t) \\in G$, the *generator* $X \\in \\mathfrak{g}$ is\n\n$$X = \\left.\\frac{d}{dt}g(t)\\right|_{t=0} .$$\n\n*Generators* of symmetry transformations correspond to conserved quantities in physical systems, e.g,. \n\n - *Time translations*: Energy (Hamiltonian) $H$\n - *Spatial translations*: Linear momentum $\\vec{P}$\n - *Rotations*: Angular momentum $\\vec{L}$\n\nSymbolically, if $U(g)$ is a unitary representation of a Lie group element $g$, and\n$X$ is the corresponding generator, then $U(g) = e^{iXt}$.\nIn *classical mechanics*, generators form a Lie algebra under the *Poisson bracket*,\ni.e., the components of angular momentum satisfy\n\n$$\\{L_i, L_j\\} = \\sum_{k=1}^{3} \\epsilon_{ijk} L_k ,$$\n\nwhere $\\epsilon_{ijk}$ is the Levi-Civita symbol.\nIn *quantum mechanics*, the Poisson bracket corresponds to the commutator\n\n$$[L_i, L_j] = i\\hbar \\sum_{k=1}^{3} \\epsilon_{ijk} L_k .$$\nIn essence, the Poisson bracket is the realization of the classical limit of \nthe quantum commutator\n\n$$\\lim_{\\hbar \\to 0} \\frac{1}{i\\hbar}[\\hat{A}, \\hat{B}] = \\{A, B\\} .$$\n\n{\\bf{Theorem}} [Noether's theorem in terms of generators] Let $G$ be a generator \nof a symmetry transformation that leaves the action invariant, then $G$ is a \nconserved quantity $\\frac{dG}{dt} = 0$.",
      "word_count": 201
    },
    {
      "title": "Distribution Action and Path Integrals",
      "content": "In quantum mechanics, the *transition amplitude between states* is given by \nFeynman's path integral\n\n$$\\langle q_f, t_f | q_i, t_i \\rangle = \\int \\mathcal{D}q \\, e^{\\frac{i}{\\hbar}S[q]},$$\n\nwhere $\\mathcal{D}q$ represents integration over all possible paths connecting $(q_i, t_i)$ to $(q_f, t_f)$.\nThe probability amplitude $e^{\\frac{i}{\\hbar}S[q]}$ assigns a complex weight to each path, with the classical path corresponding to the stationary phase.\n\nMore rigorously, the path integral is defined as a limit\n\n$$\\int \\mathcal{D}q \\, e^{\\frac{i}{\\hbar}S[q]} = \\lim_{N \\to \\infty} \\left(\\frac{m}{2\\pi i \\hbar \\epsilon}\\right)^{N/2} \\int \\prod_{j=1}^{N-1} dq_j \\, \\exp\\left[\\frac{i}{\\hbar}\\sum_{j=0}^{N-1} \\epsilon L\\left(\\frac{q_{j+1}-q_j}{\\epsilon}, \\frac{q_{j+1}+q_j}{2}\\right)\\right] ,$$\n\nwhere $\\epsilon = \\frac{t_f - t_i}{N}$ and $q_0 = q_i$, $q_N = q_f$.\n\n{\\bf{Definition}} [Distribution Action] The *distribution action* extends the concept\nof action to encompass statistical distributions over paths. In statistical field theory, a *partition function* is\n\n$$Z = \\int \\mathcal{D}\\phi \\, e^{-S_E[\\phi]},$$\n\nwhere $S_E$ is the *Euclidean action obtained via analytic continuation.*\n\nThe *distribution action* treats the action as a functional that assigns \nprobabilities (or probability amplitudes) to different field configurations.",
      "word_count": 164
    },
    {
      "title": "Analytic Continuation",
      "content": "Analytic continuation extends a function from a subset of its domain to a larger \ndomain, preserving its analytic properties. A function $f(z)$ is analytic at a point\n$z_0$ if it is differentiable in a neighborhood of $z_0$.\nWhen a pair of analytic functions $f(z)$ and $g(z)$ agree on a set with an \naccumulation point, then $f(z) = g(z)$ throughout their domains of analyticity.\n\nThe *Wick rotation* is a specific analytic continuation from *real time* $t$ \n(event order) to *purely imaginary time* $\\tau = it$. Under this transformation,\nthe Minkowski metric becomes Euclidean\n\n$$ds^2 = -dt^2 + d\\vec{x}^2 \\to d\\tau^2 + d\\vec{x}^2 .$$\n\nThe (general) *action* transforms as $S = \\int dt \\, L \\to iS_E = i\\int d\\tau \\, L_E$, \nwhere $S_E$ is the *Euclidean action* and the path integral becomes\n\n$$\\int \\mathcal{D}\\phi \\, e^{\\frac{i}{\\hbar}S[\\phi]} \\to \\int \\mathcal{D}\\phi \n\\, e^{-\\frac{1}{\\hbar}S_E[\\phi]} .$$\n\nThis transforms *oscillatory integrals* into *exponentially decaying* integrals\nthat are more amenable to numerical and analytical techniques.\n\nUnder eriodic boundary conditions \n$\\phi(\\tau) = \\phi(\\tau + \\beta)$, the analytic continuation $t \\to i\\tau$ \nconnects quantum field theory to thermal field theory, where \n$\\beta = \\frac{1}{k_B T}$.\nThe *partition function* of a quantum system at temperature $T$ is\n\n$$Z = \\text{Tr}(e^{-\\beta \\hat{H}}) = \\int \\mathcal{D}\\phi \\, e^{-S_E[\\phi]},$$\nwhere the functional integration is performed over fields satisfying periodic boundary conditions in *imaginary time.*\n\nAnalytic continuation is useful for deriving dispersion relations that\nconnect the real and imaginary parts of response functions through the \nKramers-Kronig relations\n\n$$\\text{Re}\\chi(\\omega) = \\frac{1}{\\pi}\\mathcal{P}\\int_{-\\infty}^{\\infty} \\frac{\\text{Im}\\chi(\\omega')}{\\omega' - \\omega} d\\omega' ,$$\n\n$$\\text{Im}\\chi(\\omega) = -\\frac{1}{\\pi}\\mathcal{P}\\int_{-\\infty}^{\\infty} \\frac{\\text{Re}\\chi(\\omega')}{\\omega' - \\omega} d\\omega' ,$$\n\nwhere $\\mathcal{P}$ denotes the principal value. These relations follow from the analyticity of response functions in the upper half of the complex plane, which is a consequence of causality.",
      "word_count": 288
    },
    {
      "title": "The Action as a Central Concept",
      "content": "The action principle provides as a unifying framework for classical and quantum physics\n\n - In *classical mechanics*, it yields the equations of motion through the principle of stationary action.\n - In *quantum mechanics*, it determines probability amplitudes through the path integral.\n - In *statistical mechanics*, the Euclidean action (after analytic continuation) determines equilibrium probabilities.\n - In *spacekime*, the action of the kime-phase distribution, $\\Phi$, on kime-test functions, see [TCIU Resources](https://www.socr.umich.edu/TCIU/HTMLs/Chapter6_TCIU_KimeInterpretation_of_QuantumMechanics.html). This is still *work in progress* ...\n\nThe *action of the kime phase distribution* $\\Phi_t$ on *kime-test functions* $\\psi$ is\ndefined by\n$$\\langle \\Phi_t, \\psi \\rangle = \\int_{-\\pi}^{\\pi} \\psi(t e^{i\\theta}) p_\\Phi(\\theta) \\, d\\theta .$$\nThis distribution action on test-functions generalizes measurable quantities by focusing on their functional properties rather than individual values of \\( \\theta \\).\nThis analytic representation emphasizes the role of smoothing and averaging over phase, which parallels the experimental approach of repeated draws of a random variable. The former is more abstract but better suited to describe underlying kime properties, where as the latter is more useful for data-driven estimation, prediction and dynamical quantification.\n\nThe extension from *global* to *local symmetries* introduces gauge fields and leads to gauge theories. \nFor a field theory with global symmetry under a transformation $\\phi \\to \\phi + \\delta\\phi$, requiring local invariance under $\\phi \\to \\phi + \\delta\\phi(x)$ necessitates introducing a gauge field $A_\\mu(x)$ with transformation properties that compensate for the local nature of the symmetry.\n\nThe *gauge-invariant action* takes the form\n$$S = \\int d^4x \\left[\\mathcal{L}_{\\text{matter}}(\\phi, D_\\mu\\phi) - \\frac{1}{4}F_{\\mu\\nu}F^{\\mu\\nu}\\right] ,$$\n\nwhere $D_\\mu = \\partial_\\mu - igA_\\mu$ is the *covariant derivative* and \n$F_{\\mu\\nu} = \\partial_\\mu A_\\nu - \\partial_\\nu A_\\mu + ig[A_\\mu, A_\\nu]$ \nis the *field strength tensor.*\n\n{\\it{Geometric Interpretation}}: The action principle can be formulated in terms of differential geometry\n\n - The *configuration space* of a system forms a manifold $\\mathcal{M}$.\n - The Lagrangian defines a *one-form* $\\mathcal{L}dt$ on the tangent bundle $T\\mathcal{M}$.\n - The *action* is the integral of this one-form along a path in $T\\mathcal{M}$.\n - The Euler-Lagrange equations express the condition that the *path is an extremal* of this integral.\n\nIn general relativity, the *Einstein-Hilbert action* is\n$S_{EH} = \\frac{1}{16\\pi G}\\int d^4x \\sqrt{-g}R ,$\nwhere $g$ is the determinant of the metric tensor $g_{\\mu\\nu}$ and $R$ is the Ricci scalar.\n\nThe concepts of *action*, *functional derivatives*, *group generators*, \n*distribution actions*, analytic continuation, and energy are interconnected and their\nfurther integration with complex-time (kime) representation may be valuable. The action principle appears as the central unifying concept to build upon.\nThe interplay between physical principles and mathematical structures, demonstrate\nhow symmetry, geometry, and variational principles come together describe the fundamental laws of nature. The main question is how to connect the statistical and data-science formulation of complex time where the repeated sampling of the \ncontrolled processes provides a mechanism to obtain a higher-dimensional representation\nthat facilitates probing the unobservable kime-phase distributions.",
      "word_count": 471
    },
    {
      "title": "Experiments and Simulations",
      "content": "## Experiment 1: The Principle of Stationary Action (Harmonic Oscillator)\n\nIn this experiment, we showcase Hamilton's principle of least action using a simple harmonic oscillator. We explore how different paths connecting the same initial and\nfinal points have different values of the action, and how the classical path \ncorresponds to the path of stationary action.\n\nTo start we'll use these basic functions.\n\n\nThe first interactive simulation allows how various parameters affect the action\nand observe the principle of stationary action in practice.\nThe simulation above demonstrates several key aspects of the action principle:\n\n - *Principle of Stationary Action*: The classical path (*green*) corresponds to the\npath with the minimum action value among all paths connecting the same endpoints.\n\n - *Variational Principle*: As we move away from the classical path (with increasing perturbation amplitude), the action increases, demonstrating that the classical path makes the action stationary.\n - *Physical Meaning*: The color gradient in the perturbation paths visualizes how far each path deviates from optimality in terms of action. Paths closer to the classical one (bluer) have action values closer to the minimum.\n\n\n## Experiment 2: Group Generators and Conservation Laws\n\nThis experiment shows Noether's theorem, connecting symmetries to conservation laws\nand shows how time-translation symmetry leads to energy conservation, and how spatial\nsymmetries relate to momentum conservation.\n\n - Harmonic Oscillator (Time-Translation Symmetry):\n   - The Lagrangian has no explicit time dependence\n   - The generator of time translations is the Hamiltonian/energy\n   - Energy is perfectly conserved as shown by the flat red line\n\n\n - Free Particle (Spatial-Translation Symmetry):\n   - The system is invariant under spatial translations\n   - The generator of spatial translations is momentum\n   - Momentum is conserved (constant purple line)\n\n\n - Particle in Gravity (Broken Time-Translation Symmetry):\n   - The potential energy depends on position, which changes with time\n   - Time-translation symmetry is broken\n   - Total energy is not conserved, as seen in the varying red line.\n\n\n\n\n## Experiment 3: Path Integrals and Quantum Tunneling\n\nThis experiment visualizes the quantum path integral approach by simulating quantum\ntunneling through a potential barrier and shows the classical path as just one\ncontribution to the quantum amplitude, and how multiple paths contribute to quantum\nphenomena.\n\nThe path integral formulation of quantum mechanics shows:\n\n - *Multiple Paths*: Unlike classical mechanics where only one path contributes, quantum mechanics considers all possible paths between initial and final states.\n - *Complex Amplitudes*: Each path contributes with a complex amplitude $e^{iS/\\hbar}$. The distribution of these amplitudes in the complex plane (bottom plot) shows how paths interfere.\n - *Quantum Tunneling*: Paths that cross the potential barrier (middle plot) have non-zero probability amplitudes, demonstrating quantum tunneling - a phenomenon impossible in classical mechanics.\n - Role of $\\hbar$: The Planck's constant, $\\hbar$, controls the \"quantumness\" of the system. Smaller values make the system more classical, larger values enhance quantum effects.\n\n\n\n\n## Experiment 4: Analytic Continuation and Euclidean Path Integral\n\nThis experiment demonstrates how analytic continuation transforms oscillatory \npath integrals into more manageable Euclidean path integrals, facilitating both\nnumerical calculations and connections to statistical mechanics.\n\n\nThis final experiment demonstrates the power of analytic continuation in quantum\nmechanics, particularly when working with path integrals. The key insights include:\n\n 1. *Oscillatory vs. Damping Behavior*: In the Minkowski formulation, the phase factor $e^{-S_E/\\hbar}$ oscillates rapidly, making numerical computation challenging. The Euclidean formulation, with its weight factor $e^{-S_E/\\hbar}$, provides exponential damping that emphasizes paths near the classical solution.\n\n 2. *Statistical Connection*: The Euclidean path integral has a direct interpretation as a statistical mechanical partition function. This connection allows techniques from statistical mechanics to be applied to quantum field theory.\n\n 3. *Numerical Advantages*: The Euclidean approach vastly improves numerical stability and convergence in path integral calculations, as shown in the weighted histogram of actions.\n\n 4. *Visualization of Quantum Behavior*: The plots illustrate how quantum paths distribute around the classical solution, with the Euclidean weighting providing a natural importance sampling for the most relevant paths.\n\n 5. *Uncertainty Principle*: The spread in position values around the expectation demonstrates the quantum uncertainty inherent in the system.\n\nThe technique of analytic continuation via *Wick rotation* ($t \\to i\\tau$) is a cornerstone of modern quantum field theory and provides one of the most important connections between quantum mechanics and statistical physics.",
      "word_count": 696
    },
    {
      "title": "Hamiltonian-Jacobi Equation for the Action",
      "content": "Next we'll consider the *Lagrangian approach* based on the Poincaré one-form,\nthe *action*, $\\delta S=0$ and the *Hamiltonian approach* based on the Poincaré two-form yielding the weak (local) Noether invariants.\n\nThe Hamilton-Jacobi (HJ) equation provides a reformulation of classical mechanics\nthat bridges the gap between Hamiltonian mechanics and quantum mechanics. \nHJ equations focuse on the action $S$ as the fundamental quantity.\nStarting from Hamilton's principal function $S(q,t)$, defined as the action \nalong a classical trajectory ending at position $q$ at time $t$, the HJ equation\nemerges from a canonical transformation that trivializes the equations of motion.\nSymbolically, the Hamilton-Jacobi equation is\n\n$$\\frac{\\partial S}{\\partial t} + H\\left(q, \\frac{\\partial S}{\\partial q}, t\\right) =0.$$\n\nwhere $H$ is the *Hamiltonian* of the system, $q$ represents *generalized coordinates*,\nand $\\frac{\\partial S}{\\partial q}$ replaces the *canonical momentum* $p$.\n\nThis equation arises by defining a *type-2 generating function* $F_2(q,P,t) = S(q,t)$\nfor a canonical transformation $(q,p) \\rightarrow (Q,P)$ that makes the new \nHamiltonian $K(Q,P,t) = 0$, resulting in trivial dynamics where $Q$ and $P$ are constants.\n\nThe Hamilton-Jacobi equation has several properties\n\n 1. *Complete Integral*: A complete solution $S(q, \\alpha, t)$, where $\\alpha$ are integration constants, allows us to find all possible trajectories of the system.\n\n 2. *Action as a Generator*: The *action* $S$ serves as a generating function for canonical transformations that simplify the equations of motion.\n\n 3. *Connection to Wave Mechanics*: The HJ equation is the classical limit of the *Schrödinger equation* when $\\hbar \\rightarrow 0$. If we substitute $\\Psi = e^{iS/\\hbar}$ into the Schrödinger equation, the leading order term yields the HJ equation as $\\hbar \\rightarrow 0$.\n\n 4. *Eikonal Equation*: In optics, the HJ equation reduces to the eikonal equation, connecting mechanics with geometric optics $\\left(\\nabla S\\right)^2 = n^2(q)$, where $n$ is the refractive index.\n\nBelow is a simulation showing the Hamilton-Jacobi solutions.\n\n\nThis Hamilton-Jacobi equation simulation shows\n\n 1. Colored surfaces representing solutions to the HJ equation for a free particle with a *different momentum* (integration constant).\n\n 2. The black lines show the *classical trajectories*, which follow paths of constant momentum along the action surfaces.\n\n 3. The *gradient of the action* $\\nabla S$ gives the momentum at each point, while the time derivative $\\partial S/\\partial t$ relates to the energy.\n\n 4. The complete integral of the HJ equation gives us a family of solutions parameterized by integration constants (different momenta in this case).\n\n## Lagrangian Approach and the Poincaré One-Form\n\nThe Lagrangian formulation of mechanics is elegantly recast in terms of \ndifferential geometry through the Poincaré one-form, providing a deep geometric\nunderstanding of the principle of least action.\n\nThe *Poincaré one-form* $\\theta$ on the cotangent bundle $T^*Q$ of the \nconfiguration manifold $Q$ is given in local coordinates by $\\theta = p_i dq^i$,\nwhere $p_i$ are the *canonical momenta* and $q^i$ are the *generalized coordinates.*\nThe *Lagrangian* $L(q, \\dot{q}, t)$ defines a map from the tangent bundle $TQ$ \nto the reals. The *action* $S$ is the integral of the Lagrangian over a path\n$\\gamma$ in the extended configuration space\n$S[\\gamma] = \\int_{\\gamma} L(q, \\dot{q}, t) \\, dt$.\n\nIn terms of the Poincaré one-form, the action can be written as\n$$S[\\gamma] = \\int_{\\gamma} \\left( \\theta - H \\, dt \\right) ,$$\nwhere $H$ is the Hamiltonian.\n\nThe *principle of stationary action* states that the physical path $\\gamma$ makes \nthe action $S[\\gamma]$ stationary with respect to variations that keep the endpoints\nfixed $\\delta S[\\gamma] = 0$. Geometrically, this variational principle reflects\npaths along which the integral of the Poincaré one-form is stationary. \nThe resulting Euler-Lagrange equations are\n\n$$\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}^i}\\right) - \\frac{\\partial L}{\\partial q^i} = 0 .$$\n\nThe geometric interpretation of this approach includes\n\n 1. The Poincaré one-form $\\theta$ provides a natural pairing between velocities and momenta.\n\n 2. The exterior derivative of $\\theta$ gives the symplectic two-form $\\omega = d\\theta$, which is invariant under Hamiltonian flow.\n\n 3. The action principle selects those paths for which the integral of $\\theta - H dt$ is stationary.\n\nThe following simulation demonstrated the *action principle*.\n\n\nIn this principle of stationary action simulation, we use a pendulum experiment to\nshow \n\n 1. The *black lines* representing the classical paths corresponding to the action stationary.\n\n 2. The *colored lines* represent perturbed paths with the same endpoints, with colors indicating the action value (blue for lower, red for higher).\n\n 3. The *bar chart* shows clearly that the classical path minimizes the action compared to the perturbed paths.\n\n 4. The principle $\\delta S = 0$ is illustrated as small perturbations away from the classical path increase the action value.\n\n## Hamiltonian Approach and the Poincaré Two-Form\n\nThe Hamiltonian formulation builds upon the Poincaré one-form by taking its exterior derivative to obtain the symplectic two-form, which provides the foundation for understanding phase space, canonical transformations, and Noether's theorem.\n\nThe Poincaré two-form $\\omega$ is obtained by taking the *exterior derivative*\nof the Poincaré one-form $\\theta$, i.e., $\\omega = d\\theta = dp_i \\wedge dq^i$.\nThis symplectic two-form has several properties\n\n 1. It is *non-degenerate*, allowing us to define a unique Hamiltonian vector field $X_H$ corresponding to any function $H$ on phase space.\n\n 2. It is *closed* ($d\\omega = 0$), which is a necessary condition for Liouville's theorem on the preservation of phase space volume.\n\n 3. It defines a *Poisson bracket structure* on phase space:\n\n$$\\{F, G\\} = \\omega(X_F, X_G) = \\frac{\\partial F}{\\partial q^i}\\frac{\\partial G}{\\partial p_i} - \\frac{\\partial F}{\\partial p_i}\\frac{\\partial G}{\\partial q^i}.$$\n\nThe Hamiltonian vector field $X_H$ defines a flow on phase space that preserves the symplectic structure $i_{X_H}\\omega = dH$, where $i_{X_H}$ denotes the interior product with $X_H$.\nA function $F$ on phase space is a conserved quantity if it is invariant along the Hamiltonian flow $\\frac{dF}{dt} = \\{F, H\\} = 0$.\nNoether's theorem establishes a deep connection between symmetries and conserved quantities:\n\n 1. *Strong Version*: If the Hamiltonian is invariant under a continuous symmetry transformation, there exists a corresponding conserved quantity.\n\n 2. *Weak (Local) Version*: Even when the symmetry is only local or the Hamiltonian is not strictly invariant, we can still identify quantities that are conserved to first order or within certain regions of phase space.\n\nThese \"weak Noether invariants\" are crucial in systems with approximate symmetries or gauge theories, where they lead to constraints and generate gauge transformations.\n\nThis demonstration shows symplectic structures and conservation laws.\n\n\nThe Hamiltonian simulation with Noether invariants shows\n\n 1. *Phase Space Structure*: The *top plot* shows trajectories in configuration space for a central force system (like a gravitational or Coulomb potential). The circular and elliptical orbits arise from the same Hamiltonian with different initial conditions.\n\n 2. *Conservation Laws*: The *middle plots* demonstrate the conservation of energy and angular momentum. Angular momentum is the Noether invariant corresponding to rotational symmetry of the central force potential.\n\n 3. *Symplectic Structure*: The *bottom plot* shows a Poincaré section, which provides a means to visualize the phase space structure by recording points where trajectories intersect a chosen plane (in this case, when $q_2= 0$ with $p_2 > 0$). The invariant curves in the Poincaré section reflect the preservation of the symplectic form and phase space volume (Liouville's theorem).\n\nThe preservation of these invariants, even in this discrete numerical simulation,\ndemonstrates how the symplectic structure fundamentally constrains the dynamics\nin phase space.\n\n\n## Complex Time (Kime) and Analytic Continuation\n\nComplex time, or kime ($\\kappa$), is defined as $\\kappa = t e^{i\\theta}$, where \n$t$ is the standard time parameter and $\\theta$ is a random kime-phase distributed\naccording to a phase distribution $\\Phi(\\theta)$ supported on $[-\\pi, \\pi)$. \nThis formulation extends time into the complex plane, providing a mechanism for\nconnecting quantum and classical mechanics through regularizing singular potentials.\n\nComplex time appears in several contexts in theoretical physics\n\n 1. *Kime-Phase Distribution*: The phase $\\theta$ is sampled from a distribution $\\Phi(\\theta)$ supported on $[-\\pi, \\pi)$, characterizing the stochastic nature of the complex time extension.\n\n 2. *Wick Rotation*: Traditionally viewed as the transformation $t \\to i\\tau$ (rotating time into the imaginary axis), this can be understood through kime as a special case where $\\theta = \\pi/2$. This transforms between Minkowski and Euclidean space-time, and the action transforms as $S_M \\to iS_E$, where $S_M$ is the Minkowski action and $S_E$ is the Euclidean action.\n\n 3. *Path Integrals*: In the path integral formulation, the quantum amplitude is $\\langle q_f, t_f | q_i, t_i \\rangle = \\int \\mathcal{D}q \\, e^{iS[q]/\\hbar}$. When examined through the kime formulation with appropriate phase distribution $\\Phi(\\theta)$, this allows for a more general analysis beyond the standard Wick rotation.\n\n 4. *Analytic Continuation of Classical Trajectories*: Classical trajectories can be extended into the complex plane via kime, allowing for the description of classically forbidden processes like tunneling, with the phase distribution $\\Phi(\\theta)$ determining the probability of various tunneling pathways.\n\nThe Hamilton-Jacobi equation can be analytically continued into complex time\n\n$$\\frac{\\partial S}{\\partial \\kappa} + H\\left(q, \\frac{\\partial S}{\\partial q}, \\kappa\\right) = 0,$$\n\nwhere $\\kappa = t e^{i\\theta}$ is the complex time variable with $\\theta \\sim \\Phi(\\theta)$.\n\nComplex-time trajectories with stochastic phase distributions provide solutions that connect classical turning points, enabling\n\n 1. *Stochastic WKB Approximation*: Improved accuracy in semiclassical approximations by incorporating phase distribution $\\Phi(\\theta)$\n 2. *Distributed Instantons*: Nonperturbative tunneling solutions with phase-dependent pathways\n 3. *Extended Resurgence Theory*: Connection between perturbative and nonperturbative effects through phase-distribution-weighted contributions\n\nHere is a quantum tunneling simulation using complex time.\n\n\nThis simulation illustrates quantum tunneling through a double-well potential using complex time analysis. In the context of the kime representation ($\\kappa = t e^{i\\theta}$), we can interpret this as follows\n\n 1. *Potential Landscape*: The *top plot* shows the double-well potential with an energy level (red dashed line) below the barrier height. Classical motion is confined to either the left or right well, bounded by turning points (blue dots). This represents the system configuration in purely real time.\n\n 2. *Complex Time Trajectory*: The *middle plot* shows a complex-time trajectory connecting the two classically allowed regions. In the kime framework, this represents a path where the phase $\\theta$ varies from 0 (real time) to values approaching $\\pi/2$ (imaginary time) for tunneling, and back to 0. This trajectory is a particular realization from the phase distribution $\\Phi(\\theta)$.\n\n3. *Projections*: The *bottom plots* show projections of the trajectory onto the real and imaginary time planes, highlighting how the kime-phase $\\theta$ modulates between classical motion ($\\theta \\approx 0$) and quantum tunneling ($\\theta \\approx \\pi/2$).\n\nThe tunneling probability, calculated from the imaginary action along the complex path, represents an integral over the possible phase paths weighted by the distribution $\\Phi(\\theta)$. In more general treatments, the phase distribution $\\Phi(\\theta)$ would determine an ensemble of possible tunneling pathways, each with its own probability contribution.\n\n## Connections and Unifying Framework\n\nThese four mathematical frameworks—Hamilton-Jacobi theory, Lagrangian formalism with the Poincaré one-form, Hamiltonian mechanics with the symplectic two-form, and complex time analysis—provide a cohesive picture of classical and quantum mechanics. Here's how they interconnect\n\nThe Hamilton-Jacobi equation\n$\\frac{\\partial S}{\\partial t} + H\\left(q, \\frac{\\partial S}{\\partial q}, t\\right) = 0$\nbecomes the quantum Hamilton-Jacobi equation when we write the wavefunction as $\\Psi = e^{iS/\\hbar}$ and substitute into the Schrödinger equation\n\n$$\\frac{\\partial S}{\\partial t} + H\\left(q, \\frac{\\partial S}{\\partial q}, t\\right) = \\frac{\\hbar^2}{2m} \\frac{1}{\\sqrt{\\rho}} \\nabla^2 \\sqrt{\\rho},$$\n\nwhere $\\rho = |\\Psi|^2$ is the probability density. The right-hand term, which vanishes as $\\hbar \\to 0$, is known as the \"quantum potential\" and accounts for quantum effects.\n\nThe Poincaré one-form $\\theta = p_i dq^i$ generates the symplectic two-form $\\omega = d\\theta = dp_i \\wedge dq^i$ through exterior differentiation. The action principle involving the one-form, \n$\\delta \\int \\left( \\theta - H \\, dt \\right) = 0$, leads to Hamilton's equations, \nwhich preserve the symplectic two-form\n\n$$\\frac{dq^i}{dt} = \\frac{\\partial H}{\\partial p_i}, \\quad \\frac{dp_i}{dt} = -\\frac{\\partial H}{\\partial q^i}.$$\n\nEextending time into the complex plane, the action becomes a complex-valued function. The paths of stationary action in complex time can describe both classical dynamics and quantum tunneling. The transformation between Minkowski and Euclidean formulations (Wick rotation) connects quantum mechanics to statistical mechanics through $Z = \\text{Tr}(e^{-\\beta H}) = \\int \\mathcal{D}q \\, e^{-S_E[q]/\\hbar}$, \nwhere $Z$ is the partition function and $\\beta = 1/k_BT$ is the inverse temperature.\n\nBelow is a unified phase space simulation with quantum corrections.\n\n\nthe graph illustrates the unified framework connecting classical and quantum mechanics\n\n 1. *Phase Space Evolution*: The *top row* shows phase space representations of a harmonic oscillator with increasing values of $\\hbar$: (1) classical ($\\hbar = 0$), perfect elliptical contours representing energy conservation; (2) semiclassical ($\\hbar = 0.2$), slightly modified contours due to quantum corrections; and (3) quantum ($\\hbar = 0.5$), more substantial deformation of phase space structure.\n\n 2. *Path Integration*: The *bottom plot *compares classical and quantum paths. While classical mechanics selects a single stationary path, quantum mechanics involves integration over neighboring paths, allowing phenomena like tunneling and interference.\n\nThe progressive deformation of phase space as $\\hbar$ increases demonstrates how \nquantum effects modify, but don't completely abolish, the underlying symplectic\nstructure of classical mechanics.\n\nTo summarize\n\n 1. *Hamilton-Jacobi Theory* gives us a powerful tool for solving mechanical problems by finding complete integrals, connecting classical mechanics to the WKB approximation in quantum mechanics.\n\n 2. *The Lagrangian Approach with the Poincaré One-Form* provides a geometric interpretation of the principle of stationary action, emphasizing the importance of the path itself.\n\n 3. *The Hamiltonian Approach with the Symplectic Two-Form* shifts focus to phase space and its invariant structure, revealing how symmetries lead to conservation laws through Noether's theorem.\n\n 4. *Complex Time Analysis* bridges quantum and classical regimes by extending dynamics into the complex plane, explaining tunneling phenomena and connecting quantum mechanics to statistical mechanics.",
      "word_count": 2216
    },
    {
      "title": "References",
      "content": "1. Goldstein, H., Poole, C., & Safko, J. (2002). *Classical Mechanics* (3rd ed.). Addison Wesley.\n\n 2. Peskin, M. E., & Schroeder, D. V. (1995). *An Introduction to Quantum Field Theory*. Westview Press.\n\n 3. Nakahara, M. (2003). *Geometry, Topology and Physics* (2nd ed.). Institute of Physics Publishing.\n\n 4. Weinberg, S. (1995). *The Quantum Theory of Fields, Volume 1: Foundations*. Cambridge University Press.\n\n 5. Zinn-Justin, J. (2021). *Path Integrals in Quantum Mechanics*. Oxford University Press.\n\n 6. Arnold, V. I. (1989). *Mathematical Methods of Classical Mechanics* (2nd ed.). Springer-Verlag.\n \n 7. Dinov, ID and Velev, MV (2021) *Data Science: Time Complexity, Inferential Uncertainty, and Spacekime Analytics*, De Gruyter (STEM Series), Berlin/Boston, ISBN 9783110697803 / 3110697807, DOI: 10.1515/9783110697827. \n \n 8. [Time Complexity and Inferencial Uncertainty (TCIU)](https://www.socr.umich.edu/TCIU/).\n \n <!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 215
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "  - \\usepackage{bm}\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "knitr::opts_chunk$set(echo = TRUE)\nlibrary(ggplot2)\nlibrary(dplyr)",
      "line_count": 3
    },
    {
      "section": "Experiments and Simulations",
      "code": "library(plotly)\nlibrary(purrr)\n\n# Core functions for our simulations\ncalculate_lagrangian <- function(x, v, m, k) {\n  # Lagrangian L = T - V = 0.5*m*v^2 - 0.5*k*x^2\n  L <- 0.5*m*v^2 - 0.5*k*x^2\n  return(L)\n}\n\ncalculate_action <- function(x, t, m, k) {\n  # Calculate velocity using central difference\n  dt <- t[2] - t[1]\n  v <- c(diff(x)/dt, (x[length(x)] - x[length(x)-1])/dt)\n  \n  # Compute Lagrangian at each point\n  L <- calculate_lagrangian(x, v, m, k)\n  \n  # Action is integral of L over time\n  S <- sum(L) * dt\n  return(S)\n}\n\n# Function to generate a path with perturbations\ngenerate_path <- function(t, omega, amplitude = 1, perturbation = NULL, \n                          pert_amplitude = 0, pert_frequency = 1) {\n  x_classical <- amplitude * cos(omega * t)\n  \n  if (!is.null(perturbation)) {\n    x <- x_classical + pert_amplitude * perturbation(pert_frequency * omega * t)\n  } else {\n    x <- x_classical\n  }\n  \n  return(x)\n}\n\n# Function to calculate action for multiple paths\ncalculate_actions_for_paths <- function(paths_list, t, m, k) {\n  # Use lapply and unlist instead of map_dbl to avoid dependency on purrr\n  actions <- unlist(lapply(paths_list, function(path) calculate_action(path, t, m, k)))\n  return(actions)\n}",
      "line_count": 43
    },
    {
      "section": "Experiments and Simulations",
      "code": "# Visualization of a simple harmonic oscillator action\n\n# # Parameters\n# m <- 1  # mass\n# k <- 1  # spring constant\n# omega <- sqrt(k/m)  # angular frequency\n# T <- 2*pi/omega  # period\n# \n# # Generate data for different paths\n# t <- seq(0, T, length.out=100)\n# x_classical <- cos(omega*t)  # classical path\n# x_perturbed1 <- cos(omega*t) + 0.2*sin(2*omega*t)  # perturbed path 1\n# x_perturbed2 <- cos(omega*t) + 0.4*sin(3*omega*t)  # perturbed path 2\n# \n# # Calculate actions\n# calculate_action <- function(x, t) {\n#   # Approximate velocities\n#   v <- c(diff(x)/diff(t), 0)\n#   \n#   # Lagrangian L = T - V = 0.5*m*v^2 - 0.5*k*x^2\n#   L <- 0.5*m*v^2 - 0.5*k*x^2\n#   \n#   # Action is integral of L over time\n#   S <- sum(L) * (t[2] - t[1])\n#   return(S)\n# }\n# \n# actions <- c(\n#   calculate_action(x_classical, t),\n#   calculate_action(x_perturbed1, t),\n#   calculate_action(x_perturbed2, t)\n# )\n# \n# # Create data frame for plotting\n# df <- data.frame(\n#   time = rep(t, 3),\n#   position = c(x_classical, x_perturbed1, x_perturbed2),\n#   path = rep(c(\"Classical\", \"Perturbed 1\", \"Perturbed 2\"), each=length(t))\n# )\n# \n# # Create plot\n# ggplot(df, aes(x=time, y=position, color=path)) +\n#   geom_line() +\n#   labs(title=\"Different Paths of a Harmonic Oscillator\",\n#        subtitle=paste(\"Classical path has stationary action S =\", round(actions[1], 2)),\n#        x=\"Time\", y=\"Position\") +\n#   theme_minimal()\n\n\n# Simulation parameters - user adjustable\nm <- 1.0  # mass\nk <- 2.0  # spring constant\nomega <- sqrt(k/m)  # angular frequency\nT <- 2*pi/omega  # period\nnum_points <- 200  # resolution of our simulation\nnum_paths <- 10  # number of perturbed paths to generate\n\n# Time points for simulation\nt <- seq(0, T, length.out = num_points)\n\n# Generate classical path\nx_classical <- generate_path(t, omega)\n\n# Generate perturbed paths with varying amplitudes\nperturbation_amplitudes <- seq(0.05, 0.5, length.out = num_paths)\npaths_list <- list()\npaths_list[[1]] <- x_classical  # First path is classical\n\nfor (i in 1:num_paths) {\n  # Add sine perturbation with varying amplitude and frequency\n  paths_list[[i+1]] <- generate_path(\n    t, omega, \n    perturbation = sin,\n    pert_amplitude = perturbation_amplitudes[i],\n    pert_frequency = 2\n  )\n}\n\n# Calculate action for each path\npath_names <- c(\"Classical\", paste(\"Perturbed\", 1:num_paths))\nactions <- calculate_actions_for_paths(paths_list, t, m, k)\n\n# Create data frame for plotting trajectories\ntrajectory_df <- map_dfr(1:(num_paths+1), function(i) {\n  data.frame(\n    time = t,\n    position = paths_list[[i]],\n    path = path_names[i],\n    action = actions[i]\n  )\n})\n\n# Create the trajectory plot\ntrajectory_plot <- plot_ly(height = 500) %>%\n  add_trace(data = trajectory_df %>% filter(path == \"Classical\"),\n            x = ~time, y = ~position, type = 'scatter', mode = 'lines',\n            name = 'Classical Path',\n            line = list(color = 'green', width = 3)) %>%\n  layout(title = \"Different Paths of a Harmonic Oscillator\",\n         xaxis = list(title = \"Time\"),\n         yaxis = list(title = \"Position\"),\n         hovermode = \"closest\")\n\n# Add perturbed paths with color gradient based on action value\nperturbed_only <- trajectory_df %>% filter(path != \"Classical\")\naction_range <- range(perturbed_only$action)\nnorm_actions <- (perturbed_only$action - action_range[1]) / (action_range[2] - action_range[1])\n\nfor (i in 1:num_paths) {\n  path_data <- perturbed_only %>% filter(path == paste(\"Perturbed\", i))\n  # Color from blue (close to classical) to red (far from classical)\n  color_val <- rgb(norm_actions[i*num_points], 0, 1-norm_actions[i*num_points])\n  \n  trajectory_plot <- trajectory_plot %>%\n    add_trace(data = path_data, x = ~time, y = ~position, \n              type = 'scatter', mode = 'lines',\n              name = paste0(path_data$path[1], \" (S = \", round(path_data$action[1], 2), \")\"),\n              line = list(color = color_val, width = 1.5))\n}\n\n# Plot the action values for each path\naction_df <- data.frame(\n  path = factor(path_names, levels = path_names),\n  action = actions\n)\n\naction_plot <- plot_ly(data = action_df, x = ~path, y = ~action, type = 'bar',\n                       marker = list(color = c('green', colorRampPalette(c('blue', 'red'))(num_paths)))) %>%\n  layout(title = \"Action Value for Each Path\",\n         xaxis = list(title = \"Path\"),\n         yaxis = list(title = \"Action Value\"),\n         showlegend = FALSE)\n\n# Display the plots\nsubplot(trajectory_plot, action_plot, nrows = 2, heights = c(0.7, 0.3)) %>%\n  layout(title = \"Principle of Stationary Action Demonstration\",\n         annotations = list(\n           list(\n             x = 0.5,\n             y = 1.05,\n             text = \"The classical path minimizes the action functional\",\n             showarrow = FALSE,\n             xref = \"paper\",\n             yref = \"paper\"\n           )\n         ))",
      "line_count": 146
    },
    {
      "section": "Experiments and Simulations",
      "code": "# Function to simulate a physical system with symmetries\nsimulate_system_with_symmetries <- function(t, initial_conditions, \n                                           params = list(m = 1, k = 1, g = 9.8),\n                                           system_type = \"harmonic\") {\n  \n  # Unpack initial conditions\n  x0 <- initial_conditions$x0\n  v0 <- initial_conditions$v0\n  \n  # Unpack parameters\n  m <- params$m\n  k <- params$k\n  g <- params$g\n  \n  # Define different system types\n  if (system_type == \"harmonic\") {\n    # Harmonic oscillator (time-translation symmetry)\n    x <- x0 * cos(sqrt(k/m) * t) + v0/sqrt(k/m) * sin(sqrt(k/m) * t)\n    v <- -x0 * sqrt(k/m) * sin(sqrt(k/m) * t) + v0 * cos(sqrt(k/m) * t)\n    \n    # Potential and kinetic energy\n    V <- 0.5 * k * x^2\n    T <- 0.5 * m * v^2\n    \n    # Total energy (should be conserved due to time symmetry)\n    E <- T + V\n    \n    return(data.frame(t = t, x = x, v = v, T = T, V = V, E = E))\n    \n  } else if (system_type == \"free_particle\") {\n    # Free particle (spatial translation symmetry)\n    x <- x0 + v0 * t\n    v <- rep(v0, length(t))\n    \n    # Momentum (should be conserved due to spatial symmetry)\n    p <- m * v\n    \n    # Kinetic energy\n    T <- 0.5 * m * v^2\n    \n    return(data.frame(t = t, x = x, v = v, p = p, T = T))\n    \n  } else if (system_type == \"gravity\") {\n    # Particle in gravity (broken time symmetry)\n    x <- x0 + v0 * t - 0.5 * g * t^2\n    v <- v0 - g * t\n    \n    # Potential and kinetic energy\n    V <- m * g * x\n    T <- 0.5 * m * v^2\n    \n    # Total energy (not conserved due to time-dependent potential)\n    E <- T + V\n    \n    return(data.frame(t = t, x = x, v = v, T = T, V = V, E = E))\n  }\n}\n\n# Time points for simulation\nt <- seq(0, 10, length.out = 200)\n\n# Initial conditions\ninitial_conditions <- list(x0 = 1, v0 = 0)\n\n# Simulate three different systems\nharmonic_data <- simulate_system_with_symmetries(t, initial_conditions, \n                                                params = list(m = 1, k = 2),\n                                                system_type = \"harmonic\")\n\nfree_particle_data <- simulate_system_with_symmetries(t, initial_conditions, \n                                                     params = list(m = 1),\n                                                     system_type = \"free_particle\")\n\ngravity_data <- simulate_system_with_symmetries(t, initial_conditions, \n                                               params = list(m = 1, g = 0.5),\n                                               system_type = \"gravity\")\n\n# Interactive plots for each system\nharmonic_plot <- plot_ly(harmonic_data, height = 400) %>%\n  add_trace(x = ~t, y = ~E, type = 'scatter', mode = 'lines', name = 'Total Energy',\n            line = list(color = 'red', width = 3)) %>%\n  add_trace(x = ~t, y = ~T, type = 'scatter', mode = 'lines', name = 'Kinetic Energy',\n            line = list(color = 'blue')) %>%\n  add_trace(x = ~t, y = ~V, type = 'scatter', mode = 'lines', name = 'Potential Energy',\n            line = list(color = 'green')) %>%\n  layout(title = \"Harmonic Oscillator (Time-Translation Symmetry)\",\n         xaxis = list(title = \"Time\"),\n         yaxis = list(title = \"Energy\"),\n         annotations = list(\n           list(\n             x = 5,\n             y = max(harmonic_data$E) * 1.1,\n             text = \"Energy is conserved due to time-translation symmetry\",\n             showarrow = FALSE\n           )\n         ))\n\nfree_particle_plot <- plot_ly(free_particle_data, height = 400) %>%\n  add_trace(x = ~t, y = ~p, type = 'scatter', mode = 'lines', name = 'Momentum',\n            line = list(color = 'purple', width = 3)) %>%\n  add_trace(x = ~t, y = ~T, type = 'scatter', mode = 'lines', name = 'Kinetic Energy',\n            line = list(color = 'blue')) %>%\n  layout(title = \"Free Particle (Spatial-Translation Symmetry)\",\n         xaxis = list(title = \"Time\"),\n         yaxis = list(title = \"Momentum/Energy\"),\n         annotations = list(\n           list(\n             x = 5,\n             y = max(free_particle_data$p) * 1.1,\n             text = \"Momentum is conserved due to spatial-translation symmetry\",\n             showarrow = FALSE\n           )\n         ))\n\ngravity_plot <- plot_ly(gravity_data, height = 400) %>%\n  add_trace(x = ~t, y = ~E, type = 'scatter', mode = 'lines', name = 'Total Energy',\n            line = list(color = 'red', width = 3)) %>%\n  add_trace(x = ~t, y = ~T, type = 'scatter', mode = 'lines', name = 'Kinetic Energy',\n            line = list(color = 'blue')) %>%\n  add_trace(x = ~t, y = ~V, type = 'scatter', mode = 'lines', name = 'Potential Energy',\n            line = list(color = 'green')) %>%\n  layout(title = \"Particle in Gravity (Broken Time-Translation Symmetry)\",\n         xaxis = list(title = \"Time\"),\n         yaxis = list(title = \"Energy\"),\n         annotations = list(\n           list(\n             x = 5,\n             y = min(gravity_data$E) * 0.9,\n             text = \"Energy is not conserved due to broken time-translation symmetry\",\n             showarrow = FALSE\n           )\n         ))\n\n# Display the plots\nsubplot(harmonic_plot, free_particle_plot, gravity_plot, nrows = 3) %>%\n  layout(title = \"Noether's Theorem: Symmetries and Conservation Laws\")",
      "line_count": 136
    },
    {
      "section": "Experiments and Simulations",
      "code": "# Function to calculate potential\ncalculate_potential <- function(x, barrier_height = 1, barrier_width = 1) {\n  # Double well potential with barrier\n  potential <- numeric(length(x))\n  \n  for (i in 1:length(x)) {\n    if (abs(x[i]) < barrier_width/2) {\n      potential[i] <- barrier_height\n    } else {\n      potential[i] <- 0.1 * (x[i]^2 - barrier_width^2)^2\n    }\n  }\n  \n  return(potential)\n}\n\n# Function to generate random paths for path integral\ngenerate_random_paths <- function(x_start, x_end, n_steps, n_paths, max_deviation = 0.5) {\n  paths <- matrix(0, nrow = n_paths, ncol = n_steps)\n  \n  # Linear path from start to end\n  straight_path <- seq(x_start, x_end, length.out = n_steps)\n  \n  for (i in 1:n_paths) {\n    # Start with straight path\n    current_path <- straight_path\n    \n    # Add random deviations, keeping endpoints fixed\n    deviations <- c(0, rnorm(n_steps-2, 0, max_deviation), 0)\n    paths[i,] <- current_path + deviations\n  }\n  \n  return(paths)\n}\n\n# Calculate quantum action (with ħ term)\ncalculate_quantum_action <- function(path, dt, m = 1, potential_fn, hbar = 1) {\n  n <- length(path)\n  dx <- diff(path)\n  v <- dx/dt\n  \n  # Kinetic energy\n  T <- 0.5 * m * v^2\n  \n  # Potential energy (average of adjacent points)\n  V <- potential_fn(path[-1]) # potential at midpoints\n  \n  # Quantum action includes i*ħ\n  S <- sum((T - V) * dt)\n  \n  return(S)\n}\n\n# Calculate quantum amplitude (complex)\ncalculate_amplitude <- function(action, hbar = 1) {\n  return(exp(1i * action / hbar))\n}\n\n# Simulate quantum tunneling\nsimulate_tunneling <- function(x_start = -2, x_end = 2, n_steps = 50, n_paths = 100, \n                              barrier_params = list(height = 1.5, width = 1.5),\n                              hbar = 0.5) {\n  # Time step\n  dt <- 0.1\n  \n  # Generate random paths\n  paths <- generate_random_paths(x_start, x_end, n_steps, n_paths)\n  \n  # Create potential function with barrier\n  potential_fn <- function(x) calculate_potential(x, barrier_params$height, barrier_params$width)\n  \n  # Position grid for potential plot\n  x_grid <- seq(-3, 3, length.out = 200)\n  potential_grid <- potential_fn(x_grid)\n  \n  # Calculate action and amplitude for each path\n  results <- data.frame(\n    path_id = 1:n_paths,\n    action = numeric(n_paths),\n    amplitude_real = numeric(n_paths),\n    amplitude_imag = numeric(n_paths),\n    amplitude_abs = numeric(n_paths)\n  )\n  \n  path_data <- list()\n  \n  for (i in 1:n_paths) {\n    # Calculate action for this path\n    action_val <- calculate_quantum_action(paths[i,], dt, potential_fn = potential_fn, hbar = hbar)\n    amplitude <- calculate_amplitude(action_val, hbar)\n    \n    results$action[i] <- action_val\n    results$amplitude_real[i] <- Re(amplitude)\n    results$amplitude_imag[i] <- Im(amplitude)\n    results$amplitude_abs[i] <- Mod(amplitude)\n    \n    # Store path data for plotting\n    path_data[[i]] <- data.frame(\n      x = paths[i,],\n      t = seq(0, (n_steps-1)*dt, by = dt),\n      path_id = i,\n      action = action_val,\n      amplitude_abs = Mod(amplitude)\n    )\n  }\n  \n  # Combine path data\n  all_paths <- do.call(rbind, path_data)\n  \n  # Create potential plot\n  potential_plot <- plot_ly(height = 300) %>%\n    add_trace(x = x_grid, y = potential_grid, type = 'scatter', mode = 'lines',\n              name = 'Potential', line = list(color = 'black', width = 2)) %>%\n    layout(title = \"Potential Barrier\",\n           xaxis = list(title = \"Position\"),\n           yaxis = list(title = \"Potential Energy\"))\n  \n  # Plot a subset of paths colored by amplitude\n  paths_to_plot <- sample(1:n_paths, min(30, n_paths))\n  \n  path_plot <- plot_ly(height = 300) %>%\n    layout(title = \"Sample Quantum Paths\",\n           xaxis = list(title = \"Time\"),\n           yaxis = list(title = \"Position\"))\n  \n  for (i in paths_to_plot) {\n    path_subset <- all_paths %>% filter(path_id == i)\n    \n    # Normalize amplitude for color\n    norm_amplitude <- (path_subset$amplitude_abs[1] - min(results$amplitude_abs)) / \n                      (max(results$amplitude_abs) - min(results$amplitude_abs))\n    \n    # Color from blue (low amplitude) to red (high amplitude)\n    color_val <- rgb(norm_amplitude, 0, 1-norm_amplitude)\n    \n    path_plot <- path_plot %>%\n      add_trace(data = path_subset, x = ~t, y = ~x, type = 'scatter', mode = 'lines',\n                line = list(color = color_val),\n                showlegend = FALSE)\n  }\n  \n  # Create amplitude distribution plot\n  amplitude_plot <- plot_ly(data = results, height = 300) %>%\n    add_trace(x = ~amplitude_real, y = ~amplitude_imag, type = 'scatter', mode = 'markers',\n              marker = list(size = 5, color = ~amplitude_abs, \n                            colorscale = 'Viridis', showscale = TRUE)) %>%\n    layout(title = \"Distribution of Path Amplitudes in Complex Plane\",\n           xaxis = list(title = \"Re(amplitude)\"),\n           yaxis = list(title = \"Im(amplitude)\"))\n  \n  # Return all plots and data\n  return(list(\n    potential_plot = potential_plot,\n    path_plot = path_plot,\n    amplitude_plot = amplitude_plot,\n    results = results,\n    all_paths = all_paths\n  ))\n}\n\n# Run the quantum tunneling simulation\ntunneling_sim <- simulate_tunneling(hbar = 0.5)\n\n# Display the plots\nsubplot(tunneling_sim$potential_plot, \n        tunneling_sim$path_plot, \n        tunneling_sim$amplitude_plot, \n        nrows = 3) %>%\n  layout(title = \"Quantum Tunneling via Path Integral Approach\",\n         annotations = list(\n           list(\n             x = 0.5,\n             y = 1.05,\n             text = paste(\"Quantum paths contribute with complex amplitudes e^(iS/ħ),\",\n                          \"allowing tunneling through classically forbidden regions\"),\n             showarrow = FALSE,\n             xref = \"paper\",\n             yref = \"paper\"\n           )\n         ))",
      "line_count": 180
    },
    {
      "section": "Experiments and Simulations",
      "code": "# Function to simulate Minkowski and Euclidean path integrals\nsimulate_analytic_continuation <- function(n_paths = 1000, n_steps = 20, hbar = 1) {\n  \n  # Time parameters\n  t_max <- 2\n  t <- seq(0, t_max, length.out = n_steps)\n  dt <- t[2] - t[1]\n  \n  # Generate paths for simple harmonic oscillator\n  m <- 1\n  k <- 1\n  omega <- sqrt(k/m)\n  \n  # Classical path\n  x_classical <- cos(omega * t)\n  \n  # Generate random paths with fixed endpoints\n  x_start <- x_classical[1]\n  x_end <- x_classical[n_steps]\n  \n  paths <- matrix(0, nrow = n_paths, ncol = n_steps)\n  paths[,1] <- x_start\n  paths[,n_steps] <- x_end\n  \n  # Random fluctuations around straight line\n  for (i in 1:n_paths) {\n    # Generate random intermediate points\n    for (j in 2:(n_steps-1)) {\n      # Linear interpolation plus random deviation\n      paths[i,j] <- x_start + (j-1)/(n_steps-1) * (x_end - x_start) + \n                     rnorm(1, 0, 0.3 * sqrt(dt))\n    }\n  }\n  \n  # Calculate actions and amplitudes for both Minkowski and Euclidean cases\n  results <- data.frame(\n    path_id = 1:n_paths,\n    minkowski_action = numeric(n_paths),\n    minkowski_amplitude_re = numeric(n_paths),\n    minkowski_amplitude_im = numeric(n_paths),\n    euclidean_action = numeric(n_paths),\n    euclidean_weight = numeric(n_paths)\n  )\n  \n  for (i in 1:n_paths) {\n    # Current path\n    path <- paths[i,]\n    \n    # Calculate velocities\n    v <- c(diff(path)/dt, 0)\n    \n    # Lagrangian L = T - V\n    L <- 0.5 * m * v[1:(n_steps-1)]^2 - 0.5 * k * path[1:(n_steps-1)]^2\n    \n    # Minkowski action (real time)\n    S_M <- sum(L * dt)\n    results$minkowski_action[i] <- S_M\n    \n    # Minkowski amplitude e^(iS/ħ)\n    amplitude <- exp(1i * S_M / hbar)\n    results$minkowski_amplitude_re[i] <- Re(amplitude)\n    results$minkowski_amplitude_im[i] <- Im(amplitude)\n    \n    # Euclidean action (imaginary time)\n    # Mathematically: t → iτ, S → iS_E\n    # Lagrangian becomes L_E = T + V (sign change)\n    L_E <- 0.5 * m * v[1:(n_steps-1)]^2 + 0.5 * k * path[1:(n_steps-1)]^2\n    S_E <- sum(L_E * dt)\n    results$euclidean_action[i] <- S_E\n    \n    # Euclidean weight e^(-S_E/ħ)\n    results$euclidean_weight[i] <- exp(-S_E / hbar)\n  }\n  \n  # Normalize Euclidean weights for visualization\n  results$euclidean_weight_norm <- results$euclidean_weight / max(results$euclidean_weight)\n  \n  # Prepare path data for plotting\n  path_data <- list()\n  selected_paths <- sample(1:n_paths, 30)  # Select random paths to plot\n  \n  for (i in selected_paths) {\n    path_data[[length(path_data) + 1]] <- data.frame(\n      t = t,\n      x = paths[i,],\n      path_id = i,\n      minkowski_action = results$minkowski_action[i],\n      euclidean_weight = results$euclidean_weight[i],\n      euclidean_weight_norm = results$euclidean_weight_norm[i]\n    )\n  }\n  \n  # Add classical path\n  path_data[[length(path_data) + 1]] <- data.frame(\n    t = t,\n    x = x_classical,\n    path_id = 0,\n    minkowski_action = NA,\n    euclidean_weight = NA,\n    euclidean_weight_norm = NA\n  )\n  \n  all_paths <- bind_rows(path_data)\n  \n  # Return all the computed data\n  return(list(\n    paths = paths,\n    results = results,\n    path_data = all_paths,\n    classical_path = x_classical,\n    t = t\n  ))\n}\n\n# Load required libraries\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(patchwork)\nlibrary(viridis)\nlibrary(grid)\nlibrary(gridExtra)\n\n# Run the simulation\nset.seed(42)\nsim_results <- simulate_analytic_continuation(n_paths = 1000, n_steps = 50, hbar = 0.5)\n\n# Plot a selection of paths with color representing Euclidean weight\np1 <- ggplot(filter(sim_results$path_data, path_id != 0)) +\n  geom_line(aes(x = t, y = x, group = path_id, color = euclidean_weight_norm), alpha = 0.7) +\n  geom_line(data = filter(sim_results$path_data, path_id == 0), \n            aes(x = t, y = x), color = \"red\", size = 1, linetype = \"dashed\") +\n  scale_color_viridis_c(name = \"Euclidean\\nWeight\", direction = -1) +\n  labs(title = \"Quantum Paths for Harmonic Oscillator\",\n       subtitle = \"Colored by Euclidean weight (higher = darker)\",\n       x = \"Time\",\n       y = \"Position\") +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n\n# Distribution of Minkowski actions and amplitudes\np2 <- ggplot(sim_results$results) +\n  geom_point(aes(x = minkowski_amplitude_re, y = minkowski_amplitude_im, color = minkowski_action),\n             alpha = 0.5) +\n  scale_color_viridis_c(name = \"Minkowski\\nAction\") +\n  coord_fixed() +\n  labs(title = \"Minkowski Path Integral\",\n       subtitle = \"Complex amplitude distribution\",\n       x = \"Re(e^(iS/ħ))\",\n       y = \"Im(e^(iS/ħ))\") +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n\n# Distribution of Euclidean actions and weights\np3 <- ggplot(sim_results$results) +\n  geom_histogram(aes(x = euclidean_action, weight = euclidean_weight), bins = 30, fill = \"steelblue\") +\n  labs(title = \"Euclidean Path Integral\",\n       subtitle = \"Action distribution weighted by e^(-S/ħ)\",\n       x = \"Euclidean Action\",\n       y = \"Weighted Frequency\") +\n  theme_minimal()\n\n# Relationship between Minkowski and Euclidean actions\np4 <- ggplot(sim_results$results) +\n  geom_point(aes(x = euclidean_action, y = minkowski_action, color = euclidean_weight_norm),\n             alpha = 0.5) +\n  scale_color_viridis_c(name = \"Euclidean\\nWeight\", direction = -1) +\n  labs(title = \"Relationship Between Actions\",\n       subtitle = \"Minkowski vs. Euclidean\",\n       x = \"Euclidean Action\",\n       y = \"Minkowski Action\") +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n\n# Combine plots\ncombined_plot <- (p1 + p2) / (p3 + p4) +\n  plot_layout(guides = \"collect\") & \n  theme(legend.position = \"right\")\n\nprint(combined_plot)\n\n# Additional analysis: Compute expectation values\ncompute_expectation_values <- function(sim_results) {\n  # Extract relevant data\n  paths <- sim_results$paths\n  weights <- sim_results$results$euclidean_weight\n  t <- sim_results$t\n  n_steps <- length(t)\n  \n  # Normalize weights\n  weights_norm <- weights / sum(weights)\n  \n  # Compute position expectation value at each time\n  pos_expectation <- numeric(n_steps)\n  pos2_expectation <- numeric(n_steps)\n  \n  for (j in 1:n_steps) {\n    pos_expectation[j] <- sum(paths[, j] * weights_norm)\n    pos2_expectation[j] <- sum(paths[, j]^2 * weights_norm)\n  }\n  \n  # Compute variance\n  pos_variance <- pos2_expectation - pos_expectation^2\n  \n  # Return expectation values\n  return(data.frame(\n    t = t,\n    position = pos_expectation,\n    position_squared = pos2_expectation,\n    position_variance = pos_variance\n  ))\n}\n\n# Compute expectation values\nexpectation_values <- compute_expectation_values(sim_results)\n\n# Plot expectation values\np5 <- ggplot() +\n  geom_line(data = expectation_values, aes(x = t, y = position), color = \"blue\", size = 1) +\n  geom_ribbon(data = expectation_values, \n              aes(x = t, ymin = position - sqrt(position_variance), \n                  ymax = position + sqrt(position_variance)), \n              alpha = 0.3, fill = \"blue\") +\n  geom_line(data = data.frame(t = sim_results$t, x = sim_results$classical_path),\n            aes(x = t, y = x), color = \"red\", linetype = \"dashed\") +\n  labs(title = \"Quantum vs. Classical Position\",\n       subtitle = \"Blue = quantum expectation with uncertainty, Red = classical path\",\n       x = \"Time\",\n       y = \"Position\") +\n  theme_minimal()\n\nprint(p5)\n\n# Create interpretive visualization comparing Minkowski and Euclidean formulations\n# First, create demonstration data\nt_values <- seq(0, 2*pi, length.out = 100)\nminkowski_wave <- data.frame(\n  t = t_values,\n  real = cos(t_values),\n  imag = sin(t_values),\n  type = \"Minkowski\"\n)\n\neuclidean_decay <- data.frame(\n  t = t_values,\n  real = exp(-t_values/2),\n  imag = 0,\n  type = \"Euclidean\"\n)\n\ncombined_data <- bind_rows(minkowski_wave, euclidean_decay)\n\np6 <- ggplot(combined_data, aes(x = t, color = type)) +\n  geom_line(aes(y = real, linetype = \"Real Part\"), size = 1) +\n  geom_line(data = filter(combined_data, type == \"Minkowski\"),\n            aes(y = imag, linetype = \"Imaginary Part\"), size = 1) +\n  scale_color_manual(values = c(\"Minkowski\" = \"blue\", \"Euclidean\" = \"darkred\")) +\n  scale_linetype_manual(values = c(\"Real Part\" = \"solid\", \"Imaginary Part\" = \"dashed\")) +\n  labs(title = \"Analytic Continuation: Minkowski vs. Euclidean Formulations\",\n       subtitle = \"Oscillatory behavior transforms to exponential decay\",\n       x = \"Time (t) / Euclidean time (τ)\",\n       y = \"Amplitude / Weight\") +\n  theme_minimal() +\n  theme(legend.title = element_blank())\n\nprint(p6)\n\n# Final combined analysis plot\nfinal_plot <- p5 / p6 + plot_layout(heights = c(3, 2))\nprint(final_plot)\n\n# Summary of findings\ncat(\"Summary of Analytic Continuation Experiment:\\n\\n\")\ncat(\"1. Minkowski path integral: Oscillatory phase factors lead to highly fluctuating sums\\n\")\ncat(\"2. Euclidean path integral: Exponential damping factors lead to well-behaved sums\\n\")\ncat(\"3. Classical path corresponds closely to the path of maximum weight in Euclidean formulation\\n\")\ncat(\"4. Quantum uncertainty is visible in the spread around expectation values\\n\")\ncat(\"5. The Wick rotation (t → iτ) transforms oscillatory behavior to exponential decay\\n\")",
      "line_count": 278
    },
    {
      "section": "Hamiltonian-Jacobi Equation for the Action",
      "code": "library(plotly)\n\n# Hamilton-Jacobi solution for a free particle\ngenerate_HJ_free_particle <- function(x_range, t_range, resolution=50, m=1) {\n  # Create grid\n  x <- seq(from=x_range[1], to=x_range[2], length.out=resolution)\n  t <- seq(from=t_range[1], to=t_range[2], length.out=resolution)\n  grid <- expand.grid(x=x, t=t)\n  \n  # Calculate action S(x,t) for multiple trajectories\n  S_values <- matrix(0, nrow=resolution, ncol=resolution)\n  \n  # Different momenta (integration constants)\n  momenta <- c(0.5, 1, 1.5, 2, 2.5)\n  colors <- c('blue', 'red', 'green', 'purple', 'orange')\n  \n  # Calculate trajectories and action surfaces\n  trajectory_data <- list()\n  \n  for(i in seq_along(momenta)) {\n    p <- momenta[i]\n    \n    # For each momentum p, compute action S(x,t) = px - p²t/(2m)\n    for(ix in 1:resolution) {\n      for(it in 1:resolution) {\n        x_val <- x[ix]\n        t_val <- t[it]\n        S_values[ix, it] <- p*x_val - (p^2)/(2*m)*t_val\n      }\n    }\n    \n    # Store action surface\n    surface_data <- expand.grid(x=x, t=t)\n    surface_data$S <- c(S_values)\n    surface_data$momentum <- p\n    \n    # Generate trajectory for this momentum\n    traj <- data.frame(\n      t = t,\n      x = p*t/m,  # Free particle trajectory x(t) = p*t/m + x₀ (setting x₀=0)\n      p = p\n    )\n    \n    trajectory_data[[i]] <- list(\n      surface = surface_data,\n      trajectory = traj,\n      color = colors[i]\n    )\n  }\n  \n  return(list(\n    x = x,\n    t = t,\n    trajectories = trajectory_data\n  ))\n}\n\n# Generate data\nhj_data <- generate_HJ_free_particle(\n  x_range = c(0, 10), \n  t_range = c(0, 5),\n  resolution = 40\n)\n\n# Create 3D surface plot of action\naction_plot <- plot_ly(height=600)\n\n# Add action surfaces for different momenta\nfor(i in seq_along(hj_data$trajectories)) {\n  traj_data <- hj_data$trajectories[[i]]\n  \n  # Convert to matrix form for surface plot\n  S_matrix <- matrix(NA, nrow=length(hj_data$x), ncol=length(hj_data$t))\n  \n  # Fill in the matrix\n  for(ix in 1:length(hj_data$x)) {\n    for(it in 1:length(hj_data$t)) {\n      x_val <- hj_data$x[ix]\n      t_val <- hj_data$t[it]\n      p <- unique(traj_data$surface$momentum)\n      S_matrix[ix, it] <- p*x_val - (p^2)/(2)*t_val\n    }\n  }\n  \n  # Add surface\n  action_plot <- action_plot %>%\n    add_surface(\n      z = S_matrix,\n      x = hj_data$t,\n      y = hj_data$x,\n      opacity = 0.7,\n      colorscale = list(c(0, 1), c(traj_data$color, traj_data$color)),\n      showscale = FALSE,\n      name = paste(\"p =\", unique(traj_data$surface$momentum))\n    )\n}\n\n# Add trajectories on the action surface\nfor(i in seq_along(hj_data$trajectories)) {\n  traj_data <- hj_data$trajectories[[i]]\n  traj <- traj_data$trajectory\n  p <- unique(traj$p)\n  \n  # Calculate S values along trajectory\n  S_traj <- p*traj$x - (p^2)/(2)*traj$t\n  \n  action_plot <- action_plot %>%\n    add_trace(\n      x = traj$t,\n      y = traj$x,\n      z = S_traj,\n      type = 'scatter3d',\n      mode = 'lines',\n      line = list(color='black', width=5),\n      name = paste(\"Trajectory p =\", p)\n    )\n}\n\n# Final layout adjustments\naction_plot %>%\n  layout(\n    title = \"Hamilton-Jacobi Action Surfaces for Free Particle\",\n    scene = list(\n      xaxis = list(title = \"Time\"),\n      yaxis = list(title = \"Position\"),\n      zaxis = list(title = \"Action S(x,t)\"),\n      camera = list(eye = list(x = 1.5, y = 1.5, z = 1.2))\n    )\n  )",
      "line_count": 129
    },
    {
      "section": "Hamiltonian-Jacobi Equation for the Action",
      "code": "# Function to calculate the Lagrangian for a simple pendulum\npendulum_lagrangian <- function(theta, theta_dot, length=1, mass=1, g=9.8) {\n  T = 0.5 * mass * (length * theta_dot)^2  # Kinetic energy\n  V = mass * g * length * (1 - cos(theta))  # Potential energy\n  return(T - V)  # Lagrangian L = T - V\n}\n\n# Function to calculate action for a given path\ncalculate_action <- function(path, dt, length=1, mass=1, g=9.8) {\n  # Extract theta and compute theta_dot\n  theta <- path\n  theta_dot <- c(diff(theta)/dt, diff(theta)[length(theta)-1]/dt)\n  \n  # Calculate Lagrangian at each point\n  L <- pendulum_lagrangian(theta, theta_dot, length, mass, g)\n  \n  # Action is integral of L over time\n  S <- sum(L) * dt\n  return(S)\n}\n\n# Generate a classical path and perturbed paths\ngenerate_pendulum_paths <- function(t_max, n_steps, n_paths=10, perturbation_max=0.5) {\n  t <- seq(0, t_max, length.out=n_steps)\n  dt <- t[2] - t[1]\n  \n  # Initial conditions\n  theta_0 <- pi/6  # Initial angle\n  omega <- sqrt(9.8)  # Natural frequency for length=1\n  \n  # Classical solution for small oscillations\n  theta_classical <- theta_0 * cos(omega * t)\n  \n  # Store all paths\n  paths <- list()\n  paths[[1]] <- theta_classical\n  \n  # Generate perturbed paths with fixed endpoints\n  for(i in 2:n_paths) {\n    # Create random perturbation (zero at endpoints)\n    perturbation_amplitude <- perturbation_max * (i-1)/(n_paths-1)\n    perturbation <- perturbation_amplitude * sin(pi * t/t_max) * sin(2*pi * t/t_max)\n    \n    # Perturbed path\n    paths[[i]] <- theta_classical + perturbation\n  }\n  \n  return(list(\n    t = t,\n    dt = dt,\n    paths = paths\n  ))\n}\n\n# Generate paths for pendulum\npendulum_data <- generate_pendulum_paths(\n  t_max = 4,\n  n_steps = 100,\n  n_paths = 20\n)\n\n# Calculate action for each path\nactions <- numeric(length(pendulum_data$paths))\nfor(i in seq_along(pendulum_data$paths)) {\n  actions[i] <- calculate_action(pendulum_data$paths[[i]], pendulum_data$dt)\n}\n\n# Create data frame for plotting\nplot_data <- data.frame()\npath_names <- c(\"Classical\", paste(\"Perturbed\", 1:(length(pendulum_data$paths)-1)))\n\nfor(i in seq_along(pendulum_data$paths)) {\n  path_df <- data.frame(\n    time = pendulum_data$t,\n    theta = pendulum_data$paths[[i]],\n    path = path_names[i],\n    action = actions[i]\n  )\n  plot_data <- rbind(plot_data, path_df)\n}\n\n# Normalize action values for color mapping\naction_range <- range(actions[-1])  # Exclude classical path\nnormalized_actions <- (actions - action_range[1]) / diff(action_range)\n\n# Plot the paths and their actions\ntrajectory_plot <- plot_ly(height=450)\n\n# Add classical path first\nclassical_data <- subset(plot_data, path == \"Classical\")\ntrajectory_plot <- trajectory_plot %>%\n  add_trace(\n    data = classical_data,\n    x = ~time,\n    y = ~theta,\n    type = 'scatter',\n    mode = 'lines',\n    name = 'Classical Path',\n    line = list(color = 'black', width = 3)\n  )\n\n# Add perturbed paths\nfor(i in 2:length(pendulum_data$paths)) {\n  path_subset <- subset(plot_data, path == path_names[i])\n  # Color gradient based on action (blue=low, red=high)\n  norm_action <- normalized_actions[i]\n  color_val <- rgb(norm_action, 0, 1-norm_action)\n  \n  trajectory_plot <- trajectory_plot %>%\n    add_trace(\n      data = path_subset,\n      x = ~time,\n      y = ~theta,\n      type = 'scatter',\n      mode = 'lines',\n      name = sprintf(\"%s (S = %.2f)\", path_names[i], actions[i]),\n      line = list(color = color_val, width = 1.5)\n    )\n}\n\n# Plot actions as bars\naction_df <- data.frame(\n  path = factor(path_names, levels = path_names),\n  action = actions\n)\n\naction_plot <- plot_ly(\n  data = action_df,\n  x = ~path,\n  y = ~action,\n  type = 'bar',\n  marker = list(\n    color = c('black', colorRamp(c('blue', 'red'))(normalized_actions[-1])),\n    line = list(color = 'black', width = 1)\n  )\n) %>%\n  layout(\n    title = \"Action Values for Different Paths\",\n    xaxis = list(title = \"Path\"),\n    yaxis = list(title = \"Action Value\")\n  )\n\n# Combine plots\nsubplot(\n  trajectory_plot %>% layout(title = \"Pendulum Paths (Classical vs Perturbed)\"),\n  action_plot,\n  nrows = 2,\n  heights = c(0.7, 0.3)\n) %>%\n  layout(\n    title = \"Principle of Stationary Action for a Pendulum\",\n    showlegend = FALSE\n  )",
      "line_count": 153
    },
    {
      "section": "Hamiltonian-Jacobi Equation for the Action",
      "code": "# Function to simulate Hamiltonian dynamics\nsimulate_hamiltonian_system <- function(\n  H_func,       # Hamiltonian function\n  grad_H_func,  # Gradient of Hamiltonian\n  initial_state,# Initial conditions [q1, q2, p1, p2]\n  t_max,        # Maximum time\n  dt,           # Time step\n  invariant_func = NULL  # Optional invariant function\n) {\n  # Number of steps\n  n_steps <- ceiling(t_max / dt)\n  \n  # Allocate arrays for results\n  states <- matrix(0, nrow=n_steps, ncol=length(initial_state))\n  times <- seq(0, t_max, length.out=n_steps)\n  energy <- numeric(n_steps)\n  invariant <- NULL\n  if(!is.null(invariant_func)) {\n    invariant <- numeric(n_steps)\n  }\n  \n  # Initialize\n  states[1,] <- initial_state\n  energy[1] <- H_func(initial_state)\n  if(!is.null(invariant_func)) {\n    invariant[1] <- invariant_func(initial_state)\n  }\n  \n  # Symplectic integration (4th order Runge-Kutta)\n  for(i in 2:n_steps) {\n    # Current state\n    state <- states[i-1,]\n    \n    # RK4 integration\n    k1 <- dt * hamiltonian_flow(state, grad_H_func)\n    k2 <- dt * hamiltonian_flow(state + 0.5*k1, grad_H_func)\n    k3 <- dt * hamiltonian_flow(state + 0.5*k2, grad_H_func)\n    k4 <- dt * hamiltonian_flow(state + k3, grad_H_func)\n    \n    # Update state\n    states[i,] <- state + (k1 + 2*k2 + 2*k3 + k4)/6\n    \n    # Calculate energy and invariant\n    energy[i] <- H_func(states[i,])\n    if(!is.null(invariant_func)) {\n      invariant[i] <- invariant_func(states[i,])\n    }\n  }\n  \n  # Return results\n  result <- list(\n    times = times,\n    states = states,\n    energy = energy\n  )\n  \n  if(!is.null(invariant_func)) {\n    result$invariant <- invariant\n  }\n  \n  return(result)\n}\n\n# Hamiltonian flow vector field\nhamiltonian_flow <- function(state, grad_H_func) {\n  # Extract position and momentum\n  q <- state[1:2]\n  p <- state[3:4]\n  \n  # Calculate gradient of Hamiltonian\n  grad_H <- grad_H_func(state)\n  \n  # Hamilton's equations: ẋ = J∇H where J is the symplectic matrix\n  flow <- c(\n    grad_H[3:4],   # dq/dt = ∂H/∂p\n    -grad_H[1:2]   # dp/dt = -∂H/∂q\n  )\n  \n  return(flow)\n}\n\n# Hamiltonian for a 2D system with central force\ncentral_force_hamiltonian <- function(state) {\n  # Extract position and momentum\n  q1 <- state[1]\n  q2 <- state[2]\n  p1 <- state[3]\n  p2 <- state[4]\n  \n  # Kinetic energy T = p²/2m (m=1)\n  T <- 0.5 * (p1^2 + p2^2)\n  \n  # Potential energy for central force V = k/r\n  r <- sqrt(q1^2 + q2^2)\n  V <- 1/r\n  \n  # Hamiltonian H = T + V\n  return(T + V)\n}\n\n# Gradient of Hamiltonian\ncentral_force_gradient <- function(state) {\n  # Extract position and momentum\n  q1 <- state[1]\n  q2 <- state[2]\n  p1 <- state[3]\n  p2 <- state[4]\n  \n  # Calculate r and its cube\n  r <- sqrt(q1^2 + q2^2)\n  r3 <- r^3\n  \n  # Gradient components\n  dH_dq1 <- -q1 / r3\n  dH_dq2 <- -q2 / r3\n  dH_dp1 <- p1\n  dH_dp2 <- p2\n  \n  return(c(dH_dq1, dH_dq2, dH_dp1, dH_dp2))\n}\n\n# Angular momentum (Noether invariant for rotational symmetry)\nangular_momentum <- function(state) {\n  # L = q1*p2 - q2*p1\n  return(state[1]*state[4] - state[2]*state[3])\n}\n\n# Simulate the system for different initial conditions\nsimulate_central_force <- function() {\n  # Initial conditions (varying angular momentum)\n  initial_states <- list(\n    c(1.0, 0.0, 0.0, 1.0),    # Circular orbit\n    c(1.0, 0.0, 0.0, 1.2),    # Elliptical orbit 1\n    c(1.0, 0.0, 0.0, 0.8)     # Elliptical orbit 2\n  )\n  \n  # Simulation parameters\n  t_max <- 20\n  dt <- 0.01\n  \n  # Run simulations\n  results <- list()\n  for(i in seq_along(initial_states)) {\n    results[[i]] <- simulate_hamiltonian_system(\n      H_func = central_force_hamiltonian,\n      grad_H_func = central_force_gradient,\n      initial_state = initial_states[[i]],\n      t_max = t_max,\n      dt = dt,\n      invariant_func = angular_momentum\n    )\n  }\n  \n  return(results)\n}\n\n# Run simulations\ncentral_force_results <- simulate_central_force()\n\n# Prepare data for plotting\ntrajectory_data <- data.frame()\nconservation_data <- data.frame()\n\norbit_names <- c(\"Circular\", \"Elliptical 1\", \"Elliptical 2\")\ncolors <- c('#1f77b4', '#ff7f0e', '#2ca02c')\n\nfor(i in seq_along(central_force_results)) {\n  result <- central_force_results[[i]]\n  \n  # Trajectory data\n  traj <- data.frame(\n    orbit = orbit_names[i],\n    time = result$times,\n    q1 = result$states[,1],\n    q2 = result$states[,2],\n    p1 = result$states[,3],\n    p2 = result$states[,4],\n    energy = result$energy,\n    angular_momentum = result$invariant\n  )\n  \n  trajectory_data <- rbind(trajectory_data, traj)\n  \n  # Conservation data (sampled)\n  sample_idx <- seq(1, length(result$times), by=10)\n  conservation <- data.frame(\n    orbit = orbit_names[i],\n    time = result$times[sample_idx],\n    energy = result$energy[sample_idx],\n    angular_momentum = result$invariant[sample_idx],\n    normalized_energy = (result$energy[sample_idx] - min(result$energy))/\n                        (max(result$energy) - min(result$energy)),\n    normalized_momentum = (result$invariant[sample_idx] - min(result$invariant))/\n                          (max(result$invariant) - min(result$invariant))\n  )\n  \n  conservation_data <- rbind(conservation_data, conservation)\n}\n\n# Create plots\n# 1. Phase space trajectories\nphase_space_plot <- plot_ly(height=400)\n\nfor(i in 1:length(orbit_names)) {\n  orbit_data <- subset(trajectory_data, orbit == orbit_names[i])\n  \n  phase_space_plot <- phase_space_plot %>%\n    add_trace(\n      data = orbit_data,\n      x = ~q1,\n      y = ~q2,\n      type = 'scatter',\n      mode = 'lines',\n      line = list(color = colors[i], width = 2),\n      name = orbit_names[i]\n    )\n}\n\nphase_space_plot <- phase_space_plot %>%\n  layout(\n    title = \"Configuration Space Trajectories\",\n    xaxis = list(title = \"q₁\"),\n    yaxis = list(title = \"q₂\")\n  )\n\n# 2. Conservation plots\nenergy_plot <- plot_ly(height=300)\nmomentum_plot <- plot_ly(height=300)\n\nfor(i in 1:length(orbit_names)) {\n  orbit_data <- subset(conservation_data, orbit == orbit_names[i])\n  \n  energy_plot <- energy_plot %>%\n    add_trace(\n      data = orbit_data,\n      x = ~time,\n      y = ~normalized_energy,\n      type = 'scatter',\n      mode = 'lines',\n      line = list(color = colors[i], width = 2),\n      name = orbit_names[i]\n    )\n  \n  momentum_plot <- momentum_plot %>%\n    add_trace(\n      data = orbit_data,\n      x = ~time,\n      y = ~normalized_momentum,\n      type = 'scatter',\n      mode = 'lines',\n      line = list(color = colors[i], width = 2),\n      name = orbit_names[i]\n    )\n}\n\nenergy_plot <- energy_plot %>%\n  layout(\n    title = \"Energy Conservation (Normalized)\",\n    xaxis = list(title = \"Time\"),\n    yaxis = list(title = \"Normalized Energy\")\n  )\n\nmomentum_plot <- momentum_plot %>%\n  layout(\n    title = \"Angular Momentum Conservation (Normalized)\",\n    xaxis = list(title = \"Time\"),\n    yaxis = list(title = \"Normalized Angular Momentum\")\n  )\n\n# 3. Poincaré section visualization (2D section of phase space)\npoincare_data <- data.frame()\n\nfor(i in 1:length(orbit_names)) {\n  orbit_data <- subset(trajectory_data, orbit == orbit_names[i])\n  \n  # Find points where trajectory crosses q2=0 plane with p2>0\n  # Modified approach to ensure we get some crossings\n  crossing_indices <- c()\n  for(j in 1:(nrow(orbit_data)-1)) {\n    # Check for crossing from negative to positive q2\n    if(orbit_data$q2[j] <= 0 && orbit_data$q2[j+1] > 0) {\n      crossing_indices <- c(crossing_indices, j)\n    }\n    # Also check for crossing from positive to negative q2\n    # to ensure we capture some points for each orbit\n    else if(orbit_data$q2[j] >= 0 && orbit_data$q2[j+1] < 0) {\n      crossing_indices <- c(crossing_indices, j)\n    }\n  }\n  \n  # If we still don't have crossings, sample some points\n  if(length(crossing_indices) < 3) {\n    # Take points closest to q2=0\n    dist_to_plane <- abs(orbit_data$q2)\n    ordered_indices <- order(dist_to_plane)\n    crossing_indices <- ordered_indices[1:10]  # Take 10 closest points\n  }\n  \n  # Create Poincaré section data\n  if(length(crossing_indices) > 0) {\n    crossings <- orbit_data[crossing_indices,]\n    crossings$section <- \"Near q₂ = 0\"\n    poincare_data <- rbind(poincare_data, crossings)\n  }\n}\n\npoincare_plot <- plot_ly(height=400)\n\nfor(i in 1:length(orbit_names)) {\n  orbit_data <- subset(poincare_data, orbit == orbit_names[i])\n  \n  if(nrow(orbit_data) > 0) {\n    poincare_plot <- poincare_plot %>%\n      add_trace(\n        data = orbit_data,\n        x = ~q1,\n        y = ~p1,\n        type = 'scatter',\n        mode = 'markers',\n        marker = list(color = colors[i], size = 10),\n        name = orbit_names[i]\n      )\n  }\n}\n\npoincare_plot <- poincare_plot %>%\n  layout(\n    title = \"Poincaré Section (q₂ = 0, p₂ > 0)\",\n    xaxis = list(title = \"q₁\"),\n    yaxis = list(title = \"p₁\")\n  )\n\n# Combine all plots\nsubplot(\n  phase_space_plot,\n  subplot(energy_plot, momentum_plot, nrows=1),\n  poincare_plot,\n  nrows = 3,\n  heights = c(0.4, 0.3, 0.3)\n) %>%\n  layout(\n    title = \"Symplectic Structure and Noether Invariants\",\n    showlegend = TRUE\n  )",
      "line_count": 344
    },
    {
      "section": "Hamiltonian-Jacobi Equation for the Action",
      "code": "# Function to generate potential\ndouble_well_potential <- function(x, a=1, b=0.25) {\n  return(a*x^4 - b*x^2)\n}\n\n# Calculate complex trajectories for tunneling\ncalculate_complex_trajectories <- function(E=0.1, a=1, b=0.25, resolution=50) {\n  # Find classical turning points by solving V(x) = E\n  # For double-well potential, we need numerical solution\n  find_turning_points <- function(E) {\n    # Starting points for numerical search\n    x_guess <- c(-1, -0.1, 0.1, 1)\n    turning_points <- numeric(0)\n    \n    for(x_start in x_guess) {\n      # Find root where V(x) = E\n      result <- uniroot(function(x) double_well_potential(x, a, b) - E, \n                         c(x_start - 0.5, x_start + 0.5), \n                         tol=1e-10, extendInt=\"yes\")\n      turning_points <- c(turning_points, result$root)\n    }\n    \n    # Remove duplicates and sort\n    turning_points <- unique(turning_points)\n    turning_points <- turning_points[order(turning_points)]\n    \n    return(turning_points)\n  }\n  \n  turning_points <- find_turning_points(E)\n  \n  # Define integration paths in complex time plane\n  # We'll use 3 segments:\n  # 1. Real time from left turning point inwards\n  # 2. Imaginary time from left to right (tunneling)\n  # 3. Real time from right turning point outwards\n  \n  # Setup grid\n  x_range <- range(turning_points) * 1.5\n  x_grid <- seq(x_range[1], x_range[2], length.out=resolution)\n  \n  # Calculate potential on grid\n  V_grid <- double_well_potential(x_grid, a, b)\n  \n  # Path 1: Real time trajectory (left well)\n  x_left <- seq(turning_points[1], -0.1, length.out=resolution/3)\n  t_left <- cumsum(c(0, sqrt(2/a) * diff(x_left) / \n                    sqrt(abs(E - double_well_potential(x_left[-length(x_left)], a, b)))))\n  \n  # Path 2: Imaginary time trajectory (tunneling)\n  x_tunnel <- seq(-0.1, 0.1, length.out=resolution/3)\n  tau_tunnel <- cumsum(c(0, sqrt(2/a) * diff(x_tunnel) / \n                      sqrt(abs(double_well_potential(x_tunnel[-length(x_tunnel)], a, b) - E))))\n  \n  # Path 3: Real time trajectory (right well)\n  x_right <- seq(0.1, turning_points[4], length.out=resolution/3)\n  t_right <- cumsum(c(0, sqrt(2/a) * diff(x_right) / \n                     sqrt(abs(E - double_well_potential(x_right[-length(x_right)], a, b)))))\n  \n  # Combine paths in complex time plane\n  kappa_real <- c(t_left, rep(max(t_left), length(tau_tunnel)), max(t_left) + t_right)\n  kappa_imag <- c(rep(0, length(t_left)), tau_tunnel, rep(max(tau_tunnel), length(t_right)))\n  x_combined <- c(x_left, x_tunnel, x_right)\n  \n  # Calculate tunneling amplitude\n  S_tunnel <- sum(sqrt(2 * a) * diff(x_tunnel) * \n                 sqrt(abs(double_well_potential(x_tunnel[-length(x_tunnel)], a, b) - E)))\n  tunneling_probability <- exp(-2 * S_tunnel / sqrt(a))\n  \n  return(list(\n    turning_points = turning_points,\n    x_grid = x_grid,\n    V_grid = V_grid,\n    x_combined = x_combined,\n    kappa_real = kappa_real,\n    kappa_imag = kappa_imag,\n    tunneling_probability = tunneling_probability,\n    energy = E\n  ))\n}\n\n# Generate tunneling data\ntunnel_data <- calculate_complex_trajectories(E=0.05)\n\n# Create 3D Visualization of Complex Time Tunneling\n# 1. Potential Plot\npotential_plot <- plot_ly(height=300) %>%\n  add_trace(\n    x = tunnel_data$x_grid,\n    y = tunnel_data$V_grid,\n    type = 'scatter',\n    mode = 'lines',\n    line = list(color = 'black', width = 3),\n    name = 'Double-Well Potential'\n  ) %>%\n  add_trace(\n    x = c(min(tunnel_data$x_grid), max(tunnel_data$x_grid)),\n    y = c(tunnel_data$energy, tunnel_data$energy),\n    type = 'scatter',\n    mode = 'lines',\n    line = list(color = 'red', dash = 'dash', width = 2),\n    name = 'Energy Level'\n  ) %>%\n  add_trace(\n    x = tunnel_data$turning_points,\n    y = rep(tunnel_data$energy, length(tunnel_data$turning_points)),\n    type = 'scatter',\n    mode = 'markers',\n    marker = list(color = 'blue', size = 10, symbol = 'circle'),\n    name = 'Turning Points'\n  ) %>%\n  layout(\n    title = paste0(\"Double-Well Potential with E = \", \n                  tunnel_data$energy,\n                  \" (Tunneling Probability ≈ \", \n                  format(tunnel_data$tunneling_probability, digits=4),\n                  \")\"),\n    xaxis = list(title = \"Position x\"),\n    yaxis = list(title = \"Potential V(x)\")\n  )\n\n# 2. Complex Time Trajectory\ncomplex_time_plot <- plot_ly(height=350) %>%\n  add_trace(\n    x = tunnel_data$kappa_real,\n    y = tunnel_data$kappa_imag,\n    z = tunnel_data$x_combined,\n    type = 'scatter3d',\n    mode = 'lines',\n    line = list(color = 'blue', width = 5),\n    name = 'Complex Time Trajectory'\n  ) %>%\n  layout(\n    scene = list(\n      xaxis = list(title = \"Re(κ)\"),\n      yaxis = list(title = \"Im(κ)\"),\n      zaxis = list(title = \"Position x\")\n    ),\n    title = \"Quantum Tunneling in Complex Time\"\n  )\n\n# 3. Projection plots\nreal_time_plot <- plot_ly(height=250) %>%\n  add_trace(\n    x = tunnel_data$kappa_real,\n    y = tunnel_data$x_combined,\n    type = 'scatter',\n    mode = 'lines',\n    line = list(color = 'green', width = 3),\n    name = 'Real Time Projection'\n  ) %>%\n  layout(\n    title = \"Trajectory Projection on Real Time Plane\",\n    xaxis = list(title = \"Re(κ)\"),\n    yaxis = list(title = \"Position x\")\n  )\n\nimag_time_plot <- plot_ly(height=250) %>%\n  add_trace(\n    x = tunnel_data$kappa_imag,\n    y = tunnel_data$x_combined,\n    type = 'scatter',\n    mode = 'lines',\n    line = list(color = 'purple', width = 3),\n    name = 'Imaginary Time Projection'\n  ) %>%\n  layout(\n    title = \"Trajectory Projection on Imaginary Time Plane\",\n    xaxis = list(title = \"Im(κ)\"),\n    yaxis = list(title = \"Position x\")\n  )\n\n# Combine all plots\nsubplot(\n  potential_plot,\n  complex_time_plot,\n  subplot(real_time_plot, imag_time_plot, nrows=1),\n  nrows = 3,\n  heights = c(0.3, 0.4, 0.3)\n) %>%\n  layout(\n    title = \"Complex Time (Kime) Analysis of Quantum Tunneling\",\n    showlegend = FALSE\n  )",
      "line_count": 184
    },
    {
      "section": "Hamiltonian-Jacobi Equation for the Action",
      "code": "# Generate unified phase space visualization with quantum corrections\ngenerate_unified_phase_space <- function(hbar_values = c(0, 0.1, 0.5), resolution = 50) {\n  # Define phase space grid\n  q_range <- c(-2, 2)\n  p_range <- c(-2, 2)\n  \n  q_grid <- seq(q_range[1], q_range[2], length.out = resolution)\n  p_grid <- seq(p_range[1], p_range[2], length.out = resolution)\n  \n  grid_points <- expand.grid(q = q_grid, p = p_grid)\n  \n  # Classical Hamiltonian (harmonic oscillator)\n  H_classical <- function(q, p, m = 1, k = 1) {\n    return(p^2/(2*m) + 0.5*k*q^2)\n  }\n  \n  # Quantum corrected Hamiltonian with \"quantum potential\" term\n  H_quantum <- function(q, p, hbar, m = 1, k = 1) {\n    # Classical term\n    H_cl <- p^2/(2*m) + 0.5*k*q^2\n    \n    # Quantum correction (simplified form of quantum potential)\n    # In full quantum mechanics, this would be more complex\n    H_q <- hbar^2/(8*m) * (k/m) / (p^2/(2*m) + 0.5*k*q^2 + 0.001)\n    \n    return(H_cl + H_q)\n  }\n  \n  # Calculate Hamiltonians for each hbar value\n  results <- list()\n  \n  for(i in seq_along(hbar_values)) {\n    hbar <- hbar_values[i]\n    \n    # Calculate energy at each grid point\n    if(hbar == 0) {\n      # Classical case\n      energy <- apply(grid_points, 1, function(point) {\n        H_classical(point[1], point[2])\n      })\n    } else {\n      # Quantum case\n      energy <- apply(grid_points, 1, function(point) {\n        H_quantum(point[1], point[2], hbar)\n      })\n    }\n    \n    # Vector field for phase space flow\n    flow_q <- grid_points$p  # dq/dt = ∂H/∂p ≈ p\n    \n    # Classical flow for p\n    flow_p_classical <- -grid_points$q  # dp/dt = -∂H/∂q ≈ -q\n    \n    # Quantum correction to flow (simplified)\n    if(hbar == 0) {\n      flow_p <- flow_p_classical\n    } else {\n      # Add quantum correction\n      quantum_correction <- -hbar^2/(4) * grid_points$q /\n                           (grid_points$p^2 + grid_points$q^2 + 0.001)^2\n      flow_p <- flow_p_classical + quantum_correction\n    }\n    \n    # Normalize flow for visualization\n    flow_magnitude <- sqrt(flow_q^2 + flow_p^2)\n    flow_q_norm <- flow_q / (flow_magnitude + 0.001)\n    flow_p_norm <- flow_p / (flow_magnitude + 0.001)\n    \n    # Store results\n    results[[i]] <- list(\n      hbar = hbar,\n      q = grid_points$q,\n      p = grid_points$p,\n      energy = energy,\n      flow_q = flow_q_norm,\n      flow_p = flow_p_norm\n    )\n  }\n  \n  return(list(\n    q_grid = q_grid,\n    p_grid = p_grid,\n    results = results\n  ))\n}\n\n# Generate data\nphase_space_data <- generate_unified_phase_space(\n  hbar_values = c(0, 0.2, 0.5),\n  resolution = 30\n)\n\n# Create visualization\nphase_space_plots <- list()\nhbar_labels <- c(\"Classical (ħ = 0)\", \"Semiclassical (ħ = 0.2)\", \"Quantum (ħ = 0.5)\")\nplot_colors <- c(\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\")\n\nfor(i in seq_along(phase_space_data$results)) {\n  result <- phase_space_data$results[[i]]\n  \n  # Reshape energy for contour plot\n  energy_matrix <- matrix(result$energy, \n                         nrow = length(phase_space_data$q_grid),\n                         ncol = length(phase_space_data$p_grid))\n  \n  # Create contour plot\n  plot_data <- expand.grid(\n    q = phase_space_data$q_grid,\n    p = phase_space_data$p_grid\n  )\n  plot_data$energy <- c(energy_matrix)\n  \n  # Subsample flow vectors for clearer visualization\n  subsample <- seq(1, length(result$q), by = 5)\n  \n  # Create plot\n  plot <- plot_ly(height = 400) %>%\n    add_contour(\n      z = energy_matrix,\n      x = phase_space_data$q_grid,\n      y = phase_space_data$p_grid,\n      contours = list(\n        start = 0,\n        end = 3,\n        size = 0.25\n      ),\n      colorscale = 'Viridis',\n      showscale = FALSE\n    ) %>%\n    add_trace(\n      x = result$q[subsample],\n      y = result$p[subsample],\n      u = result$flow_q[subsample],\n      v = result$flow_p[subsample],\n      type = 'scatter',\n      mode = 'markers+lines',\n      marker = list(size = 2, color = plot_colors[i]),\n      line = list(width = 1, color = plot_colors[i]),\n      name = 'Flow',\n      showlegend = FALSE\n    ) %>%\n    layout(\n      title = hbar_labels[i],\n      xaxis = list(title = \"Position (q)\"),\n      yaxis = list(title = \"Momentum (p)\")\n    )\n  \n  phase_space_plots[[i]] <- plot\n}\n\n# Integration illustration\nintegration_plot <- plot_ly(height = 300) %>%\n  add_trace(\n    x = seq(-2, 2, length.out = 100),\n    y = cos(pi * seq(-2, 2, length.out = 100)),\n    type = 'scatter',\n    mode = 'lines',\n    line = list(color = 'blue', width = 3),\n    name = 'Classical Path'\n  ) %>%\n  add_trace(\n    x = seq(-2, 2, length.out = 100),\n    y = cos(pi * seq(-2, 2, length.out = 100)) + \n       0.3 * sin(3 * pi * seq(-2, 2, length.out = 100)),\n    type = 'scatter',\n    mode = 'lines',\n    line = list(color = 'red', width = 3),\n    name = 'Quantum Path'\n  ) %>%\n  layout(\n    title = \"Path Integration: Classical vs Quantum\",\n    xaxis = list(title = \"Time\"),\n    yaxis = list(title = \"Position\")\n  )\n\n# Combine all plots\nsubplot(\n  subplot(phase_space_plots[[1]], phase_space_plots[[2]], phase_space_plots[[3]], \n          nrows = 1, shareY = TRUE, shareX = TRUE),\n  integration_plot,\n  nrows = 2,\n  heights = c(0.7, 0.3)\n) %>%\n  layout(\n    title = \"Unified Framework: From Classical to Quantum Mechanics\",\n    showlegend = TRUE\n  )",
      "line_count": 187
    }
  ]
}