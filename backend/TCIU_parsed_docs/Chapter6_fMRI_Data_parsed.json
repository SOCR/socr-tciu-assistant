{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.285516",
    "total_sections": 3,
    "total_code_chunks": 6,
    "total_tables": 1,
    "r_libraries": [
      "EBImage",
      "abind",
      "brainR",
      "plotly",
      "spatstat"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Spacekime Analytics (Time Complexity and Inferential Uncertainty)\"\nsubtitle: \"fMRI Data\"\nauthor: \"SOCR Team \"\ndate: \"`r format(Sys.time(),'%m/%d/%Y')`\"\noutput: \n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n      smooth_scroll: true",
      "word_count": 39
    },
    {
      "title": "fMRI Space-kime Example",
      "content": "In this example, we demonstrate spacekime data analytics using real 4D fMRI data ($x=64 \\times y=64\\times z=21\\times t=180$). For simplicity of the presentation, analysis, and visualization, we will focus on a 2D time-series of the entire 4D fMRI hypervolume. In other words, we'll (artificially) reduce the native 3D space (${\\bf{x}}=(x,y,z)\\in \\mathbb{R}^3$) to 2D (${\\bf{x}}=(x,y)\\in \\mathbb{R}^2\\subseteq \\mathbb{R}^3$) by focusing only on mid-axial/transverse slice through the brain ($z=11$). More details are provided in [DSPA Chapter 3](http://www.socr.umich.edu/people/dinov/courses/DSPA_notes/03_DataVisualization.html).\n\n\n\nSuppose the 2D fMRI time-series is represented analytically by $f({\\bf{x}},t)=f(x,y,t):\\mathbb{R}^2\\times \\mathbb{R}^+ \\longrightarrow R$ and computationally as a 3D array. Then each of these are also 3D (complex-valued) arrays: $\\hat{f}$, magnitude of the FT ($|\\hat{f}|=\\sqrt{Re(\\hat{f})^2+Im(\\hat{f})^2}$), and the phase-angles, \n$\\theta = \\arctan \\left (\\frac{Im(\\hat{f})}{Re(\\hat{f})}\\right )$. \n\nWe will focus on the function $\\hat{f}=(f_1, f_2, f_3)$ where the 3-rd dimension *correponds to time*. Specifically, we will consider the magnitude of its 3-rd dimension as $time=|f_3|$ and we will pretend its phase is unknown, i.e., $\\theta_3 =0$. Thus, inverting the FT of the modified function $\\tilde{\\hat{f}}$, where $\\theta_3 =0$, we get an estimate of **kime** for the original 2D fMRI time-series as $\\hat{\\tilde{\\hat{f}}}$.\n\nAs an observable, the *time* is measurable and the *phase* angles can either be estimated from other similar data, provided by an oracle, or fixed according to some experimental conditions. For simplicity, we'll consider two specific instance:\n\n* When the time-dimension phases are indeed the actual FT phases, which are in general unknown, however, in our fMRI simulation example, they are actually computed from the original space-time fMRI time-series via the Fourier transformation, and\n* When the time-dimension phases are provided by the investigator, e.g., trivial (nil) phases or phases derived from other similar datasets.",
      "word_count": 277
    },
    {
      "title": "Longitudinal Data (Timeseries/Kimeseries) Example",
      "content": "This timeseries demonstration shows the effects of indexing timeseries (univariate) data only using time and compares the representation of timeseries and kimeseries, which has profound impact on the subsequent data analytics. TO keep this application grounded, we will use real 4D fMRI data ($x=64 \\times y=64\\times z=21\\times t=180$), but only focus on one spatial location (${\\bf{x}}=(x,y,z)\\in \\mathbb{R}^3$). More details are provided in [DSPA Chapter 3](http://www.socr.umich.edu/people/dinov/courses/DSPA_notes/03_DataVisualization.html).\n\n\nThese examples demonstrate the timeseries representation and analysis work well in spacetime. However, in various situations where one may or may not be able to observe or estimate the kime-direction (phase) the results can widely vary based on how reasonable to synthesis of information is without explicit knowledge of the phase measures. As an observable, the *time* (kime-order) is measurable and the *phase* angles (kime-direction) can either be estimated from other similar data, provided by an oracle, or fixed according to some experimental conditions. \n\n\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"http://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"http://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"http://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 244
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    code_folding: hide\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "knitr::opts_chunk$set(echo = TRUE, warings = FALSE)",
      "line_count": 1
    },
    {
      "section": "Main",
      "code": "\n# Get this figure: fig <- get_figure(\"MattSundquist\", 4064)\n# Get this figure's data: data <- get_figure(\"MattSundquist\", 4064)$data\n# Add data to this figure: p <- add_trace(p, x=c(4, 5), y=c(4, 5), kwargs=list(filename=\"Klein bottle\", fileopt=\"extend\"))\n# Get y data of first trace: y1 <- get_figure(\"MattSundquist\", 4064)$data[[1]]$y\n\nlibrary(plotly)",
      "line_count": 7
    },
    {
      "section": "fMRI Space-kime Example",
      "code": "# FFT SHIFT\nfftshift <- function(img_ff, dim = -1) {\n\n  rows <- dim(img_ff)[1]    \n  cols <- dim(img_ff)[2]\n  # planes <- dim(img_ff)[3]\n\n  swap_up_down <- function(img_ff) {\n    rows_half <- ceiling(rows/2)\n    return(rbind(img_ff[((rows_half+1):rows), (1:cols)], img_ff[(1:rows_half), (1:cols)]))\n  }\n\n  swap_left_right <- function(img_ff) {\n    cols_half <- ceiling(cols/2)\n    return(cbind(img_ff[1:rows, ((cols_half+1):cols)], img_ff[1:rows, 1:cols_half]))\n  }\n  \n  #swap_side2side <- function(img_ff) {\n  #  planes_half <- ceiling(planes/2)\n  #  return(cbind(img_ff[1:rows, 1:cols, ((planes_half+1):planes)], img_ff[1:rows, 1:cols, 1:planes_half]))\n  #}\n\n  if (dim == -1) {\n    img_ff <- swap_up_down(img_ff)\n    return(swap_left_right(img_ff))\n  }\n  else if (dim == 1) {\n    return(swap_up_down(img_ff))\n  }\n  else if (dim == 2) {\n    return(swap_left_right(img_ff))\n  }\n  else if (dim == 3) {\n    # Use the `abind` package to bind along any dimension a pair of multi-dimensional arrays\n    # install.packages(\"abind\")\n    library(abind)\n    \n    planes <- dim(img_ff)[3]\n    rows_half <- ceiling(rows/2)\n    cols_half <- ceiling(cols/2)\n    planes_half <- ceiling(planes/2)\n    \n    img_ff <- abind(img_ff[((rows_half+1):rows), (1:cols), (1:planes)], \n                    img_ff[(1:rows_half), (1:cols), (1:planes)], along=1)\n    img_ff <- abind(img_ff[1:rows, ((cols_half+1):cols), (1:planes)], \n                    img_ff[1:rows, 1:cols_half, (1:planes)], along=2)\n    img_ff <- abind(img_ff[1:rows, 1:cols, ((planes_half+1):planes)], \n                    img_ff[1:rows, 1:cols, 1:planes_half], along=3)\n    return(img_ff)\n  }\n  else {\n    stop(\"Invalid dimension parameter\")\n  }\n}\n\nifftshift <- function(img_ff, dim = -1) {\n\n  rows <- dim(img_ff)[1]    \n  cols <- dim(img_ff)[2]    \n\n  swap_up_down <- function(img_ff) {\n    rows_half <- floor(rows/2)\n    return(rbind(img_ff[((rows_half+1):rows), (1:cols)], img_ff[(1:rows_half), (1:cols)]))\n  }\n\n  swap_left_right <- function(img_ff) {\n    cols_half <- floor(cols/2)\n    return(cbind(img_ff[1:rows, ((cols_half+1):cols)], img_ff[1:rows, 1:cols_half]))\n  }\n\n  if (dim == -1) {\n    img_ff <- swap_left_right(img_ff)\n    return(swap_up_down(img_ff))\n  }\n  else if (dim == 1) {\n    return(swap_up_down(img_ff))\n  }\n  else if (dim == 2) {\n    return(swap_left_right(img_ff))\n  }\n  else if (dim == 3) {\n    # Use the `abind` package to bind along any dimension a pair of multi-dimensional arrays\n    # install.packages(\"abind\")\n    library(abind)\n    \n    planes <- dim(img_ff)[3]\n    rows_half <- floor(rows/2)\n    cols_half <- floor(cols/2)\n    planes_half <- floor(planes/2)\n    \n    img_ff <- abind(img_ff[1:rows, 1:cols, ((planes_half+1):planes)], \n                    img_ff[1:rows, 1:cols, 1:planes_half], along=3)\n    img_ff <- abind(img_ff[1:rows, ((cols_half+1):cols), (1:planes)], \n                    img_ff[1:rows, 1:cols_half, (1:planes)], along=2)\n    img_ff <- abind(img_ff[((rows_half+1):rows), (1:cols), (1:planes)], \n                    img_ff[(1:rows_half), (1:cols), (1:planes)], along=1)\n    return(img_ff)\n  }\n  else {\n    stop(\"Invalid dimension parameter\")\n  }\n}",
      "line_count": 102
    },
    {
      "section": "fMRI Space-kime Example",
      "code": "# install EBImage\n# source(\"https://bioconductor.org/biocLite.R\")\n# biocLite(\"EBImage\")\nlibrary(EBImage)\nrequire(brainR)\nlibrary(spatstat) \nlibrary(plotly)\n\n# 1. download the 4D fMRI data\nfMRIURL <- \"http://socr.umich.edu/HTML5/BrainViewer/data/fMRI_FilteredData_4D.nii.gz\"\nfMRIFile <- file.path(tempdir(), \"fMRI_FilteredData_4D.nii.gz\")\ndownload.file(fMRIURL, dest=fMRIFile, quiet=TRUE)\n(fMRIVolume <- readNIfTI(fMRIFile, reorient=FALSE))\n# dimensions: 64 x 64 x 21 x 180 ; 4mm x 4mm x 6mm x 3 sec \n\nfMRIVolDims <- dim(fMRIVolume); fMRIVolDims\n# time_dim <- fMRIVolDims[4]; time_dim ## 180\n\n# 2. extract the time-corse of 2D mid-axial slice (3D) hypervolume\nfMRI_2D_z11 <- fMRIVolume[ , , 11, ]; dim(fMRI_2D_z11)   # 64  64 180\n\n# 3. Some plots \n### 2D\nimage(as.im(fMRI_2D_z11[, , 1]), col=grey(fMRI_2D_z11[, , 1]/max(fMRI_2D_z11[, , 1]), alpha = 1))\n\n### 3D Plotly\nimg_t90 <- as.matrix(blur(as.im(fMRI_2D_z11[, , 90]), sigma=0.1)) # the smoothed version of the 2D image (t=90)\nimage(as.im(img_t90))\n\nimg_t1 <- -20000+ as.matrix(blur(as.im(fMRI_2D_z11[, , 1]), sigma=0.1))  # t=1 baseline\nimg_t180 <- 20000+ as.matrix(blur(as.im(fMRI_2D_z11[, , 180]), sigma=0.1))  # t=180 end\n\n# Plot the image surfaces\np <- plot_ly(z=img_t90, type=\"surface\", showscale=FALSE) %>%\n add_trace(z=img_t1, type=\"surface\", showscale=FALSE, opacity=0.5) %>%\n add_trace(z=img_t180, type=\"surface\", showscale=FALSE, opacity=0.5)\np \n\n#### # try different levels at which to construct contour surfaces (10 fast)\n# lower values yield smoother surfaces # see ?contour3d\n# contour3d(fMRI_2D_z11, level = 1000, alpha = 0.1, draw = TRUE)\n\n# multiple levels may be used to show multiple shells\n# \"activations\" or surfaces like hyper-intense white matter\n# This will take 1-2 minutes to rend!\ncontour3d(fMRI_2D_z11, level = c(1000, 15000), alpha = c(0.3, 0.5),\n        add = TRUE, color=c(\"yellow\", \"red\"))\n\n# Plot the 4D array of imaging data in a 5x5 grid of images \n# The first three dimensions are spatial locations of the voxel (volume element) and the fourth dimension is time for this functional MRI (fMRI) acquisition. \n# image(fMRIVolume, zlim=range(fMRIVolume)*0.95)\n\n# 4. FT of 2D slices\nX1 = fft(img_t90); image(as.im(fftshift(Re(X1)))) # display(Re(X1), method = \"raster\")\nX1_mag <- sqrt(Re(X1)^2+Im(X1)^2); image(as.im(fftshift(Re(X1_mag)))) # display(X1_mag, method = \"raster\")\nX1_phase <- atan2(Im(X1), Re(X1)); image(as.im(fftshift(Re(X1_phase)))) # display(X1_phase, method = \"raster\")\n##  Implicit Automated IFT\nhat_X1 = Re(fft(X1, inverse = T)/length(X1)); image(as.im(hat_X1)) # display(hat_X1, method = \"raster\")\n## Manually invert the FT (IFT) using the magnitudes and phases\nReal1 = X1_mag * cos(X1_phase)\nImaginary1 = X1_mag * sin(X1_phase)\nman_hat_X1 = Re(fft(Real1 + 1i*Imaginary1, inverse = T)/length(X1)); image(as.im(man_hat_X1))\n\n# IFT fMRI-Magnitude and Nil-Phase\nReal_phase0 = X1_mag * cos(0)\nImaginary_phase0 = X1_mag * sin(0)\nift_NilPhase_X1mag = Re(ifftshift(fft(Real_phase0 + 1i*Imaginary_phase0, inverse = T)/length(X1))); image(as.im(ift_NilPhase_X1mag))",
      "line_count": 67
    },
    {
      "section": "fMRI Space-kime Example",
      "code": "# 5. FT of 3D time-series \nX1 = fft(fMRI_2D_z11); dim(X1); hist(Re(log(1+X1)), xlim=c(5, 20))\n# Plot the centered frequency spectrum FT of the 2D time-series (in 3D), only half the frequencies are needed.\nplanes_half <- ceiling(dim(fMRI_2D_z11)[3]/2)\n\n# Visualize the Simulated Original Observed Data in k-space\nimg1 <- fftshift(Re(log(1+X1)),3)[ , , (1:(planes_half+1))]   # apply log transform to temper the intensity range\ncontour3d(img1, level = c(7, 12), alpha = c(0.3, 0.5), add = TRUE, color=c(\"yellow\", \"red\"), perspective=T)\n\n## Compute the 3D Magnitude and Phase     \nX1_mag <- fftshift(sqrt(Re(X1)^2+Im(X1)^2), 3)[ , , (1:(planes_half+1))] # log transform to temper the intensity range\ncontour3d(log(X1_mag), level = c(7, 12), alpha = c(0.3, 0.5), add = TRUE, color=c(\"yellow\", \"red\"))\nX1_phase <- atan2(Im(X1), Re(X1))\ncontour3d(X1_phase, level = c(-2, 2), alpha = c(0.3, 0.5), add = TRUE, color=c(\"yellow\", \"red\"))\n\n##  Implicit Automated IFT\nhat_X1 = Re(fft(X1, inverse = T)/length(X1))\ncontour3d(hat_X1, level = c(1000, 15000), alpha = c(0.3, 0.5), add = TRUE, color=c(\"yellow\", \"red\"))\n\n## Manually invert the FT (IFT) using the magnitudes and phases\nReal1 = fftshift(sqrt(Re(X1)^2+Im(X1)^2), 3) * cos(X1_phase) #  X1_mag * cos(X1_phase)\nImaginary1 = fftshift(sqrt(Re(X1)^2+Im(X1)^2), 3) * sin(X1_phase)\nman_hat_X1 = Re(fft(Real1 + 1i*Imaginary1, inverse = T)/length(X1))\ncontour3d(man_hat_X1, level = c(1000, 15000), alpha = c(0.3, 0.5), add = TRUE, color=c(\"yellow\", \"red\"))\n\n# IFT fMRI-Magnitude and Nil-Phase\nReal_phase0 = X1_mag * cos(0)\nImaginary_phase0 = X1_mag * sin(0)\nift_NilPhase_X1mag = Re(ifftshift(fft(Real_phase0 + 1i*Imaginary_phase0, inverse = T)/length(X1), dim=3))\ncontour3d(ift_NilPhase_X1mag, level = c(1000, 15000), alpha = c(0.3, 0.5), add = TRUE, color=c(\"yellow\", \"red\"))",
      "line_count": 30
    },
    {
      "section": "Longitudinal Data (Timeseries/Kimeseries) Example",
      "code": "# install EBImage\n# source(\"https://bioconductor.org/biocLite.R\")\n# biocLite(\"EBImage\")\nlibrary(EBImage)\nrequire(brainR)\nlibrary(spatstat) \n\n# 1D timeseries FFT SHIFT\nfftshift1D <- function(img_ff) {\n  rows <- length(img_ff)   \n  rows_half <- ceiling(rows/2)\n  return(append(img_ff[(rows_half+1):rows], img_ff[1:rows_half]))\n}\n\n# 1. download the 4D fMRI data\nfMRIURL <- \"http://socr.umich.edu/HTML5/BrainViewer/data/fMRI_FilteredData_4D.nii.gz\"\nfMRIFile <- file.path(tempdir(), \"fMRI_FilteredData_4D.nii.gz\")\ndownload.file(fMRIURL, dest=fMRIFile, quiet=TRUE)\n(fMRIVolume <- readNIfTI(fMRIFile, reorient=FALSE))\n# dimensions: 64 x 64 x 21 x 180 ; 4mm x 4mm x 6mm x 3 sec \n\nfMRIVolDims <- dim(fMRIVolume); fMRIVolDims\n# time_dim <- fMRIVolDims[4]; time_dim ## 180\n\n# 2. extract the time-course of one voxel (25, 25, 12)  # 64  64 21 180\nx1 <- c(1:180)\ny1 <- loess(fMRIVolume[25, 25, 12, ]~ x1, family = \"gaussian\")\nwindows(width=10, height=8)\nplot(fMRIVolume[25, 25, 12, ], type='l', \n     main=\"Time Series of 3D Voxel \\n (x=25, y=25, z=12)\", col=\"blue\", \n     xlab = \"Time\", ylab = \"fMRIVolume[25, 25, 12, ] Intensities\")\nlines(x1, smooth(fMRIVolume[25, 25, 12, ]), col = \"red\", lwd = 2)\nlines(ksmooth(x1, fMRIVolume[25, 25, 12, ], kernel = \"normal\", bandwidth = 5), col = \"green\", lwd = 3)\nlegend(\"bottomright\", legend=c(\"(raw) fMRI\", \"smooth(fMRI)\", \"ksmooth(fMRI\"),\n       col=c(\"blue\", \"red\", \"green\"), lty=1, lwd=4, cex=1.1, y.intersp=0.6,\n       x.intersp=1.0, title = \"Voxel (25, 25, 12)\", bty = \"n\")\n\n# 3. FT of 1D time-course\ny2 <- fMRIVolume[25, 25, 12, ]\nX2 = fft(y2); plot(fftshift1D(log(Re(X2)+2)), main = \"log(fftshift1D(Re(FFT(timeseries))))\") \nX2_mag <- sqrt(Re(X2)^2+Im(X2)^2); plot(log(fftshift1D(Re(X2_mag))), main = \"log(Magnitude(FFT(timeseries)))\") \nX2_phase <- atan2(Im(X2), Re(X2)); plot(fftshift1D(X2_phase), main = \"Shift(Phase(FFT(timeseries)))\")\n\n##  Implicit Automated IFT\nhat_X2 = Re(fft(X2, inverse = T)/length(X2))\nplot(hat_X2, main = \"Re(IFT(FFT(timeseries)))\")   # point plot represents the IFT(FT(data))\nlines(x1, y2, col = \"red\", lwd = 2)               # lines represent the raw data time-course (should coincide)\n\n## Manually invert the FT (IFT) using the magnitudes and phases\nReal2 = X2_mag * cos(X2_phase)\nImaginary2 = X2_mag * sin(X2_phase)\nman_hat_X2 = Re(fft(Real2 + 1i*Imaginary2, inverse = T)/length(X2))\nplot(man_hat_X2, type=\"l\", lwd=2, main = \"Manual IFT (Magnitude, Phase) Synthesis\")\nlines(x1, y2, col = \"red\", lty=2, lwd = 2)  # overlay original data to confirm PERFECT manual reconstruction\n\n# IFT reconstruction (synthesis) using fMRI-Magnitude and Nil-Phase\nReal_phase0 = X2_mag * cos(0)\nImaginary_phase0 = X2_mag * sin(0)\nift_NilPhase_X2mag = Re(fft(Real_phase0 + 1i*Imaginary_phase0, inverse = T)/length(X2))\nwindows(width=10, height=8)\nplot(ift_NilPhase_X2mag, col=\"red\", type=\"l\", lty=2, lwd=2, \n     ylim=c(10270, 10500), main=sprintf('Signal Synthesis: IFT (Magnitude=Real, Phase=Nil)\\n Correlation(Real, Recon) = %s', format(cor(ift_NilPhase_X2mag, y2), digits=3)), xlab = \"Time\", \n     ylab = \"IFT(NilPhase_Reconstruction)[25, 25, 12, ]\", cex=1.3)\nlines(x1, y2, col = \"black\", lwd = 2)  # overlay original data to show Nil-Phase effects on reconstruction\nlegend(\"top\", bty=\"n\", legend=c(\"(raw) fMRI\", \"Nil-Phase (Time-only) Reconstruction\"),\n       col=c(\"black\", \"red\"), lty=c(1,2), lwd=c(2,2), cex=1.3, x.intersp=0.8)\n# cor(ift_NilPhase_X2mag, y2)\n\n################## Plot_ly Figure 6.5\ntime <- c(1:length(ift_NilPhase_X2mag))\np <- plot_ly()\np <- add_lines(p, x=~time,  y=~y2, \n               name = \"f=fMRIVolume[25, 25, 12, ]\", type = 'scatter', mode = 'lines', \n               hoverinfo = 'name', line=list(color='blue'))\np <- add_lines(p, x=~time, y=~ift_NilPhase_X2mag, \n               name = \"f2=ift_NilPhase_X2mag[25, 25, 12, ]\", type = 'scatter', mode = 'lines', \n               hoverinfo = 'name', \n               line=list(color='green', width = 8)) %>%\n  layout(yaxis = list(range = c(10200,10500), title=\"Intensity\"),\n    title=sprintf('Signal Synthesis: IFT (Magnitude=Real, Phase=Nil)\\n Correlation(Real, Recon) = %s',\n                       format(cor(ift_NilPhase_X2mag, y2), digits=3)),\n    legend = list(orientation = \"h\",   # show entries horizontally\n                     xanchor = \"center\",  # use center of legend as anchor\n                     x = 0.5, \n                     size = 30))      \np\n\n\n# IFT reconstruction (synthesis) using fMRI-Magnitude and Random-Phase\nset.seed(1234)\nrand_Phase <- runif(length(X2_mag), -pi, pi)\n#  rand_Phase <- runif(1, -pi, pi)\nReal_phaseRand = X2_mag * cos(rand_Phase)\nImaginary_phaseRand = X2_mag * sin(rand_Phase)\nift_RandPhase_X2mag = Re(fft(Real_phaseRand + 1i*Imaginary_phaseRand, inverse = T)/length(X2))\nplot(ift_RandPhase_X2mag-mean(ift_RandPhase_X2mag) + mean(y2), col=\"red\", type=\"l\", lty=2, lwd=2, \n     ylim=c(10300, 10500), main=sprintf('Signal Synthesis: IFT (Magnitude=Real, Phase=Random)\\n Correlation(Real, Recon) = %s', format(cor(ift_RandPhase_X2mag, y2), digits=3)))\nlines(x1, y2, col = \"black\", lwd = 2)  # overlay original data to show Rand-Phase effects on reconstruction\nlegend(\"top\", bty=\"n\", legend=c(\"(raw) fMRI\", \"Random-Phase Reconstruction\"),\n       col=c(\"black\", \"red\"), lty=c(1,2), lwd=c(2,2), cex=0.9, x.intersp=0.5)\n\n# IFT reconstruction (synthesis) using fMRI-Magnitude and Phase from a different voxel location (28, 22, 10)\ny3 <- fMRIVolume[28, 22, 10, ]\nX3 = fft(y3)  # ;  plot(fftshift1D(log(Re(X3)+2)), main = \"log(fftshift1D(Re(FFT(timeseries))))\") \n# X3_mag <- sqrt(Re(X3)^2+Im(X3)^2); plot(log(fftshift1D(Re(X3_mag))), main = \"log(Magnitude(FFT(timeseries)))\") \nneighbor_Phase <- atan2(Im(X3), Re(X3)) # ; plot(fftshift1D(X3_phase), main = \"Shift(Phase(FFT(timeseries)))\")\n\nReal_phaseNeighbor = X2_mag * cos(neighbor_Phase)\nImaginary_phaseNeighbor = X2_mag * sin(neighbor_Phase)\nift_NeighborPhase_X2mag = Re(fft(Real_phaseNeighbor + 1i*Imaginary_phaseNeighbor, inverse = T)/length(X2))\nplot(ift_NeighborPhase_X2mag, col=\"red\", type=\"l\", lty=2, lwd=2, \n     ylim=c(10300, 10500), main=sprintf('Signal Synthesis: IFT (Magnitude=Real(25, 25, 12), Phase=Voxel Neighbor(28, 22, 10))\\n Correlation(Real, Recon) = %s', format(cor(ift_NeighborPhase_X2mag, y2), digits=3)))\nlines(x1, y2, col = \"black\", lwd = 2)  # overlay original data to show Rand-Phase effects on reconstruction\nlegend(\"top\", bty=\"n\", legend=c(\"(raw) fMRI\", \"Neighbor-Derived-Phase Reconstruction\"),\n       col=c(\"black\", \"red\"), lty=c(1,2), lwd=c(2,2), cex=0.9, x.intersp=0.5)\n\n# IFT reconstruction (synthesis) using fMRI-Magnitude and Phase from a highly correlated voxel location\nset.seed(1234)\ny4 <- y2 + rnorm(n=length(y2), 0, 40) #; plot(y2, y4); cor(y2, y4)\nX4 = fft(y4)  # ;  plot(fftshift1D(log(Re(X3)+2)), main = \"log(fftshift1D(Re(FFT(timeseries))))\") \n# X4_mag <- sqrt(Re(X4)^2+Im(X4)^2); plot(log(fftshift1D(Re(X4_mag))), main = \"log(Magnitude(FFT(timeseries)))\") \ncorr_Phase <- atan2(Im(X4), Re(X4)) # ; plot(fftshift1D(X4_phase), main = \"Shift(Phase(FFT(timeseries)))\")\n\nReal_phaseCorr = X2_mag * cos(corr_Phase)\nImaginary_phaseCorr = X2_mag * sin(corr_Phase)\nift_CorrPhase_X2mag = Re(fft(Real_phaseCorr + 1i*Imaginary_phaseCorr, inverse = T)/length(X2))\nwindows(width=10, height=8)\nplot(ift_CorrPhase_X2mag, col=\"red\", type=\"l\", lty=2, lwd=2, \n     ylim=c(10250, 10510), main=sprintf('Signal Synthesis: IFT (Magnitude=Real, Phase=Highly-Correlated (%s) Voxel\\n Correlation(Real, Recon) = %s', format(cor(y4, y2), digits=3),\n                                        format(cor(ift_CorrPhase_X2mag, y2), digits=3)),\n     xlab = \"Time\", ylab = \"IFT(Highly-Corr_Reconstruction)[25, 25, 12, ] Intensities\")\nlines(x1, y2, col = \"black\", lwd = 2)  # overlay original data to show Rand-Phase effects on reconstruction\nlegend(\"top\", bty=\"n\", legend=c(\"(raw) fMRI\", \"Correlated-Voxel-Phase Reconstruction\"),\n       col=c(\"black\", \"red\"), lty=c(1,2), lwd=c(2,2), cex=1.2, x.intersp=0.8)\n\n##### Plot_Ly Figure 6.6\np <- plot_ly()\np <- add_lines(p, x=~time,  y=~y2, \n               name = \"f=fMRIVolume[25, 25, 12, ]\", type = 'scatter', mode = 'lines', \n               hoverinfo = 'name', line=list(color='blue'))\np <- add_lines(p, x=~time, y=~ift_CorrPhase_X2mag, \n               name = \"f2=IFT(Highly-Corr_Reconstruction)[25, 25, 12, ] Intensities\", type = 'scatter', mode = 'lines', \n               hoverinfo = 'name', \n               line=list(color='green', width = 8)) %>%\n  layout(yaxis = list(range = c(10200,10500), title=\"Intensity\"),\n    title=sprintf('Signal Synthesis: IFT (Magnitude=Real, Phase=Highly-Correlated (%s)) Voxel\\n Correlation(Real, Recon) = %s', \n                  format(cor(y4, y2), digits=3),\n                  format(cor(ift_CorrPhase_X2mag, y2), digits=3)),\n    legend = list(orientation = \"h\",   # show entries horizontally\n                     xanchor = \"center\",  # use center of legend as anchor\n                     x = 0.5, \n                     size = 30))      \np\n\n# This is an effective reconstruction (synthesis) of the raw data by approximating the \"unknown\" phases.\n# The reason why this works is that the real and estimated phases closely resemble each other\nplot(X2_phase, corr_Phase, xlab = \"Real Phase\", ylab = \"Approximate Phase\", \n     main =sprintf('Scatterplot of True (x-axis) and Approximate Phases\\n\n     Correlation = %s', format(cor(X2_phase, corr_Phase), digits=3)))\n\n# Similarly, the reconstructed and real signal are highly correlated as the scatterplot shows\nplot(y2, y4, xlab = \"Real Signal\", ylab = \"Reconstructed (using estimated Phases)\", \n     main =sprintf('Scatterplot of True Signal (x-axis) and Approximate-Phase reconstructed Signal\\n\n     Correlation = %s', format(cor(y2, y4), digits=3)))",
      "line_count": 164
    }
  ]
}