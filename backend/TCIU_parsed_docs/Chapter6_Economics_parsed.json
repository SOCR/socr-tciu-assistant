{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.274436",
    "total_sections": 13,
    "total_code_chunks": 56,
    "total_tables": 1,
    "r_libraries": [
      "FactoMineR",
      "ada",
      "arm",
      "caret",
      "cluster",
      "doParallel",
      "dplyr",
      "e1071",
      "factoextra",
      "fastDummies",
      "forecast",
      "ggplot2",
      "ggrepel",
      "glmnet",
      "gridExtra",
      "ipred",
      "kernlab",
      "knitr",
      "magrittr",
      "plot3D",
      "plotly",
      "pracma",
      "randomForest",
      "scatterplot3d",
      "tidyr"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Spacekime Analytics (Time Complexity and Inferential Uncertainty)\"\nsubtitle: \"European Economic Spacekime Analysis Part 1 â€“ Longitudinal Modeling\"\nauthor: \"SOCR Team \"\ndate: \"`r format(Sys.time(),'%m/%d/%Y')`\"\noutput: \n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n      smooth_scroll: true",
      "word_count": 46
    },
    {
      "title": "Data Preprocessing {.tabset .tabset-fade .tabset-dropdown}",
      "content": "- Load the data\n - Find all \"Common\" features (highly-observed and congruent Econ indicators)\n - Establish homologies between the XReg predictors for ALL 31 EU countries.\n \n\n\n\nLoading all packages that are required.\n\n\nLoad the data and preprocess the data.",
      "word_count": 39
    },
    {
      "title": "Laplace Transform",
      "content": "Define the *forward* and *reverse* *Laplace Transforms* (LT/ILT).",
      "word_count": 8
    },
    {
      "title": "Kimesurface of GDP for 30 EU countries",
      "content": "",
      "word_count": 0
    },
    {
      "title": "Inverse Laplace Transform",
      "content": "",
      "word_count": 0
    },
    {
      "title": "Reformat the data into a 3D array (country \\* feature \\* time)",
      "content": "",
      "word_count": 0
    },
    {
      "title": "Data visualization",
      "content": "",
      "word_count": 0
    },
    {
      "title": "Time series format",
      "content": "Remove duplicates.",
      "word_count": 2
    },
    {
      "title": "Fit the ARIMA model for each country",
      "content": "## Belgium \n\nExtract Belgium data.\n\n\nManually clean (preprocess) the Belgium data and fit ARIMAX model \n$$Y = BelguimSuperSample\\$'Unemployment,\\ Females,\\ From\\ 15-64\\ years,\\ Total',$$\n\n$$X = XReg\\ (all\\ other\\ covariates\\ -starts\\_with('Unemployment')).$$\n\n\n* *GDP Description*: [GDP](https://datamarket.com/data/set/196v/gross-domestic-product-at-market-prices) (gross domestic product) is an indicator for a nation's economic situation. It reflects the total value of all goods and services produced less the value of goods and services used for intermediate consumption in their production. Expressing GDP in PPS (purchasing power standards) eliminates differences in price levels between countries, and calculations on a per head basis allows for the comparison of economies significantly different in absolute size.\n\n[GDP unit of measure](https://ec.europa.eu/eurostat/statistics-explained/index.php/Glossary:GDP_per_capita_in_purchasing_power_standards) represents the *Current prices, euro per capita*. The volume index of GDP per capita in Purchasing Power Standards (PPS) is intended for cross-country comparisons rather than for temporal comparisons. GDP per capita when expressed in PPS eliminates the differences in price levels between countries allowing meaningful volume comparisons of GDP between countries. Expressed in relation to the European Union (*EU27 GDP = 100*), a country with an index that is higher than $100$ or lower than $100$ corresponds to that country's level of GDP per head being higher or lower than the EU average, respectively.\n\n\n## Bulgaria\n\nDefine a new function that (1) cleans the data, and (2) fits the ARIMA model estimating the seasonal and non-seasonal time-series parameters $(p,d,q)$ and the effect-sizes ($\\beta$'s) for the exogenous regression features ($X$).",
      "word_count": 236
    },
    {
      "title": "TS Forecasting",
      "content": "## Perform ARIMAX modeling \n\n<!-- Predict `Y={Unemployment , Females, From 15-64 years, Total}`, using all other features not directly related to \"unemployment\". Recall the core data organization: -->\n\nPredict `Y={Gross domestic product at market prices}`, using all other features not directly related to ***GDP**. Recall the core data organization:\n\n - 131 (common BE + BG) `Xreg` Predictors and 1 Outcome Variable to be modeled as a timeseries: 2000 - 2014 (15 years, Quarterly measures, 5-fold spline interpolation, $15*4*5=300$);\n - Spline interpolation x5 (freq=20 observations per year);   2000-01 to 2014-20 (300 timepoint observations over 15 years, for `training`). The remaining 60 timepoints used for `testing` (2015-01 to 2017-20).\n\nReport `ARIMA(p,d,q)` params and quality metrics AIC/BIC.\n\n\n## Display the alternative (spacetime) analytical models (ARIMAX)\n\nPlot only the last 5-years of training (2010-2014), $100TimePoints=5Years\\times 4Quarters\\times 5SuperSample$ and the 3-year prospective forecasting $60TimePoints=3Years\\times 4Quarters\\times 5SuperSample$.\n\n\nPlot entire 15-year training time-span  (2000-2014), $300TimePoints=15Years\\times 4Quarters\\times 5SuperSample$ and the 3-year prospective forecasting $60TimePoints=3Years\\times 4Quarters\\times 5SuperSample$.",
      "word_count": 158
    },
    {
      "title": "Spacekime analytics",
      "content": "## Generic K-Space transformations (FT/IFT)\n\nLet's start by defining the generic k-space transformation.\n\n\n## Kime-Phase Distributions\n\nExamine the Kime-direction Distributions of the Phases for all *Belgium* features (predictors + outcome). Define a generic function that plots the Phase distributions.\n\n\n## Nil-Phase Synthesis and ARIMAX re-modeling \n\nPerform Nil-Phase reconstruction - `IFT_NilPhase_FT_Belgium` - and then re-fit the ARIMAX model\n\n\n## Swapped-Phase Synthesis and ARIMAX Modeling\n\nSpace-time reconstructions by inverting back the `mag_FT` for each feature signal after swapping the feature-phases. In other words, we randomly shuffle the `columns` of the Phases-matrix (Training & Testing XReg Data) and use these *swapped* phases to synthesize the design covariate matrix ($Xreg$).\n\n\n## Random-Phase Synthesis and ARIMAX re-modeling \n\nPerform Random-Phase reconstruction - `IFT_RandPhase_FT_Belgium` - by randomly sampling from the phase distributions for each feature and then re-fitting the ARIMAX model\n\n\n## Result Visualization",
      "word_count": 137
    },
    {
      "title": "ML Data Analytics",
      "content": "## Data Preprocessing\n\nFind all \"Common\" features (highly-observed and congruent Econ indicators)\n\n\nFor each country ($n$) and each common feature ($k$), fit ARIMA model and estimate the parameters $(p,d,q)$ (non-exogenous, just the timeseries model for this feature), (p,d,q) triples for non-seasonal and seasonal effects.  For each (Country, Feature) pair, the 9 ARIMA-derived vector includes:\n** (ts_avg, forecast_avg, non-seasonal AR, non-seasonal MA, seasonal AR, seasonal MA, period, non-seasonal Diff, seasonal differences)**.\n\n\nConvert list of ARIMA models to a Data.Frame `[Countries, megaFeatures]` that can be put through ML data analytics. Augment the features using the [EU_SOCR_Country_Ranking_Data_2011 dataset](http://wiki.stat.ucla.edu/socr/index.php/SOCR_Data_2008_World_CountriesRankings).\n\n\n## `Spacetime` Analytics\n\n### Supervised classification\n\nUse [Model-based and Model-free methods](https://dspa.predictive.space/) to predict the *overall* (OA) country ranking.\n\n\n<!-- ### Unsupervised clustering -->\n\n<!-- Use [hierarchical, k-means and spectral clustering](https://dspa.predictive.space/) to generate derived-computed phenotypes of countries. Do these derived labels relate (correspond to) the overall (OA) country ranking? -->\n\n<!-- ```{r message=F, error=F, warning=F} -->\n\n<!-- # ... -->\n\n<!-- ``` -->\n\n### Dimensionality Reduction\n\nPCA and t-SNE 2D and 3D projections using [SOCR Dimensionality Reduction Webapp](https://socr.umich.edu/HTML5/SOCR_TensorBoard_UKBB/UsersData.html).\n\n - the *tensor* file `EU_Econ_TensorData_31Countries_By_386Features.txt` contains 31 rows (countries) and 386 = 42*9(ARIMA) + 8(meta-data) columns\n - the *labels* file `EU_Econ_Labels_31Countries_and OverallRankingOutcome.txt` includes 31 rows with 2 columns specifying the Countries and their OA (Overall rankings).\n - The reader can load these *tensor* data files into the [SOCR Dimensionality Reduction Webapp](https://socr.umich.edu/HTML5/SOCR_TensorBoard_UKBB/UsersData.html) and generate dynamic views of the 2D or 3D projections (PCA=Euclidean) and (t-SNE manifold).\n\n\n\n## `Spacekime` Analytics\n\n### Supervised classification\n\nUse [Model-based and Model-free methods](https://dspa.predictive.space/) to predict the *overall* (OA) country ranking.\n\n\n### Core redesign\n\nGeneric Functions\n\n\n#### Weak-signal Analytics\n\nUsing only the 378 ARIMA signatures for the prediction (out of the total of 386 features).\n\n##### Space-Time Analytics\n\n\n##### Space-Kime Analytics\n\n**Nil-Phase Synthesis** and LASSO model estimation ...\n \n\n**Swapped Feature Phases** and then synthesize the data (reconstruction)\n\n\n### Stronger Signal Analytics\n\nUsing all 386 features (378 ARIMA signatures + 8 meta-data).\n\n##### Space-Time Analytics\n\n\n##### Space-Kime Analytics\n\n**Nil-Phase Synthesis** and LASSO model estimation ...\n\n\n**Swapped Feature Phases** and then synthesize the data (reconstruction)\n\n\n\n#### Overall Plots\n\n\n### Unsupervised clustering\n\nUse [hierarchical, k-means and spectral clustering](https://dspa.predictive.space/) to generate derived-computed phenotypes of countries. Do these derived labels relate (correspond to) the overall (OA) country ranking?\n\n\n#### Spacetime analytics\n\n - **1.1 Lasso features selection**\n\n\n - ** 1.2 Comparison of different ML algorithms of different feature numbers**\n\n\n - **1.3 Clustering**\n\n\n#### Spacekime - Nil-Phase\n\n - ** 2.1 Lasso features selection**\n\n - ** 2.2 Comparison of different ML algorithms of different feature numbers**\n\n - ** 2.3 Clustering**\n  \n#### Spacekime - Swapped-Phase\n\n - ** 3.1 Lasso features selection**\n\n\n - ** 3.2 Comparison of different ML algorithms of different feature numbers**\n\n\n - ** 3.3 Clustering**",
      "word_count": 442
    },
    {
      "title": "Save Workspace",
      "content": "<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 95
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    code_folding: hide\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "library(dplyr)\nlibrary(plotly)\nlibrary(pracma)\nlibrary(ggplot2)\nrequire(magrittr)\nlibrary(gridExtra)",
      "line_count": 6
    },
    {
      "section": "Data Preprocessing {.tabset .tabset-fade .tabset-dropdown}",
      "code": "load(\"EU_Econ_rawdata.RData\")",
      "line_count": 1
    },
    {
      "section": "Data Preprocessing {.tabset .tabset-fade .tabset-dropdown}",
      "code": "#super sample the dataset\ncleardata <- function(mat) {\n  for (i in 1:ncol(mat)) {\n    mat[is.na(mat[,i]),i]<-mean(mat[,i],na.rm = T) + rnorm(sum(is.na(mat[,i])),sd = sd(mat[,i],na.rm = T))\n  }\n  return(mat)\n}\n# 1. Find all \"Common\" features (highly-observed and congruent Econ indicators)\ncountryNames <- unique(time_series$country); length(countryNames); # countryNames\n# initialize 3D array of DF's that will store the data for each of the countries into a 2D frame\ncountryData <- list()  # countryData[[listID==Country]][1-time-72, 1-feature-197]\n\nfor (i in 1:length(countryNames)) {\n  countryData[[i]] <- filter(time_series, country == countryNames[i])\n}\n# Check countryData[[2]][2, 3] == Belgium[2,3]\n\nlist_of_dfs_CommonFeatures <- list()  # list of data for supersampled countries 360 * 197\n\n# 2. General function that ensures the XReg predictors for ALL 31 EU countries are homologous\ncompleteHomologousX_features <- function (list_of_dfs) {\n  # delete features that are missing at all time points\n  for (j in 1:length(list_of_dfs)) {\n    print(paste0(\"Pre-processing Country: ...\", countryNames[j], \"... \"))\n    data = list_of_dfs[[j]]\n    data = data[ , colSums(is.na(data)) != nrow(data)]\n    data = dplyr::select(data, !any_of(c(\"time\", \"country\")))\n    DataMatrix = as.matrix(data)\n    DataMatrix = cleardata(DataMatrix)\n    DataMatrix = DataMatrix[ , colSums(is.na(DataMatrix)) == 0] # remove features with only 1 value\n    DataMatrix = DataMatrix[ , colSums(DataMatrix) != 0] # remove features with all values=0\n    # Supersample 72 --*5--> 360 timepoints \n    #DataMatrix = splinecreate(DataMatrix)\n    DataSuperSample = as.data.frame(DataMatrix) # super-Sample the data\n    # remove some of features  \n    #DataSuperSample = DataSuperSample[, -c(50:80)]; dim(X)  # 360 167\n    # ensure full-rank design matrix, DataSuperSample\n    DataSuperSample <- \n      DataSuperSample[ , qr(DataSuperSample)$pivot[seq_len(qr(DataSuperSample)$rank)]]\n    print(paste0(\"dim()=(\", dim(DataSuperSample)[1], \",\", dim(DataSuperSample)[2], \") ...\"))\n    # update the current DF/Country\n    list_of_dfs_CommonFeatures[[j]] <- DataSuperSample\n  }\n\n  # Identify All Xreg features that are homologous (same feature columns) across All 31 countries\n  # Identify Common Columns (features)\n  comCol <- Reduce(intersect, lapply(list_of_dfs_CommonFeatures, colnames))\n  list_of_dfs_CommonFeatures <- lapply(list_of_dfs_CommonFeatures, function(x) x[comCol])\n\n  for (j in 1:length(list_of_dfs_CommonFeatures)) {\n    list_of_dfs_CommonFeatures[[j]] <- subset(list_of_dfs_CommonFeatures[[j]], select = comCol)\n    print(paste0(\"dim(\", countryNames[j], \")=(\", dim(list_of_dfs_CommonFeatures[[j]])[1], \n                 \",\", dim(list_of_dfs_CommonFeatures[[j]])[2], \")!\"))  # 72 * 197\n  }\n  return(list_of_dfs_CommonFeatures)\n}\n# Test completeHomologousX_features: dim(AllCountries)=(360,42)!\nlist_of_dfs_CommonFeatures <- completeHomologousX_features(countryData); \nlength(list_of_dfs_CommonFeatures); dim(list_of_dfs_CommonFeatures[[1]]) # Austria data matrix 360*42",
      "line_count": 59
    },
    {
      "section": "Laplace Transform",
      "code": "x2 = seq(from = 1, to = 11, length.out = 50)\n# drop the first row to avoid real part value of 0\ny2 = seq(from = -5, to = 5, length.out = 50)\n# drop the first column to avoid imaginary part value of 0\nXY = expand.grid(X=x2, Y=y2)       \ncomplex_xy = mapply(complex, real=XY$X,imaginary=XY$Y)\nX<-1:72\ntime_points <- seq(0+0.01, 2*pi, length.out = 72)",
      "line_count": 8
    },
    {
      "section": "Laplace Transform",
      "code": "# create the LT\nNuLT = function(datax, datay, inputz, k = 3, fitwarning = FALSE, mirror = FALSE, range = 2*pi) {\n  \n  datax = as.numeric(datax)\n  datay = as.numeric(datay)\n\n  n = length(datax)\n  x1 = n/(n+0.5)*((datax-min(datax))/(max(datax)-min(datax)))*range\n  \n  if(mirror){\n    x1 = c(x1,rev(2*range - x1))/2\n    n = 2*n\n    datay = c(datay, rev(datay))\n    #plot(x1, datay)\n  }\n  \n  #generate the coefficients in indefinite integral of t^n*exp(-zt)\n  coef = 1;\n  coefm = as.matrix(coef)\n  for(i in 1:k){\n    coefm = cbind(coefm,0)\n    coef = c(coef*i,1)\n    coefm = rbind(coefm,coef)\n  }\n  # these coefficients ordered by ^0, ^1, ^2, ... in column format\n  \n  # compute 1, z, z^2...,z^k\n  zz = cbind(1,inputz)\n  zt = inputz\n  for (i in 2:k){\n    zt = zt*inputz\n    zz = cbind(zz,zt)\n  }\n  zd = zt*inputz\n  \n  # compute 1, x, x^2...,x^k\n  tx = x1;\n  xm = cbind(1,x1)\n  for (i in 2:k){\n    tx = tx*x1\n    xm = cbind(xm,tx)\n  }\n  \n  \n  # sum over intervals\n  result = 0*inputz\n  ii = 1\n  while(ii+k<=n)\n  {\n    A = xm[seq(ii,ii+k),c(0:k+1)]\n    b = datay[seq(ii,ii+k)]\n    # polyfit might be faster when using polynomial basis, while matrix inverse, `solve()`,\n    # is the more general approach that works for any function basis\n    polyc = as.numeric(solve(A,b))\n\n  \n    #ordered by ^0, ^1, ^2, ... in column format\n    \n    # Enter a new function variable qualityCheck=FALSE\n    # check fit quality; this step can be skipped for speed/efficiency\n    # if (qualityCheck) { .... }\n    \n    if (fitwarning){\n      xx = seq(A[1,2],A[k+1,2],length.out = 100);\n      yy = polyval(rev(polyc),xx)\n      if(max(abs(yy-mean(b)))>2*max(abs(b-mean(b)))){\n        print(c(\"Warning: Poor Fit at \",ii,\", Largest Deviation is\",max(abs(yy-mean(b)))))\n        print(c(\"Spline Polynomial is\", polyc),3);\n        #print(c(polyval(rev(polyc),A[,2]),b))\n        plot(xx, yy, main=\"Polynomial fit\", ylab=\"\", type=\"l\", col=\"blue\")\n        lines(A[,2],b, col=\"red\")\n        legend(\"topleft\",c(\"fit\",\"data\"),fill=c(\"blue\",\"red\"))\n        print(\" \")\n      }\n    }\n    \n    # Use vector/matrix operations to avoid looping, \n    # some of the expressions look weird\n    # May need to actually compare the efficiency/speed of\n    # vector based vs. standard numeric calculations\n    \n    m1 = t(t(polyc*coefm)*A[1,])\n    m11 = as.numeric(tapply(m1, col(m1)-row(m1), sum))[0:k+1] \n    \n    m2 = t(t(polyc*coefm)*A[k+1,])\n    m22 = as.numeric(tapply(m2, col(m2)-row(m2), sum))[0:k+1]\n    \n    intgl = (exp(-inputz*A[1,2])*colSums(t(zz)*m11)-\n               exp(-inputz*A[k+1,2])*colSums(t(zz)*m22))/zd\n    result = result+intgl\n    ii=ii+k\n  }\n  \n  # Computations over the last interval\n  if(ii<n){\n    nk = n-ii;\n    A = xm[seq(ii,ii+nk),c(0:nk+1)]\n    b = datay[seq(ii,ii+nk)]\n    nc = as.numeric(solve(A,b))\n    nc = c(nc,seq(0,0,length.out = k-nk))\n    \n    A = xm[seq(ii,ii+nk),]\n    m1 = t(t(nc*coefm)*A[1,])\n    m11 = as.numeric(tapply(m1, col(m1)-row(m1), sum))[0:k+1]\n    \n    m2 = t(t(nc*coefm)*A[nk+1,])\n    m22 = as.numeric(tapply(m2, col(m2)-row(m2), sum))[0:k+1]\n    \n    # cc = colSums(coefm*polyc)\n    intgl = (exp(-inputz*A[1,2])*colSums(t(zz)*m11)-\n               exp(-inputz*A[nk+1,2])*colSums(t(zz)*m22))/zd\n    result = result+intgl\n  }\n  #offset = 0.05*pi\n  #result = result + datay[n]*(exp(-2*pi*inputz)-exp(-(2*pi+offset)*inputz))/inputz\n  return(result)\n}",
      "line_count": 117
    },
    {
      "section": "Laplace Transform",
      "code": "tensor_all<-array(dim=c(30,33,50,50))\nfor(m in 1:30)\n{\n  for(i in 1:33){\n  Y=list_of_dfs_CommonFeatures[[m]][,i]\n  poly_z<-NuLT(time_points, Y, complex_xy, k = 3, fitwarning = FALSE)\n  dim(poly_z) = c(length(x2), length(y2))\n  tensor_all[m,i,,]<-poly_z\n}\n}",
      "line_count": 10
    },
    {
      "section": "Laplace Transform",
      "code": " X_tensor<-tensor_all[,-31,,]\n Y_tensor<-tensor_all[,31,,]\n ",
      "line_count": 3
    },
    {
      "section": "Kimesurface of GDP for 30 EU countries",
      "code": "magnitude_feature<-lapply(1:33,function(i) Mod(tensor_all[,i,,]))\nphase_feature<-lapply(1:33,function(i) atan2(Im(tensor_all[,i,,]), Re(tensor_all[,i,,])))\n#xy2<-expand.grid(1:20,1:20)\ncolorscale = cbind(seq(0, 1, by=1/(length(x2) - 1)), rainbow(length(x2)))\ncommonefeature<-colnames(list_of_dfs_CommonFeatures[[31]])\np_feature<- plot_ly(hoverinfo=\"none\", showscale = FALSE)  %>% layout(title=commonefeature[31])\n\nfor (j in 1:5)\n{\n  for (i in 1:6){\n    xx2<-1:50+50*(j-1)\n    yy2<-1:50+50*(i-1)\n  p_feature <- p_feature %>%\n    add_trace(x=xx2,y=yy2, z =magnitude_feature[[31]][j+(i-1)*5,,], \n              surfacecolor=phase_feature[[31]][j+(i-1)*5,,], colorscale=colorscale,   #Phase-based color\n              type = 'surface',name=substr(countryNames[j+(i-1)*5],0,50),opacity=0.7,showlegend=TRUE)\n\n  }\n}",
      "line_count": 19
    },
    {
      "section": "Kimesurface of GDP for 30 EU countries",
      "code": "p_feature",
      "line_count": 1
    },
    {
      "section": "Inverse Laplace Transform",
      "code": "ctILT = function(\n  LTF,\n  tini = 0.001,\n  tend = 9,\n  nnt = 200){\n  if (TRUE){\n    a=8; ns=100; nd=29;  \n  }   #% implicit parameters\n  \n  N = ns+nd+1\n\n  radt=seq(tini,tend*nnt /(nnt + 0.5),length.out = nnt); # time vector\n  \n  if (tini==0){\n      #radt=radt[c(2:nnt)]\n  } # t=0 is not allowed\n  #tic    % measure the CPU time\n  \n  alfa = seq(1,ns+1+nd)\n  beta = alfa\n  \n  for (j in seq(1,ns+1+nd)){#     % prepare necessary coefficients\n     alfa[j]=a+(j-1)*pi*1i;\n     beta[j]=-exp(a)*(-1)^j;\n  }\n  \n  #print(beta)\n  n = c(1:nd)\n  bdif=rev(cumsum(gamma(nd+1)/gamma(nd+2-n)/gamma(n)))/(2^nd)\n  #print(beta[ns+2:ns+1+nd])\n  temp = beta[seq(ns+2,ns+1+nd)]*bdif\n  print(temp)\n  beta[seq(ns+2,ns+1+nd)]= temp\n  beta[1]=beta[1]/2;\n  ft2 = seq(1,nnt)\n  \n  Qz = c()\n  \n  for (kt in seq(1,nnt)){  # cycle for time t\n     tt=radt[kt];\n     s=alfa/tt;                     # complex frequency s\n     Qz = c(Qz,s)\n  }\n   \n  LTQz = LTF(Qz)\n\n  for (kt in seq(1,nnt)){  # cycle for time t\n     tt=radt[kt];\n     s=alfa/tt;                     # complex frequency s\n     bt=beta/tt;\n     #btF=bt*NuLT(datax, datay, s);  # functional value F(s)\n     btF = bt*LTQz[seq((kt-1)*N+1,kt*N)]\n     ft2[kt]=sum(Re(btF));          # original f(tt)\n     if(is.na(ft2[kt])){\n       print(kt)\n       print(LTQz[seq((kt-1)*N+1,kt*N)])\n       print(btF)\n     }\n     \n  }\n  return(ft2)\n}\n",
      "line_count": 63
    },
    {
      "section": "Inverse Laplace Transform",
      "code": "\nrge = 2*pi\ntnd = 2*pi\n\n\n\nz2_funct<- function(z) NuLT(time_points,list_of_dfs_CommonFeatures[[2]][,31],inputz = z,mirror = TRUE, range  = rge)\n inv_result<-ctILT(z2_funct,tend = tnd, nnt=72*2)\nz2_funct<- function(z) NuLT(time_points,list_of_dfs_CommonFeatures[[3]][,31],inputz = z,mirror = TRUE, range  = rge)\n inv_result_2<-ctILT(z2_funct,tend = tnd, nnt=72*2)\nz2_funct<- function(z) NuLT(time_points,list_of_dfs_CommonFeatures[[10]][,31],inputz = z,mirror = TRUE, range  = rge)\n inv_result_3<-ctILT(z2_funct,tend = tnd, nnt=72*2)\nz2_funct<- function(z) NuLT(time_points,list_of_dfs_CommonFeatures[[21]][,31],inputz = z,mirror = TRUE, range  = rge)\n inv_result_4<-ctILT(z2_funct,tend = tnd, nnt=72*2)",
      "line_count": 14
    },
    {
      "section": "Inverse Laplace Transform",
      "code": "valsn_df_1 <- as.data.frame(cbind(inv_result=inv_result[1:72],\n                                    time_series=list_of_dfs_CommonFeatures[[2]][,31], time_points=time_points))\nx <- list(\n  title = \"Time\"\n  \n)\ny <- list(\n  title = \"GDP of Belgium\"\n  \n)\np1=plot_ly(valsn_df_1, x = ~time_points,y = ~time_series, name = 'original_ts',mode = 'lines', type = 'scatter')\n\np1<- p1 %>% add_trace(y = ~ inv_result, name = 'inv_result',mode = 'lines', line=list(dash='dot'))\np1 <- p1 %>% layout(xaxis = x, yaxis = y)\n\n",
      "line_count": 16
    },
    {
      "section": "Inverse Laplace Transform",
      "code": "valsn_df_2 <- as.data.frame(cbind(inv_result=inv_result_2[1:72],\n                                    time_series=list_of_dfs_CommonFeatures[[3]][,31], time_points=time_points))\n\nx <- list(\n  title = \"Time\"\n  \n)\ny <- list(\n  title = \"GDP of Bulgaria\"\n  \n)\np2=plot_ly(valsn_df_2, x = ~time_points,y = ~time_series, name = 'original_ts',mode = 'lines', type = 'scatter')\n\np2<- p2 %>% add_trace(y = ~ inv_result, name = 'inv_result',mode = 'lines', line=list(dash='dot'))\np2 <- p2 %>% layout(xaxis = x, yaxis = y)\n\n",
      "line_count": 17
    },
    {
      "section": "Inverse Laplace Transform",
      "code": "\n\nvalsn_df_3 <- as.data.frame(cbind(inv_result=inv_result_3[1:72],\n                                    time_series=list_of_dfs_CommonFeatures[[10]][,31], time_points=time_points))\n\nx <- list(\n  title = \"Time\"\n  \n)\ny <- list(\n  title = \"GDP of France\"\n  \n)\np3=plot_ly(valsn_df_3, x = ~time_points,y = ~time_series, name = 'original_ts',mode = 'lines', type = 'scatter')\n\np3 <- p3 %>% add_trace(y = ~ inv_result, name = 'inv_result',mode = 'lines', line=list(dash='dot'))\np3 <- p3 %>% layout(xaxis = x, yaxis = y)\n",
      "line_count": 18
    },
    {
      "section": "Inverse Laplace Transform",
      "code": "valsn_df_4 <- as.data.frame(cbind(inv_result=inv_result_4[1:72],\n                                    time_series=list_of_dfs_CommonFeatures[[21]][,31], time_points=time_points))\n\nx <- list(\n  title = \"Time\"\n  \n)\ny <- list(\n  title = \"GDP of Netherlands\"\n  \n)\np4=plot_ly(valsn_df_4, x = ~time_points,y = ~time_series, name = 'original_ts',mode = 'lines', type = 'scatter')\n\np4 <- p4 %>% add_trace(y = ~ inv_result, name = 'inv_result',mode = 'lines', line=list(dash='dot'))\np4 <- p4 %>% layout(xaxis = x, yaxis = y)\n",
      "line_count": 16
    },
    {
      "section": "Inverse Laplace Transform",
      "code": "fig<-subplot(\n  p1,\n  p2,\n  p3,\n  p4,\n  nrows = 2,\n  titleY = TRUE,margin = 0.05,shareX = TRUE\n )%>% layout(title =\"Original Time-series and Reconstructed Time-series by ILT\")\nfig",
      "line_count": 9
    },
    {
      "section": "Data Preprocessing {.tabset .tabset-fade .tabset-dropdown}",
      "code": "library(dplyr)\nlibrary(arm)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(plot3D)\nlibrary(scatterplot3d)\nlibrary(plotly)\nlibrary(fastDummies)\nlibrary(forecast)\n\n# Load Previously Computed Workspace:\nload(\"C:/Users/dinov/Desktop/Ivo.dir/Research/UMichigan/Publications_Books/2018/others/4D_Time_Space_Book_Ideas/ARIMAX_EU_DataAnalytics/EU_Econ_SpaceKime.RData\")",
      "line_count": 13
    },
    {
      "section": "Data Preprocessing {.tabset .tabset-fade .tabset-dropdown}",
      "code": "setwd(\"C:/Users/dinov/Desktop/Ivo.dir/Research/UMichigan/Publications_Books/2018/others/4D_Time_Space_Book_Ideas/ARIMAX_EU_DataAnalytics\")\neu <- read.csv(\"Master_Aggregate_EU_Econ_Data_11_29_2018_TimeTransform.csv\", stringsAsFactors = F)[,-5]\ncolnames(eu) <- c(\"country\",\"time\",\"feature\",\"value\")\neu <- filter(eu,!country %in% c(\"European Union (25 countries)\",\"D1_Country\",\"\"))\neu$value <- sapply(c(1:nrow(eu)),function(x) as.numeric(gsub(\":|,\",\"\",eu$value[x])))\neu <- filter(eu, feature != \"\")\ndim(eu)",
      "line_count": 7
    },
    {
      "section": "Reformat the data into a 3D array (country \\* feature \\* time)",
      "code": "unq_country <- sort(unique(eu$country))\nunq_time <- sort(unique(eu$time))\nunq_fea <- sort(unique(eu$feature))\nnum_country <- length(unq_country)\nnum_time <- length(unq_time)\nnum_fea <- length(unq_fea)\neu <- arrange(eu,country,time,feature)\neu_3d_array <- array(NA,dim = c(num_country,num_time,num_fea),dimnames = list(unq_country,unq_time,unq_fea))\nfor (i in 1:num_country){\n  for (j in 1:num_time){\n    for (k in 1:num_fea){\n      eu_3d_array[i,j,k] = eu$value[(i-1)*num_time*num_fea + (j-1)*num_fea + k]\n    }\n  }\n}\neu_3d_array[1:10,1:10,1]",
      "line_count": 16
    },
    {
      "section": "Data visualization",
      "code": "eu <- arrange(eu,time,feature,country)\neu_visualization <- dplyr::select(eu,time,feature,country,value)\neu_visualization$time <- sapply(c(1:nrow(eu_visualization)),function(x) as.numeric(gsub(\"Q\",\".\",eu_visualization$time[x])))\neu_visualization$feature <- as.factor(eu_visualization$feature)\neu_visualization$country <- as.factor(eu_visualization$country)\neu_visualization$value <- as.numeric(eu_visualization$value)\neu_visualization$feature <- sapply(c(1:nrow(eu_visualization)),function(x) substr(eu_visualization$feature[x],1,20))\n#plot_ly(eu_visualization, x = ~time, y = ~country, z = ~value, color = ~feature,split = ~ country,type = 'scatter3d', mode = 'lines')",
      "line_count": 8
    },
    {
      "section": "Time series format",
      "code": "#Find the duplicates\neu_time_series <- na.omit(eu)\nallFeatures = as.character(unique(eu_time_series$feature))\nallTime = unique(eu_time_series$time)\nallCountry = as.character(unique(eu_time_series$country))\nallCombination = length(allFeatures)*length(allTime)*length(allCountry)\ndup = c()\nfor (i in 1:length(allFeatures)){\n  for (j in 1:length(allCountry)){\n    for (k in 1:length(allTime)){\n      if (nrow(filter(eu_time_series,country == allCountry[j] & feature == allFeatures[i] & time == allTime[k]))>1){\n        dup = c(dup,as.character(allFeatures[i]))\n        break\n      }\n    }\n    break\n  }\n}\ndup #These features have multiple observations at the same time point",
      "line_count": 19
    },
    {
      "section": "Time series format",
      "code": "removeDup = filter(eu_time_series, feature != \"Employment by sex, age and educational attainment level, Total, From 15 to 64 years, All ISCED 2011 levels\" &\n                     feature != \"Labor cost for LCI excluding bonuses\" &\n                     feature != \"Labor costs other than wages or salaries\" &\n                     feature != \"Labour cost for LCI (compensation of employees plus taxes minus subsidies)\" &\n                     feature != \"Labour cost for LCI excluding bonuses\" &\n                     feature != \"Labour costs other than wages and salaries\" &\n                     feature != \"Wages and salaries (total)\")\ntime_series = spread(removeDup,feature,value)\ndim(time_series)",
      "line_count": 9
    },
    {
      "section": "Fit the ARIMA model for each country",
      "code": "#Chose Belgium and fit the arima\nbelgium = filter(time_series,country == \"Belgium\")\nbelgium = belgium[, colSums(is.na(belgium)) != nrow(belgium)] #delete the feature that is missing at all the time point\nbelgium = dplyr::select(belgium,-time,-country)\ndim(belgium)",
      "line_count": 5
    },
    {
      "section": "Fit the ARIMA model for each country",
      "code": "#super sample the dataset\ncleardata <- function(mat) {\n  for (i in 1:ncol(mat)) {\n    mat[is.na(mat[,i]),i]<-mean(mat[,i],na.rm = T) + rnorm(sum(is.na(mat[,i])),sd = sd(mat[,i],na.rm = T))\n  }\n  return(mat)\n}\n\n#use spline regression model to expand the dataset\nsplinecreate <- function(mat) {\n  res<-NULL\n  for (i in 1:ncol(mat)) {\n    sp<-smooth.spline(seq(1:72),mat[,i])\n    spresult<-predict(sp,seq(from=0,by=1/5,length.out = 360))\n    spfeat<-spresult$y+rnorm(360,sd=sd(mat[,i]))\n    res<-cbind(res,spfeat)\n  }\n  colnames(res)<-colnames(mat)\n  return(res)\n}\nBelguimMatrix = as.matrix(belgium)\nBelguimMatrix = cleardata(BelguimMatrix)\nBelguimMatrix = splinecreate(BelguimMatrix)\nBelguimSuperSample = as.data.frame(BelguimMatrix)\n\n#############################\n# Outcome Features to examine, predict, forecast, spacekime-analyze\n#   \"Gross domestic product at market prices\"\n#   \"Unemployment , Females, From 15-64 years, Total\"\n#   \"Capital transfers, payable\"       \n#   \"Capital transfers, receivable\"\n#   \"Debt securities\"\n#   \"Government consolidated gross debt\"\n#   ... View(colnames(BelguimMatrix))\n############################# \n\n################################################\n#    \"Unemployment , Females, From 15-64 years, Total\"\nY = dplyr::select(BelguimSuperSample, \"Unemployment , Females, From 15-64 years, Total\"); dim(Y)\nX = dplyr::select(BelguimSuperSample, -starts_with(\"Unemployment\")); dim(X)\nfitArimaX = auto.arima(Y, xreg=as.matrix(X[,-112])); fitArimaX$arma\n\n################################################\n#    \"Government consolidated gross debt\"\n#Y = select(BelguimSuperSample, \"Government consolidated gross debt\"); dim(Y)\n#X = select(BelguimSuperSample, -matches(\"debt|Debt\")); dim(X)\n# X_scale <- scale(X); Matrix::rankMatrix(X_scale); any(is.na(X_scale)); any(is.infinite(X_scale))\n#     remove columns with infinite or missing value  \n# X_scale_1 <- X_scale[ , !is.infinite(colSums(X_scale)) & !is.na(colSums(X_scale))]\n#X_1 <- X[ , !is.infinite(colSums(X)) & !is.na(colSums(X))]; dim(X_1); Matrix::rankMatrix(X_1)\n#X_2 <- X_1[, qr(X_1)$pivot[seq_len(qr(X_1)$rank)]]; dim(X_2)\n# \n#fitArimaX = auto.arima(Y, xreg=as.matrix(X_2), method = \"CSS\", # \"SANN\", method = \"CSS\", optim.method = \"BFGS\"\n#          optim.control=list(maxit = 20000, temp = 20), optim.method = \"BFGS\")\n#fitArimaX; View(sort(fitArimaX$coef)[1:10]); fitArimaX$arma\n\n################################################\n#   \"Gross domestic product at market prices\"\nY = dplyr::select(BelguimSuperSample, \"Gross domestic product at market prices\"); dim(Y)\nX = dplyr::select(BelguimSuperSample, -matches(\"debt|Debt\")); dim(X)  # 360 167\nX <- X[, qr(X)$pivot[seq_len(qr(X)$rank)]]; dim(X)\nts_Y <- ts(Y, start=c(2000,1), end=c(2017, 20), frequency = 20); length(ts_Y)\nset.seed(1234)\nfitArimaX = auto.arima(ts_Y, xreg=as.matrix(X[ , -c(50:60)])); fitArimaX$arma\n# 5  0  2  0 20  0  0\n# sigma^2 estimated as 57.04:  log likelihood=-1132.78 AIC=2593.55   AICc=2871.09   BIC=3230.88\npred_arimaX_5_0_2_Y_Belgium_train300_Belgium_test60 <- \npredict(fitArimaX, n.ahead = 60, newxreg = as.matrix(X[301:360 , -c(50:60)]))$pred\nplot(forecast(fitArimaX, xreg = as.matrix(X[301:360 , -c(50:60)])), # ARIMA forecast\n     include=120, lwd=4, lty=3, xlab=\"Time\", ylab=\"GDP\", ylim=c(50, 150),\n     main = \"ARIMAX Analytics (Train: 2000-2017; Test: 2018-2020) GDP Forecasting\\n\n      based on fitting ARIMAX Models on raw (spline interpolated) Belgium data\")\n lines(pred_arimaX_5_0_2_Y_Belgium_train300_Belgium_test60, col = \"red\", lwd = 4, lty=3) \n legend(\"topleft\", bty=\"n\", legend=c(\"Belgium Training Data (2000-2017)\", \n                        \"ARIMAX(5,0,2)-model GDP Forecasting (2018-2020)\",\n                        \"ARIMAX(5,0,2)-model GDP Forecasting (2018-2020)\"),\n       col=c(\"black\", \"blue\", \"red\"), \n       lty=c(3,3,3), lwd=c(4,4,4), cex=1.2, x.intersp=1.5, y.intersp=0.6)\ntext(2015, 60, expression(atop(paste(\"Training Region (2000-2017)\"), \n                paste(Model(Unempl) %->% \"ARIMAX(p, q, r) ;  \", \n                      XReg %==% X[i], \" \", i %in% {1 : 167}))), cex=1.5)\ntext(2019.5, 60, expression(atop(paste(\"Validation Region (2018-2020)\"), \n        paste(hat(Unempl) %<-% \"ARIMAX(5,0 ,2); \", \n              XReg %==% X[i], \" \", i %in% {1 : 167}))), cex=1.5)",
      "line_count": 84
    },
    {
      "section": "Fit the ARIMA model for each country",
      "code": "library(dplyr)\n#write a function of clean the data and fit the ARIMA model\nFit_ARIMA <- function(countryData=Belgium, start=2000, end=2017, frequency=20,\n                     feature=\"Unemployment , Females, From 15-64 years, Total\")\n{\n  #delete features that are missing at all time points\n  countryData = countryData[, colSums(is.na(countryData)) != nrow(countryData)]\n  countryData = dplyr::select(countryData, -time, -country)\n  DataMatrix = as.matrix(countryData)\n  DataMatrix = cleardata(DataMatrix)\n  DataMatrix = DataMatrix[ , colSums(is.na(DataMatrix)) == 0] # remove feature that only has one value\n  DataMatrix = DataMatrix[ , colSums(DataMatrix) != 0] # remove feature that all the values are 0\n  DataMatrix = splinecreate(DataMatrix)\n  DataSuperSample = as.data.frame(DataMatrix)\n  if (feature==\"Unemployment , Females, From 15-64 years, Total\") {\n      Y = dplyr::select(DataSuperSample, \"Unemployment , Females, From 15-64 years, Total\")\n      X = dplyr::select(DataSuperSample, -starts_with(\"Unemployment\"))\n  } else if (feature==\"Gross domestic product at market prices\") {\n    Y = dplyr::select(DataSuperSample, \"Gross domestic product at market prices\"); dim(Y)\n    X = dplyr::select(DataSuperSample, -matches(\"debt|Debt\")); dim(X)  # 360 167\n    print(paste0(\"dim(X)=(\", dim(X)[1], \",\", dim(X)[2], \");  \",\n                 \" dim(Y)=(\", dim(Y)[1], \",\", dim(Y)[2], \") ...\"))\n    X <- X[, qr(X)$pivot[seq_len(qr(X)$rank)]]; dim(X)  # ensure full-rank design matrix, X\n  }\n  else {\n    print(paste0(\"This feature \", feature, \" is not implemented yet! Exiting Fit_ARIMA() method ...\")) \n    return(NULL)\n  }\n  ts_Y <- ts(Y, start=c(start, 1), end=c(end, frequency), frequency = frequency); length(ts_Y)\n  set.seed(1234)\n  fitArimaX = auto.arima(ts_Y, xreg=as.matrix(X))\n  return(fitArimaX)\n}\nBulgaria = filter(time_series,country == \"Bulgaria\")\nBulgariaARIMA = Fit_ARIMA(countryData=Bulgaria, start=2000, end=2017, frequency=20, \n                     feature=\"Gross domestic product at market prices\")\nBulgariaARIMA$arma\n\n# Extend the Fit-ARIMA method to ensure testing-training modeling/assessment for 2 countries works\npreprocess_ARIMA <- function(countryData=Belgium, start=2000, end=2017, frequency=20,\n                     feature=\"Unemployment , Females, From 15-64 years, Total\")\n{\n  #delete features that are missing at all time points\n  countryData = countryData[, colSums(is.na(countryData)) != nrow(countryData)]\n  countryData = dplyr::select(countryData, !any_of(c(\"time\", \"country\")))\n  DataMatrix = as.matrix(countryData)\n  DataMatrix = cleardata(DataMatrix)\n  DataMatrix = DataMatrix[ , colSums(is.na(DataMatrix)) == 0] # remove features with only 1 value\n  DataMatrix = DataMatrix[ , colSums(DataMatrix) != 0] # remove features with all values=0\n  DataMatrix = splinecreate(DataMatrix)\n  DataSuperSample = as.data.frame(DataMatrix) # super-Sample the data\n  print(paste0(\"Processing feature: ...\", feature, \"... \"))\n      \n  if (feature==\"Unemployment , Females, From 15-64 years, Total\") {\n      Y = dplyr::select(DataSuperSample, \"Unemployment , Females, From 15-64 years, Total\")\n      X = dplyr::select(DataSuperSample, -starts_with(\"Unemployment\"))\n  } else if (feature==\"Gross domestic product at market prices\") {\n      Y = dplyr::select(DataSuperSample, \"Gross domestic product at market prices\"); dim(Y)\n      X = dplyr::select(DataSuperSample, -matches(\"debt|Debt\")); \n      X <- X [, -c(50:80)]; dim(X)  # 360 167\n  } else {\n    print(paste0(\"This feature: ...\", feature, \"... is not implemented yet! Exiting preprocess_ARIMA() method ...\")) \n    return(NULL)\n  }\n  \n  # reduce the number of observations (matrix rows) to specified time range\n  len_1 <- (end + 1 - start) * frequency; print(paste0(\"dim(X)[1]=\", len_1))\n  X <- X[1:len_1 , qr(X[1:len_1 , ])$pivot[seq_len(qr(X[1:len_1 , ])$rank)]]; dim(X)  \n  # ensure full-rank design matrix, X\n  Y <- as.data.frame(Y[1:len_1 , ])\n  print(paste0(\"dim(X)=(\", dim(X)[1], \",\", dim(X)[2], \");  \",         # 300 136\n                 \" dim(Y)=(\", dim(Y)[1], \",\", dim(Y)[2], \") ...\"))    # 300 1\n  return(list(\"X\"=X, \"Y\"=Y))\n}\n\n# Outcome Variable to be modeled, as a timeseries: 2000 - 2017 (18 years, Quarterly measures)\n# Spline interpolation *5;   2000-01 - 2014-20 (300 observations for training): 60 observations (2015-2017) for Testing\n\nBelgium  <- filter(time_series, country == \"Belgium\")\nBulgaria <- filter(time_series, country == \"Bulgaria\")\nNetherlands <- filter(time_series, country == \"Netherlands\")\n# Test preprocess_ARIMA()\n#preprocess_Belgium <- preprocess_ARIMA(countryData=Belgium, start=2000, end=2014,\n#                frequency=20, feature=\"Gross domestic product at market prices\")\n#preprocess_Bulgaria <- preprocess_ARIMA(countryData=Bulgaria, start=2000, end=2014,\n#                frequency=20, feature=\"Gross domestic product at market prices\")\n\n\n# General function that ensures the XReg predictors for 2 countries are homologous\nhomologousX_features <- function (X_Country1, X_Country2){\n  # Check if the Belgium and Bulgaria Xreg are homologous (same feature columns)\n  common_cols <- intersect(colnames(X_Country1), colnames(X_Country2))\n  X_Country1 <- subset(X_Country1, select = common_cols)\n  X_Country2 <- subset(X_Country2, select = common_cols)\n  print(paste0(\"dim(X1)=(\", dim(X_Country1)[1], \",\", dim(X_Country1)[2], \");  \", # 300 131\n              \" dim(X2)=(\", dim(X_Country2)[1], \",\", dim(X_Country2)[2], \")!\"))  # 300 131\n  return(list(\"X_Country1\"=X_Country1, \"X_Country2\"=X_Country2))\n}\n# Test homologousX_features\n# homoFeat <- homologousX_features(preprocess_Belgium$X, preprocess_Bulgaria$X)\n# X_Belgium  <- homoFeat$X_Country1\n# X_Bulgaria <- homoFeat$X_Country2\n\nfit_ARIMA <- function(country1Data=Belgium, country2Data=Bulgaria, \n                     start=2000, end=2014, frequency=20,\n                     feature=\"Gross domestic product at market prices\") {\n  preprocess_Country1 <- preprocess_ARIMA(countryData=country1Data, \n                    start=start, end=end, frequency=frequency, feature=feature)\n  preprocess_Country2 <- preprocess_ARIMA(countryData=country2Data, \n                    start=start, end=end, frequency=frequency, feature=feature)\n  ts_Y_Country1 <- ts(preprocess_Country1$Y, start=c(start, 1), \n            end=c(end, frequency), frequency = frequency); length(ts_Y_Country1)\n  \n  homoFeat <- homologousX_features(preprocess_Country1$X, preprocess_Country2$X)\n  X_Country1 <- homoFeat$X_Country1\n  X_Country2 <- homoFeat$X_Country2\n  \n  set.seed(1234)\n  fitArimaX_Country1 = auto.arima(ts_Y_Country1, xreg=as.matrix(X_Country1))\n  return(fitArimaX_Country1)\n}\n\n# Belgium = filter(time_series,country == \"Belgium\")\nBelgiumARIMA = fit_ARIMA(country1Data=Belgium, \n                    country2Data=Bulgaria, # country2Data=Netherlands,\n                    start=2000, end=2014, frequency=20,\n                    feature=\"Gross domestic product at market prices\")\nBelgiumARIMA$arma    # [1]  4  0  2  0 20  0  0\n\n# sigma^2 estimated as 45.99:  log likelihood=-919.13 AIC=2116.26 AICc=2359.51 BIC=2631.09\n\n# Outcome Variable to be modeled, as a timeseries: 2000 - 2017 (18 years, Quarterly measures)\n# Spline interpolation x5;   2000-01 - 2014-20 (300 observations for training)\n# ts_Y_Belgium_train <- ts(Y_Belgium_train, start=c(2000,1), end=c(2014, 20), frequency=20)\n# length(ts_Y_Belgium_train)\n# ts_Y_Belgium_test <- ts(Y_Belgium_test, start=c(2015,1), end=c(2017, 20), frequency = 20)\n#length(ts_Y_Belgium_test)\n# Find ARIMAX model\n# arimaX_Belgium_train <- auto.arima(ts_Y_Belgium_train, xreg=as.matrix(X_Belgium_train)); # arimaX_Belgium_train$arma",
      "line_count": 139
    },
    {
      "section": "TS Forecasting",
      "code": "# Previously, we already extracted the Belgium and Bulgaria Data, preprocess it, \n# and fit the ARIMAX (Belgium-training) model. Now, we will assess the model on Bulgaria_testing sets\n# BelgiumARIMA = fit_ARIMA(country1Data=Belgium, country2Data=Bulgaria,\n#                    start=2000, end=2014, frequency=20,\n#                    feature=\"Gross domestic product at market prices\")\n# BelgiumARIMA$arma    # [1]  4  0  2  0 20  0  0\n\n# View rank-ordered ARIMAX effects:\n# View(BelgiumARIMA$coef[order(BelgiumARIMA$coef)])\nsort(BelgiumARIMA$coef)[1:10]\n#           Unemployment , Females, From 15-64 years, From 18 to 23 months \n#                                                               -1.5203281 \n#                                                                      ar2 \n#                                                               -1.1808472 \n#                                 Labor cost other than wages and salaries \n#                                                               -0.8380554 \n#           Unemployment , Females, From 15-64 years, From 12 to 17 months \n#                                                               -0.7037336 \n#                                                                      ar4 \n#                                                               -0.6360880 \n#                                                                     sar2 \n#                                                               -0.6260002 \n#             Unemployment , Females, From 15-64 years, From 3 to 5 months \n#                                                               -0.5262376 \n#  Labor cost for LCI (compensation of employees plus taxes minus subsidies) \n#                                                               -0.2885038 \n#              Unemployment , Females, From 15-64 years, 48 months or over \n#                                                               -0.2773650 \n#               Unemployment , Males, From 15-64 years, from 3 to 5 months \n#                                                               -0.2567934 \n\n#Get the Prospective Xreg=X design matrices ready (2015-2017, 60 rows)\npreprocess_Belgium <- preprocess_ARIMA(countryData=Belgium, \n                    start=2000, end=2017, frequency=20, \n                    feature=\"Gross domestic product at market prices\")\npreprocess_Bulgaria <- preprocess_ARIMA(countryData=Bulgaria,  #Netherlands\n                    start=2000, end=2017, frequency=20, \n                    feature=\"Gross domestic product at market prices\")\nhomoFeat <- homologousX_features(preprocess_Belgium$X, preprocess_Bulgaria$X)\nX_Belgium_test  <- homoFeat$X_Country1[301:360, ]; dim(X_Belgium_test)\nX_Bulgaria_test <- homoFeat$X_Country2[301:360, ]; dim(X_Bulgaria_test)\n \n# Get Predictions\npred_arimaX_4_0_2_Y_Belgium_train300_Bulgaria_test60 <- \n      forecast(BelgiumARIMA, xreg = as.matrix(X_Bulgaria_test))$mean\npred_arimaX_4_0_2_Y_Belgium_train300_Belgium_test60 <- \n      forecast(BelgiumARIMA, xreg = as.matrix(X_Belgium_test))$mean\npred_arimaX_4_0_2_Y_Belgium_train300_Offset_Bulgaria_test60 <-\n  forecast(BelgiumARIMA, xreg = as.matrix(X_Bulgaria_test))$mean +\n  mean(pred_arimaX_4_0_2_Y_Belgium_train300_Belgium_test60) -\n  mean(pred_arimaX_4_0_2_Y_Belgium_train300_Bulgaria_test60)\n\ncor(pred_arimaX_4_0_2_Y_Belgium_train300_Belgium_test60, ts_Y_Belgium_test)  # 0.11\nmean(pred_arimaX_4_0_2_Y_Belgium_train300_Belgium_test60) # [1] 118\n\n# Alternative predictions:\n# X_Country1 <- X_Belgium_test; X_Country2 <- X_Bulgaria_test\n# pred_arimaX_1_0_2_Y_Belgium_train300_Bulgaria_test60 <- predict(BelgiumARIMA, n.ahead = 60, newxreg = X_Bulgaria_test)$pred\n# pred_arimaX_1_0_2_Y_Belgium_train300_Belgium_test60 <- predict(BelgiumARIMA, n.ahead = 60, newxreg = X_Belgium_test)$pred",
      "line_count": 59
    },
    {
      "section": "TS Forecasting",
      "code": "ts_Y_Belgium_test <- ts(preprocess_Belgium$Y[301:360, ], \n                        start=c(2015,1), end=c(2017, 20), frequency = 20)\nlength(ts_Y_Belgium_test)\n\n# windows(width=14, height=10)\nplot(forecast(BelgiumARIMA, xreg = as.matrix(X_Belgium_test)),   # ARIMA forecast\n     include=100, lwd=4, lty=3, xlab=\"Time\", ylab=\"GDP Purchasing Power Standards (PPS)\",\n     ylim=c(25, 150),\n     main = \"ARIMAX Analytics (Train: 2000-2014; Test: 2015-2017) GDP (PPS) Forecasting\\n\n      based on fitting ARIMAX Models on raw (spline interpolated) Belgium data\")\nlines(pred_arimaX_4_0_2_Y_Belgium_train300_Belgium_test60, col = \"green\", lwd = 4, lty=2)   # Belgium train+test\nlines(pred_arimaX_4_0_2_Y_Belgium_train300_Bulgaria_test60, col = \"purple\", lwd = 4, lty=1) # Belgium train+Bulgaria test\nlines(pred_arimaX_4_0_2_Y_Belgium_train300_Offset_Bulgaria_test60, col = \"orange\", lwd = 4, lty=1) \n# Belgium train+ Offset Bulgaria test: 188.3753 - 416.5375\nlines(ts_Y_Belgium_test, col = \"red\", lwd = 6, lty=1)       # Observed Y_Test timeseries\nlegend(\"topleft\", bty=\"n\", legend=c(\"Belgium Training Data (2000-2014)\", \n                        \"ARIMAX(4,0,2)-model GDP Forecasting (2015-2017)\",\n                        \"ARIMAX(4,0,2) Belgium train + XReg=Belgium test (2015-2017)\",\n                        \"ARIMAX(4,0,2) Belgium train + XReg=Bulgaria test (2015-2017)\",\n                        \"Offset ARIMAX(4,0,2) Belgium train + XReg=Bulgaria test (2015-2017)\",\n                        \"Belgium Official Reported GDP (2015-2017)\"),\n       col=c(\"black\", \"blue\", \"green\", \"purple\", \"orange\", \"red\"), \n       lty=c(3,1,2,1, 1, 1), lwd=c(4,4,4,4,4, 6), cex=1.2, x.intersp=1.5, y.intersp=0.7)\ntext(2012.5, 30, expression(atop(paste(\"Training Region (2000-2014)\"), \n                paste(Model(GDP) %->% \"ARIMAX(p, q, r) ;  \", \n                      XReg %==% X[i], \" \", i %in% {1 : 131}))), cex=1.2)\ntext(2016.5, 30, expression(atop(paste(\"Validation Region (2015-2017)\"), \n        paste(hat(GDP) %<-% \"ARIMAX(4, 0, 2); \", \n              XReg %==% X[i], \" \", i %in% {1 : 131}))), cex=1.2)",
      "line_count": 29
    },
    {
      "section": "TS Forecasting",
      "code": "ts_Y_Belgium_test <- ts(preprocess_Belgium$Y[301:360, ], \n                        start=c(2015,1), end=c(2017, 20), frequency = 20)\nlength(ts_Y_Belgium_test)\n\n# windows(width=14, height=10)\nplot(forecast(BelgiumARIMA, xreg = as.matrix(X_Belgium_test)),     # ARIMA forecast\n     lwd=4, lty=3, xlab=\"Time\", ylab=\"GDP Purchasing Power Standards (PPS)\",\n     ylim=c(25, 150),\n     main = \"ARIMAX Analytics (Train: 2000-2014; Test: 2015-2017) GDP (PPS) Forecasting\\n\n      based on fitting ARIMAX Models on raw (spline interpolated) Belgium data\")\nlines(pred_arimaX_4_0_2_Y_Belgium_train300_Belgium_test60, col = \"green\", lwd = 4, lty=2)   # Belgium train+test\nlines(pred_arimaX_4_0_2_Y_Belgium_train300_Bulgaria_test60, col = \"purple\", lwd = 4, lty=1) # Belgium train+Bulgaria test\nlines(pred_arimaX_4_0_2_Y_Belgium_train300_Offset_Bulgaria_test60, col = \"orange\", lwd = 4, lty=1) \n# Belgium train+ Offset Bulgaria test: 188.3753 - 416.5375\nlines(ts_Y_Belgium_test, col = \"red\", lwd = 6, lty=1)       # Observed Y_Test timeseries\nlegend(\"topleft\", bty=\"n\", legend=c(\"Belgium Training Data (2000-2014)\", \n                        \"ARIMAX(4,0,2)-model GDP Forecasting (2015-2017)\",\n                        \"ARIMAX(4,0,2) Belgium train + XReg=Belgium test (2015-2017)\",\n                        \"ARIMAX(4,0,2) Belgium train + XReg=Bulgaria test (2015-2017)\",\n                        \"Offset ARIMAX(4,0,2) Belgium train + XReg=Bulgaria test (2015-2017)\",\n                        \"Belgium Official Reported GDP (2015-2017)\"),\n       col=c(\"black\", \"blue\", \"green\", \"purple\", \"orange\", \"red\"), \n       lty=c(3,1,2,1, 1, 1), lwd=c(4,4,4,4,4, 6), cex=1.2, x.intersp=1.5, y.intersp=0.7)\ntext(2005, 30, expression(atop(paste(\"Training Region (2000-2014)\"), \n                paste(Model(GDP) %->% \"ARIMAX(p, q, r) ;  \", \n                      XReg %==% X[i], \" \", i %in% {1 : 131}))), cex=1.2)\ntext(2015, 30, expression(atop(paste(\"Validation Region (2015-2017)\"), \n        paste(hat(GDP) %<-% \"ARIMAX(4, 0, 2); \", \n              XReg %==% X[i], \" \", i %in% {1 : 131}))), cex=1.2)",
      "line_count": 29
    },
    {
      "section": "Spacekime analytics",
      "code": "# FT/Spacekime Analytics\n# 1D timeseries FFT SHIFT\nfftshift1D <- function(img_ff) {\n  rows <- length(img_ff)   \n  rows_half <- ceiling(rows/2)\n  return(append(img_ff[(rows_half+1):rows], img_ff[1:rows_half]))\n}\n\n# Generic function to Transform Data ={all predictors (X) and outcome (Y)} to k-space (Fourier domain)\nkSpaceTransform <- function(data, inverse = FALSE, reconPhases = NULL) {\n  # ForwardFT (rawData, FALSE, NULL)\n  # InverseFT(magnitudes, TRUE, reconPhasesToUse) or InverseFT(FT_data, TRUE, NULL)\n  FT_data <- array(complex(), c(dim(data)[1], dim(data)[2]))\n  mag_FT_data <- array(complex(), c(dim(data)[1], dim(data)[2]))\n  phase_FT_data <- array(complex(), c(dim(data)[1], dim(data)[2]))\n  IFT_reconPhases_data <- array(complex(), c(dim(data)[1], dim(data)[2]))\n\n  for (i in 1:dim(data)[2]) {\n    if (inverse == FALSE | is.null(reconPhases)) {\n      FT_data[ , i] <- fft(data[ , i], inverse)\n      X2 <- FT_data[ , i]\n      # plot(fftshift1D(log(Re(X2)+2)), main = \"log(fftshift1D(Re(FFT(timeseries))))\") \n      mag_FT_data[ , i] <- sqrt(Re(X2)^2+Im(X2)^2); \n      # plot(log(fftshift1D(Re(mag_FT_MCSI_data))), main = \"log(Magnitude(FFT(timeseries)))\") \n      phase_FT_data[ , i] <- atan2(Im(X2), Re(X2)); \n      # plot(Re(fftshift1D(phase_FT_MCSI_data[ , 1])), main = \"Shift(Phase(FFT(timeseries)))\")\n    }\n    else {  # for IFT synthesis using user-provided Phases, typically from kime-phase aggregators\n      Real <- data[ , i] * cos(reconPhases[ , i])  \n      Imaginary <- data[ , i] * sin(reconPhases[ , i]) \n      IFT_reconPhases_data[ ,i] <- \n          Re(fft(Real+1i*Imaginary, inverse = TRUE)/length(data[ , i]))\n    }\n  }\n    ######### Test the FT-IFT analysis-synthesis back-and-forth transform process \n    #         to confirm calculations\n    # X2 <- FT_data[ , 1]; mag_FT_data[ , 1] <- sqrt(Re(X2)^2+Im(X2)^2); \n    # phase_FT_data[ , 1] <- atan2(Im(X2), Re(X2)); \n    # Real2 = mag_FT_data[ , 1] * cos(phase_FT_data[ , 1])\n    # Imaginary2 = mag_FT_data[ , 1] * sin(phase_FT_data[ , 1])\n    # man_hat_X2 = Re(fft(Real2 + 1i*Imaginary2, inverse = T)/length(X2))\n    # ifelse(abs(man_hat_X2[5] - data[5, 1]) < 0.001, \"Perfect Synthesis\", \"Problems!!!\")\n    #########\n  \n    if (inverse == FALSE | is.null(reconPhases)) {\n      return(list(\"magnitudes\"=mag_FT_data, \"phases\"=phase_FT_data))\n      # Use kSpaceTransform$magnitudes & kSpaceTransform$phases to retrieve teh Mags and Phases\n    }\n    else {\n      return(IFT_reconPhases_data)\n      # Use Re(kSpaceTransform) to extract spacetime Real-valued reconstructed data\n    }\n}",
      "line_count": 53
    },
    {
      "section": "Spacekime analytics",
      "code": "library(tidyr)\nlibrary(ggplot2)\n\nplotPhaseDistributions <- function (dataFT, dataColnames, size=10, ...) {\n  df.phase <- as.data.frame(Re(dataFT$phases))\n  df.phase %>% gather() %>% head()\n  colnames(df.phase) <- dataColnames\n  phaseDistributions <- gather(df.phase)\n  colnames(phaseDistributions) <- c(\"Feature\", \"Phase\")\n  if (is.null(size)) size=10\n  \n  # map the value as our x variable, and use facet_wrap to separate by the key column:\n  ggplot(phaseDistributions, aes(Phase)) + \n    # geom_histogram(bins = 10) + \n    geom_histogram(aes(y=..density..), bins = 10) + \n    facet_wrap( ~Feature, scales = 'free_x') +\n    xlim(-pi, pi) + \n    theme(strip.text.x = element_text(size = size, colour = \"black\", angle = 0))\n}\n\n# homoFeat <- homologousX_features(preprocess_Belgium$X, preprocess_Bulgaria$X)\nX_Belgium <- homoFeat$X_Country1; dim(X_Belgium)\nY_Belgium <- preprocess_Belgium$Y; dim(Y_Belgium)\n\nFT_Belgium <- kSpaceTransform(cbind(X_Belgium, Y_Belgium), FALSE, NULL)\ndataColnames <- c(colnames(X_Belgium), \"Y_GDP_Belgium\")\nplotPhaseDistributions(FT_Belgium, dataColnames)\n\nIFT_FT_Belgium <- kSpaceTransform(FT_Belgium$magnitudes, TRUE, FT_Belgium$phases)\n# Check IFT(FT) == I: \n# ifelse(abs(cbind(X_Belgium, Y_Belgium)[5,4] - Re(IFT_FT_Belgium[5,4])) < 0.001, \"Perfect Synthesis\", \"Problems!!!\")",
      "line_count": 31
    },
    {
      "section": "Spacekime analytics",
      "code": "# 1. Nil-Phase data synthesis (reconstruction)\ntemp_Data <- cbind(X_Belgium, Y_Belgium)\nnilPhase_FT_data <- array(complex(real=0, imaginary=0), c(dim(temp_Data)[1], dim(temp_Data)[2]))\ndim(nilPhase_FT_data)    # ;  head(nilPhase_FT_data)\n# [1] 360 132\nIFT_NilPhase_FT_Belgium <- array(complex(), c(dim(temp_Data)[1], dim(temp_Data)[2]))\n\n#       Invert back to spacetime the FT_Belgium$magnitudes[ , i] signal with nil-phase\nIFT_NilPhase_FT_Belgium <- Re(kSpaceTransform(FT_Belgium$magnitudes, TRUE, nilPhase_FT_data))\n\ncolnames(IFT_NilPhase_FT_Belgium) <- c(colnames(X_Belgium), \"Y_GDP_Belgium\")\ndim(IFT_NilPhase_FT_Belgium); dim(FT_Belgium$magnitudes)\n# colnames(IFT_NilPhase_FT_Belgium); head(IFT_NilPhase_FT_Belgium); # head(temp_Data)\n\n# 2. Perform ARIMAX modeling on IFT_NilPhase_FT_Belgium; report (p,d,q) params and quality metrics AIC/BIC\n# library(forecast)\nIFT_NilPhase_FT_Belgium_Y_train <- IFT_NilPhase_FT_Belgium[1:300, 132]; length(IFT_NilPhase_FT_Belgium_Y_train)\nIFT_NilPhase_FT_Belgium_Y_test <- IFT_NilPhase_FT_Belgium[301:360]; length(IFT_NilPhase_FT_Belgium_Y_test)\n\n# Training and Testing Data Covariates explaining the longitudinal outcome (Y)\nIFT_NilPhase_FT_Belgium_X_train <- as.data.frame(IFT_NilPhase_FT_Belgium)[1:300, 1:131]; dim(IFT_NilPhase_FT_Belgium_X_train)\nIFT_NilPhase_FT_Belgium_X_test <- as.data.frame(IFT_NilPhase_FT_Belgium)[301:360, 1:131]; dim(IFT_NilPhase_FT_Belgium_X_test)\n\n# Outcome Variable to be ARIMAX-modeled, as a timeseries\nts_IFT_NilPhase_FT_Belgium_Y_train <- \n         ts(IFT_NilPhase_FT_Belgium_Y_train, start=c(2000,1), end=c(2014, 20), frequency = 20)\n\n# Find ARIMAX model: 2  1  2  0 20  0  0\nset.seed(1234)\nmodArima_IFT_NilPhase_FT_Belgium_Y_train <- \n        auto.arima(ts_IFT_NilPhase_FT_Belgium_Y_train, xreg=as.matrix(IFT_NilPhase_FT_Belgium_X_train))\nmodArima_IFT_NilPhase_FT_Belgium_Y_train$arma\n\n# Regression with ARIMA(2,0,1)(2,0,0)[20] errors \n# Coefficients:\n#          ar1      ar2     ma1    sar1     sar2  Acquisitions less disposals of non-financial non-produced assets\n#      -1.4232  -0.8592  -0.987  0.0941  -0.3451                                                            0.0123\n#s.e.   0.0341   0.0311     NaN  0.0688   0.0742                                                            0.0007\n# sigma^2 estimated as 0.8622:  log likelihood=-320.39 AIC=914.79   AICc=1148.19   BIC=1422.2\n\npred_arimax_2_0_1_Nil <- forecast(modArima_IFT_NilPhase_FT_Belgium_Y_train, xreg = as.matrix(IFT_NilPhase_FT_Belgium_X_test))\npred_arimax_2_0_1_Nil_2015_2017 <- \n  ts(pred_arimax_2_0_1_Nil$mean, frequency=20, start=c(2015,1), end=c(2017,20))\npred_arimax_2_0_1_Nil_2015_2017\n# alternatively:\n# pred_arimax_1_0_1_2015_2017 <- predict(modArima_IFT_NilPhase_FT_Belgium_Y_train, \n#                                              n.ahead = 3*20, newxreg = IFT_NilPhase_FT_Belgium_X_test)$pred\nsort(modArima_IFT_NilPhase_FT_Belgium_Y_train$coef)[1:10]\n# Labor cost for LCI (compensation of employees plus taxes minus subsidies), effect=-1.5972295 \n#                                                                      ar1, effect=-1.4231617 \n#                                 Labor cost other than wages and salaries, effect=-1.2213214 \n#                                                                      ma1, effect=-0.9869571 \n#                                                                      ar2, effect=-0.8591937 \n#           Unemployment , Females, From 15-64 years, From 12 to 17 months, effect=-0.7075454 \n#             Unemployment , Total, From 15-64 years, From 18 to 23 months, effect=-0.5797656 \n#               Unemployment , Males, From 15-64 years, from 3 to 5 months, effect=-0.5026139 \n#                                                                     sar2, effect=-0.3450866 \n#             Unemployment , Males, From 15-64 years, from 24 to 47 months, effect=-0.2965540 \ncor(pred_arimax_2_0_1_Nil$mean, ts_Y_Belgium_test)  # 0.14\nmean(pred_arimax_2_0_1_Nil_2015_2017) # [1] 105",
      "line_count": 60
    },
    {
      "section": "Spacekime analytics",
      "code": "# 1. Swap Feature Phases and then synthesize the data (reconstruction)\n# temp_Data <- cbind(X_Belgium, Y_Belgium)\nswapped_phase_FT_Belgium_data <- FT_Belgium$phases\ncolnames(swapped_phase_FT_Belgium_data) <- c(colnames(X_Belgium), \"Y_GDP_Belgium\")\nswapped_phase_FT_Belgium_data1 <- swapped_phase_FT_Belgium_data\ndim(swapped_phase_FT_Belgium_data)    # ;  head(swappedPhase_FT_data)\n# [1] 360 132\nIFT_SwappedPhase_FT_Belgium <- array(complex(), c(dim(temp_Data)[1], dim(temp_Data)[2]))\n\nset.seed(12345)   # sample randomly Phase-columns for each of the 131 covariates (X)\n#swap_phase_FT_Belgium_indices <- sample(ncol(swapped_phase_FT_Belgium_data)-1)\n# for (j in 1:131) {  # for all columns of the design Xreg matrix, excluding Y, randomly swap columns phases\n#  swapped_phase_FT_Belgium_data1[ , j] <- swapped_phase_FT_Belgium_data[, swap_phase_FT_Belgium_indices[j]]\n#}\nswapped_phase_FT_Belgium_data1 <- as.data.frame(cbind(\n  swapped_phase_FT_Belgium_data[ , sample(ncol(swapped_phase_FT_Belgium_data[ , 1:131]))], \n  swapped_phase_FT_Belgium_data[ , 132]))\nswapped_phase_FT_Belgium_data <- swapped_phase_FT_Belgium_data1\ncolnames(swapped_phase_FT_Belgium_data)[132] <- \"Y_GDP_Belgium\"\n# colnames(swapped_phase_FT_Belgium_data)\ndim(swapped_phase_FT_Belgium_data); dim(FT_Belgium$phases)\n\n# Invert back to spacetime the FT_Belgium$magnitudes[ , i] signal using the feature swapped phases\nIFT_SwappedPhase_FT_Belgium <- Re(kSpaceTransform(FT_Belgium$magnitudes, TRUE, swapped_phase_FT_Belgium_data))\n\ncolnames(IFT_SwappedPhase_FT_Belgium) <- c(colnames(X_Belgium), \"Y_GDP_Belgium\")\ndim(IFT_SwappedPhase_FT_Belgium); dim(FT_Belgium$magnitudes)\ncolnames(IFT_SwappedPhase_FT_Belgium); tail(IFT_SwappedPhase_FT_Belgium); # tail(temp_Data)\n\n# 2. Perform ARIMAX modeling on IFT_SwappedPhase_FT_Belgium; report (p,d,q) params and quality metrics AIC/BIC\n# library(forecast)\nIFT_SwappedPhase_FT_Belgium_Y_train <- IFT_SwappedPhase_FT_Belgium[1:300, 132]; length(IFT_SwappedPhase_FT_Belgium_Y_train)\nIFT_SwappedPhase_FT_Belgium_Y_test <- IFT_SwappedPhase_FT_Belgium[301:360]; length(IFT_SwappedPhase_FT_Belgium_Y_test)\n\n# Training and Testing Data Covariates explaining the longitudinal outcome (Y)\nIFT_SwappedPhase_FT_Belgium_X_train <- as.data.frame(IFT_SwappedPhase_FT_Belgium)[1:300, 1:131]\ndim(IFT_SwappedPhase_FT_Belgium_X_train)\nIFT_SwappedPhase_FT_Belgium_X_test <- as.data.frame(IFT_SwappedPhase_FT_Belgium)[301:360, 1:131]\ndim(IFT_SwappedPhase_FT_Belgium_X_test)\n\n# Outcome Variable to be ARIMAX-modeled, as a timeseries\nts_IFT_SwappedPhase_FT_Belgium_Y_train <- \n         ts(IFT_SwappedPhase_FT_Belgium_Y_train, start=c(2000,1), end=c(2014, 20), frequency = 20)\n\n# Find ARIMAX model: 1  0  2  0 20  0  0\nset.seed(1234)\nmodArima_IFT_SwappedPhase_FT_Belgium_Y_train <- \n        auto.arima(ts_IFT_SwappedPhase_FT_Belgium_Y_train, xreg=as.matrix(IFT_SwappedPhase_FT_Belgium_X_train))\nmodArima_IFT_SwappedPhase_FT_Belgium_Y_train$arma\n\n# Regression with ARIMA(1,0,0)(2,0,0)[20] errors \n# Coefficients:\n#          ar1     sar1    sar2  intercept  Acquisitions less disposals of non-financial non-produced assets\n#      -0.3837  -0.2196  0.2827    46.1704                                                            0.0063\n#s.e.   0.1113   0.0903  0.0779    36.8492                                                            0.0080\n# sigma^2 estimated as 70:  log likelihood=-976.01 AIC=2224.02   AICc=2452.63   BIC=2727.73\n\npred_arimax_1_0_0_Swapped <- forecast(modArima_IFT_SwappedPhase_FT_Belgium_Y_train, xreg = as.matrix(IFT_SwappedPhase_FT_Belgium_X_test))\npred_arimax_1_0_0_Swapped_2015_2017 <- \n  ts(pred_arimax_1_0_0_Swapped$mean, frequency=20, start=c(2015,1), end=c(2017,20))\npred_arimax_1_0_0_Swapped_2015_2017\n# alternatively:\n# pred_arimax_1_0_0_Swapped_2015_2017 <- predict(modArima_IFT_SwappedPhase_FT_Belgium_Y_train, \n#                                              n.ahead = 3*20, newxreg = IFT_SwappedPhase_FT_Belgium_X_test)$pred\nsort(modArima_IFT_SwappedPhase_FT_Belgium_Y_train$coef)[1:10]\n#                                                                     ar1, effect=-0.38372043 \n#           Unemployment , Females, From 15-64 years, From 18 to 23 months, effect=-0.31137514 \n#                                 Labor cost other than wages and salaries, effect=-0.31094561 \n#                                                                     sar1, effect=-0.21964957 \n#            Unemployment , Females, From 15-64 years, From 6 to 11 months, effect=-0.20878853 \n#Labor cost for LCI (compensation of employees plus taxes minus subsidies), effect=-0.12497311 \n#                Unemployment , Males, From 15-64 years, Less than 1 month, effect=-0.10849013 \n#                Unemployment , Total, From 15-64 years, 48 months or over, effect=-0.09066684 \n#               Unemployment , Total, From 15-64 years, From 1 to 2 months, effect=-0.05852382 \n#              Unemployment , Females, From 15-64 years, 48 months or over, effect=-0.05695172 \ncor(pred_arimax_1_0_0_Swapped$mean, ts_Y_Belgium_test)  # 0.0\nmean(pred_arimax_1_0_0_Swapped_2015_2017) # [1] 105",
      "line_count": 77
    },
    {
      "section": "Spacekime analytics",
      "code": "# 1. Random-Phase data synthesis (reconstruction)\n# temp_Data <- cbind(X_Belgium, Y_Belgium)\nrandPhase_FT_data <- array(complex(), c(dim(temp_Data)[1], dim(temp_Data)[2]))\ndim(randPhase_FT_data)    # ;  head(randPhase_FT_data)\n# [1] 360 132\nIFT_RandPhase_FT_Belgium <- array(complex(), c(dim(temp_Data)[1], dim(temp_Data)[2]))\n\nrandPhase_FT_data <- FT_Belgium$phases\nfor (i in 1:(dim(randPhase_FT_data)[2] -1)) {\n  if (i < dim(randPhase_FT_data)[2]) {\n    set.seed(12345)   # sample randomly Phases for each of the 131 predictors covariates (X)\n    randPhase_FT_data[ , i] <- FT_Belgium$phases[sample(nrow(FT_Belgium$phases)), i]\n  } else {   } # for the Y outcome (Last Column) - do not change the phases of the Y\n}\n#       Invert back to spacetime the FT_Belgium$magnitudes[ , i] signal with avg-phase\nIFT_RandPhase_FT_Belgium <- Re(kSpaceTransform(FT_Belgium$magnitudes, TRUE, randPhase_FT_data))\ncolnames(IFT_RandPhase_FT_Belgium) <- c(colnames(X_Belgium), \"Y_GDP_Belgium\")\ndim(IFT_RandPhase_FT_Belgium); dim(FT_Belgium$magnitudes)\n# colnames(IFT_RandPhase_FT_Belgium); tail(IFT_RandPhase_FT_Belgium); # tail(temp_Data)\n\ndim(IFT_RandPhase_FT_Belgium); head(Re(IFT_RandPhase_FT_Belgium)); tail(Re(IFT_RandPhase_FT_Belgium))\n\n\n# 2. Perform ARIMAX modeling on IFT_RandPhase_FT_Belgium; report (p,d,q) params and quality metrics AIC/BIC\n# library(forecast)\nIFT_RandPhase_FT_Belgium_Y_train <- IFT_RandPhase_FT_Belgium[1:300, 132]; length(IFT_RandPhase_FT_Belgium_Y_train)\nIFT_RandPhase_FT_Belgium_Y_test <- IFT_RandPhase_FT_Belgium[301:360]; length(IFT_RandPhase_FT_Belgium_Y_test)\n\n# Training and Testing Data Covariates explaining the longitudinal outcome (Y)\nIFT_RandPhase_FT_Belgium_X_train <- as.data.frame(IFT_RandPhase_FT_Belgium)[1:300, 1:131]; dim(IFT_RandPhase_FT_Belgium_X_train)\nIFT_RandPhase_FT_Belgium_X_test <- as.data.frame(IFT_RandPhase_FT_Belgium)[301:360, 1:131]; dim(IFT_RandPhase_FT_Belgium_X_test)\n\n# Outcome Variable to be ARIMAX-modeled, as a timeseries\nts_IFT_RandPhase_FT_Belgium_Y_train <- \n         ts(IFT_RandPhase_FT_Belgium_Y_train, start=c(2000,1), end=c(2014, 20), frequency = 20)\n\n# Find ARIMAX model: 0  0  2  0 20  0  0\nset.seed(1234)\nmodArima_IFT_RandPhase_FT_Belgium_Y_train <- \n        auto.arima(ts_IFT_RandPhase_FT_Belgium_Y_train, xreg=as.matrix(IFT_RandPhase_FT_Belgium_X_train))\nmodArima_IFT_RandPhase_FT_Belgium_Y_train$arma\n\n# Regression with ARIMA(0,0,0)(2,0,0)[20] errors \n# Coefficients:\n#         sar1    sar2  Acquisitions less disposals of non-financial non-produced assets\n#      -0.0743  0.5766                                                            0.0162\n#s.e.   0.0625  0.0752                                                            0.0100 \n#sigma^2 estimated as 72.17:  log likelihood=-988.06 AIC=2244.12   AICc=2463.4   BIC=2740.43\n\npred_arimax_0_0_0_Rand <- forecast(modArima_IFT_RandPhase_FT_Belgium_Y_train, xreg = as.matrix(IFT_RandPhase_FT_Belgium_X_test))\npred_arimax_0_0_0_Rand_2015_2017 <- \n  ts(pred_arimax_0_0_0_Rand$mean, frequency=20, start=c(2015,1), end=c(2017,20))\npred_arimax_0_0_0_Rand_2015_2017\n# alternatively:\n# pred_arimax_1_0_1_Rand_2015_2017 <- predict(modArima_IFT_RandPhase_FT_Belgium_Y_train, \n#                                              n.ahead = 3*20, newxreg = IFT_RandPhase_FT_Belgium_X_test)$pred\nsort(modArima_IFT_RandPhase_FT_Belgium_Y_train$coef)[1:10]\n# Labor cost for LCI (compensation of employees plus taxes minus subsidies), effect=-0.71989958 \n#           Unemployment , Females, From 15-64 years, From 18 to 23 months, effect=-0.54541627 \n#              Unemployment , Females, From 15-64 years, 48 months or over, effect=-0.44230677 \n#                                 Labor cost other than wages and salaries, effect=-0.32854422 \n#              Unemployment , Males, From 15-64 years, from 6 to 11 months, effect=-0.24511374 \n#             Unemployment , Total, From 15-64 years, From 24 to 47 months, effect=-0.19283037 \n#      Agriculture, forestry and fishing - Employers' social contributions, effect=-0.11994897 \n#           Unemployment , Females, From 15-64 years, From 24 to 47 months, effect=-0.10835175 \n#             Unemployment , Females, From 15-64 years, From 1 to 2 months, effect=-0.09093252 \n#             Unemployment , Total, From 15-64 years, From 18 to 23 months, effect=-0.07427297 \ncor(pred_arimax_0_0_0_Rand$mean, ts_Y_Belgium_test)  # -0.15\nmean(pred_arimax_0_0_0_Rand_2015_2017) # [1] 87.74201",
      "line_count": 69
    },
    {
      "section": "Spacekime analytics",
      "code": "## Plot the results of the model ARIMAX fitting\nts_Y_Belgium_test <- ts(preprocess_Belgium$Y[301:360, ], \n                        start=c(2015,1), end=c(2017, 20), frequency = 20)\nlength(ts_Y_Belgium_test)\n\n# windows(width=14, height=10)\nplot(forecast(BelgiumARIMA, xreg = as.matrix(X_Belgium_test)),         # ARIMA forecast\n     include=60, lwd=4, lty=3, xlab=\"Time\", ylab=\"GDP Purchasing Power Standards (PPS)\",\n     ylim=c(60, 160),\n     main = \"Spacekime ARIMAX Analytics (Train: 2000-2014; Test: 2015-2017) GDP (PPS) Forecasting\\n\n      based on fitting ARIMAX Models on spline interpolated & kime-transformed Belgium data\")\nlines(pred_arimax_2_0_1_Nil_2015_2017, col = \"green\", lwd = 4, lty=2)   # Belgium Xreg Nil-Phase Reconstructions\nlines(pred_arimax_1_0_0_Swapped_2015_2017, col = \"purple\", lwd = 4, lty=1) # Belgium Xreg Swapped-Phase Reconstructions\nlines(pred_arimax_0_0_0_Rand_2015_2017, col = \"orange\", lwd = 4, lty=1) # Belgium Xreg Random-Phase Reconstructions\nlines(ts_Y_Belgium_test, col = \"red\", lwd = 6, lty=1)       # Observed Y_Test timeseries\nlegend(\"topleft\", bty=\"n\", legend=c(\"Belgium Training Data (2000-2014)\", \n                        \"ARIMAX(4,0,2)-model GDP Forecasting (2015-2017)\",\n                        \"ARIMAX(2,0,1) Belgium Xreg Nil-Phase Reconstruction (2015-2017)\",\n                        \"ARIMAX(1,0,0) Belgium Xreg Swapped-Phase Reconstructions (2015-2017)\",\n                        \"ARIMAX(0,0,0)(2,0,0)[20]  Belgium Xreg Random-Phase Reconstructions (2015-2017)\",\n                        \"Belgium Official Reported GDP (2015-2017)\"),\n       col=c(\"black\", \"blue\", \"green\", \"purple\", \"orange\", \"red\"), \n       lty=c(3,1,2,1, 1, 1), lwd=c(4,4,4,4,4, 6), cex=1.2, x.intersp=1.5, y.intersp=0.7)\ntext(2013.5, 65, expression(atop(paste(\"Training Region (2000-2014)\"), \n                paste(Model(GDP) %->% \"ARIMAX(p, q, r) ;  \", \n                      XReg %==% X[i], \" \", i %in% {1 : 131}))), cex=1.2)\ntext(2016.5, 65, expression(atop(paste(\"Validation Region (2015-2017)\"), \n        paste(hat(GDP) %<-% \"ARIMAX(., ., .); \", \n              XReg %==% X[i], \" \", i %in% {1 : 131}))), cex=1.2)",
      "line_count": 29
    },
    {
      "section": "ML Data Analytics",
      "code": "# 1. Find all \"Common\" features (highly-observed and congruent Econ indicators)\ncountryNames <- unique(time_series$country); length(countryNames); # countryNames\n# initialize 3D array of DF's that will store the data for each of the countries into a 2D frame\ncountryData <- list()  # countryData[[listID==Country]][1-time-72, 1-feature-197]\n\nfor (i in 1:length(countryNames)) {\n  countryData[[i]] <- filter(time_series, country == countryNames[i])\n}\n# Check countryData[[2]][2, 3] == Belgium[2,3]\n\nlist_of_dfs_CommonFeatures <- list()  # list of data for supersampled countries 360 * 197\n\n# 2. General function that ensures the XReg predictors for ALL 31 EU countries are homologous\ncompleteHomologousX_features <- function (list_of_dfs) {\n  # delete features that are missing at all time points\n  for (j in 1:length(list_of_dfs)) {\n    print(paste0(\"Pre-processing Country: ...\", countryNames[j], \"... \"))\n    data = list_of_dfs[[j]]\n    data = data[ , colSums(is.na(data)) != nrow(data)]\n    data = dplyr::select(data, !any_of(c(\"time\", \"country\")))\n    DataMatrix = as.matrix(data)\n    DataMatrix = cleardata(DataMatrix)\n    DataMatrix = DataMatrix[ , colSums(is.na(DataMatrix)) == 0] # remove features with only 1 value\n    DataMatrix = DataMatrix[ , colSums(DataMatrix) != 0] # remove features with all values=0\n    # Supersample 72 --*5--> 360 timepoints \n    DataMatrix = splinecreate(DataMatrix)\n    DataSuperSample = as.data.frame(DataMatrix) # super-Sample the data\n    # remove some of features  \n    DataSuperSample = DataSuperSample[, -c(50:80)]; dim(X)  # 360 167\n    # ensure full-rank design matrix, DataSuperSample\n    DataSuperSample <- \n      DataSuperSample[ , qr(DataSuperSample)$pivot[seq_len(qr(DataSuperSample)$rank)]]\n    print(paste0(\"dim()=(\", dim(DataSuperSample)[1], \",\", dim(DataSuperSample)[2], \") ...\"))\n    # update the current DF/Country\n    list_of_dfs_CommonFeatures[[j]] <- DataSuperSample\n  }\n\n  # Identify All Xreg features that are homologous (same feature columns) across All 31 countries\n  # Identify Common Columns (features)\n  comCol <- Reduce(intersect, lapply(list_of_dfs_CommonFeatures, colnames))\n  list_of_dfs_CommonFeatures <- lapply(list_of_dfs_CommonFeatures, function(x) x[comCol])\n\n  for (j in 1:length(list_of_dfs_CommonFeatures)) {\n    list_of_dfs_CommonFeatures[[j]] <- subset(list_of_dfs_CommonFeatures[[j]], select = comCol)\n    print(paste0(\"dim(\", countryNames[j], \")=(\", dim(list_of_dfs_CommonFeatures[[j]])[1], \n                 \",\", dim(list_of_dfs_CommonFeatures[[j]])[2], \")!\"))  # 72 * 197\n  }\n  return(list_of_dfs_CommonFeatures)\n}\n# Test completeHomologousX_features: dim(AllCountries)=(360,42)!\nlist_of_dfs_CommonFeatures <- completeHomologousX_features(countryData); \nlength(list_of_dfs_CommonFeatures); dim(list_of_dfs_CommonFeatures[[1]]) # Austria data matrix 360*42",
      "line_count": 52
    },
    {
      "section": "ML Data Analytics",
      "code": "# 3. For each country (n) and each common feature (k), compute (p,d,q) ARIMA models (non-exogenous, \n# just the timeseries model for this feature), (p,d,q) triples\n# Country * Feature\narimaModels_DF <- list() \n#data.frame(matrix(NA, nrow = length(countryNames), \n#  ncol = dim(list_of_dfs_CommonFeatures[[1]])[2]), row.names=countryNames, stringsAsFactors=T)\n\n# colnames(arimaModels_DF) <- colnames(list_of_dfs_CommonFeatures[[1]])\n\n# list_index <- 1\n# arimaModels_ARMA_coefs <- list()  # array( , c(31, 9*dim(list_of_dfs_CommonFeatures[[1]])[2]))\n# dim(arimaModels_ARMA_coefs) # [1]  31 x 378 == 31 x (9 * 42)\n# For each (Country, feature) index, the 9 ARIMA-derived vector includes:\n# (ts_avg, forecast_avg, non-seasonal AR, non-seasonal MA, seasonal AR, seasonal MA, period, non-seasonal Diff, seasonal differences)\n\nfor(n in 1:(length(list_of_dfs_CommonFeatures))) {          # for each Country 1<=n<=31\n  for (k in 1:(dim(list_of_dfs_CommonFeatures[[1]])[2])) {  # for each feature 1<=k<=42\n    # extract one timeseries (the feature+country time course)\n    ts = ts(list_of_dfs_CommonFeatures[[n]][ , k],\n            frequency=20, start=c(2000,1), end=c(2017,20))\n    set.seed(1234)\n    arimaModels_DF[[list_index]] <- auto.arima(ts)\n      # pred_arimaModels_DF = forecast(arimaModels_DF[[list_index]])\n      # ts_pred_arimaModels_DF <- \n      #  ts(pred_arimaModels_DF$mean, frequency=20, start=c(2015,1), end=c(2017,20))\n      # ts_pred_arimaModels_DF\n    arimaModels_ARMA_coefs[[list_index]] <- c (\n        mean(ts),                           # time-series average (retrospective) \n        mean(forecast(arimaModels_DF[[list_index]])$mean), # forecasted TS average (prospective)\n        arimaModels_DF[[list_index]]$arma)  # 7 ARMA estimated parameters\n    # cat(\"arimaModels_ARMA_coefs[country=\", countryNames[n], \", feature=\",\n    #          colnames(list_of_dfs_CommonFeatures[[1]])[k],\n    #          \"] Derived-Features=(\", round(arimaModels_ARMA_coefs[[list_index]], 2), \") ...\")\n    #print(paste0(\"arimaModels_DF[country=\", countryNames[i], \", feature=\",\n    #         colnames(list_of_dfs_CommonFeatures[[1]])[k],\n    #         \"]$arma =\", arimaModels_DF[[list_index]]$arma))\n    list_index <- list_index + 1\n  }\n}\n\nlength(arimaModels_ARMA_coefs) == 31*42  # [1] TRUE  # Each list-element consists of 9 values, see above\n#  == dim(list_of_dfs_CommonFeatures[[1]])[1] * dim(list_of_dfs_CommonFeatures[[1]])[2]\n# Maps to convert between 1D indices and 2D (Country, Feature) pairs\nindex2CountryFeature <- function(indx=1) { \n  if (indx<1 | indx>length(arimaModels_ARMA_coefs)) {\n    cat(\"Index out of bounds: indx=\", indx, \"; must be between 1 and \", \n        length(arimaModels_ARMA_coefs), \" ... Exiting ...\")\n    return (NULL)\n  } else { \n    feature = (indx-1) %% (dim(list_of_dfs_CommonFeatures[[1]])[2])\n    country = floor((indx - feature)/(dim(list_of_dfs_CommonFeatures[[1]])[2]))\n    return(list(\"feature\"=(feature+1), \"country\"=(country+1)))  }\n}\n\ncountryFeature2Index <- function(countryIndx=1, featureIndx=1) { \n  if (countryIndx<1 | countryIndx>(dim(list_of_dfs_CommonFeatures[[1]])[1]) |\n      featureIndx<1 | featureIndx>(dim(list_of_dfs_CommonFeatures[[1]])[2])) {\n    cat(\"Indices out of bounds: countryIndx=\", countryIndx, \"; featureIndx=\", featureIndx, \"; Exiting ...\")\n    return (NULL)\n  } else { return (featureIndx + (countryIndx-1)*(dim(list_of_dfs_CommonFeatures[[1]])[2])) }\n}\n\n# test forward and reverse index mapping functions\nindex2CountryFeature(42);  index2CountryFeature(45)$country;  index2CountryFeature(45)$feature\ncountryFeature2Index(countryIndx=2, featureIndx=3)\n\n# Column/Feature Names: colnames(list_of_dfs_CommonFeatures[[1]])\n# Country/Row Names: countryNames\narimaModels_ARMA_coefs[[1]] # Austria/Feature1  1:9 feature vector\n# Cuntry2=Bulgaria, feature 5, 1:9 vector\narimaModels_ARMA_coefs[[countryFeature2Index(countryIndx=2, featureIndx=5)]]",
      "line_count": 71
    },
    {
      "section": "ML Data Analytics",
      "code": "# 4. Add the country ranking as a new feature, using the OA ranks here:\n# (http://wiki.stat.ucla.edu/socr/index.php/SOCR_Data_2008_World_CountriesRankings)\nEU_SOCR_Country_Ranking_Data_2011 <- read.csv2(\"C:/Users/dinov/Desktop/Ivo.dir/Research/UMichigan/Publications_Books/2018/others/4D_Time_Space_Book_Ideas/ARIMAX_EU_DataAnalytics/EU_SOCR_Country_Ranking_Data_2011.csv\", header=T, sep=\",\")\n\nlength(arimaModels_ARMA_coefs) # 31*42 \narima_df <- data.frame(matrix(NA, \n          nrow=length(countryNames), ncol=length(colnames(list_of_dfs_CommonFeatures[[1]]))*9))\ndim(arima_df)   # [1]  31 378\n\nfor(n in 1:dim(arima_df)[1]) {        # for each Country 1<=n<=31\n  for (k in 1:length(colnames(list_of_dfs_CommonFeatures[[1]]))) {     # for each feature 1<=k<=42\n    for (l in 1:9) {                  # for each arima vector 1:9, see above\n        arima_df[n, (k-1)*9 + l] <- \n          round(arimaModels_ARMA_coefs[[countryFeature2Index(countryIndx=n, featureIndx=k)]][l], 1)\n        if (n==dim(arima_df)[1]) colnames(arima_df)[(k-1)*9 + l] <- paste0(\"Feature_\",k, \"_ArimaVec_\",l)\n    }\n  }\n}\n\n# DF Conversion Validation\narimaModels_ARMA_coefs[[countryFeature2Index(countryIndx=3, featureIndx=5)]][2] == arima_df[3, (5-1)*9 + 2]\n# [1] 1802.956\n\n# Aggregate 2 datasets\ndim(EU_SOCR_Country_Ranking_Data_2011)  # [1] 31 10\n\naggregate_arima_vector_country_ranking_df <- \n  as.data.frame(cbind(arima_df, EU_SOCR_Country_Ranking_Data_2011[ , -1]))\ndim(aggregate_arima_vector_country_ranking_df)   # [1]  Country=31 * Features=387 (ARIMA=378 + Ranking=9)\n# View(aggregate_arima_vector_country_ranking_df)\nrownames(aggregate_arima_vector_country_ranking_df) <- countryNames\nwrite.csv(aggregate_arima_vector_country_ranking_df, row.names = T, fileEncoding = \"UTF-16LE\",\n           \"C:/Users/dinov/Desktop/Ivo.dir/Research/UMichigan/Publications_Books/2018/others/4D_Time_Space_Book_Ideas/ARIMAX_EU_DataAnalytics/EU_aggregate_arima_vector_country_ranking.csv\")",
      "line_count": 33
    },
    {
      "section": "ML Data Analytics",
      "code": "# 1. LASSO regression/feature extraction\nlibrary(glmnet)\nlibrary(arm)\nlibrary(knitr)\n# subset test data\nY = aggregate_arima_vector_country_ranking_df$OA\nX = aggregate_arima_vector_country_ranking_df[ , -387]\n# remove columns containing NAs and convert character DF to numeric type\nX = as.data.frame(apply(X[ , colSums(is.na(X)) == 0], 2, as.numeric)); dim(X)  # [1]  31 386\n\nfitRidge = glmnet(as.matrix(X), Y, alpha = 0)  # Ridge Regression\nfitLASSO = glmnet(as.matrix(X), Y, alpha = 1)  # The LASSO\n# LASSO\nplot(fitLASSO, xvar=\"lambda\", label=\"TRUE\", lwd=3)\n# add label to upper x-axis\nmtext(\"LASSO regularizer: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n# Ridge\nplot(fitRidge, xvar=\"lambda\", label=\"TRUE\", lwd=3)\n# add label to upper x-axis\nmtext(\"Ridge regularizer: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n#### 10-fold cross validation ####\n# LASSO\nlibrary(doParallel)\nregisterDoParallel(6)\nset.seed(1234)  # set seed \n# (10-fold) cross validation for the LASSO\ncvLASSO = cv.glmnet(data.matrix(X), Y, alpha = 1, parallel=TRUE)\ncvRidge = cv.glmnet(data.matrix(X), Y, alpha = 0, parallel=TRUE)\nplot(cvLASSO)\nmtext(\"CV LASSO: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO <-  predict(cvLASSO, s = cvLASSO$lambda.min, newx = data.matrix(X))\ntestMSE_LASSO <- mean((predLASSO - Y)^2); testMSE_LASSO\n\npredLASSO = predict(cvLASSO, s = cvLASSO$lambda.min, newx = data.matrix(X))\npredRidge = predict(fitRidge, s = cvRidge$lambda.min, newx = data.matrix(X))\n\n# calculate test set MSE\ntestMSELASSO = mean((predLASSO - Y)^2)\ntestMSERidge = mean((predRidge - Y)^2)\n##################################Use only ARIMA effects, no SOCR meta-data#####\nset.seed(4321)\ncvLASSO_lim = cv.glmnet(data.matrix(X[ , 1:(42*9)]), Y, alpha = 1, parallel=TRUE)\nplot(cvLASSO_lim)\nmtext(\"CV LASSO (using only Timeseries data): Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO_lim <-  predict(cvLASSO_lim, s = 3, # cvLASSO_lim$lambda.min, \n                          newx = data.matrix(X[ , 1:(42*9)]))\ncoefList_lim <- coef(cvLASSO_lim, s=3) # 'lambda.min')\ncoefList_lim <- data.frame(coefList_lim@Dimnames[[1]][coefList_lim@i+1],coefList_lim@x)\nnames(coefList_lim) <- c('Feature','EffectSize')\narrange(coefList_lim, -abs(EffectSize))[2:10, ]\ncor(Y, predLASSO_lim[, 1])  # 0.84\n################################################################################\n\n# Plot Regression Coefficients: create variable names for plotting \nlibrary(\"arm\")\n# par(mar=c(2, 13, 1, 1))   # extra large left margin # par(mar=c(5,5,5,5))\nvarNames <- colnames(X); # varNames; \nlength(varNames)\n\nbetaHatLASSO = as.double(coef(fitLASSO, s = cvLASSO$lambda.min))  # cvLASSO$lambda.1se\nbetaHatRidge = as.double(coef(fitRidge, s = cvRidge$lambda.min))\n\n#coefplot(betaHatLASSO[2:386], sd = rep(0, 385), pch=0, cex.pts = 3, main = \"LASSO-Regularized Regression Coefficient Estimates\", varnames = varNames)\ncoefplot(betaHatLASSO[377:386], sd = rep(0, 10), pch=0, cex.pts = 3, col=\"red\", main = \"LASSO-Regularized Regression Coefficient Estimates\", varnames = varNames[377:386])\ncoefplot(betaHatRidge[377:386], sd = rep(0, 10), pch=2, add = TRUE, col.pts = \"blue\", cex.pts = 3)\nlegend(\"bottomleft\", c(\"LASSO\", \"Ridge\"), col = c(\"red\", \"blue\"), pch = c(1 , 2), bty = \"o\", cex = 2)\n\nvarImp <- function(object, lambda = NULL, ...) {\n  ## skipping a few lines\n  beta <- predict(object, s = lambda, type = \"coef\")\n  if(is.list(beta)) {\n    out <- do.call(\"cbind\", lapply(beta, function(x) x[,1]))\n    out <- as.data.frame(out)\n  } else out <- data.frame(Overall = beta[,1])\n  out <- abs(out[rownames(out) != \"(Intercept)\",,drop = FALSE])\n  out\n}\n\nvarImp(cvLASSO, lambda = cvLASSO$lambda.min)\n\ncoefList <- coef(cvLASSO, s='lambda.min')\ncoefList <- data.frame(coefList@Dimnames[[1]][coefList@i+1],coefList@x)\nnames(coefList) <- c('Feature','EffectSize')\narrange(coefList, -abs(EffectSize))[2:10, ]\n#                      var        val  # Feature names: colnames(list_of_dfs_CommonFeatures[[1]])\n#1            (Intercept) 49.4896874\n#2   Feature_1_ArimaVec_8 -2.4050811   # Feature 1 = Active population: Females 15 to 64 years\n#3  Feature_20_ArimaVec_8 -1.4015001   # Feature 20= \"Employment: Females 15 to 64 years\n#4            IncomeGroup -1.2271177\n#5   Feature_9_ArimaVec_8 -1.0629835   # Feature 9= Active population: Total 15 to 64 years\n#6                     ED -0.7481041\n#7                     PE -0.5167668\n#8  Feature_25_ArimaVec_5  0.4416775   # Feature 25= Property income\n#9   Feature_9_ArimaVec_4 -0.2217804\n#10                   QOL -0.1965342\n#                                     ARIMA: 4=non-seasonal MA, 5=seasonal AR, 8=non-seasonal Diff\n#\n#9 ARIMA-derived vector includes:\n# (1=ts_avg, 2=forecast_avg, 3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA, \n#  7=period, 8=non-seasonal Diff, 9=seasonal differences)\n\n# [1] \"Active population by sex, age and educational attainment level, Females, From 15 to 64 years, All ISCED 2011 levels\"                                                     \n# [2] \"Active population by sex, age and educational attainment level, Females, From 15 to 64 years, Less than primary, primary and lower secondary education (levels 0-2)\"     \n# [3] \"Active population by sex, age and educational attainment level, Females, From 15 to 64 years, Tertiary education (levels 5-8)\"                                           \n# [4] \"Active population by sex, age and educational attainment level, Females, From 15 to 64 years, Upper secondary and post-secondary non-tertiary education (levels 3 and 4)\"\n# [5] \"Active population by sex, age and educational attainment level, Males, From 15 to 64 years, All ISCED 2011 levels\"                                                       \n# [6] \"Active population by sex, age and educational attainment level, Males, From 15 to 64 years, Less than primary, primary and lower secondary education (levels 0-2)\"       \n# [7] \"Active population by sex, age and educational attainment level, Males, From 15 to 64 years, Tertiary education (levels 5-8)\"                                             \n# [8] \"Active population by sex, age and educational attainment level, Males, From 15 to 64 years, Upper secondary and post-secondary non-tertiary education (levels 3 and 4)\"  \n# [9] \"Active population by sex, age and educational attainment level, Total, From 15 to 64 years, All ISCED 2011 levels\"  \n#[10] \"Active population by sex, age and educational attainment level, Total, From 15 to 64 years, Less than primary, primary and lower secondary education (levels 0-2)\" \n#[11] \"Active population by sex, age and educational attainment level, Total, From 15 to 64 years, Tertiary education (levels 5-8)\"        \n#[12] \"Active population by sex, age and educational attainment level, Total, From 15 to 64 years, Upper secondary and post-secondary non-tertiary education (levels 3 and 4)\"\n#[13] \"All ISCED 2011 levels \" \n# [14] \"All ISCED 2011 levels, Females\"  \n# [15] \"All ISCED 2011 levels, Males\"\n# [16] \"Capital transfers, payable\"  \n# [17] \"Capital transfers, receivable\"  \n# [18] \"Compensation of employees, payable\"  \n# [19] \"Current taxes on income, wealth, etc., receivable\"\n#[20] \"Employment by sex, age and educational attainment level, Females, From 15 to 64 years, All ISCED 2011 levels \" \n# [21] \"Employment by sex, age and educational attainment level, Females, From 15 to 64 years, Less than primary, primary and lower secondary education (levels 0-2)\"            \n# [22] \"Other current transfers, payable\"\n# [23] \"Other current transfers, receivable\" \n# [24] \"Property income, payable\" \n# [25] \"Property income, receivable\" \n# [26] \"Savings, gross\" \n# [27] \"Subsidies, payable\"\n# [28] \"Taxes on production and imports, receivable\"\n# [29] \"Total general government expenditure\"\n# [30] \"Total general government revenue\"\n# [31] \"Unemployment , Females, From 15-64 years, Total\"\n# [32] \"Unemployment , Males, From 15-64 years\" \n# [33] \"Unemployment , Males, From 15-64 years, from 1 to 2 months\" \n# [34] \"Unemployment , Males, From 15-64 years, from 3 to 5 months\"\n# [35] \"Unemployment , Males, From 15-64 years, from 6 to 11 months\"  \n# [36] \"Unemployment , Total, From 15-64 years, From 1 to 2 months\"\n# [37] \"Unemployment , Total, From 15-64 years, From 12 to 17 months\"\n# [38] \"Unemployment , Total, From 15-64 years, From 3 to 5 months\" \n# [39] \"Unemployment , Total, From 15-64 years, From 6 to 11 months\"  \n# [40] \"Unemployment , Total, From 15-64 years, Less than 1 month\" \n# [41] \"Unemployment by sex, age, duration. DurationNA not started\"\n# [42] \"VAT, receivable\"   \n\ncoef(cvLASSO, s = \"lambda.min\") %>%\n  broom::tidy() %>%\n  filter(row != \"(Intercept)\") %>%\n  top_n(100, wt = abs(value)) %>%\n  ggplot(aes(value, reorder(row, value), color = value > 0)) +\n  geom_point(show.legend = FALSE, aes(size = abs(value))) +\n  ggtitle(\"Top 9 salient features (LASSO penalty)\") +\n  xlab(\"Effect-size\") +\n  ylab(NULL)\n\nvalidation <- data.frame(matrix(NA, nrow = dim(predLASSO)[1], ncol=3), row.names=countryNames)\nvalidation [ , 1] <- Y; validation [ , 2] <- predLASSO_lim[, 1]; validation [ , 3] <- predRidge[, 1]\ncolnames(validation) <- c(\"Y\", \"LASSO\", \"Ridge\")\ndim(validation)\nhead(validation)\n\n# Prediction correlations: \ncor(validation[ , 1], validation[, 2])  # Y=observed OA rank vs. LASSO-pred  0.96 (lim) 0.84\ncor(validation[ , 1], validation[, 3])  # Y=observed OA rank vs. Ridge-pred  0.95\n\n# Plot observed Y (Overall Country ranking) vs. LASSO (9-parameters) predicted Y^\nlinFit1 <- lm(validation[ , 1] ~ predLASSO)\nplot(validation[ , 1] ~ predLASSO,\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"Observed Country Overall Ranking\", ylab=\"LASSO 9/(42*9) param model\",\n     main = sprintf(\"Observed (X) vs. LASSO-Predicted (Y) Overall Country Ranking, cor=%.02f\", \n                    cor(validation[ , 1], validation[, 2])))\nabline(linFit1, lwd=3, col=\"red\")\n\n# Plot observed LASSO (9-parameters) predicted Y^ vs. Y (Overall Country ranking) \nlinFit1 <- lm(predLASSO_lim ~ validation[ , 1])\nplot(predLASSO_lim ~ validation[ , 1],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"Observed Country Overall Ranking\", ylab=\"LASSO 9/(42*9) param model\",\n     main = sprintf(\"Observed (X) vs. LASSO-Predicted (Y) Overall Country Ranking, cor=%.02f\", \n                    cor(validation[ , 1], validation[, 2])))\nabline(linFit1, lwd=3, col=\"red\")",
      "line_count": 187
    },
    {
      "section": "ML Data Analytics",
      "code": "# https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/05_DimensionalityReduction.html \n# ...",
      "line_count": 2
    },
    {
      "section": "ML Data Analytics",
      "code": "\n# Generic function to Transform Data ={all predictors (X) and outcome (Y)} to k-space (Fourier domain): kSpaceTransform(data, inverse = FALSE, reconPhases = NULL) \n  # ForwardFT (rawData, FALSE, NULL)\n  # InverseFT(magnitudes, TRUE, reconPhasesToUse) or InverseFT(FT_data, TRUE, NULL)\n\n# DATA\n# subset test data\nY = aggregate_arima_vector_country_ranking_df$OA\nX = aggregate_arima_vector_country_ranking_df[ , -387]\n# remove columns containing NAs\nX = as.data.frame(apply(X[ , colSums(is.na(X)) == 0], 2, as.numeric)); dim(X)  # [1]  31 386\nlength(Y); dim(X)\n\nFT_aggregate_arima_vector_country_ranking_df <- \n  kSpaceTransform(as.data.frame(apply(\n    aggregate_arima_vector_country_ranking_df[ , colSums(is.na(aggregate_arima_vector_country_ranking_df)) == 0], \n    2, as.numeric)), inverse = FALSE, reconPhases = NULL) \n  \n## Kime-Phase Distributions\n# Examine the Kime-direction Distributions of the Phases for all *Belgium* features (predictors + outcome). Define a generic function that plots the Phase distributions.\n# plotPhaseDistributions(dataFT, dataColnames)\nplotPhaseDistributions(FT_aggregate_arima_vector_country_ranking_df,\n                       colnames(aggregate_arima_vector_country_ranking_df), size=4, cex=0.1)\n\nIFT_FT_aggregate_arima_vector_country_ranking_df <- \n  kSpaceTransform(FT_aggregate_arima_vector_country_ranking_df$magnitudes, \n                  TRUE, FT_aggregate_arima_vector_country_ranking_df$phases)\n# Check IFT(FT) == I: \n# ifelse(aggregate_arima_vector_country_ranking_df[5,4] -\n#     Re(IFT_FT_aggregate_arima_vector_country_ranking_df[5,4]) < 0.001, \"Perfect Synthesis\", \"Problems!!!\")\n\n##############################################\n# Nil-Phase Synthesis and LASSO model estimation\n# 1. Nil-Phase data synthesis (reconstruction)\ntemp_Data <- aggregate_arima_vector_country_ranking_df\nnilPhase_FT_aggregate_arima_vector <- \n  array(complex(real=0, imaginary=0), c(dim(temp_Data)[1], dim(temp_Data)[2]))\ndim(nilPhase_FT_aggregate_arima_vector)    # ;  head(nilPhase_FT_aggregate_arima_vector)\n# [1] 31 387\nIFT_NilPhase_FT_aggregate_arima_vector <- array(complex(), c(dim(temp_Data)[1], dim(temp_Data)[2]))\n\n#       Invert back to spacetime the \n# FT_aggregate_arima_vector_country_ranking_df$magnitudes[ , i] signal with nil-phase\nIFT_NilPhase_FT_aggregate_arima_vector <- \n  Re(kSpaceTransform(FT_aggregate_arima_vector_country_ranking_df$magnitudes, \n                     TRUE, nilPhase_FT_aggregate_arima_vector))\n\ncolnames(IFT_NilPhase_FT_aggregate_arima_vector) <-\n  colnames(aggregate_arima_vector_country_ranking_df)\nrownames(IFT_NilPhase_FT_aggregate_arima_vector) <-\n  rownames(aggregate_arima_vector_country_ranking_df)\ndim(IFT_NilPhase_FT_aggregate_arima_vector)\ndim(FT_aggregate_arima_vector_country_ranking_df$magnitudes)\ncolnames(IFT_NilPhase_FT_aggregate_arima_vector)\n# IFT_NilPhase_FT_aggregate_arima_vector[1:5, 1:4];  temp_Data[1:5, 1:4]\n\n# 2. Perform LASSO modeling on IFT_NilPhase_FT_aggregate_arima_vector; \n# report param estimates and quality metrics AIC/BIC\n# library(forecast)\nset.seed(54321)\ncvLASSO_kime = cv.glmnet(data.matrix(IFT_NilPhase_FT_aggregate_arima_vector[ , -387]), \n           # IFT_NilPhase_FT_aggregate_arima_vector[ , 387], alpha = 1, parallel=TRUE)\n           Y, alpha = 1, parallel=TRUE)\nplot(cvLASSO_kime)\nmtext(\"(Spacekime, Nil-phase) CV LASSO: Number of Nonzero (Active) Coefficients\", \n      side=3, line=2.5)\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO_kime <-  predict(cvLASSO_kime, s = cvLASSO_kime$lambda.min, \n        newx = data.matrix(IFT_NilPhase_FT_aggregate_arima_vector[ , -387])); predLASSO_kime\n# testMSE_LASSO_kime <- mean((predLASSO_kime - IFT_NilPhase_FT_aggregate_arima_vector[ , 387])^2)\n# testMSE_LASSO_kime\npredLASSO_kime = predict(cvLASSO_kime, s = exp(1/3), # cvLASSO_kime$lambda.min, \n        newx = data.matrix(IFT_NilPhase_FT_aggregate_arima_vector[ , -387])); predLASSO_kime\n\n##################################Use only ARIMA effects, no SOCR meta-data#####\nset.seed(12345)\ncvLASSO_kime_lim = cv.glmnet(data.matrix(IFT_NilPhase_FT_aggregate_arima_vector[ , 1:(42*9)]), \n                        Y, alpha = 1, parallel=TRUE)\nplot(cvLASSO_kime_lim)\nmtext(\"CV LASSO Nil-Phase (using only Timeseries data): Number of Nonzero (Active) Coefficients\",\n      side=3, line=2.5)\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO_kime_lim <-  predict(cvLASSO_kime_lim, s = 1, \n                          newx = data.matrix(X[ , 1:(42*9)]))\ncoefList_kime_lim <- coef(cvLASSO_kime_lim, s=1)\ncoefList_kime_lim <- data.frame(coefList_kime_lim@Dimnames[[1]][coefList_kime_lim@i+1],coefList_kime_lim@x)\nnames(coefList_kime_lim) <- c('Feature','EffectSize')\narrange(coefList_kime_lim, -abs(EffectSize))[2:10, ]\ncor(Y, predLASSO_kime_lim[, 1])  # 0.1142824\n################################################################################\n\n# Plot Regression Coefficients: create variable names for plotting \nlibrary(\"arm\")\n# par(mar=c(2, 13, 1, 1))   # extra large left margin # par(mar=c(5,5,5,5))\n# varNames <- colnames(X); varNames; length(varNames)\n\nbetaHatLASSO_kime = as.double(coef(cvLASSO_kime, s=cvLASSO_kime$lambda.min))\n#cvLASSO_kime$lambda.1se\n\ncoefplot(betaHatLASSO_kime[377:386], sd = rep(0, 10), pch=0, cex.pts = 3, col=\"red\", \n         main = \"(Spacekime) LASSO-Regularized Regression Coefficient Estimates\",\n         varnames = varNames[377:386])\n\nvarImp(cvLASSO_kime, lambda = cvLASSO_kime$lambda.min)\n\ncoefList_kime <- coef(cvLASSO_kime, s=1)  # 'lambda.min')\ncoefList_kime <- data.frame(coefList_kime@Dimnames[[1]][coefList_kime@i+1], coefList_kime@x)\nnames(coefList_kime) <- c('Feature','EffectSize')\narrange(coefList_kime, -abs(EffectSize))[1:9, ]\n#                 Feature  EffectSize\n#1           (Intercept) 26.069326257\n#2 Feature_12_ArimaVec_8 -8.662856430\n#3 Feature_11_ArimaVec_4  8.585283751\n#4 Feature_12_ArimaVec_4 -5.023601842\n#5 Feature_30_ArimaVec_4  2.242157842\n#6 Feature_26_ArimaVec_6  1.760267216\n#7 Feature_39_ArimaVec_5 -1.256101950\n#8 Feature_34_ArimaVec_5 -1.148865337\n#9 Feature_37_ArimaVec_2  0.001322367\n#     ARIMA-spacetime:     4=non-seasonal MA, 5=seasonal AR, 8=non-seasonal Diff\n#     ARIMA-spacekimeNil:  2=forecast_avg, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA, 8=non-seasonal Diff\n#9 ARIMA-derived vector includes:\n# (1=ts_avg, 2=forecast_avg, 3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA, \n#  7=period, 8=non-seasonal Diff, 9=seasonal differences)\n\ncoef(cvLASSO_kime, s = 1/5) %>%  ### \"lambda.min\") %>%\n  broom::tidy() %>%\n  filter(row != \"(Intercept)\") %>%\n  top_n(100, wt = abs(value)) %>%\n  ggplot(aes(value, reorder(row, value), color = value > 0)) +\n  geom_point(show.legend = FALSE, aes(size = abs(value))) +\n  ggtitle(\"(Spacekime) Top 9 salient features (LASSO penalty)\") +\n  xlab(\"Effect-size\") +\n  ylab(NULL)\n\n# pack a 31*3 DF with (predLASSO_kime, IFT_NilPhase_FT_aggregate_arima_vector_Y, Y)\nvalidation_kime <- cbind(predLASSO_kime[, 1], \n                         IFT_NilPhase_FT_aggregate_arima_vector[ , 387], Y)  \ncolnames(validation_kime) <- c(\"predLASSO_kime\", \"IFT_NilPhase_FT_Y\", \"Orig_Y\")\nhead(validation_kime)\n\n# Prediction correlations: \ncor(validation_kime[ , 1], validation_kime[, 2])  # Y=predLASSO_kime OA rank vs. kime_LASSO_pred:  0.99\ncor(validation_kime[ , 1], validation_kime[, 3])  # Y=predLASSO_kime OA rank vs. Orig_Y:  0.64\n\n# Plot observed Y (Overall Country ranking) vs. LASSO (9-parameters) predicted Y^\nlinFit1_kime <- lm(predLASSO_kime ~ validation_kime[ , 3])\nplot(predLASSO_kime ~ validation_kime[ , 3],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"Observed Country Overall Ranking\", ylab=\"IFT_NilPhase predLASSO_kime\",\n     main = sprintf(\"Observed (x) vs. IFT_NilPhase Predicted (y) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_kime[ , 1], validation_kime[, 3])))\nabline(linFit1_kime, lwd=3, col=\"red\")\n# abline(linFit1, lwd=3, col=\"green\")\n\n\n##############################################\n# 3. Swap Feature Phases and then synthesize the data (reconstruction)\n# temp_Data <- aggregate_arima_vector_country_ranking_df\nswappedPhase_FT_aggregate_arima_vector <- FT_aggregate_arima_vector_country_ranking_df$phases\ndim(swappedPhase_FT_aggregate_arima_vector)    # ;  head(swappedPhase_FT_aggregate_arima_vector)\n# [1] 31 387\nIFT_SwappedPhase_FT_aggregate_arima_vector <- array(complex(), \n                          c(dim(temp_Data)[1], dim(temp_Data)[2]))\n\nset.seed(12345)   # sample randomly Phase-columns for each of the 131 covariates (X)\nswappedPhase_FT_aggregate_arima_vector1 <- as.data.frame(cbind(\n  swappedPhase_FT_aggregate_arima_vector[ , \n          sample(ncol(swappedPhase_FT_aggregate_arima_vector[ , 1:378]))],  # mix ARIMA signature phases\n  swappedPhase_FT_aggregate_arima_vector[ , \n          sample(ncol(swappedPhase_FT_aggregate_arima_vector[ , 379:386]))],# mix the meta-data phases\n  swappedPhase_FT_aggregate_arima_vector[ , 387]))                          # add correct Outcome phase\nswappedPhase_FT_aggregate_arima_vector <- swappedPhase_FT_aggregate_arima_vector1\n\ncolnames(swappedPhase_FT_aggregate_arima_vector) <- colnames(temp_Data)\ncolnames(swappedPhase_FT_aggregate_arima_vector); dim(swappedPhase_FT_aggregate_arima_vector)\n# 31 387\n\n#       Invert back to spacetime the \n# FT_aggregate_arima_vector$magnitudes[ , i] signal with swapped-X-phases (Y-phase is fixed)\nIFT_SwappedPhase_FT_aggregate_arima_vector <- \n  Re(kSpaceTransform(FT_aggregate_arima_vector_country_ranking_df$magnitudes, \n                     TRUE, swappedPhase_FT_aggregate_arima_vector))\n\ncolnames(IFT_SwappedPhase_FT_aggregate_arima_vector) <-\n  colnames(aggregate_arima_vector_country_ranking_df)\nrownames(IFT_SwappedPhase_FT_aggregate_arima_vector) <-\n  rownames(aggregate_arima_vector_country_ranking_df)\ndim(IFT_SwappedPhase_FT_aggregate_arima_vector)\ndim(FT_aggregate_arima_vector_country_ranking_df$magnitudes)\ncolnames(IFT_SwappedPhase_FT_aggregate_arima_vector)\n# IFT_SwappedPhase_FT_aggregate_arima_vector[1:5, 1:4];  temp_Data[1:5, 1:4]\n\n# 2. Perform LASSO modeling on IFT_SwappedPhase_FT_aggregate_arima_vector; \n# report param estimates and quality metrics AIC/BIC\nset.seed(12345)\ncvLASSO_kime_swapped = \n  cv.glmnet(data.matrix(IFT_SwappedPhase_FT_aggregate_arima_vector[ , -387]), \n           # IFT_SwappedPhase_FT_aggregate_arima_vector[ , 387], alpha = 1, parallel=TRUE)\n           Y, alpha = 1, parallel=TRUE)\nplot(cvLASSO_kime_swapped)\nmtext(\"(Spacekime, Swapped-Phases) CV LASSO: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n##################################Use only ARIMA effects, no SOCR meta-data#####\nset.seed(12345)\ncvLASSO_kime_swapped_lim = cv.glmnet(data.matrix(\n  IFT_SwappedPhase_FT_aggregate_arima_vector[ , 1:(42*9)]), Y, alpha = 1, parallel=TRUE)\nplot(cvLASSO_kime_swapped_lim)\nmtext(\"CV LASSO Swapped-Phase (using only Timeseries data): Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO_kime_swapped_lim <-  predict(cvLASSO_kime_swapped_lim, \n              s = cvLASSO_kime_swapped_lim$lambda.min, \n              newx = data.matrix(IFT_SwappedPhase_FT_aggregate_arima_vector[ , 1:(42*9)]))\ncoefList_kime_swapped_lim <- coef(cvLASSO_kime_swapped_lim, s='lambda.min')\ncoefList_kime_swapped_lim <- data.frame(coefList_kime_swapped_lim@Dimnames[[1]][coefList_kime_swapped_lim@i+1],coefList_kime_swapped_lim@x)\nnames(coefList_kime_swapped_lim) <- c('Feature','EffectSize')\narrange(coefList_kime_swapped_lim, -abs(EffectSize))[2:10, ]\ncor(Y, predLASSO_kime_swapped_lim[, 1])  # 0.86\n################################################################################\n\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO_kime_swapped <-  predict(cvLASSO_kime_swapped, s = cvLASSO_kime_swapped$lambda.min, \n        newx = data.matrix(IFT_SwappedPhase_FT_aggregate_arima_vector[ , -387]))\n# testMSE_LASSO_kime_swapped <- \n#        mean((predLASSO_kime_swapped - IFT_SwappedPhase_FT_aggregate_arima_vector[ , 387])^2)\n# testMSE_LASSO_kime_swapped\npredLASSO_kime_swapped = predict(cvLASSO_kime_swapped, s = 3, \n        newx = data.matrix(IFT_SwappedPhase_FT_aggregate_arima_vector[ , -387]))\npredLASSO_kime_swapped\n\n# Plot Regression Coefficients: create variable names for plotting \nbetaHatLASSO_kime_swapped = as.double(coef(cvLASSO_kime_swapped,\n                                           s=cvLASSO_kime_swapped$lambda.min))\n#cvLASSO_kime_swapped$lambda.1se\n\ncoefplot(betaHatLASSO_kime_swapped[377:386], sd = rep(0, 10), pch=0, cex.pts = 3, col=\"red\", \n         main = \"(Spacekime, Swapped-Phases) LASSO-Regularized Regression Coefficient Estimates\",\n         varnames = varNames[377:386])\n\nvarImp(cvLASSO_kime_swapped, lambda = cvLASSO_kime_swapped$lambda.min)\n\ncoefList_kime_swapped <- coef(cvLASSO_kime_swapped, s=3)    # 'lambda.min')\ncoefList_kime_swapped <- data.frame(coefList_kime_swapped@Dimnames[[1]][coefList_kime_swapped@i+1], coefList_kime_swapped@x)\nnames(coefList_kime_swapped) <- c('Feature','EffectSize')\narrange(coefList_kime_swapped, -abs(EffectSize))[2:10, ]\n#                 Feature  EffectSize\n#2  Feature_32_ArimaVec_6  3.3820076\n#3   Feature_1_ArimaVec_3  2.2133139\n#4  Feature_21_ArimaVec_4  1.5376447\n#5  Feature_22_ArimaVec_3  1.0546605\n#6  Feature_14_ArimaVec_5  0.7428693\n#7                     ED  0.6525794\n#8  Feature_24_ArimaVec_5  0.5987113\n#9  Feature_12_ArimaVec_5  0.3177650\n#10 Feature_37_ArimaVec_6  0.1598574\n#\n#     ARIMA-spacetime:        4=non-seasonal MA, 5=seasonal AR, 8=non-seasonal Diff\n#     ARIMA-spacekime_nill:   3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA\n#    ARIMA-spacekime_swapped: 3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA\n# 9 ARIMA-derived vector includes:\n# (1=ts_avg, 2=forecast_avg, 3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA, \n#  7=period, 8=non-seasonal Diff, 9=seasonal differences)\n\ncoef(cvLASSO_kime_swapped, s = 3) %>%  # \"lambda.min\") %>%\n  broom::tidy() %>%\n  filter(row != \"(Intercept)\") %>%\n  top_n(100, wt = abs(value)) %>%\n  ggplot(aes(value, reorder(row, value), color = value > 0)) +\n  geom_point(show.legend = FALSE, aes(size = abs(value))) +\n  ggtitle(\"(Spacekime, Swapped-Phases) Top 9 salient features (LASSO penalty)\") +\n  xlab(\"Effect-size\") +\n  ylab(NULL)\n\n# pack a 31*4 DF with (predLASSO_kime, IFT_NilPhase_FT_aggregate_arima_vector_Y, \n#                      IFT_SwappedPhase_FT_aggregate_arima_vector_Y, Y)\nvalidation_kime_swapped <- cbind(predLASSO_lim[, 1], \n                         predLASSO_kime[ , 1], predLASSO_kime_swapped[ , 1], Y)  \ncolnames(validation_kime_swapped) <- c(\"predLASSO (spacetime)\", \"predLASSO_IFT_NilPhase\",\n                               \"predLASSO_IFT_SwappedPhase\", \"Orig_Y\")\nhead(validation_kime_swapped); dim(validation_kime_swapped)\n\n# Prediction correlations: \ncor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])  \n# predLASSO_IFT_SwappedPhase OA rank vs. predLASSO_spacekime:  0.7\ncor(validation_kime_swapped[ , 1], validation_kime_swapped[, 3])  \n# predLASSO (spacetime) vs.  predLASSO_IFT_SwappedPhase OA rank:  0.83\n\n# Plot observed Y (Overall Country ranking) vs. LASSO (9-parameters) predicted Y^\nlinFit1_kime_swapped <- lm(validation_kime_swapped[ , 4] ~ predLASSO)\nplot(validation_kime_swapped[ , 4] ~ predLASSO,\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"predLASSO_spacekime Country Overall Ranking\", ylab=\"predLASSO_IFT_SwappedPhase_FT_Y\",\n     main = sprintf(\"Spacetime Predicted (x) vs. Kime IFT_SwappedPhase_FT_Y (y) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])))\nabline(linFit1_kime_swapped, lwd=3, col=\"red\")\n#abline(linFit1_kime, lwd=3, col=\"green\")\n\n# Plot Spacetime LASSO forecasting\n# Plot observed Y (Overall Country ranking) vs. LASSO (9-parameters) predicted Y^\nlinFit1_spacetime <- lm(validation_kime_swapped[ , 1] ~ validation_kime_swapped[ , 4])\nplot(validation_kime_swapped[ , 1] ~ validation_kime_swapped[ , 4],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"Observed Country Overall Ranking\", ylab=\"predLASSO_spacetime\",\n     main = sprintf(\"Spacetime Predicted (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_kime_swapped[ , 1], validation_kime_swapped[, 4])))\nabline(linFit1_spacetime, lwd=3, col=\"red\")\n\n# test with using swapped-phases LASSO estimates\nlinFit1_spacekime <- lm(validation_kime_swapped[ , 3] ~ validation_kime_swapped[ , 4])\nplot(validation_kime_swapped[ , 3] ~ validation_kime_swapped[ , 4],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"Observed Country Overall Ranking\", ylab=\"predLASSO_spacekime Swapped-Phases\",\n     main = sprintf(\"Spacekime Predicted, Swapped-Phases (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])))\nabline(linFit1_spacekime, lwd=3, col=\"red\")\n\n# add Top_30_Ranking_Indicator\nvalidation_kime_swapped <- as.data.frame(cbind(validation_kime_swapped, ifelse (validation_kime_swapped[,4]<=30, 1, 0)))\ncolnames(validation_kime_swapped)[5] <- \"Top30Rank\"\nhead(validation_kime_swapped)\n\nlibrary(\"ggrepel\")\n# Spacetime LASSO modeling\nmyPlotSpacetime <- ggplot(as.data.frame(validation_kime_swapped), aes(x=Orig_Y,\n            y=`predLASSO (spacetime)`, label=rownames(validation_kime_swapped))) +\n     geom_point() +\n     # Color by groups\n     # geom_text(aes(color=factor(rownames(validation_kime_swapped)))) +\n     geom_label_repel(aes(label = rownames(validation_kime_swapped),\n                    fill = factor(Top30Rank)), color = 'black', size = 5,  \n                    point.padding = unit(0.3, \"lines\")) +\n     # theme(legend.position = \"bottom\") +\n     theme(legend.position = c(0.1, 0.9), \n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\")) +\n     scale_fill_discrete(name = \"Country Overall Ranking\", \n                         labels = c(\"Below 30 Rank\", \"Top 30 Rank\")) +\n     labs(title=sprintf(\"Spacetime LASSO Prediction (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\",  cor(validation_kime_swapped[ , 1], validation_kime_swapped[, 4])),\n          x =\"Observed Overall Country Ranking (1 is 'best')\", \n          y = \"Spacetime LASSO Rank Forecasting\")\nmyPlotSpacetime\n\n# NIL-PHASE KIME reconstruction\nmyPlotNilPhase <- ggplot(as.data.frame(validation_kime_swapped), aes(x=Orig_Y,\n            y=predLASSO_kime, label=rownames(validation_kime_swapped))) +\n     geom_point() +\n     # Color by groups\n     # geom_text(aes(color=factor(rownames(validation_kime_swapped)))) +\n     geom_label_repel(aes(label = rownames(validation_kime_swapped),\n                    fill = factor(Top30Rank)), color = 'black', size = 5,  \n                    point.padding = unit(0.3, \"lines\")) +\n     # theme(legend.position = \"bottom\") +\n     theme(legend.position = c(0.1, 0.9), \n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\")) +\n     scale_fill_discrete(name = \"Country Overall Ranking\", \n                         labels = c(\"Below 30 Rank\", \"Top 30 Rank\")) +\n     labs(title=sprintf(\"Spacekime LASSO Predicted, Nil-Phases, (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\",  cor(validation_kime_swapped[ , 2], validation_kime_swapped[, 4])),\n          x =\"Observed Overall Country Ranking (1 is 'best')\", \n          y = \"Spacekime LASSO Predicted, using Nil-Phases\")\nmyPlotNilPhase\n\n# SWAPPED PHASE KIME reconstruction\nmyPlotSwappedPhase <- ggplot(as.data.frame(validation_kime_swapped), aes(x=Orig_Y,\n            y=predLASSO_kime_swapped, label=rownames(validation_kime_swapped))) +\n     geom_point() +\n     # Color by groups\n     # geom_text(aes(color=factor(rownames(validation_kime_swapped)))) +\n     geom_label_repel(aes(label = rownames(validation_kime_swapped),\n                    fill = factor(Top30Rank)), color = 'black', size = 5,  \n                    point.padding = unit(0.3, \"lines\")) +\n     # theme(legend.position = \"bottom\") +\n     theme(legend.position = c(0.1, 0.9), \n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\")) +\n     scale_fill_discrete(name = \"Country Overall Ranking\", \n                         labels = c(\"Below 30 Rank\", \"Top 30 Rank\")) +\n     labs(title=sprintf(\"Spacekime LASSO Predicted, Swapped-Phases, (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\",  cor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])),\n          x =\"Observed Overall Country Ranking (1 is 'best')\", \n          y = \"Spacekime LASSO Predicted, using Swapped-Phases\")\nmyPlotSwappedPhase\n\ncountryNames[11]<-\"Germany\"\naggregateResults <- (rbind(cbind(as.character(countryNames), \"predLASSO_spacetime\", as.numeric(predLASSO)), \n                           cbind(as.character(countryNames), \"predLASSO_lim\", predLASSO_lim),\n                           cbind(as.character(countryNames), \"predLASSO_nil\", predLASSO_kime),\n                           cbind(as.character(countryNames), \"predLASSO_swapped\", predLASSO_kime_swapped),\n                           cbind(as.character(countryNames), \"observed\", Y)\n                     ))\naggregateResults <- data.frame(aggregateResults[ , -3], as.numeric(aggregateResults[,3]))\ncolnames(aggregateResults) <- c(\"country\", \"estimate_method\", \"ranking\")\nggplot(aggregateResults, aes(x=country, y=ranking, color=estimate_method)) +\n  geom_point(aes(shape=estimate_method, color=estimate_method, size=estimate_method)) + geom_point(size = 5) +\n  geom_line(data = aggregateResults[aggregateResults$estimate_method == \"observed\", ], \n            aes(group = estimate_method), size=2, linetype = \"dashed\") +\n  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=.5)) +\n  # theme(legend.position = \"bottom\") +\n  # scale_shape_manual(values = as.factor(aggregateResults$estimate_method)) +\n  theme(text = element_text(size = 15), legend.position = c(0.3, 0.85), \n           axis.text=element_text(size=16),\n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\"))\n#  + scale_fill_discrete(\n#    name=\"Country Overall Ranking\",\n#    breaks=c(\"predLASSO_spacetime\", \"predLASSO_lim\", \"predLASSO_nil\", \"predLASSO_swapped\", \"observed\"),\n#    labels=c(sprintf(\"predLASSO_spacetime LASSO Predicted (386), cor=%.02f\",  cor(predLASSO, Y)),\n#             sprintf(\"predLASSO_lim LASSO Predicted (378), cor=%.02f\",  cor(predLASSO_lim, Y)), \n#             sprintf(\"predLASSO_nil (spacekime) LASSO Predicted, cor=%.02f\",  cor(predLASSO_kime, Y)), \n#             sprintf(\"predLASSO_swapped (spacekime) LASSO Predicted, cor=%.02f\",  cor(predLASSO_kime_swapped, Y)), \n#             \"observed\"))",
      "line_count": 414
    },
    {
      "section": "ML Data Analytics",
      "code": "# Plotting the coefficients\ncoef_plot <- function(betahat, varn, plotname) {\n  betahat<-betahat[-1]\n  P <- coefplot(betahat[which(betahat!=0)], sd = rep(0, length(betahat[which(betahat!=0)])), \n                pch=0, cex.pts = 3, col=\"red\", main = plotname, varnames = varn[which(betahat!=0)])\n  return(P)\n}\n\n# Plotting the coefficients for those two methods\nfindfeatures <- function(lassobeta, ridgebeta=NULL) {\n  lassobeta<-lassobeta[-1]\n  feat1 <- which(lassobeta!=0)\n  features <- feat1\n  if (!is.null(ridgebeta)) {\n    ridgebeta<-ridgebeta[-1]\n    feat2 <- order(abs(ridgebeta),decreasing = TRUE)[1:10]\n    features <- union(feat1, feat2)\n  }\n  return(features)\n}\n\nvarImp <- function(object, lambda = NULL, ...) {\n  ## skipping a few lines\n  beta <- predict(object, s = lambda, type = \"coef\")\n  if(is.list(beta)) {\n    out <- do.call(\"cbind\", lapply(beta, function(x) x[,1]))\n    out <- as.data.frame(out)\n    s <- rowSums(out)\n    out <- out[which(s)!=0,,drop=FALSE]\n  } else  {\n    out<-data.frame(Overall = beta[,1])\n    out<-out[which(out!=0),,drop=FALSE]\n  }\n  out <- abs(out[rownames(out) != \"(Intercept)\",,drop = FALSE])\n  out\n}",
      "line_count": 36
    },
    {
      "section": "ML Data Analytics",
      "code": "# 1. LASSO regression/feature extraction\nlibrary(glmnet)\nlibrary(arm)\nlibrary(knitr)\n# subset test data\nY = aggregate_arima_vector_country_ranking_df$OA\nX = aggregate_arima_vector_country_ranking_df[ , 1:378]\n# remove columns containing NAs\nX = X[ , colSums(is.na(X)) == 0]; dim(X)  # [1]  31 378\n\n#### 10-fold cross validation: for the LASSO\nlibrary(\"glmnet\")\nlibrary(doParallel)\nregisterDoParallel(6)\n\nset.seed(4321)\ncvLASSO_lim = cv.glmnet(data.matrix(X[ , 1:(42*9)]), Y, alpha = 1, parallel=TRUE)\nplot(cvLASSO_lim)\nmtext(\"CV LASSO (using only Timeseries data): Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO_lim <-  predict(cvLASSO_lim, s = 3, # cvLASSO_lim$lambda.min, \n                          newx = data.matrix(X[ , 1:(42*9)]))\ncoefList_lim <- coef(cvLASSO_lim, s=3) # 'lambda.min')\ncoefList_lim <- data.frame(coefList_lim@Dimnames[[1]][coefList_lim@i+1],coefList_lim@x)\nnames(coefList_lim) <- c('Feature','EffectSize')\narrange(coefList_lim, -abs(EffectSize))[2:10, ]\ncor(Y, predLASSO_lim[, 1])  # 0.84\n################################################################################\n\nvarImp(cvLASSO_lim, lambda = cvLASSO_lim$lambda.min)\n#2   Feature_1_ArimaVec_8 -2.3864299\n#3  Feature_19_ArimaVec_8  2.0871310\n#4  Feature_16_ArimaVec_3  2.0465254\n#5  Feature_13_ArimaVec_8 -1.7348553\n#6  Feature_15_ArimaVec_4 -1.4588173\n#7  Feature_22_ArimaVec_4 -1.1068801\n#8  Feature_25_ArimaVec_5  0.9336800\n#9  Feature_35_ArimaVec_4 -0.9276244\n#10 Feature_25_ArimaVec_4 -0.8486434\n\n#coefList_lim <- coef(cvLASSO_lim, s='lambda.min')\n#coefList_lim <- data.frame(coefList_lim@Dimnames[[1]][coefList_lim@i+1], coefList_lim@x)\n#names(coefList_lim) <- c('Feature','EffectSize')\n#arrange(coefList_lim, -abs(EffectSize))[2:10, ]\n#\n#      9 ARIMA-derived vector includes:\n# (1=ts_avg, 2=forecast_avg, 3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA, \n#  7=period, 8=non-seasonal Diff, 9=seasonal differences)\n\n# [1] \"Active population by sex, age and educational attainment level, Females, From 15 to 64 years, All ISCED 2011 levels\"                                                     \n# [2] \"Active population by sex, age and educational attainment level, Females, From 15 to 64 years, Less than primary, primary and lower secondary education (levels 0-2)\"     \n# [3] \"Active population by sex, age and educational attainment level, Females, From 15 to 64 years, Tertiary education (levels 5-8)\"                                           \n# [4] \"Active population by sex, age and educational attainment level, Females, From 15 to 64 years, Upper secondary and post-secondary non-tertiary education (levels 3 and 4)\"\n# [5] \"Active population by sex, age and educational attainment level, Males, From 15 to 64 years, All ISCED 2011 levels\"                                                       \n# [6] \"Active population by sex, age and educational attainment level, Males, From 15 to 64 years, Less than primary, primary and lower secondary education (levels 0-2)\"       \n# [7] \"Active population by sex, age and educational attainment level, Males, From 15 to 64 years, Tertiary education (levels 5-8)\"                                             \n# [8] \"Active population by sex, age and educational attainment level, Males, From 15 to 64 years, Upper secondary and post-secondary non-tertiary education (levels 3 and 4)\"  \n# [9] \"Active population by sex, age and educational attainment level, Total, From 15 to 64 years, All ISCED 2011 levels\"  \n#[10] \"Active population by sex, age and educational attainment level, Total, From 15 to 64 years, Less than primary, primary and lower secondary education (levels 0-2)\" \n#[11] \"Active population by sex, age and educational attainment level, Total, From 15 to 64 years, Tertiary education (levels 5-8)\"        \n#[12] \"Active population by sex, age and educational attainment level, Total, From 15 to 64 years, Upper secondary and post-secondary non-tertiary education (levels 3 and 4)\"\n#[13] \"All ISCED 2011 levels \" \n# [14] \"All ISCED 2011 levels, Females\"  \n# [15] \"All ISCED 2011 levels, Males\"\n# [16] \"Capital transfers, payable\"  \n# [17] \"Capital transfers, receivable\"  \n# [18] \"Compensation of employees, payable\"  \n# [19] \"Current taxes on income, wealth, etc., receivable\"\n#[20] \"Employment by sex, age and educational attainment level, Females, From 15 to 64 years, All ISCED 2011 levels \" \n# [21] \"Employment by sex, age and educational attainment level, Females, From 15 to 64 years, Less than primary, primary and lower secondary education (levels 0-2)\"            \n# [22] \"Other current transfers, payable\"\n# [23] \"Other current transfers, receivable\" \n# [24] \"Property income, payable\" \n# [25] \"Property income, receivable\" \n# [26] \"Savings, gross\" \n# [27] \"Subsidies, payable\"\n# [28] \"Taxes on production and imports, receivable\"\n# [29] \"Total general government expenditure\"\n# [30] \"Total general government revenue\"\n# [31] \"Unemployment , Females, From 15-64 years, Total\"\n# [32] \"Unemployment , Males, From 15-64 years\" \n# [33] \"Unemployment , Males, From 15-64 years, from 1 to 2 months\" \n# [34] \"Unemployment , Males, From 15-64 years, from 3 to 5 months\"\n# [35] \"Unemployment , Males, From 15-64 years, from 6 to 11 months\"  \n# [36] \"Unemployment , Total, From 15-64 years, From 1 to 2 months\"\n# [37] \"Unemployment , Total, From 15-64 years, From 12 to 17 months\"\n# [38] \"Unemployment , Total, From 15-64 years, From 3 to 5 months\" \n# [39] \"Unemployment , Total, From 15-64 years, From 6 to 11 months\"  \n# [40] \"Unemployment , Total, From 15-64 years, Less than 1 month\" \n# [41] \"Unemployment by sex, age, duration. DurationNA not started\"\n# [42] \"VAT, receivable\"   \n\ncoef(cvLASSO_lim, s = 3) %>%  # \"lambda.min\"\n  broom::tidy() %>%\n  filter(row != \"(Intercept)\") %>%\n  top_n(100, wt = abs(value)) %>%\n  ggplot(aes(value, reorder(row, value), color = value > 0)) +\n  geom_point(show.legend = FALSE, aes(size = abs(value))) +\n  ggtitle(\"Top 9 salient features (LASSO penalty)\") +\n  xlab(\"Effect-size\") +\n  ylab(NULL)\n\nvalidation_lim <- data.frame(matrix(NA, nrow = dim(predLASSO_lim)[1], ncol=2), row.names=countryNames)\nvalidation_lim [ , 1] <- Y; validation_lim[ , 2] <- predLASSO_lim[, 1]\ncolnames(validation_lim) <- c(\"Orig_Y\", \"LASSO\")\ndim(validation_lim); head(validation_lim)\n\n# add Top_30_Ranking_Indicator\nvalidation_lim <- as.data.frame(cbind(validation_lim, ifelse (validation_lim[, 1]<=30, 1, 0)))\ncolnames(validation_lim)[3] <- \"Top30Rank\"\nhead(validation_lim)\n\n# Prediction correlations: \ncor(validation_lim[ , 1], validation_lim[, 2])  # Y=observed OA rank vs. LASSO-pred  0.98 (lim) 0.84\n\n# Plot observed Y (Overall Country ranking) vs. LASSO (9-parameters) predicted Y^\nlinFit_lim <- lm(validation_lim[ , 1] ~ validation_lim[, 2])\nplot(validation_lim[ , 1] ~ validation_lim[, 2],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"Observed Country Overall Ranking\", ylab=\"LASSO (42*9 +8) param model\",\n     main = sprintf(\"Observed (X) vs. LASSO-Predicted (Y) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_lim[ , 1], validation_lim[, 2])))\nabline(linFit_lim, lwd=3, col=\"red\")\n\n# Plot\nmyPlot <- ggplot(as.data.frame(validation_lim), aes(x=validation_lim[ , 1],\n            y=validation_lim[ , 2], label=rownames(validation_lim))) +\n     geom_smooth(method='lm') +\n     geom_point() +\n     # Color by groups\n     # geom_text(aes(color=factor(rownames(validation_lim)))) +\n     geom_label_repel(aes(label = rownames(validation_lim),\n                    fill = factor(Top30Rank)), color = 'black', size = 5,  \n                    point.padding = unit(0.3, \"lines\")) +\n     # theme(legend.position = \"bottom\") +\n     theme(legend.position = c(0.1, 0.9), \n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\")) +\n     scale_fill_discrete(name = \"Country Overall Ranking\", \n                         labels = c(\"Below 30 Rank\", \"Top 30 Rank\")) +\n     labs(title=sprintf(\"Spacetime LASSO Predicted (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\",  cor(validation_lim[ , 1], validation_lim[, 2])),\n          x =\"Observed Overall Country Ranking (1 is 'best')\", \n          y = \"Spacetime LASSO Predicted\")\nmyPlot",
      "line_count": 145
    },
    {
      "section": "ML Data Analytics",
      "code": "# Generic function to Transform Data ={all predictors (X) and outcome (Y)} to k-space (Fourier domain): kSpaceTransform(data, inverse = FALSE, reconPhases = NULL) \n  # ForwardFT (rawData, FALSE, NULL)\n  # InverseFT(magnitudes, TRUE, reconPhasesToUse) or InverseFT(FT_data, TRUE, NULL)\n# DATA\n# subset test data\naggregate_arima_vector_country_ranking_df <- as.data.frame(apply(\n    aggregate_arima_vector_country_ranking_df[ , colSums(is.na(aggregate_arima_vector_country_ranking_df)) == 0], \n    2, as.numeric))\n\nY = aggregate_arima_vector_country_ranking_df$OA\nX = aggregate_arima_vector_country_ranking_df[ , 1:378]\n# remove columns containing NAs\n# X = X[ , colSums(is.na(X)) == 0]; dim(X)  # [1]  31 386\nlength(Y); dim(X)\n\nFT_aggregate_arima_vector_country_ranking_df <- \n  kSpaceTransform(aggregate_arima_vector_country_ranking_df, inverse = FALSE, reconPhases = NULL) \n  \n## Kime-Phase Distributions\n# Examine the Kime-direction Distributions of the Phases for all *Belgium* features (predictors + outcome). Define a generic function that plots the Phase distributions.\n# plotPhaseDistributions(dataFT, dataColnames)\nplotPhaseDistributions(FT_aggregate_arima_vector_country_ranking_df,\n                       colnames(aggregate_arima_vector_country_ranking_df), size=4, cex=0.1)\n\nIFT_FT_aggregate_arima_vector_country_ranking_df <- \n  kSpaceTransform(FT_aggregate_arima_vector_country_ranking_df$magnitudes, \n                  TRUE, FT_aggregate_arima_vector_country_ranking_df$phases)\n# Check IFT(FT) == I: \n# ifelse(aggregate_arima_vector_country_ranking_df[5,4] -\n#     Re(IFT_FT_aggregate_arima_vector_country_ranking_df[5,4]) < 0.001, \"Perfect Synthesis\", \"Problems!!!\")\n\n##############################################\n# Nil-Phase Synthesis and LASSO model estimation\n# 1. Nil-Phase data synthesis (reconstruction)\ntemp_Data <- aggregate_arima_vector_country_ranking_df\nnilPhase_FT_aggregate_arima_vector <- \n  array(complex(real=0, imaginary=0), c(dim(temp_Data)[1], dim(temp_Data)[2]))\ndim(nilPhase_FT_aggregate_arima_vector)    # ;  head(nilPhase_FT_aggregate_arima_vector)\n# [1] 31 387\nIFT_NilPhase_FT_aggregate_arima_vector <- array(complex(), c(dim(temp_Data)[1], dim(temp_Data)[2]))\n\n#       Invert back to spacetime the \n# FT_aggregate_arima_vector_country_ranking_df$magnitudes[ , i] signal with nil-phase\nIFT_NilPhase_FT_aggregate_arima_vector <- \n  Re(kSpaceTransform(FT_aggregate_arima_vector_country_ranking_df$magnitudes, \n                     TRUE, nilPhase_FT_aggregate_arima_vector))\n\ncolnames(IFT_NilPhase_FT_aggregate_arima_vector) <-\n  colnames(aggregate_arima_vector_country_ranking_df)\nrownames(IFT_NilPhase_FT_aggregate_arima_vector) <-\n  rownames(aggregate_arima_vector_country_ranking_df)\ndim(IFT_NilPhase_FT_aggregate_arima_vector)\ndim(FT_aggregate_arima_vector_country_ranking_df$magnitudes)\ncolnames(IFT_NilPhase_FT_aggregate_arima_vector)\n# IFT_NilPhase_FT_aggregate_arima_vector[1:5, 1:4];  temp_Data[1:5, 1:4]\n\n# 2. Perform LASSO modeling on IFT_NilPhase_FT_aggregate_arima_vector; \n# report param estimates and quality metrics AIC/BIC\n# library(forecast)\nset.seed(123)\ncvLASSO_nil_kime = cv.glmnet(data.matrix(IFT_NilPhase_FT_aggregate_arima_vector[ , 1:378]), \n           # IFT_NilPhase_FT_aggregate_arima_vector[ , 387], alpha = 1, parallel=TRUE)\n           Y, alpha = 1, parallel=TRUE)\nplot(cvLASSO_nil_kime)\nmtext(\"(Spacekime, Nil-phase) CV LASSO: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO_nil_kime <-  predict(cvLASSO_nil_kime, s = cvLASSO_nil_kime$lambda.min, \n        newx = data.matrix(IFT_NilPhase_FT_aggregate_arima_vector[ , 1:378])); predLASSO_nil_kime\n# testMSE_LASSO_nil_kime <- mean((predLASSO_nil_kime - IFT_NilPhase_FT_aggregate_arima_vector[ , 387])^2)\n# testMSE_LASSO_nil_kime\n\n# Plot Regression Coefficients: create variable names for plotting \nlibrary(\"arm\")\n# par(mar=c(2, 13, 1, 1))   # extra large left margin # par(mar=c(5,5,5,5))\n# varNames <- colnames(X); varNames; length(varNames)\n#betaHatLASSO_kime = as.double(coef(cvLASSO_kime, s=cvLASSO_kime$lambda.min))\n#cvLASSO_kime$lambda.1se\n#\n#coefplot(betaHatLASSO_kime[377:386], sd = rep(0, 10), pch=0, cex.pts = 3, col=\"red\", \n#         main = \"(Spacekime) LASSO-Regularized Regression Coefficient Estimates\",\n#         varnames = varNames[377:386])\n\nvarImp(cvLASSO_nil_kime, lambda = cvLASSO_nil_kime$lambda.min)\n\ncoefList_nil_kime <- coef(cvLASSO_nil_kime, s='lambda.min')\ncoefList_nil_kime <- data.frame(coefList_nil_kime@Dimnames[[1]][coefList_nil_kime@i+1], coefList_nil_kime@x)\nnames(coefList_nil_kime) <- c('Feature','EffectSize')\narrange(coefList_nil_kime, -abs(EffectSize))[1:9, ]\n#                 Feature  EffectSize\n#1           (Intercept) 26.385520159\n#2 Feature_12_ArimaVec_8 -9.312528495\n#3 Feature_11_ArimaVec_4  8.561417371\n#4 Feature_12_ArimaVec_4 -5.220797416\n#5 Feature_30_ArimaVec_4  2.623218791\n#6 Feature_26_ArimaVec_6  1.927773213\n#7 Feature_39_ArimaVec_5 -1.534741402\n#8 Feature_34_ArimaVec_5 -1.171720008\n#9 Feature_37_ArimaVec_2  0.004213823\n#     ARIMA-spacetime:     4=non-seasonal MA, 5=seasonal AR, 8=non-seasonal Diff\n#     ARIMA-spacekimeNil:  2=forecast_avg, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA, 8=non-seasonal Diff\n#9 ARIMA-derived vector includes:\n# (1=ts_avg, 2=forecast_avg, 3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA, \n#  7=period, 8=non-seasonal Diff, 9=seasonal differences)\n\ncoef(cvLASSO_nil_kime, s = \"lambda.min\") %>%\n  broom::tidy() %>%\n  filter(row != \"(Intercept)\") %>%\n  top_n(100, wt = abs(value)) %>%\n  ggplot(aes(value, reorder(row, value), color = value > 0)) +\n  geom_point(show.legend = FALSE, aes(size = abs(value))) +\n  ggtitle(\"(Spacekime) Top 9 salient features (LASSO penalty)\") +\n  xlab(\"Effect-size\") +\n  ylab(NULL)\n\n# pack a 31*3 DF with (predLASSO_kime, IFT_NilPhase_FT_aggregate_arima_vector_Y, Y)\nvalidation_nil_kime <- cbind(predLASSO_nil_kime[, 1], \n                         IFT_NilPhase_FT_aggregate_arima_vector[ , 387], Y)  \ncolnames(validation_nil_kime) <- c(\"predLASSO_kime\", \"IFT_NilPhase_FT_Y\", \"Orig_Y\")\nrownames(validation_nil_kime)[11] <- \"Germany\"\nhead(validation_nil_kime)\n\nvalidation_nil_kime <- as.data.frame(cbind(validation_nil_kime, ifelse (validation_nil_kime[,3]<=30, 1, 0)))\ncolnames(validation_nil_kime)[4] <- \"Top30Rank\"\nhead(validation_nil_kime)\n\n# Prediction correlations: \n# cor(validation_nil_kime[ , 1], validation_nil_kime[, 2])  # Y=predLASSO_kime OA rank vs. kime_LASSO_pred:  0.99\ncor(validation_nil_kime[ , 1], validation_nil_kime[, 3])  # Y=predLASSO_kime OA rank vs. Orig_Y:  0.64\n\n# Plot observed Y (Overall Country ranking) vs. LASSO (9-parameters) predicted Y^\nlinFit1_nil_kime <- lm(predLASSO_nil_kime ~ validation_nil_kime[ , 3])\nplot(predLASSO_nil_kime ~ validation_nil_kime[ , 3],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"Observed Country Overall Ranking\", ylab=\"IFT_NilPhase predLASSO_kime\",\n     main = sprintf(\"Observed (x) vs. IFT_NilPhase Predicted (y) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_nil_kime[ , 1], validation_nil_kime[, 3])))\nabline(linFit1_kime, lwd=3, col=\"red\")\n# abline(linFit1, lwd=3, col=\"green\")\n\n# Spacetime LASSO modeling\nmyPlotNilPhase <- ggplot(as.data.frame(validation_nil_kime), aes(x=Orig_Y,\n            y=predLASSO_nil_kime, label=rownames(validation_nil_kime))) +\n     geom_smooth(method='lm') +\n     geom_point() +\n     # Color by groups\n     # geom_text(aes(color=factor(rownames(validation_nil_kime)))) +\n     geom_label_repel(aes(label = rownames(validation_nil_kime),\n                    fill = factor(Top30Rank)), color = 'black', size = 5,  \n                    point.padding = unit(0.3, \"lines\")) +\n     # theme(legend.position = \"bottom\") +\n     theme(legend.position = c(0.1, 0.9), \n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\")) +\n     scale_fill_discrete(name = \"Country Overall Ranking\", \n                         labels = c(\"Below 30 Rank\", \"Top 30 Rank\")) +\n     labs(title=sprintf(\"Spacekime LASSO Predicted, Nil-Phases (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\",  cor(validation_nil_kime[ , 1], validation_nil_kime[, 3])),\n          x =\"Observed Overall Country Ranking (1 is 'best')\", \n          y = \"Spacekime LASSO Predicted, using Nil-Phases\")\nmyPlotNilPhase",
      "line_count": 160
    },
    {
      "section": "ML Data Analytics",
      "code": "# temp_Data <- aggregate_arima_vector_country_ranking_df\nswappedPhase_FT_aggregate_arima_vector <- FT_aggregate_arima_vector_country_ranking_df$phases\ndim(swappedPhase_FT_aggregate_arima_vector)    # ;  head(swappedPhase_FT_aggregate_arima_vector)\n# [1] 31 387\nIFT_SwappedPhase_FT_aggregate_arima_vector <- array(complex(), c(dim(temp_Data)[1], dim(temp_Data)[2]))\n\nset.seed(12345)   # sample randomly Phase-columns for each of the 131 covariates (X)\nswappedPhase_FT_aggregate_arima_vector1 <- as.data.frame(cbind(\n  swappedPhase_FT_aggregate_arima_vector[ , \n          sample(ncol(swappedPhase_FT_aggregate_arima_vector[ , 1:378]))],  # mix ARIMA signature phases\n  swappedPhase_FT_aggregate_arima_vector[ , \n          sample(ncol(swappedPhase_FT_aggregate_arima_vector[ , 379:386]))],# mix the meta-data phases\n  swappedPhase_FT_aggregate_arima_vector[ , 387]))                          # add correct Outcome phase\nswappedPhase_FT_aggregate_arima_vector <- swappedPhase_FT_aggregate_arima_vector1\n\ncolnames(swappedPhase_FT_aggregate_arima_vector) <- colnames(temp_Data)\ncolnames(swappedPhase_FT_aggregate_arima_vector); dim(swappedPhase_FT_aggregate_arima_vector)\n# 31 387\n\n#       Invert back to spacetime the \n# FT_aggregate_arima_vector$magnitudes[ , i] signal with swapped-X-phases (Y-phase is fixed)\nIFT_SwappedPhase_FT_aggregate_arima_vector <- \n  Re(kSpaceTransform(FT_aggregate_arima_vector_country_ranking_df$magnitudes, \n                     TRUE, swappedPhase_FT_aggregate_arima_vector))\n\ncolnames(IFT_SwappedPhase_FT_aggregate_arima_vector) <-\n  colnames(aggregate_arima_vector_country_ranking_df)\nrownames(IFT_SwappedPhase_FT_aggregate_arima_vector) <-\n  rownames(aggregate_arima_vector_country_ranking_df)\ndim(IFT_SwappedPhase_FT_aggregate_arima_vector)\ndim(FT_aggregate_arima_vector_country_ranking_df$magnitudes)\ncolnames(IFT_SwappedPhase_FT_aggregate_arima_vector)\n# IFT_SwappedPhase_FT_aggregate_arima_vector[1:5, 1:4];  temp_Data[1:5, 1:4]\n\n# 2. Perform LASSO modeling on IFT_SwappedPhase_FT_aggregate_arima_vector; \n# report param estimates and quality metrics AIC/BIC\nset.seed(12)\ncvLASSO_kime_swapped = \n  cv.glmnet(data.matrix(IFT_SwappedPhase_FT_aggregate_arima_vector[ , 1:378]), \n           # IFT_SwappedPhase_FT_aggregate_arima_vector[ , 387], alpha = 1, parallel=TRUE)\n           Y, alpha = 1, parallel=TRUE)\nplot(cvLASSO_kime_swapped)\nmtext(\"(Spacekime, Swapped-Phases) CV LASSO: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO_kime_swapped <-  predict(cvLASSO_kime_swapped, s = 3,    # cvLASSO_kime_swapped$lambda.min, \n        newx = data.matrix(IFT_SwappedPhase_FT_aggregate_arima_vector[ , 1:378]))\n# testMSE_LASSO_kime_swapped <- \n#        mean((predLASSO_kime_swapped - IFT_SwappedPhase_FT_aggregate_arima_vector[ , 387])^2)\n# testMSE_LASSO_kime_swapped\npredLASSO_kime_swapped\n\n# Plot Regression Coefficients: create variable names for plotting \nbetaHatLASSO_kime_swapped = as.double(coef(cvLASSO_kime_swapped,\n                   s=3))   # cvLASSO_kime_swapped$lambda.min))\n#cvLASSO_kime_swapped$lambda.1se\n#coefplot(betaHatLASSO_kime_swapped[377:386], sd = rep(0, 10), pch=0, cex.pts = 3, col=\"red\", \n#         main = \"(Spacekime, Swapped-Phases) LASSO-Regularized Regression Coefficient Estimates\",\n#         varnames = varNames[377:386])\nvarImp(cvLASSO_kime_swapped, lambda = 3)  #cvLASSO_kime_swapped$lambda.min)\n\ncoefList_kime_swapped <- coef(cvLASSO_kime_swapped, s=3)    # 'lambda.min')\ncoefList_kime_swapped <- data.frame(coefList_kime_swapped@Dimnames[[1]][coefList_kime_swapped@i+1], coefList_kime_swapped@x)\nnames(coefList_kime_swapped) <- c('Feature','EffectSize')\narrange(coefList_kime_swapped, -abs(EffectSize))[2:10, ]\n#                 Feature  EffectSize\n#2   Feature_3_ArimaVec_8  5.4414240889\n#3  Feature_24_ArimaVec_5 -4.9895032906\n#4  Feature_41_ArimaVec_6  1.7580440109\n#5   Feature_7_ArimaVec_6 -1.6317407164\n#6  Feature_41_ArimaVec_3 -0.4666980893\n#7  Feature_42_ArimaVec_3  0.4100416326\n#8   Feature_6_ArimaVec_3 -0.2052325091\n#9   Feature_7_ArimaVec_1 -0.0007922646\n#10 Feature_24_ArimaVec_1 -0.0002003192\n#\n#     ARIMA-spacetime:        4=non-seasonal MA, 5=seasonal AR, 8=non-seasonal Diff\n#     ARIMA-spacekime_nill:   3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA\n#    ARIMA-spacekime_swapped: 3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA\n# 9 ARIMA-derived vector includes:\n# (1=ts_avg, 2=forecast_avg, 3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA, \n#  7=period, 8=non-seasonal Diff, 9=seasonal differences)\n\ncoef(cvLASSO_kime_swapped, s = 3) %>%  # \"lambda.min\") %>%\n  broom::tidy() %>%\n  filter(row != \"(Intercept)\") %>%\n  top_n(100, wt = abs(value)) %>%\n  ggplot(aes(value, reorder(row, value), color = value > 0)) +\n  geom_point(show.legend = FALSE, aes(size = abs(value))) +\n  ggtitle(\"(Spacekime, Swapped-Phases) Top 9 salient features (LASSO penalty)\") +\n  xlab(\"Effect-size\") +\n  ylab(NULL)\n\n# pack a 31*4 DF with (predLASSO_kime, IFT_NilPhase_FT_aggregate_arima_vector_Y, \n#                      IFT_SwappedPhase_FT_aggregate_arima_vector_Y, Y)\nvalidation_kime_swapped <- cbind(predLASSO_lim[, 1], predLASSO_nil_kime[, 1], \n                         predLASSO_kime_swapped[ , 1], Y)  \ncolnames(validation_kime_swapped) <- c(\"predLASSO (spacetime)\", \"predLASSO_IFT_NilPhase\",\n                               \"predLASSO_IFT_SwappedPhase\", \"Orig_Y\")\nhead(validation_kime_swapped); dim(validation_kime_swapped)\n\n# Prediction correlations: \ncor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])  \n# predLASSO_IFT_SwappedPhase OA rank vs. predLASSO_spacekime:  0.7\ncor(validation_kime_swapped[ , 1], validation_kime_swapped[, 3])  \n# predLASSO (spacetime) vs.  predLASSO_IFT_SwappedPhase OA rank:  0.83\n\n# Plot observed Y (Overall Country ranking), x-axis vs. Kime-Swapped LASSO (9-parameters) predicted Y^\nlinFit1_kime_swapped <- lm(validation_kime_swapped[ , 3] ~ validation_kime_swapped[ , 4])\nplot(validation_kime_swapped[ , 3] ~ validation_kime_swapped[ , 4],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"predLASSO_IFT_SwappedPhase_FT_Y\", ylab=\"predLASSO_spacekime_swapped Country Overall Ranking\",\n     main = sprintf(\"Observed (x) vs. Kime IFT_SwappedPhase_FT_Y (y) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])))\nabline(linFit1_kime_swapped, lwd=3, col=\"red\")\n#abline(linFit1_kime, lwd=3, col=\"green\")\n\n# Plot Spacetime LASSO forecasting\n# Plot observed Y (Overall Country ranking), x-axis vs. LASSO (9-parameters) predicted Y^, y-axis\nlinFit1_spacetime <- lm(validation_kime_swapped[ , 3] ~ validation_kime_swapped[ , 4])\nplot(validation_kime_swapped[ , 3] ~ validation_kime_swapped[ , 4],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"Observed Country Overall Ranking\", ylab=\"predLASSO_spacetime\",\n     main = sprintf(\"Predicted (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])))\nabline(linFit1_spacetime, lwd=3, col=\"red\")\n\n# add Top_30_Ranking_Indicator\nvalidation_kime_swapped <- as.data.frame(cbind(validation_kime_swapped, ifelse (validation_kime_swapped[,4]<=30, 1, 0)))\ncolnames(validation_kime_swapped)[5] <- \"Top30Rank\"\nrownames(validation_kime_swapped)[11] <- \"Germany\"\nhead(validation_kime_swapped)\n\n# Spacetime LASSO modeling\nmyPlotSwappedPhase <- ggplot(as.data.frame(validation_kime_swapped), aes(x=Orig_Y,\n            y=validation_kime_swapped[, 3], label=rownames(validation_kime_swapped))) +\n     geom_smooth(method='lm') +\n     geom_point() +\n     # Color by groups\n     # geom_text(aes(color=factor(rownames(validation_kime_swapped)))) +\n     geom_label_repel(aes(label = rownames(validation_kime_swapped),\n                    fill = factor(Top30Rank)), color = 'black', size = 5,  \n                    point.padding = unit(0.3, \"lines\")) +\n     # theme(legend.position = \"bottom\") +\n     theme(legend.position = c(0.1, 0.9), \n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\")) +\n     scale_fill_discrete(name = \"Country Overall Ranking\", \n                         labels = c(\"Below 30 Rank\", \"Top 30 Rank\")) +\n     labs(title=sprintf(\"Spacekime LASSO Predicted, Swapped-Phases (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\",  cor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])),\n          x =\"Observed Overall Country Ranking (1 is 'best')\", \n          y = \"Spacekime LASSO Predicted, using Swapped-Phases\")\nmyPlotSwappedPhase",
      "line_count": 153
    },
    {
      "section": "ML Data Analytics",
      "code": "# 1. LASSO regression/feature extraction\nlibrary(glmnet)\nlibrary(arm)\nlibrary(knitr)\n# subset test data\nY = aggregate_arima_vector_country_ranking_df$OA\nX = aggregate_arima_vector_country_ranking_df[ , 1:386]\n# remove columns containing NAs\nX = X[ , colSums(is.na(X)) == 0]; dim(X)  # [1]  31 378\n\n#### 10-fold cross validation: for the LASSO\nset.seed(4321)\ncvLASSO_lim_all = cv.glmnet(data.matrix(X), Y, alpha = 1, parallel=TRUE)\nplot(cvLASSO_lim)\nmtext(\"CV LASSO (using only Timeseries data): Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO_lim_all <-  predict(cvLASSO_lim_all, s = 1.1,  # cvLASSO_lim$lambda.min, \n                          newx = data.matrix(X))\ncoefList_lim_all <- coef(cvLASSO_lim_all, s='lambda.min')\ncoefList_lim_all <- data.frame(coefList_lim_all@Dimnames[[1]][coefList_lim_all@i+1],coefList_lim_all@x)\nnames(coefList_lim_all) <- c('Feature','EffectSize')\narrange(coefList_lim_all, -abs(EffectSize))[2:10, ]\ncor(Y, predLASSO_lim_all[, 1])  # 0.9974121\n\nvarImp(cvLASSO_lim_all, lambda = 1.1) # cvLASSO_lim_all$lambda.min)\n#Feature_1_ArimaVec_8  2.7518241\n#Feature_9_ArimaVec_4  0.2662136\n#Feature_9_ArimaVec_8  1.0871240\n#Feature_20_ArimaVec_8 1.6851990\n#Feature_25_ArimaVec_5 0.5113345\n#IncomeGroup           1.1787811\n#ED                    0.7508295\n#QOL                   0.2057181\n#PE                    0.5131427\n\ncoef(cvLASSO_lim_all, s = 1.1) %>%  #\"lambda.min\") %>%\n  broom::tidy() %>%\n  filter(row != \"(Intercept)\") %>%\n  top_n(100, wt = abs(value)) %>%\n  ggplot(aes(value, reorder(row, value), color = value > 0)) +\n  geom_point(show.legend = FALSE, aes(size = abs(value))) +\n  ggtitle(\"Top 9 salient features (LASSO penalty)\") +\n  xlab(\"Effect-size\") +\n  ylab(NULL)\n\ncountryNames[11] <- \"Germany\"\nvalidation_lim_all <- data.frame(matrix(NA, nrow = dim(predLASSO_lim_all)[1], ncol=2), row.names=countryNames)\nvalidation_lim_all [ , 1] <- Y; validation_lim_all[ , 2] <- predLASSO_lim_all[, 1]\ncolnames(validation_lim_all) <- c(\"Orig_Y\", \"LASSO\")\ndim(validation_lim_all); head(validation_lim_all)\n\n# add Top_30_Ranking_Indicator\nvalidation_lim_all <- as.data.frame(cbind(validation_lim_all, ifelse (validation_lim_all[, 1]<=30, 1, 0)))\ncolnames(validation_lim_all)[3] <- \"Top30Rank\"\nhead(validation_lim_all)\n\n# Prediction correlations: \ncor(validation_lim_all[ , 1], validation_lim_all[, 2])  # Y=observed OA rank vs. LASSO-pred  0.98 (lim) 0.84\n\n# Plot observed Y (Overall Country ranking) vs. LASSO (9-parameters) predicted Y^\nlinFit_lim_all <- lm(validation_lim_all[ , 1] ~ validation_lim_all[, 2])\nplot(validation_lim_all[ , 1] ~ validation_lim_all[, 2],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"Observed Country Overall Ranking\", ylab=\"LASSO (42*9 +8) param model\",\n     main = sprintf(\"Observed (X) vs. LASSO-Predicted (Y) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_lim_all[ , 1], validation_lim_all[, 2])))\nabline(linFit_lim_all, lwd=3, col=\"red\")\n\n# Plot\nmyPlot_all <- ggplot(as.data.frame(validation_lim_all), aes(x=validation_lim_all[ , 1],\n            y=validation_lim_all[ , 2], label=rownames(validation_lim_all))) +\n     geom_smooth(method='lm') +\n     geom_point() +\n     # Color by groups\n     # geom_text(aes(color=factor(rownames(validation_lim_all)))) +\n     geom_label_repel(aes(label = rownames(validation_lim_all),\n                    fill = factor(Top30Rank)), color = 'black', size = 5,  \n                    point.padding = unit(0.3, \"lines\")) +\n     # theme(legend.position = \"bottom\") +\n     theme(legend.position = c(0.1, 0.9), \n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\")) +\n     scale_fill_discrete(name = \"Country Overall Ranking\", \n                         labels = c(\"Below 30 Rank\", \"Top 30 Rank\")) +\n     labs(title=sprintf(\"Spacetime LASSO Predicted (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\",  cor(validation_lim_all[ , 1], validation_lim_all[, 2])),\n          x =\"Observed Overall Country Ranking (1 is 'best')\", \n          y = \"Spacetime LASSO Predicted\")\nmyPlot_all",
      "line_count": 89
    },
    {
      "section": "ML Data Analytics",
      "code": "library(glmnet)\n# Generic function to Transform Data ={all predictors (X) and outcome (Y)} to k-space (Fourier domain): kSpaceTransform(data, inverse = FALSE, reconPhases = NULL) \n  # ForwardFT (rawData, FALSE, NULL)\n  # InverseFT(magnitudes, TRUE, reconPhasesToUse) or InverseFT(FT_data, TRUE, NULL)\n# DATA\n# subset test data\nY = aggregate_arima_vector_country_ranking_df$OA\nX = aggregate_arima_vector_country_ranking_df[ , 1:386]\n# remove columns containing NAs\n# X = X[ , colSums(is.na(X)) == 0]; dim(X)  # [1]  31 386\nlength(Y); dim(X)\n\nFT_aggregate_arima_vector_country_ranking_df <- \n  kSpaceTransform(aggregate_arima_vector_country_ranking_df, inverse = FALSE, reconPhases = NULL) \n  \n## Kime-Phase Distributions\n# Examine the Kime-direction Distributions of the Phases for all *Belgium* features (predictors + outcome). Define a generic function that plots the Phase distributions.\n# plotPhaseDistributions(dataFT, dataColnames)\nplotPhaseDistributions(FT_aggregate_arima_vector_country_ranking_df,\n                       colnames(aggregate_arima_vector_country_ranking_df), size=4, cex=0.1)\n\nIFT_FT_aggregate_arima_vector_country_ranking_df <- \n  kSpaceTransform(FT_aggregate_arima_vector_country_ranking_df$magnitudes, \n                  TRUE, FT_aggregate_arima_vector_country_ranking_df$phases)\n# Check IFT(FT) == I: \n# ifelse(aggregate_arima_vector_country_ranking_df[5,4] -\n#     Re(IFT_FT_aggregate_arima_vector_country_ranking_df[5,4]) < 0.001, \"Perfect Synthesis\", \"Problems!!!\")\n\n##############################################\n# Nil-Phase Synthesis and LASSO model estimation\n# 1. Nil-Phase data synthesis (reconstruction)\ntemp_Data <- aggregate_arima_vector_country_ranking_df\nnilPhase_FT_aggregate_arima_vector <- \n  array(complex(real=0, imaginary=0), c(dim(temp_Data)[1], dim(temp_Data)[2]))\ndim(nilPhase_FT_aggregate_arima_vector)    # ;  head(nilPhase_FT_aggregate_arima_vector)\n# [1] 31 387\nIFT_NilPhase_FT_aggregate_arima_vector <- array(complex(), c(dim(temp_Data)[1], dim(temp_Data)[2]))\n\n#       Invert back to spacetime the \n# FT_aggregate_arima_vector_country_ranking_df$magnitudes[ , i] signal with nil-phase\nIFT_NilPhase_FT_aggregate_arima_vector <- \n  Re(kSpaceTransform(FT_aggregate_arima_vector_country_ranking_df$magnitudes, \n                     TRUE, nilPhase_FT_aggregate_arima_vector))\n\ncolnames(IFT_NilPhase_FT_aggregate_arima_vector) <-\n  colnames(aggregate_arima_vector_country_ranking_df)\nrownames(IFT_NilPhase_FT_aggregate_arima_vector) <-\n  rownames(aggregate_arima_vector_country_ranking_df)\ndim(IFT_NilPhase_FT_aggregate_arima_vector)\ndim(FT_aggregate_arima_vector_country_ranking_df$magnitudes)\ncolnames(IFT_NilPhase_FT_aggregate_arima_vector)\n# IFT_NilPhase_FT_aggregate_arima_vector[1:5, 1:4];  temp_Data[1:5, 1:4]\n\n# 2. Perform LASSO modeling on IFT_NilPhase_FT_aggregate_arima_vector; \n# report param estimates and quality metrics AIC/BIC\n# library(forecast)\nset.seed(123)\ncvLASSO_nil_kime_all = cv.glmnet(data.matrix(IFT_NilPhase_FT_aggregate_arima_vector[ , 1:386]), \n           # IFT_NilPhase_FT_aggregate_arima_vector[ , 387], alpha = 1, parallel=TRUE)\n           Y, alpha = 1, parallel=TRUE)\nplot(cvLASSO_nil_kime_all)\nmtext(\"(Spacekime, Nil-phase) CV LASSO: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO_nil_kime_all <-  predict(cvLASSO_nil_kime_all, s = exp(-1/4),    # cvLASSO_nil_kime$lambda.min, \n        newx = data.matrix(IFT_NilPhase_FT_aggregate_arima_vector[ , 1:386])); predLASSO_nil_kime_all\n# testMSE_LASSO_nil_kime <- mean((predLASSO_nil_kime - IFT_NilPhase_FT_aggregate_arima_vector[ , 387])^2)\n# testMSE_LASSO_nil_kime\n\nvarImp(cvLASSO_nil_kime_all, lambda = exp(-1/4)) # cvLASSO_nil_kime_all$lambda.min)\n\ncoefList_nil_kime_all <- coef(cvLASSO_nil_kime_all, s=exp(-1/4))   # 'lambda.min')\ncoefList_nil_kime_all <- data.frame(coefList_nil_kime_all@Dimnames[[1]][coefList_nil_kime_all@i+1],\n                                    coefList_nil_kime_all@x)\nnames(coefList_nil_kime_all) <- c('Feature','EffectSize')\narrange(coefList_nil_kime_all, -abs(EffectSize))[1:9, ]\n#                 Feature  EffectSize\n#1           (Intercept) 26.385520159\n#Feature_2_ArimaVec_6   0.07190025\n#Feature_6_ArimaVec_6   0.49799326\n#Feature_11_ArimaVec_4  8.45132661\n#Feature_12_ArimaVec_4  5.38002499\n#Feature_12_ArimaVec_8 10.37633956\n#Feature_26_ArimaVec_6  2.06530937\n#Feature_30_ArimaVec_4  3.29579474\n#Feature_34_ArimaVec_5  0.96507673\n#Feature_37_ArimaVec_2  0.01033978\n#Feature_39_ArimaVec_5  2.08659578\n#     ARIMA-spacetime:     4=non-seasonal MA, 5=seasonal AR, 8=non-seasonal Diff\n#     ARIMA-spacekimeNil:  2=forecast_avg, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA, 8=non-seasonal Diff\n#9 ARIMA-derived vector includes:\n# (1=ts_avg, 2=forecast_avg, 3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA, \n#  7=period, 8=non-seasonal Diff, 9=seasonal differences)\n\ncoef(cvLASSO_nil_kime_all, s = exp(-1/4)) %>%   # \"lambda.min\") %>%\n  broom::tidy() %>%\n  filter(row != \"(Intercept)\") %>%\n  top_n(100, wt = abs(value)) %>%\n  ggplot(aes(value, reorder(row, value), color = value > 0)) +\n  geom_point(show.legend = FALSE, aes(size = abs(value))) +\n  ggtitle(\"(Spacekime) Top 9 salient features (LASSO penalty)\") +\n  xlab(\"Effect-size\") +\n  ylab(NULL)\n\n# pack a 31*3 DF with (predLASSO_kime, IFT_NilPhase_FT_aggregate_arima_vector_Y, Y)\nvalidation_nil_kime_all <- cbind(predLASSO_nil_kime_all[, 1], \n                         IFT_NilPhase_FT_aggregate_arima_vector[ , 387], Y)  \ncolnames(validation_nil_kime_all) <- c(\"predLASSO_kime\", \"IFT_NilPhase_FT_Y\", \"Orig_Y\")\nrownames(validation_nil_kime_all)[11] <- \"Germany\"\nhead(validation_nil_kime_all)\n\nvalidation_nil_kime_all <- as.data.frame(cbind(validation_nil_kime_all, \n                              ifelse (validation_nil_kime_all[,3]<=30, 1, 0)))\ncolnames(validation_nil_kime_all)[4] <- \"Top30Rank\"\nhead(validation_nil_kime_all)\n\n# Prediction correlations: \n# cor(validation_nil_kime[ , 1], validation_nil_kime[, 2])  # Y=predLASSO_kime OA rank vs. kime_LASSO_pred:  0.99\ncor(validation_nil_kime_all[ , 1], validation_nil_kime_all[, 3])  # Y=predLASSO_kime OA rank vs. Orig_Y:  0.64\n\n# Plot observed Y (Overall Country ranking) vs. LASSO (9-parameters) predicted Y^\nlinFit1_nil_kime_all <- lm(predLASSO_nil_kime_all ~ validation_nil_kime_all[ , 3])\nplot(predLASSO_nil_kime_all ~ validation_nil_kime_all[ , 3],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"Observed Country Overall Ranking\", ylab=\"IFT_NilPhase predLASSO_kime\",\n     main = sprintf(\"Observed (x) vs. IFT_NilPhase Predicted (y) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_nil_kime_all[ , 1], validation_nil_kime_all[, 3])))\nabline(linFit1_nil_kime_all, lwd=3, col=\"red\")\n# abline(linFit1, lwd=3, col=\"green\")\n\n# Spacetime LASSO modeling\nmyPlotNilPhase_all <- ggplot(as.data.frame(validation_nil_kime_all), aes(x=Orig_Y,\n            y=predLASSO_nil_kime_all, label=rownames(validation_nil_kime_all))) +\n     geom_smooth(method='lm') +\n     geom_point() +\n     # Color by groups\n     # geom_text(aes(color=factor(rownames(validation_nil_kime)))) +\n     geom_label_repel(aes(label = rownames(validation_nil_kime_all),\n                    fill = factor(Top30Rank)), color = 'black', size = 5,  \n                    point.padding = unit(0.3, \"lines\")) +\n     # theme(legend.position = \"bottom\") +\n     theme(legend.position = c(0.1, 0.9), \n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\")) +\n     scale_fill_discrete(name = \"Country Overall Ranking\", \n                         labels = c(\"Below 30 Rank\", \"Top 30 Rank\")) +\n     labs(title=sprintf(\"Spacekime LASSO Predicted, Nil-Phases (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\",  cor(validation_nil_kime_all[ , 1], validation_nil_kime_all[, 3])),\n          x =\"Observed Overall Country Ranking (1 is 'best')\", \n          y = \"Spacekime LASSO Predicted, using Nil-Phases\")\nmyPlotNilPhase_all",
      "line_count": 150
    },
    {
      "section": "ML Data Analytics",
      "code": "# temp_Data <- aggregate_arima_vector_country_ranking_df\nswappedPhase_FT_aggregate_arima_vector <- FT_aggregate_arima_vector_country_ranking_df$phases\ndim(swappedPhase_FT_aggregate_arima_vector)    # ;  head(swappedPhase_FT_aggregate_arima_vector)\n# [1] 31 387\nIFT_SwappedPhase_FT_aggregate_arima_vector <- array(complex(), c(dim(temp_Data)[1], dim(temp_Data)[2]))\n\nset.seed(1234)   # sample randomly Phase-columns for each of the 131 covariates (X)\nswappedPhase_FT_aggregate_arima_vector1 <- as.data.frame(cbind(\n  swappedPhase_FT_aggregate_arima_vector[ , \n          sample(ncol(swappedPhase_FT_aggregate_arima_vector[ , 1:378]))],  # mix ARIMA signature phases\n  swappedPhase_FT_aggregate_arima_vector[ , \n          sample(ncol(swappedPhase_FT_aggregate_arima_vector[ , 379:386]))],# mix the meta-data phases\n  swappedPhase_FT_aggregate_arima_vector[ , 387]))                          # add correct Outcome phase\nswappedPhase_FT_aggregate_arima_vector <- swappedPhase_FT_aggregate_arima_vector1\n\ncolnames(swappedPhase_FT_aggregate_arima_vector) <- colnames(temp_Data)\ncolnames(swappedPhase_FT_aggregate_arima_vector); dim(swappedPhase_FT_aggregate_arima_vector)\n# 31 387\n\n#       Invert back to spacetime the \n# FT_aggregate_arima_vector$magnitudes[ , i] signal with swapped-X-phases (Y-phase is fixed)\nIFT_SwappedPhase_FT_aggregate_arima_vector <- \n  Re(kSpaceTransform(FT_aggregate_arima_vector_country_ranking_df$magnitudes, \n                     TRUE, swappedPhase_FT_aggregate_arima_vector))\n\n# Save IFT_SwappedPhase_FT_aggregate_arima_vector out for PCA/t-SNE SpaceKime modeling\n#options(digits = 2)\n#write.table(format(IFT_SwappedPhase_FT_aggregate_arima_vector[ , 1:386]), \n#                   #scientific=FALSE),  #, digits=2), \n#          fileEncoding = \"UTF-16LE\", append = FALSE, quote = FALSE, sep = \"\\t\",\n#          eol = \"\\n\", na = \"NA\", dec = \".\", row.names = FALSE, col.names = FALSE,\n#          \"C:/Users/dinov/Desktop/Ivo.dir/Research/UMichigan/Publications_Books/2018/others/4D_Time_Space_Book_Ideas/ARIMAX_EU_DataAnalytics/EU_Econ_TensorData_31Countries_By_386Features_SpaceKime_SwappedPhase.txt\")\n\ncolnames(IFT_SwappedPhase_FT_aggregate_arima_vector) <-\n  colnames(aggregate_arima_vector_country_ranking_df)\nrownames(IFT_SwappedPhase_FT_aggregate_arima_vector) <-\n  rownames(aggregate_arima_vector_country_ranking_df)\ndim(IFT_SwappedPhase_FT_aggregate_arima_vector)\ndim(FT_aggregate_arima_vector_country_ranking_df$magnitudes)\ncolnames(IFT_SwappedPhase_FT_aggregate_arima_vector)\n# IFT_SwappedPhase_FT_aggregate_arima_vector[1:5, 1:4];  temp_Data[1:5, 1:4]\n\n# 2. Perform LASSO modeling on IFT_SwappedPhase_FT_aggregate_arima_vector; \n# report param estimates and quality metrics AIC/BIC\nset.seed(12)\ncvLASSO_kime_swapped = \n  cv.glmnet(data.matrix(IFT_SwappedPhase_FT_aggregate_arima_vector[ , 1:378]), \n           Y, alpha = 1, parallel=TRUE)\nplot(cvLASSO_kime_swapped)\nmtext(\"(Spacekime, Swapped-Phases) CV LASSO: Number of Nonzero (Active) Coefficients\", side=3, line=2.5)\n\n# Identify top predictors and forecast the Y=Overall (OA) Country ranking outcome\npredLASSO_kime_swapped <-  predict(cvLASSO_kime_swapped, s = cvLASSO_kime_swapped$lambda.min, \n        newx = data.matrix(IFT_SwappedPhase_FT_aggregate_arima_vector[ , 1:378]))\n# testMSE_LASSO_kime_swapped <- \n#        mean((predLASSO_kime_swapped - IFT_SwappedPhase_FT_aggregate_arima_vector[ , 387])^2)\n# testMSE_LASSO_kime_swapped\npredLASSO_kime_swapped\n\n# Plot Regression Coefficients: create variable names for plotting \nbetaHatLASSO_kime_swapped = as.double(coef(cvLASSO_kime_swapped,\n                   s=cvLASSO_kime_swapped$lambda.min))\n#cvLASSO_kime_swapped$lambda.1se\n#coefplot(betaHatLASSO_kime_swapped[377:386], sd = rep(0, 10), pch=0, cex.pts = 3, col=\"red\", \n#         main = \"(Spacekime, Swapped-Phases) LASSO-Regularized Regression Coefficient Estimates\",\n#         varnames = varNames[377:386])\nvarImp(cvLASSO_kime_swapped, lambda = cvLASSO_kime_swapped$lambda.min)\n\ncoefList_kime_swapped <- coef(cvLASSO_kime_swapped, s='lambda.min')\ncoefList_kime_swapped <- data.frame(coefList_kime_swapped@Dimnames[[1]][coefList_kime_swapped@i+1], coefList_kime_swapped@x)\nnames(coefList_kime_swapped) <- c('Feature','EffectSize')\narrange(coefList_kime_swapped, -abs(EffectSize))[2:10, ]\n#                 Feature  EffectSize\n#2   Feature_2_ArimaVec_8  1.484856e+15\n#3  Feature_42_ArimaVec_7  1.970862e+14\n#4  Feature_23_ArimaVec_7 -2.467246e+13\n#5  Feature_37_ArimaVec_5 -2.983216e+00\n#6  Feature_34_ArimaVec_4 -1.382639e+00\n#7  Feature_36_ArimaVec_3 -1.198157e+00\n#8   Feature_6_ArimaVec_3  1.106294e-01\n#9  Feature_38_ArimaVec_2 -1.058259e-02\n#10 Feature_38_ArimaVec_1 -1.124584e-03\n#\n#     ARIMA-spacetime:        4=non-seasonal MA, 5=seasonal AR, 8=non-seasonal Diff\n#     ARIMA-spacekime_nill:   3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA\n#    ARIMA-spacekime_swapped: 3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA\n# 9 ARIMA-derived vector includes:\n# (1=ts_avg, 2=forecast_avg, 3=non-seasonal AR, 4=non-seasonal MA, 5=seasonal AR, 6=seasonal MA, \n#  7=period, 8=non-seasonal Diff, 9=seasonal differences)\n\ncoef(cvLASSO_kime_swapped, s = \"lambda.min\") %>%\n  broom::tidy() %>%\n  filter(row != \"(Intercept)\") %>%\n  top_n(100, wt = abs(value)) %>%\n  ggplot(aes(value, reorder(row, value), color = value > 0)) +\n  geom_point(show.legend = FALSE, aes(size = abs(value))) +\n  ggtitle(\"(Spacekime, Swapped-Phases) Top 9 salient features (LASSO penalty)\") +\n  xlab(\"Effect-size\") +\n  ylab(NULL)\n\n# pack a 31*4 DF with (predLASSO_kime, IFT_NilPhase_FT_aggregate_arima_vector_Y, \n#                      IFT_SwappedPhase_FT_aggregate_arima_vector_Y, Y)\nvalidation_kime_swapped <- cbind(predLASSO[, 1], predLASSO_nil_kime_all[, 1], \n                         predLASSO_kime_swapped[ , 1], Y)  \ncolnames(validation_kime_swapped) <- c(\"predLASSO (spacetime)\", \"predLASSO_IFT_NilPhase\",\n                               \"predLASSO_IFT_SwappedPhase\", \"Orig_Y\")\nhead(validation_kime_swapped); dim(validation_kime_swapped)\n\n# Prediction correlations: \ncor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])  \n# predLASSO_IFT_SwappedPhase OA rank vs. predLASSO_spacekime:  0.7\ncor(validation_kime_swapped[ , 1], validation_kime_swapped[, 3])  \n# predLASSO (spacetime) vs.  predLASSO_IFT_SwappedPhase OA rank:  0.83\n\n# Plot observed Y (Overall Country ranking), x-axis vs. Kime-Swapped LASSO (9-parameters) predicted Y^\nlinFit1_kime_swapped <- lm(validation_kime_swapped[ , 3] ~ validation_kime_swapped[ , 4])\nplot(validation_kime_swapped[ , 3] ~ validation_kime_swapped[ , 4],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"predLASSO_IFT_SwappedPhase_FT_Y\", ylab=\"predLASSO_spacekime_swapped Country Overall Ranking\",\n     main = sprintf(\"Observed (x) vs. Kime IFT_SwappedPhase_FT_Y (y) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])))\nabline(linFit1_kime_swapped, lwd=3, col=\"red\")\n#abline(linFit1_kime, lwd=3, col=\"green\")\n\n# Plot Spacetime LASSO forecasting\n# Plot observed Y (Overall Country ranking), x-axis vs. LASSO (9-parameters) predicted Y^, y-axis\nlinFit1_spacetime <- lm(validation_kime_swapped[ , 3] ~ validation_kime_swapped[ , 4])\nplot(validation_kime_swapped[ , 3] ~ validation_kime_swapped[ , 4],\n     col=\"blue\", xaxt='n', yaxt='n', pch = 16, cex=3,\n     xlab=\"Observed Country Overall Ranking\", ylab=\"predLASSO_spacetime\",\n     main = sprintf(\"Predicted (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\", \n                    cor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])))\nabline(linFit1_spacetime, lwd=3, col=\"red\")\n\n# add Top_30_Ranking_Indicator\nvalidation_kime_swapped <- as.data.frame(cbind(validation_kime_swapped, ifelse (validation_kime_swapped[,4]<=30, 1, 0)))\ncolnames(validation_kime_swapped)[5] <- \"Top30Rank\"\nrownames(validation_kime_swapped)[11] <- \"Germany\"\nhead(validation_kime_swapped)\n\n# Write out the Binary top-30/Not-Top-30 labels\ndf_top30 <- cbind(countryNames, validation_kime_swapped[ , 5])\ncolnames(df_top30) <- c(\"Country\", \"Top-30-Label\")\nwrite.table(df_top30, \n          fileEncoding = \"UTF-16LE\", append = FALSE, quote = FALSE, sep = \"\\t\",\n          eol = \"\\n\", na = \"NA\", dec = \".\", row.names = FALSE, col.names = TRUE,\n          \"C:/Users/dinov/Desktop/Ivo.dir/Research/UMichigan/Publications_Books/2018/others/4D_Time_Space_Book_Ideas/ARIMAX_EU_DataAnalytics/EU_Econ_Labels_31Countries_Top_30_BinaryOutcome.txt\")\n\n# Spacetime LASSO modeling\nmyPlotSwappedPhase <- ggplot(as.data.frame(validation_kime_swapped), aes(x=Orig_Y,\n            y=validation_kime_swapped[, 3], label=rownames(validation_kime_swapped))) +\n     geom_smooth(method='lm') +\n     geom_point() +\n     # Color by groups\n     # geom_text(aes(color=factor(rownames(validation_kime_swapped)))) +\n     geom_label_repel(aes(label = rownames(validation_kime_swapped),\n                    fill = factor(Top30Rank)), color = 'black', size = 5,  \n                    point.padding = unit(0.3, \"lines\")) +\n     # theme(legend.position = \"bottom\") +\n     theme(legend.position = c(0.1, 0.9), \n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\")) +\n     scale_fill_discrete(name = \"Country Overall Ranking\", \n                         labels = c(\"Below 30 Rank\", \"Top 30 Rank\")) +\n     labs(title=sprintf(\"Spacekime LASSO Predicted, Swapped-Phases (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\",  cor(validation_kime_swapped[ , 3], validation_kime_swapped[, 4])),\n          x =\"Observed Overall Country Ranking (1 is 'best')\", \n          y = \"Spacekime LASSO Predicted, using Swapped-Phases\")\nmyPlotSwappedPhase",
      "line_count": 168
    },
    {
      "section": "ML Data Analytics",
      "code": "myPlotNilPhase <- ggplot(as.data.frame(validation_kime_swapped), aes(x=Orig_Y,\n            y=predLASSO_kime, label=rownames(validation_kime_swapped))) +\n     geom_smooth(method='lm') +\n     geom_point() +\n     # Color by groups\n     # geom_text(aes(color=factor(rownames(validation_kime_swapped)))) +\n     geom_label_repel(aes(label = rownames(validation_kime_swapped),\n                    fill = factor(Top30Rank)), color = 'black', size = 5,  \n                    point.padding = unit(0.3, \"lines\")) +\n     # theme(legend.position = \"bottom\") +\n     theme(legend.position = c(0.1, 0.9), \n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\")) +\n     scale_fill_discrete(name = \"Country Overall Ranking\", \n                         labels = c(\"Below 30 Rank\", \"Top 30 Rank\")) +\n     labs(title=sprintf(\"Spacekime LASSO Predicted, Nil-Phases, (y) vs. Observed (x) Overall Country Ranking, cor=%.02f\",  cor(validation_kime_swapped[ , 2], validation_kime_swapped[, 4])),\n          x =\"Observed Overall Country Ranking (1 is 'best')\", \n          y = \"Spacekime LASSO Predicted, using Nil-Phases\")\nmyPlotNilPhase\n\ncountryNames[11]<-\"Germany\"\naggregateResults <- (rbind(cbind(as.character(countryNames), \"predLASSO_spacetime_386\", as.numeric(predLASSO)), \n                     cbind(as.character(countryNames), \"predLASSO_spacetime_378\", predLASSO_lim),\n                     cbind(as.character(countryNames), \"predLASSO_nil_kime_386\", predLASSO_nil_kime_all),\n                     cbind(as.character(countryNames), \"predLASSO_nil_kime_378\", predLASSO_nil_kime),\n                     cbind(as.character(countryNames), \"predLASSO_swapped_kime_386\", predLASSO_kime_swapped),\n                     cbind(as.character(countryNames), \"predLASSO_swapped_kime_378\", predLASSO_kime_swapped_lim),\n                     cbind(as.character(countryNames), \"observed\", Y)\n                ))\naggregateResults <- data.frame(aggregateResults[ , -3], as.numeric(aggregateResults[,3]))\ncolnames(aggregateResults) <- c(\"country\", \"estimate_method\", \"ranking\")\nggplot(aggregateResults, aes(x=country, y=ranking, color=estimate_method)) +\n  geom_point(aes(shape=estimate_method, color=estimate_method, size=estimate_method)) + \n  geom_point(size = 5) +\n  geom_line(data = aggregateResults[aggregateResults$estimate_method == \"observed\", ], \n            aes(group = estimate_method), size=2, linetype = \"dashed\") +\n  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=.5)) +\n  # theme(legend.position = \"bottom\") +\n  # scale_shape_manual(values = as.factor(aggregateResults$estimate_method)) +\n  # scale_color_gradientn(colours = rainbow(7)) +\n  theme(text = element_text(size = 15), legend.position = c(0.3, 0.85), \n           axis.text=element_text(size=16),\n           legend.text = element_text(colour=\"black\", size=12, face=\"bold\"),\n           legend.title = element_text(colour=\"black\", size=14, face=\"bold\"))\n\nlibrary(plotly)\nplot_ly(aggregateResults) %>%\n  add_markers(x = ~country, y = ~ranking, type = \"scatter\", \n        color = ~estimate_method, colors = c(\"black\", \"red\", \"blue\", \"green\", \"purple\", \"orange\", \"yellow\"),\n        mode = \"markers\", marker = list(size = ~ranking, opacity=~(1-(ranking-1)/49),\n                                        line = list(color = \"black\", width = 2))) %>% \n    layout(title=\"Spacekime Analytics - Country Ranking using Different Phase Estimators\",\n           legend = list(orientation = \"h\",   # show legend horizontally\n                     xanchor = \"center\",      # use center of legend as anchor\n                     x = 0))                # put legend in center of x-axis)",
      "line_count": 55
    },
    {
      "section": "ML Data Analytics",
      "code": "load(\"C:/Users/dinov/Desktop/Ivo.dir/Research/UMichigan/Publications_Books/2018/others/4D_Time_Space_Book_Ideas/ARIMAX_EU_DataAnalytics/EU_Econ_SpaceKime.RData\")\n# View(aggregate_arima_vector_country_ranking_df)\ndim(aggregate_arima_vector_country_ranking_df)  \n# 31(countries) 387(features)\n# Features = country-index + 386 features (378 time-series derivatives + 8 meta-data features)",
      "line_count": 5
    },
    {
      "section": "ML Data Analytics",
      "code": "eudata <- aggregate_arima_vector_country_ranking_df\ncolnames(eudata) <- c(\"country\",colnames(eudata[,-1]))\neudata <- eudata[ , -ncol(eudata)]\nY<-aggregate_arima_vector_country_ranking_df$OA\n\n# Complete data 386 features (378 + 8)\nX<-eudata[,-ncol(eudata)]; dim(X)\n# TS-derivative features only (378)\nX378 <- X[, -c(379:386)]; dim(X378)\ncountryinfo<-as.character(X[,1])\ncountryinfo[11]<-\"Germany\"\nX<-X[,-1]\nkeeplist<-NULL\nfor (i in 1:ncol(X)) {\n  if(FALSE %in% (X[,i]==mean(X[,i]))) {keeplist<-c(keeplist,i)}\n}\nX<-X[,keeplist]; dim(X)\n\n# Reduced to 378 features \n#countryinfo<-as.character(X378[,1])\n#countryinfo[11]<-\"Germany\"\n#X378<-X378[,-1]\n#keeplist<-NULL\n#for (i in 1:ncol(X378)) {\n#    if(FALSE %in% (X378[,i]==mean(X378[,i]))) {keeplist<-c(keeplist,i)}\n#}\n#X378<-X378[,keeplist]; dim(X378)\n\nlibrary(glmnet)\nfitLASSO <- glmnet(as.matrix(X), Y, alpha = 1)\nlibrary(doParallel)\nregisterDoParallel(5)\n#cross-validation\ncvLASSO = cv.glmnet(data.matrix(X), Y, alpha = 1, parallel=TRUE)\n\n# fitLASSO <- glmnet(as.matrix(X378), Y, alpha = 1)\n#library(doParallel)\n#registerDoParallel(5)\n#cross-validation\n#cvLASSO = cv.glmnet(data.matrix(X378), Y, alpha = 1, parallel=TRUE)\n\n# To choose features we like to have based on lasso\nchooselambda <- function(cvlasso, option, k=NULL) {\n  lambmat<-cbind(cvlasso$glmnet.fit$df,cvlasso$glmnet.fit$lambda)\n  result<-tapply(lambmat[,2],lambmat[,1],max)\n  kresult<-result[which(names(result)==as.factor(k))]\n  if(option==1) {return(result)}\n  else if (option==2) {return(kresult)}\n  else (return(\"Not a valid option\"))\n}\nshowfeatures <- function(object, lambda, k ,...) {\n  lam<-lambda[which(names(lambda)==as.factor(k))]\n  beta <- predict(object, s = lam, type = \"coef\")\n  if(is.list(beta)) {\n    out <- do.call(\"cbind\", lapply(beta, function(x) x[,1]))\n    out <- as.data.frame(out)\n    s <- rowSums(out)\n    out <- out[which(s)!=0,,drop=FALSE]\n  } else  {out<-data.frame(Overall = beta[,1])\n  out<-out[which(out!=0),,drop=FALSE]\n  }\n  out <- abs(out[rownames(out) != \"(Intercept)\",,drop = FALSE])\n  out\n}",
      "line_count": 64
    },
    {
      "section": "ML Data Analytics",
      "code": "#test training data setup\nrandchoose <- function(matr) {\n  leng<-nrow(matr)\n  se<-seq(1:leng)\n  sam<-sample(se,as.integer(leng*0.6))\n  return(sam)\n}\n\neusample<-X\neusample$Rank<-as.factor(ifelse(Y<30, 1, 0))\nset.seed(1234)\neutrain<-eusample[randchoose(eusample), ]\nset.seed(1234)\neutest<-eusample[-randchoose(eusample), ]\n\neusample378 <- X378\neusample378$Rank <- as.factor(ifelse(Y<30, 1, 0))\nset.seed(1234)\neutrain378 <- eusample378[randchoose(eusample378), ]\nset.seed(1234)\neutest378 <- eusample378[-randchoose(eusample378), ]\n\n# Load Libraries\nlibrary(e1071)\nlibrary(\"randomForest\")\nlibrary(ada); library(adabag)\nlibrary(caret)\nlibrary(kernlab)\nlibrary(cluster)\nlibrary(ipred)\nlibrary(ggplot2)\n\nMLcomp <- function(fitlas, cvlas, trn, test, option=1) {\n  allfeat<-as.numeric(names(chooselambda(cvlasso = cvlas, option = 1)))\n  allfeat<-allfeat[which(allfeat>4)]\n  trainlist<-as.list(NULL)\n  for (i in 1:length(allfeat)) {\n    trainlist[[i]]<-trn[,which(colnames(trn) %in% \n                                 c(row.names(showfeatures(fitlas, chooselambda(cvlas = cvlas,1), allfeat[i])), \"Rank\"))]\n  }\nresultframe<-data.frame(origin=rep(NA,length(allfeat)))\nrownames(resultframe)<-allfeat\nresultframe$Decision_tree_bagging<-rep(NA,length(allfeat))\n  for (i in 1:length(allfeat)) {\n    set.seed(1234)\n    eubag<-ipred::bagging(Rank~.,data = trainlist[[i]],nbagg=100)\n    bagtest<-predict(eubag, eutest)\n    bagagg<-bagtest==eutest$Rank\n    accuracy<-prop.table(table(bagagg))[c(\"TRUE\")]\n    resultframe$Decision_tree_bagging[i]<-accuracy\n  }\nresultframe$Random_forest<-rep(NA,length(allfeat))\n  for (i in 1:length(allfeat)) {\n    set.seed(1234)\n    eurf<-randomForest(Rank~.,data=trainlist[[i]])\n    rftest<-predict(eurf,eutest)\n    rfagg<-rftest==eutest$Rank\n    accuracy<-prop.table(table(rfagg))[c(\"TRUE\")]\n    resultframe$Random_forest[i]<-accuracy\n  }\nresultframe$Decision_tree_adaboost<-rep(NA,length(allfeat))\n  for (i in 1:length(allfeat)) {\n    set.seed(1234)\n    enada<-ada(Rank~.,data = trainlist[[i]],iter=50)\n    adatest<-predict(enada,eutest)\n    adaagg<-adatest==eutest$Rank\n    accuracy<-prop.table(table(adaagg))[c(\"TRUE\")]\n    resultframe$Decision_tree_adaboost[i]<-accuracy\n  }\nresultframe$GLM<-rep(NA,length(allfeat))\n  for (i in 1:length(allfeat)) {\n    euglm<-glm(Rank~.,data = trainlist[[i]],family = \"binomial\")\n    glmtest<-predict(euglm,eutest)\n    glmtest<-ifelse(glmtest<0,0,1)\n    glmagg<-glmtest==eutest$Rank\n    accuracy<-prop.table(table(glmagg))[c(\"TRUE\")]\n    resultframe$GLM[i]<-accuracy\n  }\nresultframe$SVM_best_Gamma_Cost<-rep(NA,length(allfeat))  \n  for (i in 1:length(allfeat)) {\n    set.seed(1234)\n    svmtune<-tune.svm(Rank~.,data = trainlist[[i]],gamma = 10^(-6:1),cost = 10^(-10:10))\n    svmed<-svm(Rank~.,data=trainlist[[i]],gamma=svmtune$best.parameters[1],cost=svmtune$best.parameters[2])\n    svmtest<-predict(svmed,eutest)\n    svmagg<-svmtest==eutest$Rank\n    accuracy<-prop.table(table(svmagg))[c(\"TRUE\")]\n    resultframe$SVM_best_Gamma_Cost[i]<-accuracy\n  }\n  resultframe$origin<-NULL\n  if(option==1){return(resultframe)}\n}\nresultframe <- MLcomp(fitLASSO, cvLASSO, eutrain, eutest, 1)\nresultframe_386_ST <- resultframe\n# View(resultframe_386_ST)\n\n# resultframe_378_ST <- MLcomp(fitLASSO, cvLASSO, eutrain378, eutest378, 1)\n\n# Display results\nresultframe$features<-as.factor(as.numeric(rownames(resultframe)))\nppframe<-data.frame(NULL)\nfor (i in 1:5) {\n  FM <- data.frame(resultframe[,i], resultframe$features,\n                   Methods<-rep(colnames(resultframe)[i], nrow(resultframe)))\n  ppframe<-rbind(ppframe, FM)\n}\ncolnames(ppframe)<-c(\"Accuracy\", \"Features\", \"Methods\")\nggplot(ppframe, aes(x=Features, y=Accuracy, colour=Methods, \n                    group=Methods, shape=Methods))+\n  geom_line(position=position_dodge(0.2), lwd=2)+\n  ylim(0.2, 1.0) +\n  geom_point(size=5, position=position_dodge(0.2))+\n  theme(legend.position=\"top\", legend.text=element_text(size=16))+\n  ggtitle(\"Spacetime (386 features): Compare ML Forecasting Results\")+\n  theme(\n    axis.text=element_text(size=16),\n    plot.title = element_text(size=18, face=\"bold.italic\"),\n    axis.title.x = element_text(size=14, face=\"bold\"),\n    axis.title.y = element_text(size=14, face=\"bold\"))\n\n# spacetime (ST) 378_ST\nresultframe_378_ST$features<-as.factor(as.numeric(rownames(resultframe_378_ST)))\nppframe_378_ST<-data.frame(NULL)\nfor (i in 1:5) {\n  FM_378_ST <- data.frame(resultframe_378_ST[,i], resultframe_378_ST$features,\n          Methods<-rep(colnames(resultframe_378_ST)[i], nrow(resultframe_378_ST)))\n  ppframe_378_ST<-rbind(ppframe_378_ST, FM_378_ST)\n}\ncolnames(ppframe_378_ST)<-c(\"Accuracy\", \"Features\", \"Methods\")\nggplot(ppframe_378_ST, aes(x=Features, y=Accuracy, colour=Methods, \n                    group=Methods, shape=Methods))+\n  geom_line(position=position_dodge(0.2), lwd=2)+\n  ylim(0.2, 1.0) +\n  geom_point(size=5, position=position_dodge(0.2))+\n  theme(legend.position=\"top\", legend.text=element_text(size=16))+\n  ggtitle(\"Spacetime (386 features): Compare ML Forecasting Results\")+\n  theme(\n    axis.text=element_text(size=16),\n    plot.title = element_text(size=18, face=\"bold.italic\"),\n    axis.title.x = element_text(size=14, face=\"bold\"),\n    axis.title.y = element_text(size=14, face=\"bold\"))",
      "line_count": 140
    },
    {
      "section": "ML Data Analytics",
      "code": "showfeatures(fitLASSO, chooselambda(cvLASSO,1), 10)\nfeat_5 <-  predict(fitLASSO, s = chooselambda(cvLASSO,2,10), newx = data.matrix(X))\ndf1 <- as.data.frame(rbind(as.numeric(feat_5),Y), \n                     row.names = c(\"Predicted Rank\",\"OA Rank\"))\ncolnames(df1) <- countryNames\ndf1 # View(t(df1))\n\n# Clustering\ncluster5 <- X[, which(colnames(X) %in%\n                        row.names(showfeatures(fitLASSO, chooselambda(cvLASSO,1), 10)))]\nrownames(cluster5) <- countryNames # countryinfo\n\n#1. hierarchical clustering\nscaled_cluster5 <- scale(cluster5)\n##deal with NAN values\n#scaled_country<-scaled_country[,which(is.nan(scaled_country[1,])==FALSE)]\ndis_SC5 <- dist(scaled_cluster5)\nH_clust_SC5 <- hclust(dis_SC5)\n\nlibrary(\"factoextra\")\nlibrary(\"FactoMineR\")\nH_clust_SC5 <- eclust(scaled_cluster5, k=5, \"hclust\")\nfviz_dend(H_clust_SC5, rect = TRUE, cex=0.5)\n# fviz_dend(H_clust_SC5, lwd=2, rect = TRUE)\n\n\n# ST 378\ncluster5_378_ST <- X378[, which(colnames(X378) %in%\n                        row.names(showfeatures(fitLASSO, chooselambda(cvLASSO,1), 10)))]\nrownames(cluster5_378_ST) <- countryNames # countryinfo\n#1. hierarchical clustering\nscaled_cluster5_378_ST <- scale(cluster5_378_ST)\ndis_SC5_378_ST <- dist(scaled_cluster5_378_ST)\nH_clust_SC5_378_ST <- hclust(dis_SC5_378_ST)\nH_clust_SC5_378_ST <- eclust(scaled_cluster5_378_ST, k=5, \"hclust\")\nfviz_dend(H_clust_SC5_378_ST,rect = TRUE, cex=0.5)",
      "line_count": 36
    },
    {
      "section": "ML Data Analytics",
      "code": "dim(IFT_SwappedPhase_FT_aggregate_arima_vector)\n# [1]  31 387\neudata_SwappedPhase <- IFT_SwappedPhase_FT_aggregate_arima_vector\ncolnames(eudata_SwappedPhase) <- c(\"country\", colnames(eudata_SwappedPhase[,-1]))\neudata_SwappedPhase <- as.data.frame(eudata_SwappedPhase[ , -ncol(eudata_SwappedPhase)])\nY <- as.data.frame(IFT_SwappedPhase_FT_aggregate_arima_vector)$OA\n\n# Complete data 386 features (378 + 8)\nX <- eudata_SwappedPhase\ncountryinfo<-as.character(X[,1])\ncountryinfo[11]<-\"Germany\"\nX<-X[,-1]\nkeeplist<-NULL\nfor (i in 1:ncol(X)) {\n  if(FALSE %in% (X[,i]==mean(X[,i]))) {keeplist<-c(keeplist,i)}\n}\nX<-X[,keeplist]; dim(X)   # 31 343\n\n# Reduced to 378 features \n# TS-derivative features only (378)\n# X378 <- X[, -c(379:386)]; dim(X378)\n#countryinfo<-as.character(X378[,1])\n#countryinfo[11]<-\"Germany\"\n#X378<-X378[,-1]\n#keeplist<-NULL\n#for (i in 1:ncol(X378)) {\n#    if(FALSE %in% (X378[,i]==mean(X378[,i]))) {keeplist<-c(keeplist,i)}\n#}\n#X378<-X378[,keeplist]; dim(X378)\n\nlibrary(glmnet)\nfitLASSO_X <- glmnet(as.matrix(X), Y, alpha = 1)\nlibrary(doParallel)\nregisterDoParallel(5)\n#cross-validation\ncvLASSO_X = cv.glmnet(data.matrix(X), Y, alpha = 1, parallel=TRUE)\n\n# fitLASSO_X <- glmnet(as.matrix(X378), Y, alpha = 1)\n#library(doParallel)\n#registerDoParallel(5)\n#cross-validation\n#cvLASSO_X = cv.glmnet(data.matrix(X378), Y, alpha = 1, parallel=TRUE)\n\n# To choose features we like to have based on lasso\nchooselambda <- function(cvlasso, option, k=NULL) {\n  lambmat<-cbind(cvlasso$glmnet.fit$df,cvlasso$glmnet.fit$lambda)\n  result<-tapply(lambmat[,2],lambmat[,1],max)\n  kresult<-result[which(names(result)==as.factor(k))]\n  if(option==1) {return(result)}\n  else if (option==2) {return(kresult)}\n  else (return(\"Not a valid option\"))\n}\nshowfeatures <- function(object, lambda, k ,...) {\n  lam<-lambda[which(names(lambda)==as.factor(k))]\n  beta <- predict(object, s = lam, type = \"coef\")\n  if(is.list(beta)) {\n    out <- do.call(\"cbind\", lapply(beta, function(x) x[,1]))\n    out <- as.data.frame(out)\n    s <- rowSums(out)\n    out <- out[which(s)!=0,,drop=FALSE]\n  } else  {out<-data.frame(Overall = beta[,1])\n  out<-out[which(out!=0),,drop=FALSE]\n  }\n  out <- abs(out[rownames(out) != \"(Intercept)\",,drop = FALSE])\n  out\n}",
      "line_count": 66
    },
    {
      "section": "ML Data Analytics",
      "code": "#test training data setup\nrandchoose <- function(matr) {\n  leng<-nrow(matr)\n  se<-seq(1:leng)\n  sam<-sample(se,as.integer(leng*0.6))\n  return(sam)\n}\n\nXsample <- X\nXsample$Rank <- as.factor(ifelse(Y<30, 1, 0))\nset.seed(1234)\nXtrain <- Xsample[randchoose(Xsample), ]\nset.seed(1234)\nXtest <- Xsample[-randchoose(Xsample), ]\n\n#Xsample378 <- X378\n#Xsample378$Rank <- as.factor(ifelse(Y<30, 1, 0))\n#set.seed(1234)\n#Xtrain378 <- Xsample378[randchoose(Xsample378), ]\n#set.seed(1234)\n#Xtest378 <- Xsample378[-randchoose(Xsample378), ]\n\n# Load Libraries\nlibrary(e1071)\nlibrary(\"randomForest\")\nlibrary(ada); library(adabag)\nlibrary(caret)\nlibrary(kernlab)\nlibrary(cluster)\nlibrary(ipred)\nlibrary(ggplot2)\n\n# resultXframe <- MLcomp(fitLASSO, cvLASSO, Xtrain, Xtest, 1)\nMLcompX <- function(fitlas, cvlas, trn, test, option=1) {\n  allfeat<-as.numeric(names(chooselambda(cvlasso = cvlas, option = 1)))\n  allfeat<-allfeat[which(allfeat>4)]\n  trainlist<-as.list(NULL)\n  for (i in 1:length(allfeat)) {\n    trainlist[[i]]<-trn[,which(colnames(trn) %in% \n                                 c(row.names(showfeatures(fitlas, chooselambda(cvlas = cvlas,1), allfeat[i])), \"Rank\"))]\n  }\n \n  resultXframe<-data.frame(origin=rep(NA,length(allfeat)))\n  rownames(resultXframe)<-allfeat\n  resultXframe$Decision_tree_bagging<-rep(NA,length(allfeat))\n  for (i in 1:length(allfeat)) {\n    #ERROR HANDLING\n    possibleError <- tryCatch(\n        function () {\n          set.seed(1234)\n          Xbag<-ipred::bagging(Rank~ . ,data = trainlist[[i]], nbagg=100, \n                               control=rpart.control(minsplit=2, cp=0.1, xval=10))\n          bagtest<-predict(Xbag, Xtest)\n          bagagg<-bagtest==Xtest$Rank\n          accuracy<-prop.table(table(bagagg))[c(\"TRUE\")]\n          resultXframe$Decision_tree_bagging[i]<-accuracy\n        },\n        error=function(e) e\n    )\n    if(inherits(possibleError, \"error\")) next\n    # print(i)\n  }\n\n  resultXframe$Random_forest<-rep(NA,length(allfeat))\n  for (i in 1:length(allfeat)) {\n    set.seed(1234)\n    Xrf<-randomForest(Rank~.,data=trainlist[[i]])\n    rftest<-predict(Xrf,test)\n    rfagg<-rftest==test$Rank\n    accuracy<-prop.table(table(rfagg))[c(\"TRUE\")]\n    resultXframe$Random_forest[i]<-accuracy\n  }\n\n  resultXframe$Decision_tree_adaboost<-rep(NA,length(allfeat))\n  for (i in 1:length(allfeat)) {\n    set.seed(1234)\n    Xada<-ada(Rank~.,data = trainlist[[i]],iter=50)\n    adatest<-predict(Xada,test)\n    adaagg<-adatest==test$Rank\n    accuracy<-prop.table(table(adaagg))[c(\"TRUE\")]\n    resultXframe$Decision_tree_adaboost[i]<-accuracy\n  }\n\n  resultXframe$GLM<-rep(NA,length(allfeat))\n  for (i in 1:length(allfeat)) {\n    euglm<-glm(Rank~.,data = trainlist[[i]],family = \"binomial\")\n    glmtest<-predict(euglm,test)\n    glmtest<-ifelse(glmtest<0,0,1)\n    glmagg<-glmtest==test$Rank\n    accuracy<-prop.table(table(glmagg))[c(\"TRUE\")]\n    resultXframe$GLM[i]<-accuracy\n  }\n\n  resultXframe$SVM_best_Gamma_Cost<-rep(NA,length(allfeat))  \n  for (i in 1:length(allfeat)) {\n    set.seed(1234)\n    svmtune<-tune.svm(Rank~.,data = trainlist[[i]],gamma = 10^(-6:1),cost = 10^(-10:10))\n    svmed<-svm(Rank~.,data=trainlist[[i]],gamma=svmtune$best.parameters[1],cost=svmtune$best.parameters[2])\n    svmtest<-predict(svmed,test)\n    svmagg<-svmtest==test$Rank\n    accuracy<-prop.table(table(svmagg))[c(\"TRUE\")]\n    resultXframe$SVM_best_Gamma_Cost[i]<-accuracy\n  }\n  resultXframe$origin<-NULL\n  if(option==1){return(resultXframe)}\n}\n\nresultXframe <- MLcompX(fitLASSO_X, cvLASSO_X, Xtrain, Xtest, 1)\nresultXframe_386_SK_Swapped <- resultXframe\n# View(resultXframe_386_SK_Swapped)\n\n# resultXframe_378_SK_Swapped <- MLcompX(fitLASSO_X, cvLASSO_X, Xtrain378, Xtest378, 1)\n\n# Display results\nresultXframe$features<-as.factor(as.numeric(rownames(resultXframe)))\nppframeX<-data.frame(NULL)\nfor (i in 1:5) {\n  FM <- data.frame(resultXframe[,i], resultXframe$features,\n                   Methods<-rep(colnames(resultXframe)[i], nrow(resultXframe)))\n  ppframeX<-rbind(ppframeX, FM)\n}\ncolnames(ppframeX)<-c(\"Accuracy\", \"Features\", \"Methods\")\nggplot(ppframeX, aes(x=Features, y=Accuracy, colour=Methods, \n                    group=Methods, shape=Methods))+\n  geom_line(position=position_dodge(0.2), lwd=2)+\n  ylim(0.2, 1.0) +\n  geom_point(size=5, position=position_dodge(0.2))+\n  theme(legend.position=\"top\", legend.text=element_text(size=16))+\n  ggtitle(\"Spacekime Swapped-Phases (386 features): Compare ML Forecasting Results\")+\n  theme(\n    axis.text=element_text(size=16),\n    plot.title = element_text(size=18, face=\"bold.italic\"),\n    axis.title.x = element_text(size=14, face=\"bold\"),\n    axis.title.y = element_text(size=14, face=\"bold\"))\n\n# spacetime (ST) 378_ST\nresultframe_378_ST$features<-as.factor(as.numeric(rownames(resultframe_378_ST)))\nppframe_378_ST<-data.frame(NULL)\nfor (i in 1:5) {\n  FM_378_ST <- data.frame(resultframe_378_ST[,i], resultframe_378_ST$features,\n          Methods<-rep(colnames(resultframe_378_ST)[i], nrow(resultframe_378_ST)))\n  ppframe_378_ST<-rbind(ppframe_378_ST, FM_378_ST)\n}\ncolnames(ppframe_378_ST)<-c(\"Accuracy\", \"Features\", \"Methods\")\nggplot(ppframe_378_ST, aes(x=Features, y=Accuracy, colour=Methods, \n                    group=Methods, shape=Methods))+\n  geom_line(position=position_dodge(0.2), lwd=2)+\n  ylim(0.2, 1.0) +\n  geom_point(size=5, position=position_dodge(0.2))+\n  theme(legend.position=\"top\", legend.text=element_text(size=16))+\n  ggtitle(\"Spacetime (386 features): Compare ML Forecasting Results\")+\n  theme(\n    axis.text=element_text(size=16),\n    plot.title = element_text(size=18, face=\"bold.italic\"),\n    axis.title.x = element_text(size=14, face=\"bold\"),\n    axis.title.y = element_text(size=14, face=\"bold\"))\n\n##################### for resultXframe_378_SK_Swapped\nresultXframe_378_SK_Swapped$features<-as.factor(as.numeric(rownames(resultXframe_378_SK_Swapped)))\nppframeX<-data.frame(NULL)\nfor (i in 1:5) {\n    FM <- data.frame(resultXframe_378_SK_Swapped[, i], resultXframe_378_SK_Swapped$features,\n                     Methods<-rep(colnames(resultXframe_378_SK_Swapped)[i], nrow(resultXframe_378_SK_Swapped)))\n    ppframeX<-rbind(ppframeX, FM)\n}\ncolnames(ppframeX)<-c(\"Accuracy\", \"Features\", \"Methods\")\nggplot(ppframeX, aes(x=Features, y=Accuracy, colour=Methods, \n                     group=Methods, shape=Methods))+\n    geom_line(position=position_dodge(0.2), lwd=2)+\n    ylim(0.2, 1.0) +\n    geom_point(size=5, position=position_dodge(0.2))+\n    theme(legend.position=\"top\", legend.text=element_text(size=16))+\n    ggtitle(\"Spacekime Swapped-Phases (386 features): Compare ML Forecasting Results\")+\n    theme(\n        axis.text=element_text(size=16),\n        plot.title = element_text(size=18, face=\"bold.italic\"),\n        axis.title.x = element_text(size=14, face=\"bold\"),\n        axis.title.y = element_text(size=14, face=\"bold\"))",
      "line_count": 178
    },
    {
      "section": "ML Data Analytics",
      "code": "showfeatures(fitLASSO_X, chooselambda(cvLASSO_X, 1), 10)\nfeat_5 <-  predict(fitLASSO_X, s = chooselambda(cvLASSO_X, 2, 10), newx = data.matrix(X))\ndf1 <- as.data.frame(rbind(as.numeric(feat_5), Y), \n                     row.names = c(\"Predicted Rank\",\"OA Rank\"))\ncolnames(df1) <- countryNames\ndf1 # View(t(df1))\n\n# Clustering\ncluster5 <- X[, which(colnames(X) %in%\n                        row.names(showfeatures(fitLASSO_X, chooselambda(cvLASSO_X, 1), 10)))]\nrownames(cluster5) <- countryNames # countryinfo\n\n#1. hierarchical clustering\nscaled_cluster5 <- scale(cluster5)\n##deal with NAN values\n#scaled_country<-scaled_country[,which(is.nan(scaled_country[1,])==FALSE)]\ndis_SC5 <- dist(scaled_cluster5)\nH_clust_SC5 <- hclust(dis_SC5)\n\nlibrary(\"factoextra\")\nlibrary(\"FactoMineR\")\nH_clust_SC5 <- eclust(scaled_cluster5, k=5, \"hclust\")\nfviz_dend(H_clust_SC5, rect = TRUE, cex=0.5)\n# fviz_dend(H_clust_SC5, lwd=2, rect = TRUE)\n\n\n# ST 378\ncluster5_378_SK <- X378[, which(colnames(X378) %in%\n                        row.names(showfeatures(fitLASSO_X, chooselambda(cvLASSO_X, 1), 10)))]\nrownames(cluster5_378_SK) <- countryNames # countryinfo\n#1. hierarchical clustering\nscaled_cluster5_378_SK <- scale(cluster5_378_SK)\ndis_SC5_378_SK <- dist(scaled_cluster5_378_SK)\nH_clust_SC5_378_SK <- hclust(dis_SC5_378_SK)\nH_clust_SC5_378_SK <- eclust(scaled_cluster5_378_SK, k=5, \"hclust\")\nfviz_dend(H_clust_SC5_378_SK,rect = TRUE, cex=0.5)",
      "line_count": 36
    },
    {
      "section": "Save Workspace",
      "code": "# Save this entire Computed Workspace as an image:\n\n# save.image(\"C:/Users/dinov/Desktop/Ivo.dir/Research/UMichigan/Publications_Books/2018/others/4D_Time_Space_Book_Ideas/ARIMAX_EU_DataAnalytics/EU_Econ_SpaceKime.RData\")",
      "line_count": 3
    }
  ]
}