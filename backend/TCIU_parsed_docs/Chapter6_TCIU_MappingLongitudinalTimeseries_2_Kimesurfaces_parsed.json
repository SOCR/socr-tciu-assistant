{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.341099",
    "total_sections": 6,
    "total_code_chunks": 26,
    "total_tables": 5,
    "r_libraries": [
      "ExtDist",
      "KernSmooth",
      "MASS",
      "Matrix",
      "R.matlab",
      "TCIU",
      "fields",
      "htmlwidgets",
      "kernlab",
      "parallel",
      "plotly",
      "spatstat"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Complex-Time (Kime) Interpretation of Quantum Mechanics\"\nauthor: \"SOCR (Ivo Dinov, Yueyang Shen)\"\ndate: \"`r format(Sys.time(), '%B %d, %Y')`\"\noutput:\n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 2\n    toc_float:\n      collapsed: false\n      smooth_scroll: true\n    code_folding: hide\n  word_document:\n    toc: true\n    toc_depth: '2'\n  pdf_document:\n    toc: true\n    toc_depth: '2'\nalways_allow_html: true\nsubtitle: \"Mapping Repeated Measurement Longitudinal Data (Time-series) to 2D Manifolds (Kimesurfaces)\"\ntags:\n- DSPA\n- SOCR\n- MIDAS\n- Big Data\nThis [TCIU Section in Chapter 6](https://www.socr.umich.edu/TCIU/HTMLs/Chapter6_TCIU_KimeInterpretation_of_QuantumMechanics.html) extends previous work to show alternative strategies to transform repeated data measurements\nof longitudinal data as 2D parametric manifolds (kimesurfaces). \n\nThere are alternative strategies to map series of repeated longitudinal measurements\ninto *kimesurfaces*, i.e., 2D manifolds parameterized by complex time $\\kappa = t e^{i\\theta}$.\nTypes of such transformations include analytical, numerical, and algorithmic approaches. \nThe selection of an appropriate transform of series of repeated longitudinal measurements \ninto kimesurfaces generally depends on the specific data characteristics \nincluding data density, noise levels, and interpretability needs.\nThe resulting kimesurface can effectively unify repeated time-series into a structured 2D manifold,\nenabling novel subsequent AI modeling and analytics to support gaining\nintuition and insights into the phenomenon's temporal-phase variability.\n\nThere are multiple complementary approaches for mapping repeated time-series (longitudinal\ndata) into a 2D kimesurface, i.e., a manifold parametrized by the kime magnitude and\nphase $(t,\\theta)$, where $t = |\\kappa|$, the usual notion of time, and $\\theta$ \nis an added phase index indexing the repeated samples.",
      "word_count": 241
    },
    {
      "title": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "content": "Analytical transforms of time-series to kimesurfaces provide interpretability \nbut require mathematical tractability.\n\n## Laplace and Fourier Transform Mapping\n\nOne idea is to *mathematically transform* the time-series data $f(t)$\ninto a complex function $F(\\kappa)$ with $\\kappa = t e^{i\\theta}$. \nFor instance, consider the *generalized Laplace transform*, \n$\\mathcal{L}:\\{f\\in L^1(\\mathbb{R}^+)\\} \\longrightarrow \\{F: \\mathbb{C}\\overbrace{\\longrightarrow}^{analytic}\\mathbb{C}\\}$, \nwhich is defined over $\\kappa = t e^{i\\theta}\\in \\mathbb{C}$ by\n\n$$F(\\kappa) = \\mathcal{L}\\{f(t)\\}(\\kappa) = \\int_0^\\infty f(t) e^{-\\kappa t} dt = \\int_0^\\infty f(t) e^{-t^2 e^{i\\theta}} dt,$$\n\nwhere $\\theta$ as a parameter. This maps time-series data to a complex surface, with\n$\\theta$ indexing the repeated longitudinal trials. The output of the Laplace transform\nis a [complex analytic function](https://en.wikipedia.org/wiki/Analytic_function) \nwith suitable decay, which has a convergent power series\nexpansion whose coefficients decompose the function $F$ into its (statistical) *moments.*\nRecall that the standard Laplace transform (LT) of $f(t)$ is \n$\\mathcal{L}\\{f\\}(s) = \\int_0^\\infty f(t)\\,e^{-st}dt$,\nfor $\\mathrm{Re}(s) > 0$.  The LT generalizes to\n\n$$F(\\kappa)\\;=\\;\\int_0^\\infty f(t)\\, e^{-\\kappa\\,t}\\,dt\n\\quad\\text{or}\\quad F(\\kappa)\\;=\\;\\int_0^\\infty f(\\tau)\\,\\kappa^{- \\tau}\\,d\\tau,$$\nwhere $\\kappa = t\\,e^{i\\theta}$ might be treated as the transform variable.  \nHowever, this requires ensuring the integral *convergence* and appropriate \ninterpretation of how $\\kappa\\mapsto t e^{i\\theta}$ factors in.  \n\nAlternatively, we can employ the *Fourier series expansion* \nfor each fixed $t$, expand observations across $\\theta$ into the Fourier coefficients, \n$c_k(t)$, $f(t, \\theta) = \\sum_{k=-\\infty}^\\infty c_k(t) e^{ik\\theta},$ \nwhere $c_k(t)$ are time-dependent coefficients estimated from repeated trials.\n\nIn practice, having a repeated dataset $\\{f_n(t)\\}$, requires transforming each one \n$F_n(\\kappa) = \\int_0^T f_n(t)\\,\\varphi(\\kappa,t)\\,dt$ using some transform kernel\n$\\varphi(\\kappa,t)$.  Then, if the phase $\\theta\\sim\\Phi(t)$ is the experiment index,\nwe gather all $\\{F_n(\\kappa)\\}_{n-1}^N$ and interpret them as sampling \nphase angles in the complex plane. We can also consider a *Fourier transform in time*,\nbut then replace the real frequency $\\omega$ by the phase angle $\\theta$. \n\nAnother alternative is to consider a *Hilbert transform*\napproach to define an *analytic continuation* of the real time series, thereby \nobtaining a phase function for each sample. In many of these transforms, a purely \n*real* time variable is vital as input. Extending *time* to *kime*, \n$t\\to \\kappa = t\\, e^{i\\theta}$ can complicate\nstandard theorems on convergence, hence we need to validate the rigorous \nintegral transforms into a complex domain.\n\n[Many examples of Laplace-transformed time-series are shown in the TCIU Chapter 6 Tutorial](https://www.socr.umich.edu/TCIU/HTMLs/Chapter6_TCIU_Basic_SpacekimePredictiveAnalytics.html).\n\n### Simulated fMRI Time-Series to Kimesurface Example\n\nFirst plot the simulated *On* (stimulus) and *Off* (rest) fMRI time-series at a fixed\nvoxel location $(44,42,33)\\in\\mathbb{R}^3$, along with the averaged (pooled) \nOn and Off signal over all $8$ repeats in the single run (epoch) of $160$ time-points.\n\n\nNext, we'll define and apply the Laplace Transform (LT) and its inverse (ILT) and use them to \nshow the *analytical kimesurface reconstruction*.\n\n\nLet's test the discrete LT using the $\\sin(x),\\cos(x)$ function.\n\n\nCompare the *above numerical calculation of the Laplace Transform* (LT) \nof $f(x)=\\cos(x)$ against the *below kimesurface of the exact analytical* \n(ground truth integration) of the LT of $f(x)=\\cos(x)$, which is \n\n$$F(z)\\equiv \\mathcal{L}(f)(z)\\equiv \\int_0^{2\\pi}f(t)e^{-zt}dt = \\frac{z-e^{-2\\pi z}z}{1+z^2}\\ .$$\n\n\nThe visual agreement between the *exact* and *numerical* calculations of the kimesurface\n$F(z)$ corresponding to the signal $f(x)=\\cos(x)$ can also be checked by \ncomputing the average surface difference as shown below.\n\n\nNext, apply the discrete LT to the *average-On* (`onAvg`) and *average-Off signals* \n(`offAvg`), interpolating from their original size, $n=10$, to a new *supersampled* \nsize $n=200$, and transforming the time support *from* $t\\in[1:10]$\nin increments of $\\Delta t=1$, *to* $t' \\in[0,2\\pi)$, in increments of \n$\\Delta t'=\\frac{n}{n+0.5}\\times \\frac{1}{(200-1)2\\pi}.$\n\nThis *numerical longitudinal data preprocessing* is done purely to establish \nsome homologies in the structure of the *LT domain*, i.e., the input space \nsignals (time-series), and the *LT Range*, i.e., the output space \nmanifold (kimesurface). See the [DSPA2 signal interpolation appendix](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_10_Spatiotemporal_Interpolation.html) to find out how to regularize either \n[regularly (equally-spaced) sampled longitudinal data](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_10_Spatiotemporal_Interpolation.html#21_Regularly_spaced_sample) or \n[*irregularly* (unequally-spaced) sampled longitudinal data](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_10_Spatiotemporal_Interpolation.html#22_Irregularly_spaced_sample).\n\n\nFinally, we generate a synchtonized 3D scene plot showing the ON and OFF fMRI kime-surfaces\nalong with their difference (ON - OFF) fMRI kimesurface.\n\n\n## Wavelet transform\n\nFor the *continuous wavelet transform (CWT)* in our kime framework, given a *mother wavelet*\n$\\psi(t)$, we can define a complex kime-wavelet by $\\psi_{\\kappa}(t) = \\psi(t)e^{i\\theta}$,\nwhere $\\kappa = te^{i\\theta}$ is kime.\nThe CWT of a time-series signal $x(t)$ with respect to our kime-wavelet is\n$$W_x(a,\\kappa) = \\frac{1}{\\sqrt{|a|}} \\int_{-\\infty}^{\\infty} x(t)\\psi^*\\left(\\frac{t-\\tau}{a}\\right)e^{-i\\theta}dt ,$$\nwhere $a$ is the *scale parameter*, $\\tau$ is the *translation parameter*, $\\psi^*$ is \nthe *complex conjugate of the mother wavelet*, and $\\theta$ is the *kime-phase.*\n\nThe `R` example below uses synthetic sample data (simulation) with multiple frequency\ncomponents, $f(t)=\\sin(2\\pi t) + 0.5 \\sin(2\\pi 3 t) + N(\\mu=0, \\sigma= 0.2)$, \nto demonstrate the use of the *Morlet mother wavelet*, $e^{-t^2/2} \\cdot e^{i  \\omega_o  t}$,\nto implement the kime-wavelet transform with the phase parameter, $\\omega_o$. It computes the CWT\nacross different scales and phases and creates a 3D visualization using `plotly()`.\nIn this implementation, the scale-phase relationship is represented via the \nthe wavelet transform capturing multi-scale features, The phase $\\theta$ \nmodulates the complex oscillation and jointly they form a kimesurface in the \n$(t, \\theta, scale)$ space. The analysis shows the time-frequency localization \nthrough wavelets, phase-dependent feature extraction, and scale-dependent resolution.\n\nThis example animates the kimesurface in 3D across scales encoding \n\n 1. *Time* $t$ as radial distance in polar coordinates $x = t\\cos(\\theta), y = t\\sin(\\theta)$,\n 2. *Phase* $\\theta$ as angular direction (sampled from a Laplace distribution for directional bias),\n 3. *Scale* $a$ as animation frames (controlled by a slider),\n 4. *Wavelet Magnitude* $|W_x(a, \\kappa)|$ as surface height.\n\nEach frame of the animation represents a *scale-specific kimesurface*, illustrating\nthe *frequency localization*. At smaller scales, e.g., $a=1$, high-frequency components \n(3Hz in the signal) dominate and show visibly as sharp peaks.\nThe *phase modulation*, in this case Laplace prior distribution for $\\theta$,\ncreates asymmetric angular patterns, highlighting phase-dependent signal features.\nThe *scale evolution*, controlled by the slider moves from low to larger scales, \ne.g., $a=32$, low-frequency components (1Hz) emerge as smoother, broader peaks.\n\nIn this visualization *multi-scale analysis* identifies scales that capture dominant\nsignal components. *Phase-sensitive detection* shows how phase randomization via $\\Phi(t)$\naffecting feature prominence. And finally, *noise discrimination* distinguishes true signal \ncomponents (persistent across scales) from transient noise.\nWhile the *first 3D scene* shows the kimesurface color-coded by its intensity,\nthe *second 3D plot* utilizes enhanced directional phases to highlight the phase \neffect by color-coding the surface with phase angles.\n\n\nIn the above simulation, we actually only used a *single (simulated) time-series*, \n$f(t) = \\sin(2\\pi t) + 0.5\\sin(2\\pi 3t) + rnorm(N, sd = 0.2)$, to show the wavelet \ntransform surfaces across scales. In practice, we have a number of repeatedly measured \ntime-series, $\\{f_i(t)\\}_i$ and need to reconstruct a single kimesurface \ncorresponding to the entire collection of time-series. In essence, the sequences of \n1D time-series are mapped onto a 2D parametric manifold indexed by the ordered \ntime ($t$) and the stochastic phase ($\\theta$), randomly drawn from a prior phase distribution.\n\n[Many additional examples of wavelet-constructed kimesurfaces are shown in the TCIU Chapter 6 Tutorial](https://www.socr.umich.edu/TCIU/HTMLs/Chapter6_TCIU_Basic_SpacekimePredictiveAnalytics.html).\n\n\n## Kimesurface as an Ensemble Manifold\n\nTo represent *multiple repeated time-series* as a single *kimesurface* \nparameterized by the *time* $t$ and the stochastic *phase* $\\theta \\sim \\Phi(t)$, \nwe need to integrate all signals into a unified 2D manifold using the *Laplace* \nphase prior and an *ensemble-based integral transform*.\n\nWe want to have the kimesurface represent the *aggregated behavior* of all \nrepeated time-series, where *time* $t$ is the radial coordinate in polar space \n$x = t \\cos\\theta $, $y = t \\sin\\theta$, where the *phase* $\\theta$,\ndrawn from a Laplace distribution, is the angular coordinate, and the \nkimesurface *magnitude* $z$ encodes the expected signal value at \n$(t, \\theta)$, derived from the ensemble.\n\n\n\nThis alternative (ensemble) approach is compared to the earlier strategy in this table.\n\nThe ensemble constructed kimesurface shows how the phase shifts (from Laplace noise) \naffect the $1Hz$ component’s alignment, while the $3Hz$ component remains stable.\nNoise suppression is achieved via kernel smoothing, which averages out Gaussian noise\nand reveals more stable (true?) signal structure.\nThe kime manifold topology exhibits radial ridges corresponding to *time-localized events*,\nwhile the angular variations reflect the underlying phase uncertainty.\n\nThis ensemble kimesurface representation may support subsequent time-frequency analysis\nusing wavelets to compute the *scale-phase energy density*.\nThe intensities of these ensemble kimesurfaces, $z(t, \\theta)$ represents \n*multi-scale energy* combining wavelet and phase analysis.\n\n\nBy treating $\\theta$ as a stochastic coordinate (e.g., Laplace-distributed)\nand aggregating over repeated measurements, the ensemble kimesurfaces\nmay be useful for visualizing *phase-sensitive signal components*,\nfor characterizing *noise resilience* across trials, and for identifying \n*time-localized phenomena* in longitudinal studies.\n\nThe 3D ensemble kimesurface array structure handles the (scales, $\\theta$, time) dimensions.\nThe ensemble averaging aggregates across repeated trials and scales and the \nphase randomization values ($\\theta\\sim Laplace$ model) represent\nthe stochastic phase variability.\n\nThe surface geometry reflects a radial direction $(X/Y)$ encoding time ($t$) and \nphase ($\\theta$). The height ($Z$) is the expected wavelet magnitude across trials\nand the phase sensitivity is due to the Laplace-distributed phases, creating\nasymmetric \"streaks\" showing likely phase alignments. Stable features \n(e.g., $3Hz$ component) remain consistent across $\\theta$. the multi-trial robustness\nof hte ensemble kimesurface consruction is due to cancellation of Gaussian noise \nduring the ensemble averaging, which may suggest that the true signal components\npersist across trials.",
      "word_count": 1504
    },
    {
      "title": "Stochastic Gaussian Process (SGP) Kimesurface Modeling",
      "content": "We can model the kimesurface as a *stochastic (Gaussian) process (SGP)* indexed by $(t, \\theta)$\n\n$$f(t, \\theta) \\sim \\mathcal{GP}\\left(\\mu(t), K\\left((t, \\theta), (t', \\theta')\\right)\\right),$$\nwhere the *covariance kernel* $K$ combines time and phase dependencies (e.g., product of a squared-exponential kernel in $t$ and a periodic kernel in $\\theta$).\n\nLet's demonstrate an example of a stochastic (Gaussian) process (*GP model*) for \naggregating a collection of *repeated fMRI time-courses* as *kime-surfaces*. \nThe *input* is multiple repetitions of simulated fMRI data representing multiple \nrepeated samples including multiple participants (e.g., $n=15$) undergoing the \nsame fMRI/BOLD event-related block design of ON vs. OFF finger-tapping stimulus, \nand for each participant using multiple runs (e.g., $m=20$). For simplicity we \nonly focus on on a single brain location, ignoring the brain spatial localization. \nThe *output* is a pair of kime-surfaces, one corresponding to the aggregated ON \n(stimulus) condition from the stochastic (Gaussian) process model and the other \nfor the OFF (rest) condition.\n\nThe fMRI simulation models the fMRI BOLD responses using canonical HRF (hemodynamic response function).\nIt simulates block design (ON/OFF finger-tapping stimulus/rest conditions) with $30s$ blocks\nand includes participant-specific *noise* and *drift*.\nFor a *kime pair*, $\\kappa=(t,\\theta), \\kappa'=(t',\\theta')$ the *kime-kernel*\n\n$$K((t,\\theta),(t',\\theta')) = \\sigma_t^2 e^{-\\frac{(t-t')^2}{2l_t^2}} \\times \\sigma_\\theta^2 e^{-\\frac{2\\sin^2(|\\theta-\\theta'|/2)}{l_\\theta^2}}$$\nincludes a *squared-exponential (time)* capturing temporal correlations in the BOLD responses\nand a *periodic (phase)* modeling phase relationships using a Laplace-distributed phases.\n\nThe SGP model kimesurface construction aggregates data across participants and runs,\nuses [Cholesky decomposition](https://en.wikipedia.org/wiki/Cholesky_decomposition)\nfor efficient GP computation, and maintains polar coordinate parameterization $(t,\\theta)$.\nVisualizing the *ON condition kimesurface* shows stimulus-locked responses with \ncharacteristic HRF shape and the *OFF condition kimesurface* displays baseline \nfluctuations and noise structure. The radial patterns indicate time-locked responses\nand hte angular variations show phase-dependent modulation.\n\nCompared to *traditional fMRI analyses*, a *phase-sensitive spacekime analysis*\nincorporates phase randomization through Laplace prior. Multi-subject integration\nof the kimesurface representation naturally combines data from multiple participants and runs,\ni.e., repeated experimental evidence. For uncertainty quantification, the full \ncovariance structure captures the complete response variability. \nFinally, non-stationary GP modeling handles *drifts* and *noise correlations* explicitly.\n\n## Basic GP Model\n\nA first generation, oversimplified but computationally efficient SGP model is demonstrated below.\n\n\nThe 3D visualization below shows the simple rendition of the \n*raw simulated fMRI On/Off data* without any processing. Note the extreme level of noise,\ni.e., low signal to noise ration (SNR) in the fMRI data. One of the axis ($y$)\nis a proxy of the kime-phase, indexing the repeated runs within a participant\nand the multiple samples across participants.\n\n\nClearly, these over-simplified approaches do not yield insightful kimesurface\nrepresentations, and hence, we will next explore more elaborate kimesurface\nconstructions from repeated time-series observations.\n\n## Advanced Hierarchical SGP Model\n\n### Time-dynamic Phase Distributions\n\nLet's demonstrate time-dynamic phase priors using the the example of \n*1-parameter Laplace distribution* where the *longitudinal*\nparameter is time $t$. As phase distributions are symmetric, we typically model\nthe scale parameter $b=b(t)$ as a function of time, while fixing the location \nparameter $\\mu=0$. The 1-Parameter Laplace Distribution (Time-Dependent Scale)\nprobability density function (PDF) is\n$f(x \\mid t) = \\frac{1}{2b(t)} \\exp\\left(-\\frac{|x|}{b(t)}\\right).$\n\nThe time-dependent scale $b(t) > 0$ controls the spread/variance over time and\nthe fixed location $\\mu = 0$ ensures the process is unbiased.\nThe *mean* is $\\mathbb{E}[X \\mid t] = 0$, the *variance* is \n$\\text{Var}(X \\mid t) = 2b(t)^2$, and the maximum density at $x = 0$, \nwith sharpness inversely proportional to $b(t)$.\n\nSuppose we model phase angles $\\theta(t)$ in a kime-surface framework, \nwhere phase variability increases linearly with time\n$b(t) = b_0 + \\alpha t$, where $b_0$ is the *initial scale* (constant)\nand $\\alpha$ is the *rate of scale increase* (constant).\nThen, the PDF becomes\n$f(\\theta \\mid t) = \\frac{1}{2(b_0 + \\alpha t)} \\exp\\left(-\\frac{|\\theta|}{b_0 +\\alpha t}\\right).$\n\nThe example below utilizes a Laplace PDF with time-dependent scale, however, other\nmore elaborate kime-phase distributions that explicitely introduce\ntime-phase relations can similarly be implemented and tested.\n\n\nTo generalize for non-zero location we can replace $|x|$ with \n$|x - \\mu(t)|$. For discrete-time processes, replace $t$ with \n$t_i$ for timesteps $i = 1, 2, 3, \\dots$.\nThis formulation preserves the Laplace distribution's characteristic sharp peak\nand heavy tails while allowing the spread to evolve dynamically with time.\n\nTo enhance the complexity and biological plausibility of the kimesurface construction\nfor repeated fMRI time-series, we can refine the Gaussian Process (GP) framework\nto include domain-specific modifications.\nA biophysical kernel may replace the simplistic product kernel we used in the basic model\nabove. Here we will utilize a *biophysically informed composite kernel*\n\n$$\\underbrace{K\\left(\\overbrace{(t,\\theta)}^{\\kappa},\n\\overbrace{(t',\\theta')}^{\\kappa'}\\right )}_{composite\\ kernel} = \n\\underbrace{K_{\\text{HRF}}(t,t')}_{HRF\\ temporal\\ kernel} \\times\\  \n\\underbrace{K_{\\theta}(\\theta,\\theta')}_{phase\\ kernel} \\ \n+ \\underbrace{K_{\\text{noise}}(t,t')}_{physio\\ noise\\ kernel},$$\nwhere the *HRF-Derived Temporal Kernel*\n$$K_{\\text{HRF}}(t,t') = \\sigma_{\\text{HRF}}^2 \\text{HRF}(t) \\cdot \\text{HRF}(t') \n\\cdot e^{-\\frac{(t-t')^2}{2l_{\\text{HRF}}^2}}$$\ncaptures hemodynamic response shape and temporal correlations. \n\nThe *phase-amp coupling kernel*\n$$K_{\\theta}(\\theta,\\theta') = \\sigma_{\\theta}^2 \\left(1 + \\cos(\\theta - \\theta')\\right)\n\\cdot e^{-\\frac{|\\theta - \\theta'|}{b_{\\text{Laplace}}}}$$\ncombines the Laplace phase prior (via exponential term) and periodic coupling.\nAlternatively, we can use a *periodic phase kernel* with $2\\pi$-periodic component \nenhancing hte  phase-dependent modulation\n$$K_\\theta(\\theta, \\theta') = \\exp\\left(-\\frac{2\\sin^2(|\\theta-\\theta'|/2)}{l_\\theta^2}\\right).$$\n\nAnd finally, the *physiological noise kernel*\n$$K_{\\text{noise}}(t,t') = \\sigma_{\\text{AR}}^2 \\rho^{|t-t'|} + \n\\sigma_{\\text{white}}^2 \\delta_{tt'}$$\nrepresents an $AR(1)$ process for low-frequency *drift* and Gaussian *white noise*.\n\nThe expected kimesurface characteristics include *temporal complexity*, e.g., \ndouble-peaked responses from HRF kernel with post-stimulus undershoot, \n*phase modulation*, e.g., asymmetric angular patterns from Laplace-phase periodic coupling,\nand *hierarchical texture*, e.g., fine-scale variations from preserved individual differences.\nNote that for computational efficiency specialized linear matrix computing\nlibraries are used for sparse hierarchical GP inference ($O(n \\log(n))$ complexity vs. \n$O(n^3)$ for exact SGP modeling). Further calibration of the kernel parameters \nusing empirical Bayes may be accomplished by using `inla.hyperpar(result)`, i.e., \n*INLA (Integrated Nested Laplace Approximations)* estimate the hyperparameters from \nthe data itself.\n\nA recipe for parameter tuning is shown in this table.\n\nIn practice, there should be distinct differences between the *ON Condition*, e.g.,\nradial coherence in HRF-shaped responses, and *OFF Condition*, e.g.,  random angular \npatterns with lower amplitude. This framework moves beyond simplistic averaging to model the multi-scale, \nmulti-participant nature of fMRI data while respecting its biophysical constraints.\n\n\nThis SGP model implementation provides a principled framework for analyzing repeated \nneuroimaging experiments while maintaining phase-time relationships in a \ngeometrically meaningful space. The simulation can be further improved and enhanced by using\n\n 1. *sparse GP approximations* inducing points for large datasets\n 2. *hierarchical modeling* adding participant-level random effects\n 3. *dynamic phase distributions* extending the phase priot to a time-dependent $\\Phi(t)$\n 4. *Bayesian inference* sampling from the posterior predictive probability distribution using Stan/TensorFlow probability.\n\nThe key is that the plotting function expects a *rectangular grid* in `(time × phase)`.\nThat means you need a *2D matrix* of predictions of shape $[n_{\\text{time}}, n_{\\theta}]$, \nand a *data frame* `grid` with numeric columns `t` and `theta` that represent the same rectangular product $\\{t_i\\}\\times\\{\\theta_j\\}$. \n\n\n\n### Time-Dependent Laplace $\\theta(t)$ Modeling\n\nWhen we model each time point as corresponding to a *different* random draw $\\theta_i\\sim\\mathrm{Laplace}(0,b_0+\\alpha t_i)$, we lose the \nstandard *rectangular* grid, $(t,\\theta)$. Then, we can still fir a SGP \nwith an *elementwise* 2D kernel, but the result is just a vector of predictions \nof length `n_time` (one $\\theta$ per $t$), which is *not* a regular \n$(t,\\theta)$ surface that `visualize_kimesurfaces_triple()` can slice with `outer(...)`.  \nHence the simplest approach to display the 3D scenes with the kimesurfaces is to \ndefine a *full* 2D grid in $time\\times\\theta$, as shown in the example above.\nTo account for random $\\theta$ draws, we can sample them *once*, using\nthe same set of $\\theta$ for each time to form a rectangular mesh for the plotting logic.\n\nThe function `construct_kimesurface_2D(...)` generates a rectangular $(t,\\theta)$ grid\nas a 2D matrix of predictions, and a data frame `grid` with numeric `t, theta`,\nwhich can be displayed with `visualize_kimesurfaces_triple(...)`.  \n\n### Fourier k-Space Kime-surface Constructon\n\nLet's show a kimesurface construction using time-dependent phases, $\\theta \\sim \\Phi(t)$, \ni.e., random draws from Laplace distribution. This will yield an *irregularly sampled*\nkime-surface intensity values at locations $(t_i, \\theta(t_i, run_j))$, which represent\nall observed experimental runs (i.e., repeated fMRI measurements across time). \nThe irregularly sampled kime-surface values at these 2D (time, phase) coordinates \nrepresent just the actually simulated fMRI intensities at different runs. \nSpecifically, we will explore a pair of complementary strategies for constructing the kime-surfaces. \n\n - The *first approach* (*Strategy A*) interpolates the irregularly sampled intensities in the time domain directly and converts the original irregular 2D coordinates into a regular interpolated grid, which is then used to display the kime-surface using `plot_ly()`. \n - The *second approach*  (*Strategy B*) is to do the entire kime surface reconstruction in the Fourier (frequency) k-space. In this case, we use the Fourier transform to map each of the individual fRMI time-series runs into the Fourier Domain, construct the k-space kimesurface, which again is done by using random Laplace phases and interpolating in the 2D frequency space to resample the surface on a regular 2D grid in k-space. Finally, we use the inverse 2D Fourier transform to maps the k-space kime-surface from k-space back into a kime-surface in the original time domain for analogous visualization.\n\n#### *First approach* (*Strategy A*) Interpolating Irregularly Sampled Data in the Time Domain\n\nIn the example below, the smoothness parameter $\\lambda = 0.001$ plays a pivotal role\nin the kimesurface construction via `interpolate_kimesurface()`, where we use\n*thin plate spline* regression function `Tps()` to interpolate the irregular $(t,\\theta)$\ngrid into a *regular equispace grid.*",
      "word_count": 1535
    },
    {
      "title": "Numerical Strategies",
      "content": "The numerical transforms of time-series to kimesurfaces tend to be more flexible \nbut need careful handling in cases of sparse, incomplete or irregularly-sampled data.\n\n## Strategy A - Interpolating an *irregularly sampled* $(t,\\theta)$ \n\nAssuming time-dependent Laplace phases, the *Strategy-A protocol* includes: \n\n 1. *Simulating* the `ON` and `OFF` fMRI data with multiple runs.  \n 2. For *each* stimulus condition:\n   - Building an *irregular* data frame $\\{(t,\\theta), y\\}$, where each run/time point has a random Laplace-distributed phase $\\theta_{r}(t)$.  \n   - Fitting a *thin-plate spline* (TPS) using the `fields` package for 2D interpolation.  \n   - Evaluating the spline on a *regular* $(t,\\theta)$-grid and storing the result in a structure for `visualize_kimesurfaces_triple()` plotting.  \n 3. *Displaying* both the `ON` and `OFF` surfaces side-by-side and in overlay, using the `visualize_kimesurfaces_triple(...)` function.\n\n\nNext, simulate `ON/OFF` fMRI data, for instance, in this simple example we create two arrays `ON` \n(stimulus) and `OFF` (rest) conditions.\n\n\nWe can expand to a more elaborate simulation with different time signals, HRF modulations, etc.\nUsing irregular $(t,\\theta)$ sampling with a time-dependent Laplace prior.\nNext, we create a function that:\n\n 1. Takes `fmri_data[[condition]]` (shape `[time, 1, runs]`).  \n 2. Aggregates to get a matrix $\\{(t_i, \\text{run}_j)\\} \\to y_{i,j}$.  \n 3. For each `(i, j)`, draws a random $\\theta_{ij}\\sim\\mathrm{Laplace}(0, b_0+\\alpha t_i)$.  \n 4. Returns a data frame with columns `(t, theta, intensity, runID, timeIndex)`.  \n\n\nAs the random phases yield a scatter point-cloud data, we need to employ 2D interpolation\nwith `fields::Tps` to construct a kime-surface approximation over a regular grid for plotting.\nThis process requires\n\n 1. Taking the irregular data frame $(t, \\theta, intensity)$.  \n 2. Fitting a *thin-plate spline* in 2D.  \n 3. Evaluating on a *regular* $(t,\\theta)$-grid of size $(n_t \\times n_\\theta)$.  \n 4. Returning a structure with a “grid” data frame and a 2D matrix `mean`, matching what `visualize_kimesurfaces_triple()` expects.\n\n\nNotice we set `lambda=0.01` to *reduce smoothing* and see more *surface details*.\nIn practice, we can tweak this parameter for *coarser* or *finer* kimesurface detail, as needed.\n\n\nThe 3D graph shows 3 synchronized scenes (ON, OFF, Overlay). Each panel is in \nradial coordinates: $\\bigl(x,y,z\\bigr) = \\bigl(t\\cos\\theta,\\;t\\sin\\theta,\\;\\text{fMRI-BOLD}\\bigr)$.\nBecause we set `alpha=0.02`, the phase-angle distribution can get fairly wide for $t=300$. \nIf the plots looks *overly flat* or *constant*, check if the data has a real difference\nor variation. If it’s pure noise with no $(t,\\theta)$ correlation, a *flat interpolation*\nmight appear. Adjusting the parameter $\\lambda$ controls the the kimesurface smoothness.  \nBigger $\\alpha$ or bigger $\\beta_o$ parameters yield increase of the random angle spread.  \nLarger or smaller `n_time` and `n_runs` may alter the pattern of the constructed kimesurface. \n\n 1. For *irregularly sampled* data over $(t,\\theta)$, each $(time, run)$ pair has a random phase $\\theta_{r}(t)\\sim\\mathrm{Laplace}(0, b_0 + \\alpha t)$. This yields a scattered set of $\\{(t,\\theta)\\}$.  \n 2. *2D Interpolation*: We use the function `fields::Tps()` to get a continuous function $\\hat{f}(t,\\theta)$.  \n 3. *Regular Grid*: We then sample $\\hat{f}$ on a rectangular $(t,\\theta)$-grid and use `visualize_kimesurfaces_triple(...)`  to display the kimesurfaces constructed with `outer(t, cos(theta))`.  \n\n## *Second approach* (*Strategy B*) Interpolating Irregularly Sampled Data in Fourier k-Space\n\nThe next approach involves Fourier-transforming each time-series run $\\{y_{i,j}\\}$ from the \ntime domain to the frequency domain. Construct a 2D *k-space representation* using the random phases $\\theta_j(t)$. Possibly interpolating in $(frequency, phase)$ or $(k, \\theta)$-space.\nInverting the 2D Fourier transform to return to $time \\times phase$ and plotting the resulting\nkimesurface. This requires careful definition of what we are Fourier-transforming, \nbecause the original data are irregular in $\\theta$. \n\nTypically, a Fourier transform is applied to a 1D or 2D function defined on a *regular grid.* \nWhen the time points are uneven or the phase $\\theta$ is random, we encounter a non-uniform\nor irregular FFT (sometimes called NUFFT).\nTo map each observed fMRI run $\\{y_{i,j}\\}$ to the frequency domain requires a 1D transform in time.\nBut the data also varies in $\\theta$, which requires careful handling to incorporate \nthat second dimension in the frequency domain.\nThe 2D Fourier transform $(t,\\theta)\\to (k_t,k_\\theta)$, we still need the data on \na *rectangular grid* $(t,\\theta)$ for the standard 2D FFT, but in reality we have\nan irregular grid because $\\theta_j(t_i)$ is a function of time for each run.\nHence, to do a standard 2D Fourier transform (with `fft` or  `fft2`), \nrequires and interpolation pre-processing of the irregular data onto a regular grid \n$(t,\\theta)$. The protocol involves the following steps.\n\n - Collection of the $(t,\\theta(t),y)$ data from all runs.\n - Interpolation to a uniform grid in $(t,\\theta)$.\n - Application of 2D FFT to that grid on the “k-space” data.\n - A potential need to manipulation or filtering in k-space.\n - And inversion of the 2D FFT back to a uniform $(t,\\theta)$-grid.\n\nThis is reminiscent of how you might do MRI image reconstruction from non-Cartesian k-space data.\nIn MRI, we sample k-space on radial or spiral trajectories, then do gridding or NUFFT\nto get a uniform sampling in k-space. And finally, do an inverse FFT to get the spatial image.\nBy analogy, Strategy-B starts with the “irregularly sampled” data in $(t,\\theta)$ (the real domain),\nwhich is FFT transformed, manipulated, and FFT inverted.\nPotentially we can do *spectral smoothing* or filtering in $(k_t,k_\\theta)$-space\nthat might yield different reconstructions than local interpolation in $(t,\\theta)$.\nWhen the data are naturally periodic or quasi-periodic in time or $\\theta$, \na Fourier approach might be more direct.\n\nWe still need to handle the irregular sampling in $(t,\\theta)$. The standard 2D FFT \nrequires uniform spacing and an interpolation or NUFFT step is required.\nIf $-\\infty < \\theta < \\infty$ (Laplace with unbounded domain), we nay need a finite \ndomain or a periodic assumption to do a standard FFT. Usually we might forcibly \nwrap $\\theta\\in[-\\pi,\\pi)$. A naive approach (interpolate data $\\to$ 2D FFT $\\to$\nmanipulate $\\to$ inverse 2D FFT $\\to$ re-sample) may introduce artifacts.\nThe Fourier (*Strategy B*) can be more powerful if we want to do frequency-based \nfiltering or to exploit strong signal periodicities. \n\nThe *Strategy-B protocol* involves the following steps:\n\n 1. *simulating* multi-run fMRI data with random time-dependent Laplace angles $\\theta_{r,i}$.  \n 2. *collecting* $\\{(t,\\theta_{r}(t), y)\\}$ from each run/time.  \n 3. *interpolating* those scattered points onto a *uniform* $(t,\\theta)$-grid $(t_m,\\theta_n)$.  \n 4. *2D FFT* transforming to k-space, $(k_t, k_\\theta)$.  \n 5. optionally, *manipulateing* or *filtering* the k-space kimesurface.  \n 6. *inverting 2D FFT* to get a reconstructed kimesurface in $(t,\\theta)$.  \n 7. *mapping* $(t,\\theta) \\mapsto (x,y,z)$ with $\\,x = t\\cos(\\theta)$ for 3D plotting.\n\nThis example is intentionally oversimplified. Real pipeline workflowsd may also incorporate \nwindowing (to reduce FFT boundary artifacts), zero-padding, or using a *NUFFT* approach to\navoid the interpolation step. Also, 2D FFT typically assumes *periodicity* in both dimensions,\nbut our real data in time or phase-angles might not be truly periodic.\n\n\nThe resulting `df_on` and `df_off` each have $(80\\times 5)=400$ irregular points in $(t,\\theta)$ with intensities. To perform a *2D FFT*, we need a *rectangular* matrix $\\{Z_{m,n}\\}$ of intensities\nat regular $(t_m,\\theta_n)$. We can do this interpolation with a scattered-data approach \n(e.g., *fields::Tps* or *akima::interp*). The final dimension must be $n_t \\times n_\\theta$.\n\n\nThe base R `fft(..., inverse=TRUE)` does *not* automatically divide by the array size. \nTypically, the true inverse DFT formula is\n$$X_{m,n} = \\frac{1}{MN} \\sum_{k=0}^{M-1}\\sum_{\\ell=0}^{N-1} F_{k,\\ell}\\, e^{2\\pi i (\\dots)}.$$\nSo if we do an inverse transform, we might need to manually divide by $M\\times N$.\nThis function *interpolates* scattered data to `(t,theta)` → `Z(t,theta)` and *applies*\na 2D FFT $\\to$ `F(k_t, k_theta)`. Possibly it does a *filter* or manipulation in `F`\nand *inverts* 2D FFT $\\to$ reconstructed `Z_ifft`.\n\n\nUsing the `filter_fraction`, e.g., `filter_fraction=0.3`, we keep only the top $30\\%$\nlargest Fourier coefficients by magnitude, setting others to zero. This is a naive \n“hard thresholding.” Then the inverse transform yields a “smoothed” surface.\nThe next function that takes the output of `construct_kimesurface_fourier(...)`,\nwhich has `t_seq`, `theta_seq`, and a matrix `Z_recon`, and plots it via `plot_ly()`\nin $(x,y,z)$ space\n$$x = t \\cdot \\cos(\\theta),\\quad y = t \\cdot \\sin(\\theta),\\quad z = \\text{intensity}.$$\n\n\n*Periodicity*: A standard 2D FFT treats the domain in both dimensions as if it’s periodic.\nIf the actual time or phase range is not truly periodic, we may see *wraparound artifacts*\nat the edges. Also, in practice, real signals often require windowing or zero-padding.\n\n*Irregular* $\\theta$:  Because each run/time might have a unique $\\theta$, we must \ndo an interpolation to get a uniform $(t_m,\\theta_n)$ grid. This is exactly the same\nproblem we faced in *Strategy A*, but now after we get the uniform grid, we do a *2D FFT*.\nIn real imaging contexts (e.g. fMRI), we can utilize a *NUFFT* (non-uniform FFT) \nwhen the sampling is radial or spiral in k-space.\n\n*Filtering*: In this example, we applied an oversimplified approach -- just\nkeeping the largest Fourier coefficients by magnitude. In practice, we may\nneed a more effective *radial low-pass filtering*, e.g., bandpass-filtering, \nor use a wavelet basis (again with wavelet-shrinkage. The general principle is the same\n-- apply a forward (integral) transform, manipulate, and invert the transform.\n\n*Vizualization*: For aesthetics reasons, in the above example we used a radial \ncoordinate system $(x,y)=(t\\cos\\theta,t\\sin\\theta)$, which yields a *circular-pattern*\nin the $\\theta$-dimension when $\\theta\\in[-\\pi,\\pi)$. When the phase values\ncan go beyond $\\pm \\pi$, there might be bigger circles, helical or negative phases $\\theta$,\nwhich may be fine, as long as we’re consistent.\n\nThis example demonstrates how to incorporate *Fourier* (k-space) ideas for \nthe kimesurface construction. Of course, the problem specifics might \nnecessitate protocol modifications, particularly of how to handle boundaries, \nperiodic assumptions, or advanced non-uniform FFT libraries. \n    \n## Alternative Approaches for Kimesurface Construction\n\n**Radial Basis Function (RBF) Interpolation**: For each time $t$, we can interpolate \nthe observed values $\\{f_n(t)\\}$ at phase angles \n$\\{\\theta_n\\}$ using *circular RBFs*, $f(t, \\theta) = \\sum_{n=1}^N w_n(t) \\phi\\left(|\\theta - \\theta_n|\\right),$  where $\\phi$ is a radial basis function (e.g., von Mises \nkernel for angular smoothness).\n\n**Kernel Smoothing with Adaptive Bandwidth**: We can use *Nadaraya-Watson kernel smoothing*\nto estimate $f(t, \\theta)$\n$$\\hat{f}(t, \\theta) = \\frac{\\sum_{n=1}^N K_t(t - t_n) K_\\theta(\\theta - \\theta_n) f_n(t_n)}{\\sum_{n=1}^N K_t(t - t_n) K_\\theta(\\theta - \\theta_n)},$$\nusig time-adaptive bandwidths to account for $\\Phi(t)$.\n\n**Time-Phase Gridding**: Discretize $(t, \\theta)$ into a grid, \naggregate observations in each cell, and apply *bilinear interpolation* for continuity.\n\n## Stitching Strategy\n\n[In TCIU Chapter 6 Tutorial](https://www.socr.umich.edu/TCIU/HTMLs/Chapter6_TCIU_Basic_SpacekimePredictiveAnalytics.html) we show the simple time-series stitching numerical strategy to construct kimesurface\nrepresentations of fMRI data and other repeated-measurement longitudinal datasets.\nConsider $N$ repeated time-series measurements $\\{x_n(t)\\}_{n=1}^N$, each measured\nover a time interval $t \\in [0,T]$.  Rather than treating these as separate 1D curves,\nwe will embed them in a 2D polar coordinate system $(t,\\theta)$ where the *radial coordinate*\n$t$ is the usual time, and the *angular coordinate* $\\theta_n$ is a direction or\nangle representing the phase index, i.e., the $n$-th repeated measurement.\n\nUsing a uniform assignment of $\\theta$ we can distribute the repeated experiments\nevenly around a circle, e.g. $\\theta_n = \\frac{2\\pi}{N}(n-1)\\in S^1$.  As \n$t\\in\\{0, 1, \\cdots, T\\}$, each time series is a *spoke* or radiating-ray in this polar diagram.  \nAlternatively, given an estimate, or a prior, *phase distribution* $\\Phi(t)$, \nwe can sample phase angles $\\theta_n\\sim\\Phi(t)$ in a more adaptive manner-particularly \nif the variance of $\\theta$ depends on $t$.  \n\nTo construct the kimesurface, for each $n$ and each time $t$, we \nplot $\\bigl(r,\\theta_n\\bigr) \\equiv (t,\\theta_n)$ in polar coordinates, and assign\na measured time-series value, such as $x_n(t)$.  Then, we can visualize the amplitude\nor the value of the kimesurface, $x_n(t)$, as a color, height, or contour on the\n2D kimesurface manifold.  Note that often interpolation between the radial-rays,\ni.e., the stitching spokes at $\\theta_n$), may be necessary to fill the entire \nparametric grid over th4e continuous domain in $\\theta \\in [0, 2\\pi)$.  \n\nThe stiching kimesurface construction is conceptually straightforward\nand works directly from the repeated time-series data.  \nHowever, unless strongly motivated by prior knowledge about how the repeated experiments differ,\nthe phase angles $\\theta_n$ can be quite arbitrary and break the analyticity \nof the kimesurface maps.  The stitching might reveal structure visually, \nbut can obscure deeper relationships unless carefully interpreted.\n\n\n## Using a Phase Distribution $\\Phi(\\theta;t)$\n\nAnother numerical approach enhancing the stitching strategy involves treating\nthe index $\\theta$ not just as a convenient label (measurable quantity) for experiments,\nbut as a *random variable* drawn from $\\Phi(\\theta;t)$. \nSuppose at each real time $t$, we regard the repeated measurements \n$x_1(t), x_2(t), \\cdots, x_N(t)$ as IID draws from some underlying distribution that\ndepends on $\\theta$.  Then $\\theta$ is an unobserved phase parameter that \nmight shift or shape the measurement outcomes.  \n\nA Bayesian or likelihood-based approach expresses the likelihood \n$p\\bigl(x_n(t)\\mid \\theta\\bigr)$ in terms of a prior $\\Phi(\\theta;t)$\nand fits or updates $\\Phi(\\theta;t)$ by maximizing the *posterior* given \nthe repeated datasets.  \nOnce we estimate $\\Phi(\\theta;t)$, we can construct an *expected amplitude function*\n$\\langle x(t,\\theta)\\rangle$, or a pointwise map from $(t,\\theta)$ to data space,\nthat effectively describes how the system behaves if the phase is $\\theta$.  \nThe resulting kimesurface may then be displayed as a 2D parametric manifold \n$\\{(t,\\theta)\\}$ with an *estimated amplitude* or *distribution of amplitudes*, e.g.  \n$x_{\\mathrm{mean}}(t,\\theta)\\;=\\;\\int x\\,p\\bigl(x\\mid t,\\theta\\bigr)\\,dx,$\nor more directly $\\langle x_n(t)\\rangle\\approx f(t,\\theta)$.  \nA Bayesian approach is more principled when we interpret $\\theta$ as a random phase\ninfluencing the time-series. It generates a *data-driven* estimate of $\\Phi(\\theta;t)$,\nthereby removing some arbitrariness in how stitching places each repeated series on the \nstitching-constructed kimesurface manifold.",
      "word_count": 2157
    },
    {
      "title": "Algorithmic Strategies",
      "content": "The algorithmic transforms of time-series to kimesurfaces scale well but \nmay require larger datasets and more computational resources.\n\n - A *Gaussian Process Regression (GPR)* relies on training a *Gaussian process* with a composite kernel (e.g., Matérn kernel in $t$ + periodic kernel in $\\theta$) to predict $f(t, \\theta)$ from sparse observations.\n\n - Alternatively, *Deep Learning with Phase Embedding* trains a *neural network* (e.g., CNN or transformer) to map $(t, \\theta)$ to $f(t, \\theta)$, using phase embeddings and time-series encoders.\n\n - *Manifold Learning with Constraints* applies *UMAP*, *diffusion maps*, or *t-SNE* with constraints to preserve temporal ($t$) and phase ($\\theta$) structure in a 2D latent space.\n\n - *Probabilistic and Statistical Methods*, such as *Bayesian Hierarchical Modeling* treat $\\theta$ as a latent variable with prior $\\Phi(t)$ and infer the posterior kimesurface using *Markov Chain Monte Carlo (MCMC)* or variational inference.\n\n - *Functional Data Analysis (FDA)* represent time-series as functions in a Hilbert space, then use *Karhunen-Loève expansion* to decompose variability into $t$- and $\\theta$-dependent modes.\n\n##  Interpolation and Manifold Learning Approaches\n\n*Manifold learning* may be useful to obtain a direct 2D embedding of repeated \ntime-series in a kime plane. We can collect all data points $\\bigl(t, x_n(t)\\bigr)$\nfor each repeated series $n$ and use a dimensionality reduction method (e.g., *Isomap*, \n\n*Diffusion maps*, *PCA + custom transformations*, UMAP, etc.) to embed them in a 2D manifold.  \nThen, we can post-process the 2D coordinates to interpret one axis as time, the \nother as phase, and possibly identify an angle $\\theta$ that smoothly increments \naround the manifold.  \nUsing *spline or kernel interpolation*, we can define an *approximate* mapping \n$(n,t)\\mapsto (t,\\theta_n)$ and then perform a 2D interpolation of hte observed\nlongitudinal data values to obtain a continuous kimesurface as a function of $(t,\\theta)$.  \nThis is conceptually similar to the stitching approach, but incorporating smoothing\nor weighting across multiple repeated data sets.",
      "word_count": 305
    },
    {
      "title": "Practical aspects",
      "content": "In practice, the implementations of most algorithms may require the following steps.\n\n 1. *Data Alignment*: Normalize time-series to a common time grid establishing direct homologies between all repeated experiments. Let the repeated series be arranged in a 2D array $(n, t)$.  For each $n\\in \\{1,\\cdots,N\\}$ and discrete time index $t_j\\in\\{t_0,\\dots,t_{max}\\}$, we have measurements $x_n(t_j)$.  \n\n 2. *Phase Assignment*: Assign each repetition a phase $\\theta_n \\sim \\Phi(t)$ (fixed or time-varying). For a *Uniform assignment*, $\\theta_n = 2\\pi (n-1)/N$, whereas a *data-driven assignment* relies on prior knowledge or an inferred PDF $\\Phi(\\theta;t_j)$, to sample, or invert to CDF (quantile function) to obtain $\\theta_n(t_j)$.\n\n 3. *Surface Construction*: For analytical or numerical methods, interpolatations or smoothing over $\\theta$ may be necessary at each $t$. For purely algorithmic methods, model training over $(t, \\theta, f(t, \\theta))$ tuples may be required. In the simplest approach, we can treat $\\theta_n$ as constant in $t$ and consider each repeated series is a radial spoke in polar coordinates. Alternatively, we can allow $\\theta$ to vary in time to reflect time-dependent phases from some inference procedure. \n \n 4. *Implementation*: Implement a 2D grid or mesh in $(r,\\theta)$.  At each grid node $(t_i,\\theta_j)$, define or interpolate the data value from the nearest repeated measurement. For large data sets, we can store the kimesurface in a 2D array of size $\\#(t)\\times\\#(\\theta)$.  \n\n 5. *Validation*: Use held-out repetitions to assess surface fidelity. Having a 2D representation, standard data-visualization libraries (plotly, matplotlib, etc.) can be used to display polar-coordinate contour plots, heatmaps, or 3D kimesurface plots.\n \n 6. *Statistical inference* across repetitions utilizing the kimesurface representation is vital at the end. Both parametric an nonparametric inference on $\\Phi$ would be valuable. Assuming $\\theta$ influences the shape of the time series, we can parametrize $\\Phi(\\theta;t)$ as a function and fit it by *maximizing a likelihood* that the repeated samples match the (marginalized) distribution over $\\theta$. If $\\Psi(t,\\theta)$ is an amplitude model, we want repeated draws at real time $t$ to be consistent with $\\Psi(t,\\theta)$ integrated over $\\theta$. Alternatively, we can quantify the uncertainty of each repeated time series subject to noise, assuming the phase $\\theta$ is partially hidden. By modeling that noise, we may estiate a posterior distribution for $\\theta$. The summaries of the posterior distribution can help place each experiment’s data onto the kimesurface. To assess whether the variability among repeated experiments is low-dimensional, we can use PCA or ICA on the time series.  One or two principal components might be interpreted as phase shifts or timing offsets, mapping naturally to $\\theta$ in a 2D domain.\n\n\n\n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 513
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "- Predictive Analytics\n---",
      "row_count": 2
    },
    {
      "section": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "content": "| Original Approach | Improved Ensemble Strategy |\n|------------------------------|-------------------|\n| Single time-series analysis | *Ensemble integration* across repeated measurements |\n| Phase as wavelet parameter | Phase as *stochastic coordinate* (Laplace prior) |\n| Static scale animation | *Static manifold* showing phase-time relationships |",
      "row_count": 5
    },
    {
      "section": "Stochastic Gaussian Process (SGP) Kimesurface Modeling",
      "content": "| *Application*              | *Interpretation*                                      |\n|-------------------------------|--------------------------------------------------------|\n| Time-series noise modeling    | Increasing/decreasing variance over time               |\n| Phase angle distributions     | Time-dependent phase uncertainty (e.g., sensor drift)  |\n| Financial volatility          | Stochastic volatility models                           |\n| Biological rhythms            | Circadian or stimulus-locked phase variability         |",
      "row_count": 6
    },
    {
      "section": "Stochastic Gaussian Process (SGP) Kimesurface Modeling",
      "content": "| *Feature*               | *Biological Rationale*                                                                 | *Impact on Kimesurface*                                      |\n|---------------------------|-----------------------------------------------------------------------------------------|---------------------------------------------------------------|\n| HRF-Informed Kernel       | Matches BOLD response latency/undershoot                                                | Creates characteristic \"double-peak\" temporal patterns         |\n| Laplace-Periodic Phase    | Combines stochastic phase sampling (Laplace) with oscillatory coupling                   | Generates asymmetric angular modulations                       |\n| Hierarchical Structure    | Preserves individual participant/run variability                                         | Adds surface texture from biological variability               |\n| AR(1) + White Noise       | Models physiological (low-frequency) and thermal (high-frequency) noise                 | Realistic noise floor with temporal correlations               |\n| Uncertainty Quantification| $95\\%$ credible intervals via posterior variance                                           | Reveals regions of low signal-to-noise                        |",
      "row_count": 7
    },
    {
      "section": "Stochastic Gaussian Process (SGP) Kimesurface Modeling",
      "content": "| *Parameter*      | *Role*                          | *Adjustment Strategy*                     |\n|---------------------|-----------------------------------|---------------------------------------------|\n| `b` (Laplace)       | Phase diversity                   | Increase for wider phase sampling           |\n| `l_hrf`             | Temporal detail resolution        | Decrease to capture faster HRF dynamics     |\n| `sigma_theta`       | Phase coupling strength           | Increase to enhance angular modulation      |\n| `rho` (AR noise)    | Low-frequency drift correlation   | Decrease to reduce slow signal drifts       |",
      "row_count": 6
    }
  ],
  "r_code": [
    {
      "section": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "code": "# Extract just the On kime-series at voxel (44,42,33), each time-series has 8 repeats!\nlibrary(TCIU)\nlibrary(\"R.matlab\")\nlibrary(plotly)\n\n# Data import\n# pathname <- file.path(\"./test_data\", \"subj1_run1_complex_all.mat\")\nmat1 = readMat(\"./test_data/subj1_run1_complex_all.mat\")\nbigim1 = mat1$bigim[,64:1,,]\nbigim1_mod = Mod(bigim1) # Modulus\n\nonFMRISeries <- \n  bigim1_mod[44,42,33, c(1:10, 21:30, 41:50, 61:70, 81:90, 101:110, 121:130, 141:150)]\n# the corresponding Off kime-series at voxel (44,42,33) will be the temporal complement\noffFMRISeries <- \n  bigim1_mod[44,42,33, -c(1:10, 21:30, 41:50, 61:70, 81:90, 101:110, 121:130, 141:150)]\n\nt_indx <- seq(1, 80, 1) # index of time (not actual time value)\nf_On <- onFMRISeries\nf_Off <- offFMRISeries\n\nvline <- function(x=0, color = \"lightgray\") {\n  list(type=\"line\", y0=0, y1=1, yref=\"paper\", name=\"time break points\", \n       opacity = 0.5, x0=x, x1=x, line=list(color=color))\n}\n\nhline <- function(y = 0, color = \"blue\") {\n  list(type=\"line\", x0=0, x1=1, xref=\"paper\", name=\"intensity break points\",\n       opacity = 0.3, y0=y, y1=y, line=list(color=color))\n}\n\nplot_ly() %>%\n  # On fMRI time-series\n  add_trace(x=t_indx, y=f_On, type=\"scatter\", mode=\"lines\", name=\"On time-series\") %>%\n  # On fMRI time-series\n  add_trace(x=t_indx, y=f_Off, type=\"scatter\", mode=\"lines\", name=\"Off time-series\") %>%\n  # Repeated measurement break points\n  # add_trace(x=c(10,20,30,40,50,60,70,80), y=f_Off, type=\"scatter\", mode=\"lines\", name=\"Off time-series\") %>%\n  layout(title=\"3D fMRI Simulation: On & Off Time-series at Voxel(44,42,33)\",\n         shapes = list(\n           vline(10),vline(20),vline(30),vline(40),vline(50),vline(60),vline(70),vline(80)),\n         legend = list(orientation='h', y=-0.2))\n\n# Compute and plot against each other the Average On and Average Off time-series\nseriesAvg <- function(f=0, period=0) {\n  tempAvg <- rep(0,period)  # initialize avg signal\n  for (i in c(1:period)) {\n    counter =0  #  empirically count the number of repeated samples (here it's 8)\n    for (j in c(1:length(f))) {\n      if (j %% period == i-1) {  # e.g., 159 %% 10 # [1] 9\n        tempAvg[i] = tempAvg[i] + f[j]\n        counter = counter + 1\n      }\n    }\n    tempAvg[i] = tempAvg[i]/counter\n  }\n  return(tempAvg)\n}\n\nperiod <- 10\nonAvg  <- seriesAvg(f=f_On,  period=period) \noffAvg <- seriesAvg(f=f_Off, period=period) \n\nplot_ly() %>%\n  # Average On fMRI time-series\n  add_trace(x=c(1:period), y=onAvg, type=\"scatter\", mode=\"lines\", name=\"On Average\") %>%\n  # On fMRI time-series\n  add_trace(x=c(1:period), y=offAvg, type=\"scatter\", mode=\"lines\", name=\"Off Average\") %>%\n  # Repeated measurement break points\n  layout(title=\n  \"3D fMRI Simulation: On & Off Time-series\\n (averaged over all 8 repeats) at Voxel (44,42,33)\",\n  legend = list(orientation='h', y=-0.2))",
      "line_count": 72
    },
    {
      "section": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "code": "# create the LT\nNuLT = function(datax, datay, inputz, k = 3, fitwarning = FALSE, \n                mirror = FALSE, range = 2*pi) {\n  \n  datax = as.numeric(datax)\n  datay = as.numeric(datay)\n\n  n = length(datax)\n  x1 = n/(n+0.5)*((datax-min(datax))/(max(datax)-min(datax)))*range\n  \n  if(mirror){\n    x1 = c(x1,rev(2*range - x1))/2\n    n = 2*n\n    datay = c(datay, rev(datay))\n    plot(x1, datay)\n  }\n  \n  #generate the coefficients in indefinite integral of t^n*exp(-zt)\n  coef = 1;\n  coefm = as.matrix(coef)\n  for(i in 1:k){\n    coefm = cbind(coefm,0)\n    coef = c(coef*i,1)\n    coefm = rbind(coefm,coef)\n  }\n  # these coefficients ordered by ^0, ^1, ^2, ... in column format\n  \n  # compute 1, z, z^2...,z^k\n  zz = cbind(1,inputz)\n  zt = inputz\n  for (i in 2:k){\n    zt = zt*inputz\n    zz = cbind(zz,zt)\n  }\n  zd = zt*inputz\n  \n  # compute 1, x, x^2...,x^k\n  tx = x1;\n  xm = cbind(1,x1)\n  for (i in 2:k){\n    tx = tx*x1\n    xm = cbind(xm,tx)\n  }\n  \n  \n  # sum over intervals\n  result = 0*inputz\n  ii = 1\n  while(ii+k <= n) {\n    A = xm[seq(ii,ii+k),c(0:k+1)]\n    b = datay[seq(ii,ii+k)]\n    # polyfit might be faster when using polynomial basis, while matrix inverse, `solve()`,\n    # is the more general approach that works for any function basis\n    polyc = as.numeric(solve(A,b))\n\n  \n    #ordered by ^0, ^1, ^2, ... in column format\n    \n    # Enter a new function variable qualityCheck=FALSE\n    # check fit quality; this step can be skipped for speed/efficiency\n    # if (qualityCheck) { .... }\n    \n    if (fitwarning){\n      xx = seq(A[1,2],A[k+1,2],length.out = 100);\n      yy = polyval(rev(polyc),xx)\n      if(max(abs(yy-mean(b)))>2*max(abs(b-mean(b)))){\n        print(c(\"Warning: Poor Fit at \",ii,\", Largest Deviation is\",\n                max(abs(yy-mean(b)))))\n        print(c(\"Spline Polynomial is\", polyc),3);\n        #print(c(polyval(rev(polyc),A[,2]),b))\n        plot(xx, yy, main=\"Polynomial fit\", ylab=\"\", type=\"l\", col=\"blue\")\n        lines(A[,2],b, col=\"red\")\n        legend(\"topleft\",c(\"fit\",\"data\"),fill=c(\"blue\",\"red\"))\n        print(\" \")\n      }\n    }\n    \n    # Use vector/matrix operations to avoid looping, \n    # some of the expressions look weird\n    # May need to actually compare the efficiency/speed of\n    # vector based vs. standard numeric calculations\n    \n    m1 = t(t(polyc*coefm)*A[1,])\n    m11 = as.numeric(tapply(m1, col(m1)-row(m1), sum))[0:k+1] \n    \n    m2 = t(t(polyc*coefm)*A[k+1,])\n    m22 = as.numeric(tapply(m2, col(m2)-row(m2), sum))[0:k+1]\n    \n    intgl = (exp(-inputz*A[1,2])*colSums(t(zz)*m11)-\n               exp(-inputz*A[k+1,2])*colSums(t(zz)*m22))/zd\n    result = result+intgl\n    ii=ii+k\n  }\n  \n  # Computations over the last interval\n  if(ii < n){\n    nk = n-ii;\n    A = xm[seq(ii,ii+nk),c(0:nk+1)]\n    b = datay[seq(ii,ii+nk)]\n    nc = as.numeric(solve(A,b))\n    nc = c(nc,seq(0,0,length.out = k-nk))\n    \n    A = xm[seq(ii,ii+nk),]\n    m1 = t(t(nc*coefm)*A[1,])\n    m11 = as.numeric(tapply(m1, col(m1)-row(m1), sum))[0:k+1]\n    \n    m2 = t(t(nc*coefm)*A[nk+1,])\n    m22 = as.numeric(tapply(m2, col(m2)-row(m2), sum))[0:k+1]\n    \n    # cc = colSums(coefm*polyc)\n    intgl = (exp(-inputz*A[1,2])*colSums(t(zz)*m11)-\n               exp(-inputz*A[nk+1,2])*colSums(t(zz)*m22))/zd\n    result = result+intgl\n  }\n  #offset = 0.05*pi\n  #result = result+datay[n]*(exp(-2*pi*inputz)-exp(-(2*pi+offset)*inputz))/inputz\n  return(result)\n}",
      "line_count": 118
    },
    {
      "section": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "code": "datax = seq(1,200)\n\nn = length(datax)\n\nx1 = n/(n+0.5)*((datax-min(datax))/(max(datax)-min(datax)))*(2*pi)\n\ndatay = cos(x1)  # test function!!!\n\nLout = 61\nrange_limit <- 20\nx2 <- seq(from = 0.1, to = range_limit, length.out = Lout)\ny2 <- seq(from = 0, to = range_limit, length.out = Lout)\n\nx2_g = x2 %o% seq(1,1, length.out = Lout)    \ny2_g =  seq(1,1, length.out = Lout)%o%y2 \nz2_grid = x2 %o% y2\n\nargz = as.vector(x2_g + 1i*y2_g)\nLTz = NuLT(x1, datay, argz)\nrec1 = matrix(LTz,nrow = Lout)\n\nrecm = abs(rec1)\nrecr = Re(rec1)\nreci = Im(rec1)\nph = reci/recm\nsurf_color <- atan2(reci,recr)\n# colorscale = cbind(seq(-pi, pi, by=1/10, rainbow(11)))\np <-  plot_ly(hoverinfo=\"none\", showscale = TRUE) %>%\n    add_trace(x = x2_g, y = y2_g, z = surf_color, \n    # F-magnitude or Re(F),   # z = Im(z2_grid),  # Real or Imaginary part of F(t)\n          surfacecolor=log(recm), # colorscale=colorscale, #Phase-based color\n          type = 'surface', opacity=1, visible=T) %>%\n  layout(title = \n    \"Truncated Laplace transform of cos(x), Color = Mag(Z)\", \n         showlegend = TRUE,\n         scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1.0), \n              xaxis=list(title= \"Real=Re(z)\"), yaxis=list(title = \"Imaginary=Im(z)\"),\n              zaxis=list(title= \"Z = tan-1(Im(L[f](z))/Re(L[f](z))))\")) ) # 1:1:1 aspect ratio\np",
      "line_count": 39
    },
    {
      "section": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "code": "z_val <- (x2_g+y2_g*1i)\nground_truth <- (z_val - exp(-2*pi*z_val)*z_val)/(1+z_val^2)\nsurf_ground_truth <- atan2(Im(ground_truth),Re(ground_truth))\nplot_ly(hoverinfo=\"none\", showscale = TRUE) %>%add_trace(x = x2_g, y = y2_g, z = surf_ground_truth,surfacecolor=log(abs(ground_truth)),type = 'surface', opacity=1, visible=T)%>%layout(title = \n    \"Ground Truth for the truncated Laplace transform of cos(x), Color = Mag(Z)\",scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1.0), \n              xaxis=list(title= \"Real=Re(z)\"), yaxis=list(title = \"Imaginary=Im(z)\"),\n              zaxis=list(title= \"Z = tan-1(Im(L[f](z))/Re(L[f](z)))\")) )\n",
      "line_count": 8
    },
    {
      "section": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "code": "print(paste0(\"The average difference between the ground truth and the numerical integration is \",\n             sum(abs(ground_truth -rec1))/length(ground_truth)))",
      "line_count": 2
    },
    {
      "section": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "code": "datax = seq(1,200)\nn = length(datax)\nx_old <- c(1:10)\nx1 = n/(n+0.5)*((datax-min(datax))/(max(datax)-min(datax)))*(2*pi)\n# longitudinal data series are: onAvg & offAvg\nxnew <- x1\nspl_onAvg <- spline(x=x_old, y=onAvg, xmin=min(x_old), xmax=max(x_old), n=200)\nspl_offAvg <- spline(x=x_old, y=offAvg, xmin=min(x_old), xmax=max(x_old), n=200)\n\nplot_ly(type=\"scatter\", mode=\"markers\") %>%\n  add_trace(x=x_old, y=onAvg, name=\"Raw ON-Avg\", \n            marker=list(size=20, color=\"lightblue\", sizemode=\"area\")) %>%\n  add_trace(x=x_old, y=offAvg, name=\"Raw OFF-Avg\",\n            marker=list(size=20, color=\"orange\", sizemode=\"area\")) %>%\n  add_trace(x=spl_onAvg$x, y=spl_onAvg$y, type=\"scatter\", mode=\"markers+lines\",\n            name=\"Spline ON-Avg Model\", marker=list(size=8, color=\"blue\"),\n            line = list(color = \"blue\", width = 4)) %>%\n  add_trace(x=spl_offAvg$x, y=spl_offAvg$y, type=\"scatter\", mode=\"markers+lines\",\n            name=\"Spline OFF-Avg Model\", marker=list(size=8, color=\"red\"),\n            line = list(color = \"red\", width = 4)) %>%\n  layout(title=\"Spline Modeling of 1D ON and OFF fMRI data\\n (averaged over repeated samples)\",\n         legend = list(orientation = 'h', y=-0.2)) %>%\n  hide_colorbar()\n\n# datay = sin(x1)  # test function!!!\n\n# Define a time-series to kimesurface plotting function\nplotKimeSurface <- function(datay = sin(x1),index=\"\", \n           title=\"Laplace transform of the Time-Series, Color = phase(Z)\") {\n  Lout = 61\n  range_limit <- 20\n  x2 <- seq(from = 0.1, to = range_limit, length.out = Lout)\n  y2 <- seq(from = 0, to = range_limit, length.out = Lout)\n  \n  x2_g = x2 %o% seq(1,1, length.out = Lout)    \n  y2_g =  seq(1,1, length.out = Lout)%o%y2 \n  # z2_grid = x2 %o% y2\n  \n  argz = as.vector(x2_g + 1i*y2_g)\n  # print(argz)\n  LTz = NuLT(x1, datay, argz)\n  rec1 = matrix(LTz,nrow = Lout)\n  \n  recm = abs(rec1)\n  recr = Re(rec1)\n  reci = Im(rec1)\n  ph = reci/recm\n  surf_color <- atan2(reci,recr)\n  # colorscale = cbind(seq(-pi, pi, by=1/10, rainbow(11)))\n  p <-  plot_ly(hoverinfo=\"none\", showscale = TRUE,\n           scene = paste(\"scene\",as.character(index),sep = \"\")) %>%\n      add_trace(x = x2_g, y = y2_g, z = surf_color, \n      # F-magnitude or Re(F),   # z=Im(z2_grid),  # Real or Imaginary part of F(t)\n            surfacecolor=log(recm), # colorscale=colorscale, #Phase-based color\n            type = 'surface', opacity=1, visible=T) %>%\n      layout(title = title, showlegend = TRUE,scene=list(aspectmode=\"manual\", aspectratio=list(x=1, y=1, z=1.0), \n                xaxis=list(title= \"Real\"), yaxis=list(title = \"Imaginary\"),\n                zaxis=list(title= \"Z = phase\")) ) # 1:1:1 aspect ratio)\n  \n  return(list(\"plot\"=p,\"phase\"=surf_color,\"magnitude\"=recm,\"x_grid\"=x2_g,\"y_grid\"=y2_g))\n}\n#paste(\"scene\",as.character(index),sep = \"\")\n# list(aspectmode=\"manual\", aspectratio=list(x=1, y=1, z=1.0), \n#                 xaxis=list(title= \"Real\"), yaxis=list(title = \"Imaginary\"),\n#                 zaxis=list(title= \"Z = log(mag(Lf(x+iy)))\")) ) # 1:1:1 aspect ratio\npOn  <- plotKimeSurface(datay=spl_onAvg$y, \"\",\n           title=\"ON fMRI ((44,42,33): Laplace transform of Avg Time-Series, Color = phase(Z)\")\npOff <- plotKimeSurface(datay=spl_offAvg$y,2, \n           title=\"OFF fMRI ((44,42,33): Laplace transform of Avg Time-Series, Color = phase(Z)\")",
      "line_count": 69
    },
    {
      "section": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "code": "\nlibrary(plotly)\nlibrary(htmlwidgets)\n\n# Generate some example 3D data\n# ... (Create your pOn and pOff plots here)\ndiff_plot <- plot_ly(hoverinfo=\"none\", showscale = TRUE,\n           scene = \"scene3\") %>%\n      add_trace(x = pOn$x_grid, y = pOn$y_grid, z = pOn$phase - pOff$phase, \n      # F-magnitude or Re(F),   # z=Im(z2_grid),  # Real or Imaginary part of F(t)\n            surfacecolor=pOn$magnitude-pOff$magnitude, # colorscale=colorscale, #Phase-based color\n            type = 'surface', opacity=1, visible=T) %>%\n      layout(title = title, showlegend = TRUE,scene3=list(aspectmode=\"manual\", aspectratio=list(x=1, y=1, z=1.0), \n                xaxis=list(title= \"Real\"), yaxis=list(title = \"Imaginary\"),\n                zaxis=list(title= \"Z = Phase\")) )\n# Combine them into a subplot\nmain_plot <- subplot(pOn$plot, pOff$plot,diff_plot) %>%\n  layout(\n    title = \"kimesurfaces (Left: On; Right: Off; Bottom: Kimesurface Difference (On vs. Off))\",\n    scene  = list(domain = list(x = c(0, 0.5), y = c(0.5, 1)), aspectmode = \"cube\"),\n    scene2 = list(domain = list(x = c(0.5, 1), y = c(0.5, 1)), aspectmode = \"cube\"),\n    scene3 = list(domain = list(x = c(0.25, 0.75), y = c(0, 0.5)), aspectmode = \"cube\")\n  )\n#https://stackoverflow.com/questions/77757102/possible-to-synchronize-3d-scatter-plotly-plots-in-r\nmain_plot %>%\n  htmlwidgets::onRender(\n    \"function(x, el) {\n      x.on('plotly_relayout', function(d) {\n        const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n        if (camera.length) {\n          const scenes = Object.keys(x.layout).filter((key) => /^scene\\\\d*/.test(key));\n          const new_layout = {};\n          scenes.forEach(key => {\n            new_layout[key] = {...x.layout[key], camera: {...d[camera]}};\n          });\n          Plotly.relayout(x, new_layout);\n        }\n      });\n    }\")",
      "line_count": 39
    },
    {
      "section": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "code": "# Check the animation frames as 2D heatmaps # image(all_surfaces[[1]]); image(all_surfaces[[3]])\n\nlibrary(plotly)\n\n# 1. Morlet wavelet with correct complex handling\nmorlet_wavelet <- function(t, omega0 = 6) { exp(-t^2/2) * exp(1i * omega0 * t) }\n\n# 2. Robust kimesurface computation\ncompute_kimesurface <- function(signal, t_time, scales, theta_values) {\n  N <- length(signal)\n  dt <- diff(t_time)[1]\n  surfaces <- list()\n  \n  for (scale_idx in seq_along(scales)) {\n    scale <- scales[scale_idx]\n    z_grid <- matrix(0, nrow = length(theta_values), ncol = N)\n    \n    t_wavelet <- seq(-4*scale, 4*scale, by = dt)\n    wavelet_base <- morlet_wavelet(t_wavelet/scale)\n    \n    for (theta_idx in seq_along(theta_values)) {\n      theta <- theta_values[theta_idx]\n      wavelet <- Conj(wavelet_base * exp(1i * theta)) / sqrt(scale)\n      \n      conv_full <- convolve(signal, rev(wavelet), conj = FALSE, type = \"open\")\n      valid_conv <- conv_full[seq_len(N) + max(0, (length(conv_full)-N)/2)]\n      \n      z_grid[theta_idx, ] <- abs(valid_conv[1:N])\n    }\n    surfaces[[scale_idx]] <- z_grid\n  }\n  return(surfaces)\n}\n\n# 3. Generate data\nN <- 100\nt_time <- seq(0, 10, length.out = N)\nsignal <- sin(2*pi*1*t_time) + 0.5*sin(2*pi*3*t_time) + rnorm(N, sd = 0.2)\nscales <- 2^seq(0, 5, length.out = 10)\nn_grid <- 30  # x, and y axes grid size (30 * 30)\n# theta_values <- seq(-pi, pi, length.out = n_grid)   # Uniform phase prior\ntheta_values <- ExtDist::rLaplace(n=n_grid, mu = 0, b = 1) # Laplace prior\n\n######### do we need to order/sort the phases for smooth wavelet kime-surfaces???\n# theta_values <- sort(theta_values)\n###################################\n\n# 4. Compute surfaces\nall_surfaces <- compute_kimesurface(signal, t_time, scales, theta_values)\n\n# 5. Create coordinate grids\nx_grid <- outer(t_time, cos(theta_values), \"*\")\ny_grid <- outer(t_time, sin(theta_values), \"*\")\n\n# 6. Build frames with explicit 0-based indexing\nframes <- lapply(seq_along(scales), function(i) {\n  list(name = as.character(i-1),  # 0-based index for Plotly\n    data = list(list(type = \"surface\",\n      x = x_grid, y = y_grid, z = all_surfaces[[i]])),\n    traces = list(0))\n})\n\n# 7. Initialize plot\nfig <- plot_ly() %>%\n  add_surface(x = x_grid, y = y_grid, z = all_surfaces[[1]], colorscale = \"Viridis\",\n    showscale = TRUE)\n\n# 8. Assign frames directly\nfig$x$frames <- frames\n\n# 9. Configure slider with explicit 0-based frame references\nfig <- fig %>% layout(\n  scene = list(xaxis = list(title = \"X (t·cosθ)\"),\n    yaxis = list(title = \"Y (t·sinθ)\"), zaxis = list(title = \"Magnitude\")),\n  sliders = list(list(active = 0, currentvalue = list(prefix = \"Scale: \"),\n    steps = lapply(seq_along(scales), function(i) {\n      list(args = list(list(i-1),  # 0-based frame index\n          list(mode = \"immediate\", frame = list(duration = 0, redraw = TRUE),\n            transition = list(duration = 0))),\n        label = round(scales[i], 2), method = \"animate\")\n    })\n  )))\n\nfig\n\n# 10. Directional Phase Highlighting to enhance phase interpretation by \n#     color-coding the surface with phase angles\nfig1 <- fig %>% add_surface(\n  x = x_grid, y = y_grid, z = all_surfaces[[1]],\n  surfacecolor = matrix(theta_values, nrow = n_grid, ncol = N),  # Phase-based color\n  colorscale = \"HSV\", cmin = -pi, cmax = pi,\n  colorbar = list(title = \"Phase (θ)\", len = 0.5)\n)\nfig1",
      "line_count": 94
    },
    {
      "section": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "code": "library(KernSmooth)\nlibrary(plotly)\n\n# 1. Compute Kimesurface function remains the same\ncompute_kimesurface <- function(signal, t_time, scales, theta_values) {\n  N <- length(signal)\n  dt <- diff(t_time)[1]\n  n_theta <- length(theta_values)\n  n_scales <- length(scales)\n  \n  cwt_array <- array(0, dim = c(n_scales, n_theta, N))\n  \n  for (scale_idx in seq_along(scales)) {\n    scale <- scales[scale_idx]\n    t_wavelet <- seq(-4*scale, 4*scale, by = dt)\n    wavelet_base <- Conj(morlet_wavelet(t_wavelet/scale)) / sqrt(scale)\n    \n    for (theta_idx in seq_along(theta_values)) {\n      theta <- theta_values[theta_idx]\n      wavelet <- wavelet_base * exp(1i * theta)\n      \n      conv_full <- convolve(signal, rev(wavelet), conj = FALSE, type = \"open\")\n      valid_conv <- conv_full[seq_len(N) + max(0, (length(conv_full)-N)/2)]\n      cwt_array[scale_idx, theta_idx, ] <- abs(valid_conv[1:N])\n    }\n  }\n  return(cwt_array)\n}\n\n# Generate the data\nset.seed(123)  # For reproducibility\nN_series <- 100\nN_time <- 100\nt_time <- seq(0, 10, length.out = N_time)\ntheta_values <- ExtDist::rLaplace(n = N_series, mu = 0, b = 1)\n\n# Generate signals\nsignals <- lapply(theta_values, function(theta) {\n  sin(2 * pi * 1 * (t_time + theta)) +\n    0.5 * sin(2 * pi * 3 * t_time) +\n    rnorm(N_time, sd = 0.2)\n})\n\n# Create phase grid\ntheta_grid <- seq(-pi, pi, length.out = 50)\nbw <- 0.2\n\n# Compute smoothed kimesurface with progress tracking\nkimesurface <- matrix(0, nrow = N_time, ncol = length(theta_grid))\nfor (t_idx in 1:N_time) {\n  t_vals <- sapply(signals, `[`, t_idx)\n  # Use try-catch to handle potential locpoly errors\n  result <- try({\n    locpoly(\n      x = theta_values,\n      y = t_vals,\n      bandwidth = bw,\n      gridsize = length(theta_grid),\n      range.x = c(-pi, pi)\n    )\n  }, silent = TRUE)\n  \n  if (!inherits(result, \"try-error\")) {\n    kimesurface[t_idx, ] <- result$y\n  }\n}\n\n# Transform to polar coordinates\nx_grid <- outer(t_time, cos(theta_grid), \"*\")\ny_grid <- outer(t_time, sin(theta_grid), \"*\")\nz_grid <- kimesurface\n\n# Ensure z_grid has finite values\nz_grid[!is.finite(z_grid)] <- NA\nz_range <- range(z_grid, na.rm = TRUE)\n\n# Create the visualization with explicit colorscale range\np <- plot_ly(\n  x = x_grid,\n  y = y_grid,\n  z = z_grid,\n  type = \"surface\",\n  colorscale = \"Viridis\",\n  cmin = z_range[1],\n  cmax = z_range[2]\n) %>%\n  layout(\n    scene = list(\n      xaxis = list(title = \"X (t·cosθ)\"),\n      yaxis = list(title = \"Y (t·sinθ)\"),\n      zaxis = list(title = \"Signal Magnitude\",\n                  range = z_range),\n      camera = list(\n        eye = list(x = 1.5, y = 1.5, z = 1.5)\n      )\n    ),\n    title = \"Kimesurface Visualization\"\n  )\np",
      "line_count": 99
    },
    {
      "section": "Analytical Transforms of Repeated Time-series into Kimesurfaces",
      "code": "# 1. Compute CWT for each signal\ncwt_list <- lapply(signals, function(s) {\n  scales <- 2^seq(0, 5, length.out = 20)\n  cwt <- compute_kimesurface(s, t_time, scales, theta_grid)\n  colMeans(abs(cwt))  # Average over scales\n})\n\n# Aggregate energy density\nenergy_surface <- apply(simplify2array(cwt_list), 1:2, mean)\n\n# 2: Ensemble Averaging - Compute the kimesurface across all signals and scales:\n# Parameters\nN_series <- 100  # Number of repeated trials\nscales <- 2^seq(0, 5, length.out = 20)\ntheta_grid <- ExtDist::rLaplace(n = 30, mu = 0, b = 1)  # Laplace phases\n\n# Precompute CWT for all signals\ncwt_list <- lapply(1:N_series, function(i) {\n  signal <- sin(2*pi*1*t_time) + 0.5*sin(2*pi*3*t_time) + rnorm(N_time, sd = 0.2)\n  compute_kimesurface(signal, t_time, scales, theta_grid)\n})\n\n# Average across signals and scales\ncwt_ensemble <- apply(simplify2array(cwt_list), 1:3, mean)  # [scales, theta, time]\nkimesurface <- apply(cwt_ensemble, c(2,3), mean)  # Average over scales: [theta, time]\n\n# 3: Visualization\n# Polar coordinates\nx_grid <- outer(t_time, cos(theta_grid), \"*\")  # [time × theta]\ny_grid <- outer(t_time, sin(theta_grid), \"*\")\n\n# Plot\nplot_ly(z = kimesurface, x = x_grid, y = y_grid, type = \"surface\") %>%\n  layout(\n    scene = list(\n      xaxis = list(title = \"X (t·cosθ)\"),\n      yaxis = list(title = \"Y (t·sinθ)\"),\n      zaxis = list(title = \"Ensemble Magnitude\")\n    )\n  )",
      "line_count": 40
    },
    {
      "section": "Stochastic Gaussian Process (SGP) Kimesurface Modeling",
      "code": "library(MASS)\nlibrary(plotly)\nlibrary(htmlwidgets)\nlibrary(kernlab)\nlibrary(parallel)\nlibrary(fields)\nlibrary(ExtDist)\n\n# ----------------------------\n# 1. Simulate fMRI Data\n# ----------------------------\nsimulate_fmri_data <- function(n_participants=15, n_runs=20, tr=2, duration=300) {\n  # Hemodynamic Response Function (HRF)\n  hrf <- function(t) {\n    a1 <- 6; a2 <- 12; b1 <- 0.9; b2 <- 0.9; c <- 0.35\n    t^(a1-1)*b1^a1*exp(-b1*t)/gamma(a1) - c*(t^(a2-1)*b2^a2*exp(-b2*t)/gamma(a2))\n  }\n  \n  # Experimental design parameters\n  n_timepoints <- duration/tr\n  block_length <- 30  # 30s blocks\n  n_blocks <- duration/block_length\n  \n  # Storage arrays\n  data <- list(\n    ON = array(0, dim=c(n_participants, n_runs, n_timepoints)),\n    OFF = array(0, dim=c(n_participants, n_runs, n_timepoints))\n  )\n  \n  # Generate data for each participant and run\n  set.seed(123)\n  for(p in 1:n_participants) {\n    for(r in 1:n_runs) {\n      # Generate block design\n      design <- rep(c(0,1), each=n_blocks/2)\n      hrf_response <- rep(hrf(1:(block_length/tr)), n_blocks) * design\n      \n      # Add participant-specific noise and drift\n      noise <- cumsum(rnorm(n_timepoints, sd=0.1))\n      drift <- 0.01*seq(n_timepoints)\n      \n      # Store responses\n      data$ON[p,r,] <- hrf_response + noise + drift + rnorm(n_timepoints, sd=0.2)\n      data$OFF[p,r,] <- noise + drift + rnorm(n_timepoints, sd=0.2)\n    }\n  }\n  return(data)\n}\n\n# ----------------------------\n# 2. Gaussian Process Kernel\n# ----------------------------\nkime_kernel <- function(t1, t2, theta1, theta2, sigma_t=1, lt=10, sigma_theta=1, ltheta=pi/2) {\n  # Squared-exponential kernel for time\n  k_time <- sigma_t^2 * exp(-(t1 - t2)^2/(2*lt^2))\n  \n  # Periodic kernel for phase (θ)\n  k_phase <- sigma_theta^2 * exp(-2*sin(abs(theta1 - theta2)/2)^2/(ltheta^2))\n  \n  return(k_time * k_phase)\n}\n\n# ----------------------------\n# 3. Construct Kimesurfaces\n# ----------------------------\n# construct_kimesurface <- function(data, condition, theta_samples=30) {\n#   # Aggregate data across participants and runs\n#   aggregated <- apply(data[[condition]], 3, mean)\n#   n_time <- length(aggregated)\n#   \n#   # Phase distribution (Laplace prior)\n#   theta <- ExtDist::rLaplace(theta_samples, mu=0, b=1)\n#   \n#   # Create grid\n#   t_grid <- seq(0, 300, length=n_time)\n#   grid <- expand.grid(t=t_grid, theta=theta)\n#   \n#   # GP Prior\n#   K <- matrix(0, nrow=nrow(grid), ncol=nrow(grid))\n#   for(i in 1:nrow(grid)) {\n#     for(j in 1:nrow(grid)) {\n#       K[i,j] <- kime_kernel(grid$t[i], grid$t[j], grid$theta[i], grid$theta[j])\n#     }\n#   }\n#   \n#   # Add observation noise\n#   K_obs <- K + diag(0.1, nrow(K))\n#   \n#   # GP Posterior\n#   L <- chol(K_obs)\n#   alpha <- solve(t(L), solve(L, aggregated))\n#   \n#   # Posterior mean\n#   post_mean <- K %*% alpha\n#   \n#   return(list(\n#     grid = grid,\n#     mean = matrix(post_mean, nrow=length(t_grid), ncol=theta_samples),\n#     covariance = K\n#   ))\n# }\nconstruct_kimesurface <- function(data, condition, theta_samples=30) {\n  # Aggregate data across participants and runs\n  aggregated <- apply(data[[condition]], 3, mean)\n  n_time <- length(aggregated)\n  \n  # Phase distribution (Laplace prior)\n  theta <- seq(0, 2*pi, length.out=theta_samples)  # Changed to regular grid\n  \n  # Create grid\n  t_grid <- seq(0, 300, length=n_time)\n  \n  # Initialize output matrix directly\n  result_matrix <- matrix(0, nrow=length(t_grid), ncol=theta_samples)\n  \n  # Process each time point separately to avoid memory issues\n  for(t_idx in 1:length(t_grid)) {\n    # Create kernel only for this time point\n    K_t <- matrix(0, nrow=theta_samples, ncol=theta_samples)\n    for(i in 1:theta_samples) {\n      for(j in 1:theta_samples) {\n        K_t[i,j] <- kime_kernel(t_grid[t_idx], t_grid[t_idx], \n                               theta[i], theta[j])\n      }\n    }\n    \n    # Add observation noise\n    K_t <- K_t + diag(0.1, theta_samples)\n    \n    # Compute posterior for this time point\n    L <- chol(K_t)\n    alpha <- solve(t(L), solve(L, rep(aggregated[t_idx], theta_samples)))\n    result_matrix[t_idx,] <- alpha\n  }\n  \n  return(list(\n    grid = expand.grid(t=t_grid, theta=theta),\n    mean = result_matrix,\n    timepoints = t_grid,\n    phases = theta\n  ))\n}\n\n# ----------------------------\n# 4. Visualization\n# ----------------------------\nvisualize_kimesurface <- function(surface, title) {\n  x <- outer(surface$grid$t, cos(surface$grid$theta), \"*\")\n  y <- outer(surface$grid$t, sin(surface$grid$theta), \"*\")\n  \n  plot_ly(x = x, y = y, z = surface$mean, type = \"surface\",\n          colorscale = \"Viridis\") %>%\n    layout(\n      scene = list(\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"BOLD Response\"),\n        camera = list(eye = list(x = 1.5, y = 1.5, z = 1.5))\n      ),\n      title = list(text = title)\n    )\n}\n\n##### Kimesurface Vizualization\nvisualize_kimesurfaces_triple <- function(on_surface, off_surface) {\n  # Helper function to process surface data in chunks\n  process_surface_data <- function(surface) {\n    t_vals <- unique(surface$grid$t)\n    theta_vals <- unique(surface$grid$theta)\n    \n    chunk_size <- 10\n    n_chunks <- ceiling(length(t_vals) / chunk_size)\n    \n    x_all <- y_all <- z_all <- NULL\n    \n    for(i in 1:n_chunks) {\n      start_idx <- (i-1) * chunk_size + 1\n      end_idx <- min(i * chunk_size, length(t_vals))\n      t_chunk <- t_vals[start_idx:end_idx]\n      \n      x_chunk <- outer(t_chunk, cos(theta_vals))\n      y_chunk <- outer(t_chunk, sin(theta_vals))\n      z_chunk <- surface$mean[start_idx:end_idx,]\n      \n      x_all <- rbind(x_all, x_chunk)\n      y_all <- rbind(y_all, y_chunk)\n      z_all <- rbind(z_all, z_chunk)\n    }\n    \n    return(list(x = x_all, y = y_all, z = z_all))\n  }\n  \n  # Process both surfaces\n  on_data <- process_surface_data(on_surface)\n  off_data <- process_surface_data(off_surface)\n  \n  # Reduce resolution for plotting\n  n <- 3  # Use every 3rd point\n  subsample <- function(mat) {\n    mat[seq(1, nrow(mat), n), seq(1, ncol(mat), n)]\n  }\n  \n  # Create the first plot (ON)\n  fig <- plot_ly() %>%\n    add_surface(\n      x = subsample(on_data$x),\n      y = subsample(on_data$y),\n      z = subsample(on_data$z),\n      colorscale = \"Viridis\",\n      showscale = FALSE,\n      name = \"ON\",\n      scene = 'scene1'\n    ) %>%\n    layout(\n      scene = list(\n        domain = list(x = c(0, 0.33), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"BOLD Response\")\n      )\n    )\n\n  # Add the second plot (OFF)\n  fig <- fig %>%\n    add_surface(\n      x = subsample(off_data$x),\n      y = subsample(off_data$y),\n      z = subsample(off_data$z),\n      colorscale = \"Viridis\",\n      showscale = FALSE,\n      name = \"OFF\",\n      scene = 'scene2'\n    ) %>%\n    layout(\n      scene2 = list(\n        domain = list(x = c(0.33, 0.66), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"BOLD Response\")\n      )\n    )\n\n  # Add the third plot (OVERLAY)\n  fig <- fig %>%\n    add_surface(\n      x = subsample(on_data$x),\n      y = subsample(on_data$y),\n      z = subsample(on_data$z),\n      colorscale = \"Viridis\",\n      opacity = 0.7,\n      showscale = FALSE,\n      name = \"ON (overlay)\",\n      scene = 'scene3'\n    ) %>%\n    add_surface(\n      x = subsample(off_data$x),\n      y = subsample(off_data$y),\n      z = subsample(off_data$z),\n      colorscale = \"Portland\",\n      opacity = 0.7,\n      showscale = FALSE,\n      name = \"OFF (overlay)\",\n      scene = 'scene3'\n    ) %>%\n    layout(\n      scene3 = list(\n        domain = list(x = c(0.66, 1), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"BOLD Response\")\n      )\n    )\n\n  # Add final layout settings\n  fig <- fig %>%\n    layout(\n      title = \"Kimesurface Visualization of fMRI ON and OFF Conditions\",\n      showlegend = TRUE,\n      legend = list(x = 0.85, y = 0.1),\n      annotations = list(\n        list(\n          showarrow = FALSE,\n          text = '(ON)',\n          xref = 'paper',\n          yref = 'paper',\n          x = 0.15,\n          y = 0.95,\n          xanchor = 'center',\n          yanchor = 'bottom',\n          font = list(size = 16)\n        ),\n        list(\n          showarrow = FALSE,\n          text = '(OFF)',\n          xref = 'paper',\n          yref = 'paper',\n          x = 0.5,\n          y = 0.95,\n          xanchor = 'center',\n          yanchor = 'bottom',\n          font = list(size = 16)\n        ),\n        list(\n          showarrow = FALSE,\n          text = '(OVERLAY)',\n          xref = 'paper',\n          yref = 'paper',\n          x = 0.85,\n          y = 0.95,\n          xanchor = 'center',\n          yanchor = 'bottom',\n          font = list(size = 16)\n        )\n      )\n    )\n\n  # Add synchronization\n  fig <- fig %>% onRender(\n    \"function(el) {\n      el.on('plotly_relayout', function(d) {\n        const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n        if (camera.length) {\n          const scenes = Object.keys(el.layout).filter((key) => /^scene\\\\d*/.test(key));\n          const new_layout = {};\n          scenes.forEach(key => {\n            new_layout[key] = {...el.layout[key], camera: {...d[camera]}};\n          });\n          Plotly.relayout(el, new_layout);\n        }\n      });\n    }\"\n  )\n\n  return(fig)\n}\n\n# Usage example\nfmri_data <- simulate_fmri_data()\non_surface <- construct_kimesurface(fmri_data, \"ON\")\noff_surface <- construct_kimesurface(fmri_data, \"OFF\")\nvisualize_kimesurfaces_triple(on_surface, off_surface)",
      "line_count": 344
    },
    {
      "section": "Stochastic Gaussian Process (SGP) Kimesurface Modeling",
      "code": "#############################################\n## 5) The triple visualization function\n#############################################\nvisualize_kimesurfaces_tripleREV <- function(fmri_data) {\n  t_min <- 1;     t_max <- dim(fmri_data$ON)[3]\n  th_min<- 1;     th_max<- dim(fmri_data$ON)[1]*dim(fmri_data$ON)[2]\n  \n  t_seq     <- c(t_min:t_max)\n  theta_seq <- c(th_min:th_max)\n  \n  # flatten the repeats within subject over runs (15) and across subjects (20)\n  # into a single dimensions, random sampling for theta,\n  reshapedOn <- matrix(fmri_data$ON, nrow = 15*20, ncol = 150)\n  reshapedOff <- matrix(fmri_data$OFF, nrow = 15*20, ncol = 150)\n  \n  # 2D surface in (t,theta) space\n  fig <- plot_ly() %>%\n    # First: ON\n    add_surface(\n      z = reshapedOn,\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"ON\",\n      scene      = \"scene1\"\n    ) %>%\n    layout(\n      scene = list(\n        domain     = list(x = c(0, 0.33), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"time (t)\"),\n        yaxis = list(title = \"Runs * Participants (θ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    # Second: OFF\n    add_surface(\n      z = reshapedOff,\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"OFF\",\n      scene      = \"scene2\"\n    ) %>%\n    layout(\n      scene2 = list(\n        domain     = list(x = c(0.33, 0.66), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"time (t)\"),\n        yaxis = list(title = \"Runs * Participants (θ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    # Third: Overlay\n    add_surface(\n      z = reshapedOn,\n      colorscale = \"Viridis\",\n      opacity    = 0.5,\n      showscale  = FALSE,\n      name       = \"ON (overlay)\",\n      scene      = \"scene3\"\n    ) %>%\n    add_surface(\n      z = reshapedOff,\n      colorscale = \"Portland\",\n      opacity    = 0.8,\n      showscale  = FALSE,\n      name       = \"OFF (overlay)\",\n      scene      = \"scene3\"\n    ) %>%\n    layout(\n      scene3 = list(\n        domain     = list(x = c(0.66, 1), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"time (t)\"),\n        yaxis = list(title = \"Runs * Participants (θ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    layout(\n      title      = \"Kimesurface Visualization of fMRI ON and OFF\",\n      showlegend = TRUE,\n      legend     = list(x=0.85, y=0.1),\n      annotations= list(\n        list(showarrow=FALSE, text='(ON)',  xref='paper', yref='paper',\n             x=0.15, y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OFF)', xref='paper', yref='paper',\n             x=0.5,  y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OVERLAY)',\n             xref='paper', yref='paper', x=0.85, y=0.95,\n             xanchor='center', yanchor='bottom',\n             font=list(size=16))\n      )\n    ) %>%\n    # Sync the cameras\n    onRender(\"\n      function(el) {\n        el.on('plotly_relayout', function(d) {\n          const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n          if (camera.length) {\n            const scenes = Object.keys(el.layout).filter((key) => /^scene\\\\d*/.test(key));\n            const new_layout = {};\n            scenes.forEach(key => {\n              new_layout[key] = {...el.layout[key], camera: {...d[camera]}};\n            });\n            Plotly.relayout(el, new_layout);\n          }\n        });\n      }\n    \")\n  \n  fig\n}\n\nfmri_data <- simulate_fmri_data()\nfig <- visualize_kimesurfaces_tripleREV(fmri_data)\nfig",
      "line_count": 117
    },
    {
      "section": "Stochastic Gaussian Process (SGP) Kimesurface Modeling",
      "code": "library(plotly)\n\n# Define the time-dependent Laplace distribution function\ndlaplace_time <- function(x, t, b0=1, alpha=0.1) {\n  b <- b0 + alpha * t\n  1 / (2 * b) * exp(-abs(x) / b)\n}\n\n# Generate data\ntimes <- c(0, 5, 10)\nx <- seq(-10, 10, 0.1)\ndf <- data.frame()\nfor(t in times) {\n  y <- dlaplace_time(x, t, b0=1, alpha=0.3)\n  df <- rbind(df, data.frame(x=x, y=y, t=factor(t)))\n}\n\n# Create plotly visualization\nplot_ly() %>%\n  add_trace(\n    data = subset(df, t == \"0\"),\n    x = ~x,\n    y = ~y,\n    name = \"t = 0\",\n    type = \"scatter\",\n    mode = \"lines\",\n    line = list(width = 2),\n    hovertemplate = \"x: %{x:.2f}<br>density: %{y:.4f}<extra>t = 0</extra>\"\n  ) %>%\n  add_trace(\n    data = subset(df, t == \"5\"),\n    x = ~x,\n    y = ~y,\n    name = \"t = 5\",\n    type = \"scatter\",\n    mode = \"lines\",\n    line = list(width = 2),\n    hovertemplate = \"x: %{x:.2f}<br>density: %{y:.4f}<extra>t = 5</extra>\"\n  ) %>%\n  add_trace(\n    data = subset(df, t == \"10\"),\n    x = ~x,\n    y = ~y,\n    name = \"t = 10\",\n    type = \"scatter\",\n    mode = \"lines\",\n    line = list(width = 2),\n    hovertemplate = \"x: %{x:.2f}<br>density: %{y:.4f}<extra>t = 10</extra>\"\n  ) %>%\n  layout(\n    title = list(\n      text = \"Time-Dependent Laplace Distributions\",\n      x = 0.5,\n      xanchor = \"center\"\n    ),\n    xaxis = list(\n      title = \"x\",\n      zeroline = TRUE,\n      gridcolor = \"rgb(235, 235, 235)\"\n    ),\n    yaxis = list(\n      title = \"Density\",\n      zeroline = TRUE,\n      gridcolor = \"rgb(235, 235, 235)\"\n    ),\n    hovermode = \"closest\",\n    showlegend = TRUE,\n    legend = list(\n      x = 0.85,\n      y = 0.95\n    ),\n    plot_bgcolor = \"rgb(255, 255, 255)\",\n    paper_bgcolor = \"rgb(255, 255, 255)\"\n  )",
      "line_count": 74
    },
    {
      "section": "Stochastic Gaussian Process (SGP) Kimesurface Modeling",
      "code": "# library(MASS)\n# library(plotly)\n# library(htmlwidgets)\n# library(kernlab)\n# library(Matrix)\n# library(parallel)\n# \n# # -------------------------------------------------\n# # 1. Simplified GP Inference for Kimesurfaces\n# # -------------------------------------------------\n# construct_kimesurface <- function(data, condition, theta_samples=30) {\n#   # Aggregate data across participants and runs\n#   aggregated <- apply(data[[condition]], 3, mean)\n#   n_time <- length(aggregated)\n#   \n#   # Phase sampling with Laplace prior\n#   theta <- ExtDist::rLaplace(theta_samples, mu=0, b=0.8)\n#   t_grid <- seq(0, 300, length=n_time)\n#   \n#   # Design matrix: [time × theta]\n#   design <- expand.grid(t=t_grid, theta=theta)\n#   \n#   # Biophysical kernel matrix\n#   K <- kernelMatrix(\n#     function(x1, x2) {\n#       biophysical_kernel(\n#         x1[1], x2[1], x1[2], x2[2],  # t1, t2, theta1, theta2\n#         hrf(x1[1]), hrf(x2[1]))}, \n#     as.matrix(design))\n#   \n#   # Add noise to diagonal\n#   diag(K) <- diag(K) + 0.1\n#   \n#   # GP regression\n#   # model <- gausspr(K, aggregated, kernel=\"matrix\", variance.model=TRUE)\n#   model <- gausspr(K, aggregated, kernel=\"rbfdot\", variance.model=TRUE)\n#   \n#   return(list(\n#     grid = design,\n#     mean = matrix(predict(model)), \n#     covariance = K\n#   ))\n# }\n# \n# # -------------------------------------------------\n# # 2. Revised Biophysical Kernel\n# # -------------------------------------------------\n# hrf <- function(t) { # Canonical HRF\n#   a1 <- 6; a2 <- 12; b1 <- 0.9; b2 <- 0.9; c <- 0.35\n#   t^(a1-1)*b1^a1*exp(-b1*t)/gamma(a1) - c*t^(a2-1)*b2^a2*exp(-b2*t)/gamma(a2)\n# }\n# \n# biophysical_kernel <- function(t1, t2, theta1, theta2, hrf1, hrf2) {\n#   # Temporal component\n#   k_time <- 0.8^2 * hrf1 * hrf2 * exp(-(t1 - t2)^2/(2*6^2))\n#   \n#   # Phase component\n#   phase_diff <- abs(theta1 - theta2)\n#   k_theta <- 1.2^2 * (1 + cos(phase_diff)) * exp(-phase_diff/0.7)\n#   \n#   # Noise component\n#   k_noise <- 0.3^2 * 0.9^abs(t1 - t2) + 0.1^2 * (t1 == t2)\n#   \n#   return(k_time * k_theta + k_noise)\n# }\n# \n# # -------------------------------------------------\n# # 3. Execution\n# # -------------------------------------------------\n# fmri_data <- simulate_fmri_data(n_participants=15, n_runs=20)\n# on_surface <- construct_kimesurface(fmri_data, \"ON\")\n# off_surface <- construct_kimesurface(fmri_data, \"OFF\")\n# \n# visualize_kimesurfaces_triple(on_surface, off_surface)\n\n# ========================= TEST ================================\n# # library(kernlab)\n# # library(plotly)\n# # \n# # # 1. Canonical HRF with higher temporal resolution\n# # hrf <- function(t, TR=2) {\n# #   t_hrf <- seq(0, 30, by=TR)  # 30s HRF window\n# #   a1 <- 6; a2 <- 12; b1 <- 0.9; b2 <- 0.9; c <- 0.35\n# #   resp <- t_hrf^(a1-1)*b1^a1*exp(-b1*t_hrf)/gamma(a1) - \n# #           c*t_hrf^(a2-1)*b2^a2*exp(-b2*t_hrf)/gamma(a2)\n# #   approx(t_hrf, resp, xout=t)$y  # Interpolate to input t\n# # }\n# # \n# # # 2. Enhanced Biophysical Kernel\n# # biophysical_kernel <- function(t1, t2, theta1, theta2) {\n# #   # Temporal component (sharper HRF correlation)\n# #   k_time <- 1.2^2 * hrf(t1) * hrf(t2) * exp(-(t1 - t2)^2/(2*3^2))  # l_hrf=3\n# #   \n# #   # Phase component (stronger periodic coupling)\n# #   phase_diff <- abs(theta1 - theta2) %% (2*pi)\n# #   k_theta <- 2.5^2 * exp(-2*sin(phase_diff/2)^2/(0.5^2))  # Periodic kernel\n# #   \n# #   # Physiological noise (reduced low-frequency drift)\n# #   k_noise <- 0.2^2 * 0.8^abs(t1 - t2) + 0.1^2 * (t1 == t2)\n# #   \n# #   return(k_time * k_theta + k_noise)\n# # }\n# # \n# # # 3. Kimesurface Construction with Phase Diversity\n# # construct_kimesurface <- function(data, condition, theta_samples=50) {\n# #   # Aggregate preserving individual runs\n# #   aggregated <- apply(data[[condition]], 3, c)  # Flatten participants/runs\n# #   n_time <- dim(data[[condition]])[3]\n# #   \n# #   # Wider phase sampling (Laplace b=2, modulo 2π)\n# #   theta <- (ExtDist::rLaplace(theta_samples, mu=0, b=2) %% (2*pi))\n# #   \n# #   # Time grid matching HRF dynamics\n# #   t_grid <- seq(0, 300, length=n_time)\n# #   \n# #   # Design matrix\n# #   design <- expand.grid(t=t_grid, theta=theta)\n# #   \n# #   # Compute kernel matrix\n# #   K <- kernelMatrix(\n# #     function(x1, x2) {\n# #       biophysical_kernel(x1[1], x2[1], x1[2], x2[2])\n# #     },\n# #     as.matrix(design))\n# #   \n# #   diag(K) <- diag(K) + 0.1  # Add observational noise\n# #   \n# #   # GP regression\n# #   # model <- gausspr(K, aggregated, kernel=\"matrix\")\n# #   model <- gausspr(K, aggregated, kernel=\"rbfdot\")\n# #   \n# #   # Posterior mean\n# #   post_mean <- predict(model)\n# #   \n# #   return(list(\n# #     grid = design,\n# #     mean = matrix(post_mean, nrow=n_time, ncol=theta_samples)))\n# # }\n# # \n# # # 4. Correct Polar Coordinate Mapping\n# # plot_kimesurface <- function(surface, title) {\n# #   x <- outer(surface$grid$t, cos(surface$grid$theta), \"*\")\n# #   y <- outer(surface$grid$t, sin(surface$grid$theta), \"*\")\n# #   z <- surface$mean\n# #   \n# #   plot_ly(x = x, y = y, z = z, type = \"surface\", colorscale = \"Viridis\") %>%\n# #     layout(\n# #       scene = list(\n# #         xaxis = list(title = \"X (t·cosθ)\"),\n# #         yaxis = list(title = \"Y (t·sinθ)\"),\n# #         zaxis = list(title = \"BOLD Response\"),\n# #         aspectratio = list(x = 1, y = 1, z = 0.5)\n# #       ),\n# #       title = list(text = title)\n# #     )\n# # }\n# # fmri_data <- simulate_fmri_data(n_participants=15, n_runs=20)\n# # on_surface <- construct_kimesurface(fmri_data, \"ON\")\n# # off_surface <- construct_kimesurface(fmri_data, \"OFF\")\n# \n# \n# fmri_data <- simulate_fmri_data(n_participants=15, n_runs=20)\n# # 1. Precompute HRF values for all time points\n# hrf <- function(t) {\n#   t_hrf <- seq(0, 30, by=2)\n#   a1 <- 6; a2 <- 12; b1 <- 0.9; b2 <- 0.9; c <- 0.35\n#   resp <- t_hrf^(a1-1)*b1^a1*exp(-b1*t_hrf)/gamma(a1) - \n#           c*t_hrf^(a2-1)*b2^a2*exp(-b2*t_hrf)/gamma(a2)\n#   approx(t_hrf, resp, xout=t)$y\n# }\n# \n# # 2. Optimized kernel components using Kronecker decomposition\n# compute_kernel_components <- function(t_grid, theta) {\n#   n_time <- length(t_grid)\n#   n_theta <- length(theta)\n#   \n#   # Precompute HRF values once\n#   hrf_values <- hrf(t_grid)\n#   \n#   # Time component kernel (HRF + temporal correlations)\n#   time_diff <- as.matrix(dist(t_grid, method = \"euclidean\"))\n#   K_time_hrf <- 1.2^2 * outer(hrf_values, hrf_values) * \n#                 exp(-time_diff^2/(2*3^2))\n#   \n#   # Phase component kernel (periodic)\n#   phase_diff <- outer(theta, theta, function(a,b) (abs(a-b) %% (2*pi)))\n#   K_phase <- 2.5^2 * exp(-2*sin(phase_diff/2)^2/(0.5^2))\n#   \n#   # Noise kernel (AR(1) + white noise)\n#   K_time_noise <- 0.2^2 * 0.8^abs(time_diff) + diag(0.1^2, n_time)\n#   \n#   # Combine using Kronecker products\n#   K_total <- kronecker(K_time_hrf, K_phase) + kronecker(K_time_noise, diag(n_theta))\n#   \n#   return(K_total)\n# }\n# \n# # 3. Parallelized GP construction\n# construct_kimesurface_optimized <- function(data, condition, theta_samples=50, cores=detectCores()-1) {\n#   # Aggregate data in parallel\n#   cl <- makeCluster(cores)\n#   clusterExport(cl, c(\"hrf\", \"compute_kernel_components\"))\n#   aggregated <- parApply(cl, data[[condition]], 3, mean)\n#   stopCluster(cl)\n#   \n#   # Generate phase angles\n#   theta <- (ExtDist::rLaplace(theta_samples, mu=0, b=2) %% (2*pi))\n#   t_grid <- seq(0, 300, length=length(aggregated))\n#   \n#   # Compute kernel components\n#   K_total <- compute_kernel_components(t_grid, theta)\n#   \n#   # Add observation noise to diagonal\n#   diag(K_total) <- diag(K_total) + 0.1\n#   \n#   # Parallel Cholesky decomposition\n#   cl <- makeCluster(cores)\n#   clusterEvalQ(cl, library(kernlab))\n#   model <- parLapply(cl, list(K_total), function(K) gausspr(K, aggregated, kernel=\"matrix\"))\n#   stopCluster(cl)\n#   \n#   # Format results\n#   post_mean <- matrix(predict(model[[1]]), nrow=length(t_grid), ncol=theta_samples)\n#   \n#   return(list(\n#     t_grid = t_grid,\n#     theta = theta,\n#     mean = post_mean,\n#     kernel = K_total))\n# }\n# \n# # 4. Execution and Visualization\n# fmri_data <- simulate_fmri_data(n_participants=15, n_runs=20)\n# system.time(\n#   on_surface <- construct_kimesurface_optimized(fmri_data, \"ON\", cores=8)\n# ) # ~4x speedup on 8 cores\n# \n# # plot_kimesurface(on_surface, \"Optimized ON Condition\")\n# visualize_kimesurfaces_triple(on_surface, off_surface)\n# \n# # plot_kimesurface(on_surface, \"ON Condition Kimesurface\")\n# \n# ==================================================\n###########################################\n# 0. Libraries\n###########################################\n# library(parallel)\n# library(kernlab)\n# library(ExtDist)   # Only needed if you want Laplace draws\n# library(plotly)    # For 3D surface plotting\n# \n# # Simple HRF function (as in your examples)\n# hrf <- function(t) {\n#   t_hrf <- seq(0, 30, by=2)\n#   a1 <- 6; a2 <- 12; b1 <- 0.9; b2 <- 0.9; c <- 0.35\n#   resp <- t_hrf^(a1-1)*b1^a1*exp(-b1*t_hrf)/gamma(a1) -\n#           c*t_hrf^(a2-1)*b2^a2*exp(-b2*t_hrf)/gamma(a2)\n#   approx(t_hrf, resp, xout=t, rule=2)$y\n# }\n# \n# simulate_fmri_data <- function(n_time = 120, n_runs = 5) {\n#   set.seed(123)\n#   arr <- array(rnorm(n_time * n_runs), dim = c(n_time, 1, n_runs))\n#   list(ON = arr, OFF = -arr)  # for demonstration, \"OFF\" is negative\n# }\n# \n# \n# ",
      "line_count": 268
    },
    {
      "section": "Stochastic Gaussian Process (SGP) Kimesurface Modeling",
      "code": "### (A) Helper Functions\nlibrary(parallel)\nlibrary(kernlab)\nlibrary(ExtDist)   # Only needed if you want Laplace draws\nlibrary(plotly)    # For 3D surface plotting\nlibrary(htmlwidgets)\n\n# Example HRF (same as your prior snippets)\nhrf <- function(t) {\n  t_hrf <- seq(0, 30, by=2)\n  a1 <- 6; a2 <- 12; b1 <- 0.9; b2 <- 0.9; c <- 0.35\n  resp <- t_hrf^(a1-1)*b1^a1*exp(-b1*t_hrf)/gamma(a1) -\n          c*t_hrf^(a2-1)*b2^a2*exp(-b2*t_hrf)/gamma(a2)\n  approx(t_hrf, resp, xout=t, rule=2)$y\n}\n\nsimulate_fmri_data <- function(n_time=100, n_runs=5) {\n  # Creates an array [time, 1, runs]\n  set.seed(123)\n  arr <- array(rnorm(n_time * n_runs, sd=1.0), dim=c(n_time, 1, n_runs))\n  # Could also simulate different patterns for ON vs OFF\n  list(\n    ON  = arr,\n    OFF = -arr  # trivial example: negative signal\n  )\n}\n\nvisualize_kimesurfaces_triple <- function(on_surface, off_surface) {\n  # Helper function to process surface data in chunks\n  process_surface_data <- function(surface) {\n    t_vals <- unique(surface$grid$t)\n    theta_vals <- unique(surface$grid$theta)\n    \n    chunk_size <- 10\n    n_chunks <- ceiling(length(t_vals) / chunk_size)\n    \n    x_all <- y_all <- z_all <- NULL\n    \n    for(i in 1:n_chunks) {\n      start_idx <- (i-1) * chunk_size + 1\n      end_idx <- min(i * chunk_size, length(t_vals))\n      t_chunk <- t_vals[start_idx:end_idx]\n      \n      x_chunk <- outer(t_chunk, cos(theta_vals))\n      y_chunk <- outer(t_chunk, sin(theta_vals))\n      z_chunk <- surface$mean[start_idx:end_idx,]\n      \n      x_all <- rbind(x_all, x_chunk)\n      y_all <- rbind(y_all, y_chunk)\n      z_all <- rbind(z_all, z_chunk)\n    }\n    \n    return(list(x = x_all, y = y_all, z = z_all))\n  }\n  \n  # Process both surfaces\n  on_data <- process_surface_data(on_surface)\n  off_data <- process_surface_data(off_surface)\n  \n  # Reduce resolution for plotting\n  n <- 3  # Use every 3rd point\n  subsample <- function(mat) {\n    mat[seq(1, nrow(mat), n), seq(1, ncol(mat), n)]\n  }\n  \n  # Create the first plot (ON)\n  fig <- plot_ly() %>%\n    add_surface(\n      x = subsample(on_data$x),\n      y = subsample(on_data$y),\n      z = subsample(on_data$z),\n      colorscale = \"Viridis\",\n      showscale = FALSE,\n      name = \"ON\",\n      scene = 'scene1'\n    ) %>%\n    layout(\n      scene = list(\n        domain = list(x = c(0, 0.33), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"BOLD Response\")\n      )\n    )\n\n  # Add the second plot (OFF)\n  fig <- fig %>%\n    add_surface(\n      x = subsample(off_data$x),\n      y = subsample(off_data$y),\n      z = subsample(off_data$z),\n      colorscale = \"Viridis\",\n      showscale = FALSE,\n      name = \"OFF\",\n      scene = 'scene2'\n    ) %>%\n    layout(\n      scene2 = list(\n        domain = list(x = c(0.33, 0.66), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"BOLD Response\")\n      )\n    )\n\n  # Add the third plot (OVERLAY)\n  fig <- fig %>%\n    add_surface(\n      x = subsample(on_data$x),\n      y = subsample(on_data$y),\n      z = subsample(on_data$z),\n      colorscale = \"Viridis\",\n      opacity = 0.7,\n      showscale = FALSE,\n      name = \"ON (overlay)\",\n      scene = 'scene3'\n    ) %>%\n    add_surface(\n      x = subsample(off_data$x),\n      y = subsample(off_data$y),\n      z = subsample(off_data$z),\n      colorscale = \"Portland\",\n      opacity = 0.7,\n      showscale = FALSE,\n      name = \"OFF (overlay)\",\n      scene = 'scene3'\n    ) %>%\n    layout(\n      scene3 = list(\n        domain = list(x = c(0.66, 1), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"BOLD Response\")\n      )\n    )\n\n  # Add final layout settings\n  fig <- fig %>%\n    layout(\n      title = \"Kimesurface Visualization of fMRI ON and OFF Conditions\",\n      showlegend = TRUE,\n      legend = list(x = 0.85, y = 0.1),\n      annotations = list(\n        list(\n          showarrow = FALSE,\n          text = '(ON)',\n          xref = 'paper',\n          yref = 'paper',\n          x = 0.15,\n          y = 0.95,\n          xanchor = 'center',\n          yanchor = 'bottom',\n          font = list(size = 16)\n        ),\n        list(\n          showarrow = FALSE,\n          text = '(OFF)',\n          xref = 'paper',\n          yref = 'paper',\n          x = 0.5,\n          y = 0.95,\n          xanchor = 'center',\n          yanchor = 'bottom',\n          font = list(size = 16)\n        ),\n        list(\n          showarrow = FALSE,\n          text = '(OVERLAY)',\n          xref = 'paper',\n          yref = 'paper',\n          x = 0.85,\n          y = 0.95,\n          xanchor = 'center',\n          yanchor = 'bottom',\n          font = list(size = 16)\n        )\n      )\n    )\n\n  # Add synchronization\n  fig <- fig %>% onRender(\n    \"function(el) {\n      el.on('plotly_relayout', function(d) {\n        const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n        if (camera.length) {\n          const scenes = Object.keys(el.layout).filter((key) => /^scene\\\\d*/.test(key));\n          const new_layout = {};\n          scenes.forEach(key => {\n            new_layout[key] = {...el.layout[key], camera: {...d[camera]}};\n          });\n          Plotly.relayout(el, new_layout);\n        }\n      });\n    }\"\n  )\n\n  return(fig)\n}\n\nconstruct_kimesurface_runs <- \n  function(fmri_data, condition  = \"ON\", cores = detectCores()-1,\n           # Time dimension\n           t_length   = NULL,    # optional subset\n           # Phase dimension\n           assign_phase = c(\"uniform\", \"random\"), seed = 999) \n{\n  # 1) Extract data array [time, 1, runs]\n  data_array <- fmri_data[[condition]]  # e.g., [T, 1, R]\n  T_available <- dim(data_array)[1]\n  R_runs      <- dim(data_array)[3]\n  \n  # 2) Aggregate data across the second dimension if needed (if >1)\n  #    Typically it's [time, 1, run], so no changes if second dim=1.\n  \n  # 3) Decide how many time points we use\n  #    If t_length is NULL or > T_available, use T_available\n  if (is.null(t_length) || t_length > T_available) {\n    t_length <- T_available\n  }\n  \n  # 4) Extract the first t_length points from each run\n  #    => dimension: [t_length, 1, R_runs]\n  data_array <- data_array[1:t_length, , , drop=FALSE]\n  \n  # 5) Flatten the data into a T×R matrix => y_mat[t, r]\n  #    We'll do parApply for a partial speedup\n  cl <- makeCluster(cores)\n  # parApply(..., MARGIN=c(1,3)) => a 2D result [time, run]\n  # because dimension 2 is length=1\n  y_mat <- parApply(cl, data_array, c(1,3), mean)\n  stopCluster(cl)\n  \n  # y_mat now has dimension [t_length, R_runs]\n  T_final <- nrow(y_mat)\n  R_final <- ncol(y_mat)\n  \n  # 6) Assign a single phase angle for each run\n  assign_phase <- match.arg(assign_phase)\n  set.seed(seed)\n  if (assign_phase == \"uniform\") {\n    # e.g. equally spaced angles around [0, 2π)\n    run_angles <- seq(0, 2*pi, length.out=R_final+1)[-1]\n    # drop the last to avoid duplication at 2*pi\n  } else {\n    # random\n    run_angles <- runif(R_final, min=0, max=2*pi)\n  }\n  \n  # 7) Build the time kernel\n  t_grid <- seq(0, 300, length.out = T_final)\n  \n  # Example: RBF × HRF\n  c_hrf <- 1.2\n  ell_t <- 3.0\n  time_diff <- as.matrix(dist(t_grid))\n  hrf_vals <- hrf(t_grid)\n  K_time <- (c_hrf^2)*outer(hrf_vals, hrf_vals)*exp(-time_diff^2/(2*ell_t^2))\n  \n  # Optionally add a small diagonal term\n  diag(K_time) <- diag(K_time) + 0.01\n  \n  # 8) Build the \"phase\" kernel among runs\n  #    K_phase(r, s) = periodic kernel in angles\n  ell_phase   <- 0.5\n  sigma_phase <- 2.5\n  \n  angle_diff <- outer(run_angles, run_angles, FUN=function(a,b) a - b)\n  # periodic RBF\n  K_phase <- sigma_phase^2 * exp(-2 * sin(angle_diff/2)^2 / ell_phase^2)\n  \n  # 9) Kronecker product => (T_final * R_final) x (T_final * R_final)\n  #    Flatten the y_mat into a vector => length T_final*R_final\n  K_2D <- kronecker(K_time, K_phase)\n  y_vec <- c(y_mat)   # stack columns or rows; we just need consistent ordering\n  # By default, `c(y_mat)` stacks in column-major order => the first column first, etc.\n  # We'll keep that order consistent with the Kron ordering.\n\n  # 10) as.kernelMatrix -> gausspr\n  K_kern  <- as.kernelMatrix(K_2D)\n  gp_model <- gausspr(x = K_kern, y = y_vec)\n  \n  # 11) Predict in-sample => length T_final*R_final\n  pred_vec <- predict(gp_model)\n  \n  # 12) Reshape => [t_length, R_runs]\n  pred_mat <- matrix(pred_vec, nrow=T_final, ncol=R_final)\n  \n  # 13) Build a \"grid\" data frame so that each row is (time_i, run_angle_r)\n  #     => T_final*R_final rows\n  # We'll do expand.grid in \"column-major\" order so it matches c(y_mat).\n  df_grid <- expand.grid(\n    t     = t_grid,\n    runID = seq_len(R_final),\n    KEEP.OUT.ATTRS = FALSE\n  )\n  # Now add the angle for each run ID\n  # Because expand.grid goes rowwise in the sense of slowest-varying first,\n  # we want runID to be the second factor. This matches the default c() pattern.\n  \n  # We'll replace runID with 'theta' for your radial plotting\n  # (each run has exactly one angle)\n  df_grid$theta <- run_angles[df_grid$runID]\n  \n  # Convert to numeric explicitly\n  df_grid$t <- as.numeric(df_grid$t)\n  df_grid$theta <- as.numeric(df_grid$theta)\n  \n  # Return a structure matching your visualize code:\n  #   surface$grid$t, surface$grid$theta, surface$mean\n  #   where surface$mean is [T_final, R_final]\n  list(\n    grid    = df_grid,\n    mean    = pred_mat,   # matrix [time, run], each run is a column\n    t_grid  = t_grid,\n    thetas  = run_angles,\n    runs    = R_final,\n    gp_model= gp_model,\n    y_raw   = y_mat\n  )\n}\n\n# Suppose we have 15 runs, each with 80 time points\nfmri_data <- simulate_fmri_data(n_time=80, n_runs=60)\n\n# Build ON-surface\non_surface <- construct_kimesurface_runs(\n  fmri_data   = fmri_data,\n  condition   = \"ON\",\n  cores       = 2,\n  t_length    = 80,               # use all time points\n  assign_phase= \"uniform\"         # equally spaced angles for the runs\n)\n# Build OFF-surface\noff_surface <- construct_kimesurface_runs(\n  fmri_data   = fmri_data,\n  condition   = \"OFF\",\n  cores       = 2,\n  t_length    = 80,\n  assign_phase= \"uniform\"\n)\n\n# Now we have:\n#   on_surface$grid$t, on_surface$grid$theta,\n#   on_surface$mean [80, 15]  => time x run\n# \n# If you pass these to your visualization function:\nfig <- visualize_kimesurfaces_triple(on_surface, off_surface)\nfig",
      "line_count": 351
    },
    {
      "section": "Stochastic Gaussian Process (SGP) Kimesurface Modeling",
      "code": "#############################################\n# Complete End-to-End: Strategy A\n#############################################\n\nlibrary(parallel)\nlibrary(fields)\nlibrary(plotly)\nlibrary(ExtDist)\n\n# (A) 1. Simulate\nsimulate_fmri_data <- function(n_time = 80, n_runs = 5) {\n  set.seed(123)\n  arr <- array(rnorm(n_time * n_runs, mean=0, sd=1),\n               dim = c(n_time, 1, n_runs))\n  list(ON = arr)\n}\n\n# (B) 2. Build (t,theta,intensity) with time-dependent Laplace angles\nbuild_irregular_kimesurface_data <- function(fmri_data, \n                                             condition = \"ON\",\n                                             b0 = 0.3,\n                                             alpha = 0.005,\n                                             T_max = 300,\n                                             cores = parallel::detectCores()-1) {\n  data_array <- fmri_data[[condition]]\n  n_time <- dim(data_array)[1]\n  n_runs <- dim(data_array)[3]\n  \n  cl <- makeCluster(cores)\n  y_mat <- parApply(cl, data_array, c(1,3), mean)\n  stopCluster(cl)\n  \n  t_grid <- seq(0, T_max, length.out = n_time)\n  \n  df <- expand.grid(\n    timeIndex = seq_len(n_time),\n    runID     = seq_len(n_runs),\n    KEEP.OUT.ATTRS = FALSE\n  )\n  df$t <- t_grid[df$timeIndex]\n  \n  # Draw Laplace(0, b0+alpha*t)\n  set.seed(999)\n  df$theta <- mapply(function(tt) {\n    scale_i <- b0 + alpha * tt\n    rLaplace(1, mu=0, b=scale_i)\n  }, df$t)\n  \n  df$intensity <- c(y_mat)\n  \n  df\n}\n\n# (C) 3. Interpolate with Tps\ninterpolate_kimesurface <- function(df) {\n  fit <- Tps(\n    x = cbind(df$t, df$theta),\n    Y = df$intensity,\n    lambda = 0.001   # Smoothing control, 0.0 to force \"interpolate exactly\" with no smoothing penalty\n  )\n  fit\n}\n\n# (D) 4. Predict on a regular grid & plot\nplot_kimesurface_tps <- function(fit, df, \n                                 n_time_plot=50, \n                                 n_theta_plot=50) {\n  t_min <- min(df$t);    t_max <- max(df$t)\n  th_min<- min(df$theta);th_max<- max(df$theta)\n  \n  t_seq    <- seq(t_min,  t_max,   length.out=n_time_plot)\n  theta_seq<- seq(th_min, th_max,  length.out=n_theta_plot)\n  \n  grid_mat <- as.matrix(expand.grid(t_seq, theta_seq))\n  pred_vals<- predict(fit, grid_mat)\n  \n  pred_mat <- matrix(pred_vals, nrow=n_time_plot, ncol=n_theta_plot, byrow=FALSE)\n  \n  # 2D surface in (t,theta) space\n  p <- plot_ly(\n    x = t_seq,\n    y = theta_seq,\n    z = ~pred_mat\n  ) %>%\n    add_surface() %>%\n    layout(\n      title = \"Kimesurface in (t, θ) from Tps Interpolation\",\n      scene = list(\n        xaxis = list(title = \"time (t)\"),\n        yaxis = list(title = \"θ (Laplace-dist)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    )\n  p\n}\n\n\n#############################################\n# Example usage:\n#############################################\n\n# 1) Simulate data\nfmri_data <- simulate_fmri_data(n_time=80, n_runs=5)\n\n# 2) Build random-laplace (t,theta,intensity)\ndf_kime <- build_irregular_kimesurface_data(\n  fmri_data  = fmri_data,\n  condition  = \"ON\",\n  b0         = 0.3,\n  alpha      = 0.005,\n  T_max      = 300,\n  cores      = 2\n)\nstr(df_kime)\n# 'data.frame':\t400 obs. of  5 variables:\n#  $ timeIndex: int [1:400] 1 1 1 1 1 2 2 2 2 2 ...\n#  $ runID    : int [1:400] 1 2 3 4 5 1 2 3 4 5 ...\n#  $ t        : num [1:400] 0 0 0 0 0 ...\n#  $ theta    : num [1:400] 0.2129 0.0831 -0.1051 ...\n#  $ intensity: num [1:400] 1.715 0.461 0.46 -0.686 -0.446 ...\nsummary(df_kime$theta)\n\n# 3) Interpolate in 2D with Tps\nfit_tps <- interpolate_kimesurface(df_kime)\n\n# 4) Evaluate on a regular grid & plot\np <- plot_kimesurface_tps(fit_tps, df_kime, \n                          n_time_plot=60, \n                          n_theta_plot=60)\np",
      "line_count": 130
    },
    {
      "section": "Numerical Strategies",
      "code": "library(plotly)\nlibrary(htmlwidgets)\n\nvisualize_kimesurfaces_triple <- function(on_surface, off_surface) {\n  # Helper function to process surface data in chunks\n  process_surface_data <- function(surface) {\n    t_vals    <- unique(surface$grid$t)\n    theta_vals<- unique(surface$grid$theta)\n    \n    chunk_size <- 10\n    n_chunks <- ceiling(length(t_vals) / chunk_size)\n    \n    x_all <- y_all <- z_all <- NULL\n    \n    for(i in seq_len(n_chunks)) {\n      start_idx <- (i - 1) * chunk_size + 1\n      end_idx   <- min(i * chunk_size, length(t_vals))\n      t_chunk   <- t_vals[start_idx:end_idx]\n      \n      # radial coords\n      x_chunk <- outer(t_chunk, cos(theta_vals))\n      y_chunk <- outer(t_chunk, sin(theta_vals))\n      # pick the corresponding rows in the 'mean' matrix\n      z_chunk <- surface$mean[start_idx:end_idx, ]\n      \n      x_all <- rbind(x_all, x_chunk)\n      y_all <- rbind(y_all, y_chunk)\n      z_all <- rbind(z_all, z_chunk)\n    }\n    \n    list(x = x_all, y = y_all, z = z_all)\n  }\n  \n  # Process both surfaces\n  on_data  <- process_surface_data(on_surface)\n  off_data <- process_surface_data(off_surface)\n  \n  # Reduce resolution for plotting\n  n <- 3  # sample every 3rd row/col\n  subsample <- function(mat) {\n    mat[seq(1, nrow(mat), n), seq(1, ncol(mat), n)]\n  }\n  \n  # (1) ON surface\n  fig <- plot_ly() %>%\n    add_surface(\n      x = subsample(on_data$x),\n      y = subsample(on_data$y),\n      z = subsample(on_data$z),\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"ON\",\n      scene      = 'scene1'\n    ) %>%\n    layout(\n      scene = list(\n        domain     = list(x = c(0, 0.33), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis      = list(title = \"X (t·cosθ)\"),\n        yaxis      = list(title = \"Y (t·sinθ)\"),\n        zaxis      = list(title = \"BOLD Response\")\n      )\n    )\n  \n  # (2) OFF surface\n  fig <- fig %>%\n    add_surface(\n      x = subsample(off_data$x),\n      y = subsample(off_data$y),\n      z = subsample(off_data$z),\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"OFF\",\n      scene      = 'scene2'\n    ) %>%\n    layout(\n      scene2 = list(\n        domain     = list(x = c(0.33, 0.66), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis      = list(title = \"X (t·cosθ)\"),\n        yaxis      = list(title = \"Y (t·sinθ)\"),\n        zaxis      = list(title = \"BOLD Response\")\n      )\n    )\n  \n  # (3) OVERLAY surfaces\n  fig <- fig %>%\n    add_surface(\n      x = subsample(on_data$x),\n      y = subsample(on_data$y),\n      z = subsample(on_data$z),\n      colorscale = \"Viridis\",\n      opacity    = 0.7,\n      showscale  = FALSE,\n      name       = \"ON (overlay)\",\n      scene      = 'scene3'\n    ) %>%\n    add_surface(\n      x = subsample(off_data$x),\n      y = subsample(off_data$y),\n      z = subsample(off_data$z),\n      colorscale = \"Portland\",\n      opacity    = 0.7,\n      showscale  = FALSE,\n      name       = \"OFF (overlay)\",\n      scene      = 'scene3'\n    ) %>%\n    layout(\n      scene3 = list(\n        domain     = list(x = c(0.66, 1), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis      = list(title = \"X (t·cosθ)\"),\n        yaxis      = list(title = \"Y (t·sinθ)\"),\n        zaxis      = list(title = \"BOLD Response\")\n      )\n    )\n  \n  # Final layout\n  fig <- fig %>%\n    layout(\n      title      = \"Kimesurface Visualization of fMRI ON and OFF Conditions\",\n      showlegend = TRUE,\n      legend     = list(x = 0.85, y = 0.1),\n      annotations= list(\n        list(showarrow=FALSE, text='(ON)',      xref='paper', yref='paper',\n             x=0.15, y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OFF)',     xref='paper', yref='paper',\n             x=0.5,  y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OVERLAY)', xref='paper', yref='paper',\n             x=0.85, y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16))\n      )\n    )\n  \n  # Add camera sync across the 3 scenes\n  fig <- fig %>% onRender(\"\n    function(el) {\n      el.on('plotly_relayout', function(d) {\n        const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n        if (camera.length) {\n          const scenes = Object.keys(el.layout).filter((key) => /^scene\\\\d*/.test(key));\n          const new_layout = {};\n          scenes.forEach(key => {\n            new_layout[key] = {...el.layout[key], camera: {...d[camera]}};\n          });\n          Plotly.relayout(el, new_layout);\n        }\n      });\n    }\n  \")\n  \n  fig\n}",
      "line_count": 155
    },
    {
      "section": "Numerical Strategies",
      "code": "simulate_fmri_data <- function(n_time = 80, n_runs = 5) {\n  set.seed(123)\n  \n  # Example: 'ON' data\n  arr_on <- array(\n    rnorm(n_time * n_runs, mean=0, sd=1),\n    dim = c(n_time, 1, n_runs)\n  )\n  # 'OFF' could be something different. For demonstration, let's shift it\n  arr_off <- array(\n    rnorm(n_time * n_runs, mean=1, sd=1),\n    dim = c(n_time, 1, n_runs)\n  )\n  \n  list(ON = arr_on, OFF = arr_off)\n}",
      "line_count": 16
    },
    {
      "section": "Numerical Strategies",
      "code": "library(parallel)\nlibrary(ExtDist)  # for rLaplace\n\nbuild_irregular_kimesurface_data <- \n  function(fmri_data, condition = \"ON\", b0 = 0.3, alpha   = 0.005, T_max   = 300,\n           cores   = parallel::detectCores()-1) {\n  data_array <- fmri_data[[condition]]  # [n_time, 1, n_runs]\n  n_time <- dim(data_array)[1]\n  n_runs <- dim(data_array)[3]\n  \n  # Flatten in parallel\n  cl <- makeCluster(cores)\n  y_mat <- parApply(cl, data_array, c(1,3), mean)\n  stopCluster(cl)\n  \n  # Time vector 0..T_max\n  t_grid <- seq(0, T_max, length.out=n_time)\n  \n  # Expand (timeIndex, runID)\n  df <- expand.grid(\n    timeIndex = seq_len(n_time),\n    runID     = seq_len(n_runs),\n    KEEP.OUT.ATTRS = FALSE\n  )\n  # Add actual continuous time\n  df$t <- t_grid[df$timeIndex]\n  \n  set.seed(999)\n  # For each row => random angle from Laplace(0, b0 + alpha * t)\n  df$theta <- mapply(function(tt) {\n    scale_i <- b0 + alpha * tt\n    rLaplace(1, mu=0, b=scale_i)\n  }, df$t)\n  \n  # Attach intensities from y_mat in the correct order\n  # By default, expand.grid enumerates runID fastest => matches c(y_mat)\n  df$intensity <- c(y_mat)\n  \n  df\n}",
      "line_count": 40
    },
    {
      "section": "Numerical Strategies",
      "code": "construct_kimesurface_interpolated <- \n  function(df_kime, n_t = 50, n_theta = 50, lambda  = 0.01){  # 0 for no smoothing (exact interp)\n  # 1) Fit Tps model\n  fit <- Tps( x = cbind(df_kime$t, df_kime$theta), Y = df_kime$intensity, lambda = lambda)\n    # or control smoothing with df=..., or leave defaults\n  \n  # 2) Build a regular grid in the (t, theta) domain\n  t_min    <- min(df_kime$t)\n  t_max    <- max(df_kime$t)\n  theta_min<- min(df_kime$theta)\n  theta_max<- max(df_kime$theta)\n  \n  t_seq    <- seq(t_min, t_max, length.out=n_t)\n  theta_seq<- seq(theta_min, theta_max, length.out=n_theta)\n  \n  # 3) Evaluate Tps on that grid\n  grid_mat <- as.matrix(expand.grid(t_seq, theta_seq))\n  pred_vals<- predict(fit, grid_mat)\n  \n  # 4) Reshape => [n_t, n_theta]\n  pred_mat <- matrix(pred_vals, nrow=n_t, ncol=n_theta, byrow=FALSE)\n  \n  # 5) Construct the 'grid' data frame\n  df_grid <- expand.grid(\n    t     = t_seq,\n    theta = theta_seq,\n    KEEP.OUT.ATTRS = FALSE\n  )\n  # Make sure numeric\n  df_grid$t     <- as.numeric(df_grid$t)\n  df_grid$theta <- as.numeric(df_grid$theta)\n  \n  # 6) Return in the format needed by visualize_kimesurfaces_triple\n  #    with 'mean' = [n_t x n_theta]\n  list(\n    grid   = df_grid,\n    mean   = pred_mat,\n    t_grid = t_seq,\n    theta  = theta_seq\n  )\n}",
      "line_count": 41
    },
    {
      "section": "Numerical Strategies",
      "code": "#############################################\n## 0) Libraries\n#############################################\nlibrary(parallel)\nlibrary(fields)   # Tps for 2D interpolation\nlibrary(plotly)\nlibrary(ExtDist)  # For rLaplace if not built-in\n\n#############################################\n## 1) Simulate fMRI data (ON/OFF)\n#############################################\nsimulate_fmri_data <- function(n_time = 80, n_runs = 5) {\n  # Returns a list with \"ON\" and \"OFF\" conditions, each [n_time, 1, n_runs].\n  # For demonstration, \"OFF\" is just negative of \"ON.\"\n  set.seed(123)\n  arr_on <- array(rnorm(n_time * n_runs, mean=0, sd=1),\n                  dim = c(n_time, 1, n_runs))\n  \n  list(\n    ON  = arr_on,\n    OFF = -arr_on  # trivial difference\n  )\n}\n\n#############################################\n## 2) Build Irregular (t, theta, intensity)\n##    with time-dependent Laplace angles\n#############################################\nbuild_irregular_kimesurface_data <- function(fmri_data,\n                                             condition = \"ON\",\n                                             b0 = 0.3,\n                                             alpha = 0.005,\n                                             T_max = 300,\n                                             cores = detectCores()-1) {\n  # fmri_data[[condition]] is [n_time, 1, n_runs].\n  data_array <- fmri_data[[condition]]\n  \n  n_time <- dim(data_array)[1]\n  n_runs <- dim(data_array)[3]\n  \n  # Flatten intensities: [time, run]\n  cl <- makeCluster(cores)\n  y_mat <- parApply(cl, data_array, c(1,3), mean) \n  stopCluster(cl)\n  \n  # Build a time vector from 0..T_max\n  t_grid <- seq(0, T_max, length.out = n_time)\n  \n  # We'll create one row per (time_i, run_j).\n  df <- expand.grid(\n    timeIndex = seq_len(n_time),\n    runID     = seq_len(n_runs),\n    KEEP.OUT.ATTRS = FALSE\n  )\n  # Add the continuous time\n  df$t <- t_grid[df$timeIndex]\n  \n  # For each row => draw random Laplace(0, b0 + alpha*t).\n  set.seed(999)\n  df$theta <- mapply(function(tt) {\n    scale_i <- b0 + alpha*tt\n    rLaplace(1, mu=0, b=scale_i)\n  }, df$t)\n  \n  # Map the intensity from y_mat -> vector\n  y_vec <- c(y_mat)\n  df$intensity <- y_vec\n  \n  df\n}\n\n#############################################\n## 3) Fit a 2D Thin-Plate Spline over (t,theta)\n#############################################\nfit_kimesurface_interpolation <- function(df, lambda=NULL, df_smooth=NULL) {\n  # df has columns (t, theta, intensity)\n  # Tps automatically chooses a smoothing parameter by default,\n  # but you can override with lambda=0 or set df=... for less smoothing.\n  \n  # Prepare inputs\n  X <- cbind(df$t, df$theta)\n  Y <- df$intensity\n  \n  if(!is.null(lambda)) {\n    # Force a specific lambda (e.g. 0 => exact interpolation)\n    fit <- Tps(x=X, Y=Y, lambda=lambda)\n  } else if(!is.null(df_smooth)) {\n    # Force a certain degrees of freedom\n    fit <- Tps(x=X, Y=Y, df=df_smooth)\n  } else {\n    # Let Tps choose automatically\n    fit <- Tps(x=X, Y=Y)\n  }\n  \n  fit\n}\n\n#############################################\n## 4) Construct a regular grid & predict\n##    => Return an object for triple-plot\n#############################################\nconstruct_kimesurface_interpolated <- function(fit,\n                                               df,\n                                               n_time_plot=50,\n                                               n_theta_plot=50) {\n  # We'll build a regular grid in t & theta over the range of the data,\n  # then evaluate 'fit' (the Tps model) there, returning a matrix of predictions.\n  \n  t_min <- min(df$t);    t_max <- max(df$t)\n  th_min<- min(df$theta);th_max<- max(df$theta)\n  \n  t_seq    <- seq(t_min,  t_max,   length.out=n_time_plot)\n  theta_seq<- seq(th_min, th_max,  length.out=n_theta_plot)\n  \n  # Predict for all combos\n  grid <- expand.grid(t=t_seq, theta=theta_seq, KEEP.OUT.ATTRS=FALSE)\n  \n  pred_vals <- predict(fit, as.matrix(grid))\n  \n  # Reshape => [n_time_plot, n_theta_plot]\n  pred_mat  <- matrix(pred_vals,\n                      nrow=n_time_plot,\n                      ncol=n_theta_plot,\n                      byrow=FALSE)\n  \n  # Return a structure that \"visualize_kimesurfaces_triple()\" expects:\n  list(\n    grid = grid,       # data.frame with columns 't', 'theta'\n    mean = pred_mat,   # 2D matrix of dimension [n_time_plot, n_theta_plot]\n    timepoints = t_seq,\n    phases     = theta_seq\n  )\n}\n\n#############################################\n## 5) The triple visualization function\n#############################################\nvisualize_kimesurfaces_triple <- function(on_surface, off_surface) {\n  # Helper to chunk surface data\n  process_surface_data <- function(surface) {\n    t_vals    <- unique(surface$grid$t)\n    theta_vals<- unique(surface$grid$theta)\n    \n    chunk_size <- 10\n    n_chunks <- ceiling(length(t_vals) / chunk_size)\n    \n    x_all <- y_all <- z_all <- NULL\n    \n    for(i in seq_len(n_chunks)) {\n      start_idx <- (i-1)*chunk_size + 1\n      end_idx   <- min(i*chunk_size, length(t_vals))\n      t_chunk   <- t_vals[start_idx:end_idx]\n      \n      # radial coords => x=r*cosθ, y=r*sinθ, r=t\n      x_chunk <- outer(t_chunk, cos(theta_vals))\n      y_chunk <- outer(t_chunk, sin(theta_vals))\n      z_chunk <- surface$mean[start_idx:end_idx, ]\n      \n      x_all <- rbind(x_all, x_chunk)\n      y_all <- rbind(y_all, y_chunk)\n      z_all <- rbind(z_all, z_chunk)\n    }\n    \n    list(x=x_all, y=y_all, z=z_all)\n  }\n  \n  # Process surfaces\n  on_data  <- process_surface_data(on_surface)\n  off_data <- process_surface_data(off_surface)\n  \n  # Downsample for plotting\n  n <- 3\n  subsample <- function(mat) {\n    mat[seq(1, nrow(mat), n), seq(1, ncol(mat), n)]\n  }\n  \n  fig <- plot_ly() %>%\n    # First: ON\n    add_surface(\n      x = subsample(on_data$x),\n      y = subsample(on_data$y),\n      z = subsample(on_data$z),\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"ON\",\n      scene      = \"scene1\"\n    ) %>%\n    layout(\n      scene = list(\n        domain     = list(x = c(0, 0.33), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    # Second: OFF\n    add_surface(\n      x = subsample(off_data$x),\n      y = subsample(off_data$y),\n      z = subsample(off_data$z),\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"OFF\",\n      scene      = \"scene2\"\n    ) %>%\n    layout(\n      scene2 = list(\n        domain     = list(x = c(0.33, 0.66), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    # Third: Overlay\n    add_surface(\n      x = subsample(on_data$x),\n      y = subsample(on_data$y),\n      z = subsample(on_data$z),\n      colorscale = \"Viridis\",\n      opacity    = 0.7,\n      showscale  = FALSE,\n      name       = \"ON (overlay)\",\n      scene      = \"scene3\"\n    ) %>%\n    add_surface(\n      x = subsample(off_data$x),\n      y = subsample(off_data$y),\n      z = subsample(off_data$z),\n      colorscale = \"Portland\",\n      opacity    = 0.7,\n      showscale  = FALSE,\n      name       = \"OFF (overlay)\",\n      scene      = \"scene3\"\n    ) %>%\n    layout(\n      scene3 = list(\n        domain     = list(x = c(0.66, 1), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    layout(\n      title      = \"Kimesurface Visualization of fMRI ON and OFF\",\n      showlegend = TRUE,\n      legend     = list(x=0.85, y=0.1),\n      annotations= list(\n        list(showarrow=FALSE, text='(ON)',  xref='paper', yref='paper',\n             x=0.15, y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OFF)', xref='paper', yref='paper',\n             x=0.5,  y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OVERLAY)',\n             xref='paper', yref='paper', x=0.85, y=0.95,\n             xanchor='center', yanchor='bottom',\n             font=list(size=16))\n      )\n    ) %>%\n    # Sync the cameras\n    onRender(\"\n      function(el) {\n        el.on('plotly_relayout', function(d) {\n          const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n          if (camera.length) {\n            const scenes = Object.keys(el.layout).filter((key) => /^scene\\\\d*/.test(key));\n            const new_layout = {};\n            scenes.forEach(key => {\n              new_layout[key] = {...el.layout[key], camera: {...d[camera]}};\n            });\n            Plotly.relayout(el, new_layout);\n          }\n        });\n      }\n    \")\n  \n  fig\n}\n\n################ NEW\n#############################################\n## 5) The triple visualization function\n#############################################\nvisualize_kimesurfaces_tripleNEW <- function(fitOn, dfOn, fitOff, dfOff, n_time_plot=50, n_theta_plot=50) {\n  t_min <- min(dfOn$t);     t_max <- max(dfOn$t)\n  th_min<- min(dfOn$theta); th_max<- max(dfOn$theta)\n  \n  t_seq    <- seq(t_min,  t_max,   length.out=n_time_plot)\n  theta_seq<- seq(th_min, th_max,  length.out=n_theta_plot)\n  \n  grid_mat <- as.matrix(expand.grid(t_seq, theta_seq))\n  pred_valsOn  <- predict(fitOn, grid_mat)\n  pred_valsOff <- predict(fitOff, grid_mat)\n  \n  pred_matOn <- matrix(pred_valsOn, nrow=n_time_plot, ncol=n_theta_plot, byrow=FALSE)\n  pred_matOff <- matrix(pred_valsOff, nrow=n_time_plot, ncol=n_theta_plot, byrow=FALSE)\n  \n  # 2D surface in (t,theta) space\n  p <- plot_ly(\n    x = t_seq,\n    y = theta_seq,\n    z = ~pred_mat\n  )\n  fig <- plot_ly() %>%\n    # First: ON\n    add_surface(\n      x = t_seq,\n      y = theta_seq,\n      z = ~pred_matOn,\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"ON\",\n      scene      = \"scene1\"\n    ) %>%\n    layout(\n      scene = list(\n        domain     = list(x = c(0, 0.33), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    # Second: OFF\n    add_surface(\n      x = t_seq,\n      y = theta_seq,\n      z = ~pred_matOff,\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"OFF\",\n      scene      = \"scene2\"\n    ) %>%\n    layout(\n      scene2 = list(\n        domain     = list(x = c(0.33, 0.66), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    # Third: Overlay\n    add_surface(\n      x = t_seq,\n      y = theta_seq,\n      z = ~pred_matOn,\n      colorscale = \"Viridis\",\n      opacity    = 0.5,\n      showscale  = FALSE,\n      name       = \"ON (overlay)\",\n      scene      = \"scene3\"\n    ) %>%\n    add_surface(\n      x = t_seq,\n      y = theta_seq,\n      z = ~pred_matOff,\n      colorscale = \"Portland\",\n      opacity    = 0.8,\n      showscale  = FALSE,\n      name       = \"OFF (overlay)\",\n      scene      = \"scene3\"\n    ) %>%\n    layout(\n      scene3 = list(\n        domain     = list(x = c(0.66, 1), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"X (t·cosθ)\"),\n        yaxis = list(title = \"Y (t·sinθ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    layout(\n      title      = \"Kimesurface Visualization of fMRI ON and OFF\",\n      showlegend = TRUE,\n      legend     = list(x=0.85, y=0.1),\n      annotations= list(\n        list(showarrow=FALSE, text='(ON)',  xref='paper', yref='paper',\n             x=0.15, y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OFF)', xref='paper', yref='paper',\n             x=0.5,  y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OVERLAY)',\n             xref='paper', yref='paper', x=0.85, y=0.95,\n             xanchor='center', yanchor='bottom',\n             font=list(size=16))\n      )\n    ) %>%\n    # Sync the cameras\n    onRender(\"\n      function(el) {\n        el.on('plotly_relayout', function(d) {\n          const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n          if (camera.length) {\n            const scenes = Object.keys(el.layout).filter((key) => /^scene\\\\d*/.test(key));\n            const new_layout = {};\n            scenes.forEach(key => {\n              new_layout[key] = {...el.layout[key], camera: {...d[camera]}};\n            });\n            Plotly.relayout(el, new_layout);\n          }\n        });\n      }\n    \")\n  \n  fig\n}\n\n\n#############################################\n## 6) Usage: Full Pipeline\n#############################################\n\n# 1) Simulate data\nfmri_data <- simulate_fmri_data(n_time=80, n_runs=5)\n\n# 2) Build irregular (t,theta,intensity) with Laplace(0, b(t))\ndf_on  <- build_irregular_kimesurface_data(fmri_data, \"ON\",  b0=0.3, alpha=0.02, T_max=300)\ndf_off <- build_irregular_kimesurface_data(fmri_data, \"OFF\", b0=0.3, alpha=0.02, T_max=300)\n\n# 3) Fit Tps in 2D\nfit_on  <- fit_kimesurface_interpolation(df_on,  lambda=0.001)  # lambda=0 => exact interp\nfit_off <- fit_kimesurface_interpolation(df_off, lambda=0.001)\n\n# pOn <- plot_kimesurface_tps(fit_on, df_on, n_time_plot=60, n_theta_plot=60)\n# pOn\n# pOff <- plot_kimesurface_tps(fit_off, df_off, n_time_plot=60, n_theta_plot=60)\n# pOff\n# 5) Visualize triple\nfig <- visualize_kimesurfaces_tripleNEW(fit_on, df_on, fit_off, df_off)\nfig",
      "line_count": 435
    },
    {
      "section": "Numerical Strategies",
      "code": "library(parallel)\nlibrary(fields)   # We'll reuse Tps for scattered -> uniform grid interpolation\nlibrary(plotly)\nlibrary(ExtDist)  # for rLaplace\n\n## 2) Simulate Multi-Run fMRI Data + Time-Dependent Laplace Angles\n# Similar to “Strategy A,” but we’ll keep it separate for clarity. Each `(time_i, run_j)` \n# has a random draw $\\theta_{r}(t_i)\\sim\\mathrm{Laplace}(0,\\,b_0 + \\alpha\\,t_i)$. \n# We store these in a data frame.\n\nsimulate_fmri_data <- function(n_time = 80, n_runs = 5) {\n  # For demonstration, we store ON and OFF\n  set.seed(123)\n  arr_on <- array(rnorm(n_time * n_runs, mean=0, sd=1), dim = c(n_time, 1, n_runs))\n  list(ON  = arr_on, OFF = -arr_on)\n}\n\nbuild_irregular_kimesurface_data <- function(fmri_data, condition = \"ON\",\n                                             b0 = 0.3, alpha = 0.005, T_max = 300,\n                                             cores = parallel::detectCores()-1) {\n  data_array <- fmri_data[[condition]]\n  n_time <- dim(data_array)[1]\n  n_runs <- dim(data_array)[3]\n  \n  cl <- makeCluster(cores)\n  y_mat <- parApply(cl, data_array, c(1,3), mean)\n  stopCluster(cl)\n  \n  # time from 0..T_max\n  t_grid <- seq(0, T_max, length.out = n_time)\n  \n  df <- expand.grid(\n    timeIndex = seq_len(n_time),\n    runID     = seq_len(n_runs),\n    KEEP.OUT.ATTRS = FALSE\n  )\n  df$t <- t_grid[df$timeIndex]\n  \n  # random Laplace(0, b0+alpha*t)\n  set.seed(999)\n  df$theta <- mapply(function(tt) {\n    scale_i <- b0 + alpha*tt\n    rLaplace(1, mu=0, b=scale_i)\n  }, df$t)\n  \n  df$intensity <- c(y_mat)\n  \n  df\n}\n\n### Example Usage:\n\nfmri_data <- simulate_fmri_data(n_time=80, n_runs=5)\ndf_on  <- build_irregular_kimesurface_data(fmri_data, \"ON\",  b0=0.3, alpha=0.02, T_max=300)\ndf_off <- build_irregular_kimesurface_data(fmri_data, \"OFF\", b0=0.3, alpha=0.02, T_max=300)",
      "line_count": 55
    },
    {
      "section": "Numerical Strategies",
      "code": "## 3) Interpolate onto a Uniform $(t,\\theta)$-Grid\ninterpolate_to_grid <- function(df, n_time_plot = 50, n_theta_plot= 50, lambda= 0) { # less smoothing\n  # 1) Scatter -> Tps fit\n  X <- cbind(df$t, df$theta)\n  Y <- df$intensity\n  \n  # A thin-plate spline with minimal smoothing\n  fit <- Tps(X, Y, lambda=lambda)\n  \n  # 2) Regular grid\n  t_min <- min(df$t);   t_max <- max(df$t)\n  th_min<- min(df$theta); th_max<- max(df$theta)\n  \n  t_seq    <- seq(t_min,  t_max,   length.out=n_time_plot)\n  theta_seq<- seq(th_min, th_max,  length.out=n_theta_plot)\n  \n  grid     <- expand.grid(t=t_seq, theta=theta_seq, KEEP.OUT.ATTRS=FALSE)\n  Z_pred   <- predict(fit, as.matrix(grid))\n  \n  # 3) Reshape => [n_time_plot, n_theta_plot]\n  Z_mat <- matrix(Z_pred, nrow=n_time_plot, ncol=n_theta_plot, byrow=FALSE)\n  \n  list(\n    t_seq      = t_seq,\n    theta_seq  = theta_seq,\n    Z          = Z_mat,     # 2D matrix\n    fit_object = fit        # might be used for debugging\n  )\n}\n\n## 4) 2D FFT in R\n# Base R doesn’t have a built-in “2D FFT” function, but we can define it by applying the 1D FFT row-wise, then column-wise (or vice versa). For an $(M \\times N)$ matrix `Z`, we can do:\n\nfft2d <- function(Z, inverse=FALSE) {\n  # 1) FFT each column\n  # If inverse=TRUE => we use fft(z, inverse=TRUE)\n  M <- nrow(Z)\n  N <- ncol(Z)\n  \n  # Step 1: transform columns\n  for (j in seq_len(N)) {\n    Z[,j] <- fft(Z[,j], inverse=inverse)\n  }\n  \n  # Step 2: transform rows\n  for (i in seq_len(M)) {\n    Z[i,] <- fft(Z[i,], inverse=inverse)\n  }\n  \n  # Note: For an *unscaled* DFT, the inverse also is unscaled.\n  # Typically, you'd divide by M*N if you want the \"true\" inverse.\n  # We'll handle scaling below.\n  \n  Z\n}",
      "line_count": 55
    },
    {
      "section": "Numerical Strategies",
      "code": "## 5) Constructing the k-Space Kimesurface\nconstruct_kimesurface_fourier <- function(df, n_time_plot  = 50, n_theta_plot = 50,\n                                          lambda_interp= 0, filter_fraction=1.0) {\n  ########################################\n  # 1) Interpolate to uniform grid\n  ########################################\n  grid_obj <- interpolate_to_grid(\n    df,\n    n_time_plot   = n_time_plot,\n    n_theta_plot  = n_theta_plot,\n    lambda        = lambda_interp\n  )\n  Z <- grid_obj$Z   # shape [n_time_plot, n_theta_plot]\n  M <- nrow(Z)\n  N <- ncol(Z)\n  \n  ########################################\n  # 2) Forward 2D FFT => F in k-space\n  ########################################\n  F_k <- fft2d(Z, inverse=FALSE)\n  \n  # 'F_k' is an unscaled DFT. Its indices correspond to frequencies in rows, columns.\n  # Typically the DC component is at [1,1] or [0,0]. \n  # If we want to do a \"centered\" transform, we might shift. We'll keep it simple here.\n  \n  ########################################\n  # 3) Optional: Filter or manipulate in k-space\n  ########################################\n  # For demonstration, let's do a simple \"low-pass\" or partial filter if filter_fraction < 1.0\n  # We'll keep only the top fraction of largest Fourier magnitudes, set the rest to 0.\n  \n  if(filter_fraction < 1.0) {\n    mag <- Mod(F_k)\n    cutoff <- quantile(mag, probs=1-filter_fraction)\n    F_k[mag < cutoff] <- 0\n  }\n  \n  ########################################\n  # 4) Inverse 2D FFT => Z_ifft\n  ########################################\n  Z_ifft <- fft2d(F_k, inverse=TRUE)\n  # Now we must divide by M*N for the \"true\" inverse in typical DFT conventions:\n  Z_ifft <- Z_ifft / (M*N)\n  \n  # Re(Z_ifft) is typically your real output, but it might have small imaginary noise\n  Z_ifft <- Re(Z_ifft)  # drop imaginary part if negligible\n  \n  ########################################\n  # 5) Return everything for plotting\n  ########################################\n  list(\n    t_seq      = grid_obj$t_seq,\n    theta_seq  = grid_obj$theta_seq,\n    Z_original = Z,\n    Z_recon    = Z_ifft\n  )\n}",
      "line_count": 57
    },
    {
      "section": "Numerical Strategies",
      "code": "plot_kimesurface_fourier <- function(kimesurf_obj,\n                                     use_reconstructed=TRUE,\n                                     title=\"Fourier Kimesurface\") {\n  # kimesurf_obj has:\n  #   t_seq, theta_seq, Z_original, Z_recon\n  t_seq    <- kimesurf_obj$t_seq\n  theta_seq<- kimesurf_obj$theta_seq\n  \n  Z_mat <- if(use_reconstructed) kimesurf_obj$Z_recon\n           else                 kimesurf_obj$Z_original\n  M <- length(t_seq)\n  N <- length(theta_seq)\n  \n  # Build the radial coordinate system\n  x_mat <- outer(t_seq, cos(theta_seq))\n  y_mat <- outer(t_seq, sin(theta_seq))\n  \n  plot_ly() %>%\n    add_surface(\n      x = ~x_mat,\n      y = ~y_mat,\n      z = ~Z_mat,\n      colorscale = \"Viridis\"\n    ) %>%\n    layout(\n      title = title,\n      scene = list(\n        xaxis = list(title=\"X = t cos(θ)\"),\n        yaxis = list(title=\"Y = t sin(θ)\"),\n        zaxis = list(title=\"Intensity\")\n      )\n    )\n}\n\n### to Also  to Plot the Original (Unfiltered) Surface\n# plot_kimesurface_fourier(kimesurf_obj, use_reconstructed=FALSE, title=\"Original Kimesurface\")\n\n##############################\n# End-to-End Demo: Strategy B\n##############################\n\n# A) Simulate data\nfmri_data <- simulate_fmri_data(n_time=80, n_runs=5)\n\n# B) Build random-laplace angles => Irregular (t,θ,intensity)\ndf_on  <- build_irregular_kimesurface_data(\n  fmri_data, \"ON\",\n  b0=0.3, alpha=0.02, T_max=300\n)\ndf_off <- build_irregular_kimesurface_data(\n  fmri_data, \"OFF\",\n  b0=0.3, alpha=0.02, T_max=300\n)\n\n# C) For each condition => interpolate, do 2D FFT, etc.\nkimesurf_on <- construct_kimesurface_fourier(\n  df_on,\n  n_time_plot  = 60, \n  n_theta_plot = 60,\n  lambda_interp= 0,          # no smoothing in Tps interpolation\n  filter_fraction= 0.5       # keep top 50% largest Fourier components\n)\nkimesurf_off <- construct_kimesurface_fourier(\n  df_off,\n  n_time_plot  = 60,\n  n_theta_plot = 60,\n  lambda_interp= 0,\n  filter_fraction= 0.5\n)\n\n# D) Plot the reconstructed surfaces\np_on  <- plot_kimesurface_fourier(kimesurf_on,\n                                  use_reconstructed=TRUE,\n                                  title=\"ON (Reconstructed from 2D FFT)\")\np_off <- plot_kimesurface_fourier(kimesurf_off,\n                                  use_reconstructed=TRUE,\n                                  title=\"OFF (Reconstructed)\")\n# ##### You can show them separately ....\n# p_on\n# p_off\n# #### Or jointly and synchronously ....\n\n#############################################\n## 5) The triple visualization function\n#############################################\nvisualize_kimesurfaces_tripleREV2 <- function(kimesurf_on, kimesurf_off) {\n  t_min <- 1;     t_max  <- length(kimesurf_on$t_seq)\n  th_min<- 1;     th_max <- length(kimesurf_on$theta_seq)\n  t_seq     <- c(t_min:t_max)\n  theta_seq <- c(th_min:th_max)\n  \n  reshapedOn  <- kimesurf_on$Z_recon\n  reshapedOff <- kimesurf_off$Z_recon\n  \n  # 2D surface in (t,theta) space\n  fig <- plot_ly() %>%\n    # First: ON\n    add_surface(\n      z = reshapedOn,\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"ON\",\n      scene      = \"scene1\"\n    ) %>%\n    layout(\n      scene = list(\n        domain     = list(x = c(0, 0.33), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"time (t)\"),\n        yaxis = list(title = \"Runs (θ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    # Second: OFF\n    add_surface(\n      z = reshapedOff,\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"OFF\",\n      scene      = \"scene2\"\n    ) %>%\n    layout(\n      scene2 = list(\n        domain     = list(x = c(0.33, 0.66), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"time (t)\"),\n        yaxis = list(title = \"Runs (θ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    # Third: Overlay\n    add_surface(\n      z = reshapedOn,\n      colorscale = \"Viridis\",\n      opacity    = 0.5,\n      showscale  = FALSE,\n      name       = \"ON (overlay)\",\n      scene      = \"scene3\"\n    ) %>%\n    add_surface(\n      z = reshapedOff,\n      colorscale = \"Portland\",\n      opacity    = 0.8,\n      showscale  = FALSE,\n      name       = \"OFF (overlay)\",\n      scene      = \"scene3\"\n    ) %>%\n    layout(\n      scene3 = list(\n        domain     = list(x = c(0.66, 1), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"time (t)\"),\n        yaxis = list(title = \"Runs (θ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    layout(\n      title      = \"Kimesurface Visualization of fMRI ON and OFF\",\n      showlegend = TRUE,\n      legend     = list(x=0.85, y=0.1),\n      annotations= list(\n        list(showarrow=FALSE, text='(ON)',  xref='paper', yref='paper',\n             x=0.15, y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OFF)', xref='paper', yref='paper',\n             x=0.5,  y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OVERLAY)',\n             xref='paper', yref='paper', x=0.85, y=0.95,\n             xanchor='center', yanchor='bottom',\n             font=list(size=16))\n      )\n    ) %>%\n    # Sync the cameras\n    onRender(\"\n      function(el) {\n        el.on('plotly_relayout', function(d) {\n          const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n          if (camera.length) {\n            const scenes = Object.keys(el.layout).filter((key) => /^scene\\\\d*/.test(key));\n            const new_layout = {};\n            scenes.forEach(key => {\n              new_layout[key] = {...el.layout[key], camera: {...d[camera]}};\n            });\n            Plotly.relayout(el, new_layout);\n          }\n        });\n      }\n    \")\n  \n  fig\n}\n\nfig <- visualize_kimesurfaces_tripleREV2(kimesurf_on, kimesurf_off)\nfig",
      "line_count": 195
    },
    {
      "section": "Numerical Strategies",
      "code": "library(spatstat)\nlibrary(plotly)\nlibrary(htmlwidgets)\n\n# Extract just the On kime-series at voxel (44,42,33), each time-series includes 10 time-points and has 8 repeats!\n# onFMRISeries <- bigim1_mod[44,42,33, c(1:10, 21:30, 41:50, 61:70, \n#                                        81:90, 101:110, 121:130, 141:150)]\n# # the corresponding Off kime-series at voxel (44,42,33) will be the temporal complement\n# offFMRISeries <- bigim1_mod[44,42,33, -c(1:10, 21:30, 41:50, 61:70, \n#                                          81:90, 101:110, 121:130, 141:150)]\n\n# t_indx <- seq(1, 80, 1) # index of time (not actual time value)\n# f_On <- onFMRISeries\n# f_Off <- offFMRISeries\n\n# Compute and plot against each other the Average On and Average Off time-series\nperiod <- 10   # repeated measurement period\nnumSeries <- 8 # number of fMRI timeseries in the entire run (for each of On and Off signals)\nextract8fMRI_TimeSeries <- function(f=0, period=0) {\n  # Split the fMRI vector into (numSeries=8) individual time-courses\n  fMRI_splitSeries <- split(f, ceiling(seq_along(f) / period))\n  return(fMRI_splitSeries)\n}\n\n# 1. Extract numSeries=8 series for stitching and kimesurface reconstruction\nfMRI_ON_Series <- extract8fMRI_TimeSeries(f=f_On, period=10)\nfMRI_OFF_Series <- extract8fMRI_TimeSeries(f=f_Off, period=10)\n\n# 1.a. Stitch together (using random kime-phase draws, $\\varphi\\sim\\Phi_{[-\\pi,\\pi)}$) all these complex-valued FT series into a kimesurface in k-space.\nphi_8_vec <- matrix(NA, ncol=period, nrow = numSeries)\nfor (t in 1:period) { \n  # for a given t, generate 8 new phases\n  set.seed(t);\n  phi_8_vec[ ,t] <- extraDistr::rlaplace(numSeries, mu=0, sigma=0.5)\n  # rank-order the phases for consistency\n  # within the same foliation leaf\n  phi_8_vec[ ,t] <- sort(phi_8_vec[ ,t])\n  # force phases in [-pi: pi)\n  for (i in 1:numSeries) {\n    if (phi_8_vec[i,t] < -pi) phi_8_vec[i,t] <- -pi\n    if (phi_8_vec[i,t] >= pi) phi_8_vec[i,t] <- pi\n  }\n}\n\nmatrix_ON <- matrix(0, nrow = 2*period+1, ncol = 2*period+1) \nmatrix_OFF <- matrix(0, nrow = 2*period+1, ncol = 2*period+1) \nfor (t in 1:period) {  # POLAR to CARTESIAN coordinates\n  for (p in 1:numSeries) {\n    x = (period+1) + t*cos(phi_8_vec[p,t])\n    y = (period+1) + t*sin(phi_8_vec[p,t])\n    matrix_ON[x,y]  <- fMRI_ON_Series[[p]][t]\n    matrix_OFF[x,y] <- fMRI_OFF_Series[[p]][t]\n  }\n}\n# smooth/blur the matrices\n# matrix_ON_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_ON), sigma=0.5))\n# matrix_OFF_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_OFF), sigma=0.5))\nmatrix_ON_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_ON), sigma=0.5))\nmatrix_OFF_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_OFF), sigma=0.5))\n\n# Display the Re() and Im() parts of the complex k-space kimesurfaces\n# Load necessary libraries\n# Create sequences for x and y axes\nx <- seq(1, 2*period+1, length.out = 2*period+1)\ny <- seq(1, 2*period+1, length.out = 2*period+1)\n\n# Create the first surface plot\npON_Re <- plot_ly(x=x, y=y, z=Re(matrix_ON), type=\"surface\", \n                  scene='scene1', name=\"Re(ON)\") %>% \n  layout(title = \"Re(fMRI-ON Basic Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npOFF_Re <- plot_ly(x=x, y=y, z=Re(matrix_OFF), type=\"surface\", \n                   scene='scene2', name=\"Re(OFF)\") %>% \n  layout(title = \"Re(fMRI-OFF Basic Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npDIFF_Re <- plot_ly(x=x, y=y, z=Re(matrix_ON-matrix_OFF), type=\"surface\",\n                    scene='scene3', name=\"Re(Diff)\") %>% \n  layout(title = \"Re(fMRI-ON - fMRI-OFF Basic Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\n# Scene titles\nannotations=list(list(showarrow=FALSE, text='(ON)', \n                      xref='scene',yref='scene',zref='scene', x=0.0,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='(OFF)', \n                      xref='scene2',yref='scene',zref='scene', x=0.35,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='(DIFF)', \n                      xref='scene3',yref='scene',zref='scene', x=0.7,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)))\n# Combine the plots\ncombined_plot <- subplot(pON_Re, pOFF_Re, pDIFF_Re) %>% #, nrows=2,margin=0.05) %>%\n  layout(title=\"Native-space Reconstruction of fMRI ON and OFF Kimesurfaces using Basic Stitching\", annotations=annotations)\n\n# Display the synchronized plot\ncombined_plot %>% htmlwidgets::onRender(\n    \"function(x, el) {\n      x.on('plotly_relayout', function(d) {\n        const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n        if (camera.length) {\n          const scenes = Object.keys(x.layout).filter((key) => /^scene\\\\d*/.test(key));\n          const new_layout = {};\n          scenes.forEach(key => {\n            new_layout[key] = {...x.layout[key], camera: {...d[camera]}};\n          });\n          Plotly.relayout(x, new_layout);\n        }\n      });\n    }\")",
      "line_count": 111
    }
  ]
}