{
  "metadata": {
    "created_at": "2025-05-15T17:01:01.315169",
    "total_sections": 10,
    "total_code_chunks": 64,
    "total_tables": 1,
    "r_libraries": [
      "AnalyzeFMRI",
      "DT",
      "MultiwayRegression",
      "R.matlab",
      "TCIU",
      "TDA",
      "TDAstats",
      "akima",
      "dplyr",
      "ggfortify",
      "htmlwidgets",
      "manipulateWidget",
      "plotly",
      "shapes",
      "spatstat",
      "tidyr",
      "transport"
    ]
  },
  "sections": [
    {
      "title": "Main",
      "content": "---\ntitle: \"Spacekime Analytics (Time Complexity and Inferential Uncertainty)\"\nsubtitle: \"Basic TCIU Protocol for Predictive Spacekime Analytics using Repeated-Measurement Longitudinal Data\"\nauthor: \"SOCR Team\"\ndate: \"`r format(Sys.time(),'%m/%d/%Y')`\"\noutput: \n  html_document:\n    theme: spacelab\n    highlight: tango\n    includes:\n      before_body: TCIU_header.html\n    toc: true\n    number_sections: true\n    toc_depth: 3\n    toc_float:\n      collapsed: false\n      smooth_scroll: true\n\nThis [Spacekime TCIU Learning Module](https://tciu.predictive.space/) presents \nthe *core elements of spacekime analytics* including:\n\n - Import of *repeated measurement longitudinal* data,\n - Numeric (stitching) and analytic (Laplace) *kimesurface reconstruction* from time-series data,\n - *Forward prediction* modeling extrapolating the process behavior beyond the observed time-span $[0,T]$,\n - *Group comparison* discrimination between cohorts based on the structure and properties of their corresponding kimesurfaces. For instance, statistically quantify the differences between two or more groups,\n - *Unsupervised clustering and classification* of individuals, traits, and other latent characteristics of cases included in the study,\n - Construct low-dimensional *visual representations of large repeated measurement data* across multiple individuals as pooled kimesurfaces (parameterized 2D manifolds),\n - Statistical comparison, topological quantification, and analytical inference using kimesurface representations of repeated-measurement longitudinal data.",
      "word_count": 170
    },
    {
      "title": "Preliminary setup",
      "content": "TCIU and other `R` package dependencies ...",
      "word_count": 7
    },
    {
      "title": "Longitudinal Data Import",
      "content": "In this case, we are just loading some exemplary fMRI data, which is [available here](https://drive.google.com/file/d/1Z5CvfotR032J37vHWf0_5ooAmDRpVVl8/view?usp=sharing).\n\n\nAlternatively, we can simulate synthetic ON/OFF fMRI data that can be saved as\na pair of arrays ON (stimulus) and OFF (rest) conditions.",
      "word_count": 38
    },
    {
      "title": "Time-series graphs",
      "content": "## Interactive time-series visualization\n\nThe `TCIU` function `fmri_time_series()` is used to create four interactive time series graphs for the real, imaginary, magnitude, and phase parts for the fMRI spacetime data. We can also add a reference plotly object to the plot. This function is based on the `GTSplot` function from package `TSplotly`.\n\n\n### Example fMRI(x=4, y=42, z=33, t)",
      "word_count": 58
    },
    {
      "title": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "content": "The following examples connect to several ongoing spacekime analytics, including\n[kimesurface analyticity](https://www.socr.umich.edu/TCIU/HTMLs/Chapter3_Radon_NikodymDerivatives.html), [kimesurface regularization](https://www.socr.umich.edu/TCIU/HTMLs/Chapter4_Laplace_Transform_Timeseries_Kimesurfaces.html), and \n[distribution-time dynamics](https://www.socr.umich.edu/TCIU/HTMLs/Chapter3_ReproducingKernelHilbertSpaces.html).\n\nThe first example uses a *time-series simulation* to illustrate how to transform the fMRI time-series at a fixed voxel location into a *kimesurface* (kime-series).\n\n**Notes**:\n\n - *Validate all steps* in this time-series to kimesurfaces transformation protocol of simulated data, and finalize this 3D visualization.\n\n - Try it with real fMRI data at brain voxel locations associated with the *finger-tapping task* or *musical genre study*.\n \n - [TCIU Chapter 3 Kime-Phase Tomography (KPT)](https://www.socr.umich.edu/TCIU/HTMLs/Chapter3_Kime_Phase_Problem.html) and [TCIU Appendix on Mapping Repeated Measurement Longitudinal Data (Time-series) to 2D Manifolds](https://www.socr.umich.edu/TCIU/HTMLs/Chapter6_TCIU_MappingLongitudinalTimeseries_2_Kimesurfaces.html) provide mechanisms for transforming longitudinal processes from time-courses to kime-surfaces (manifolds).\n\n## Pseudo-code\n\n+ Randomly generate $8$ $phi=\\phi$ kime-phases for each of the $10$ *time radii*. This yields an $8\\times 10$ array (*phi_8_vec*) of kime phase directions. These directions can be obtained by different strategies, e.g., (1) uniform or Laplace distribution sampling over the interval $[-\\pi:\\pi)$, (2) randomly sampling with/without replacement from known kime-phases obtained from similar processes, etc.\n+ Optionally, order all kime-phases (rows) from small to large for each column.\n+ Fix the $\\nu=(x,y,z)$ voxel location and extract the fMRI time-course $fMRI_{\\nu}(t), \\forall 1\\leq t\\leq 160$.\n+ For binary stimuli (e.g., activation (ON) and rest (OFF) event-related design), we can split the 160-long fMRI series into $80$ ON (Activation) and $80$ OFF (rest) states, or sub-series.\n+ Construct a data-frame with $160$ rows and $4$ columns; time ($1:10$), phases ($8$), states ($2$), and fMRI_value (Complex or Real intensity).\n+ Convert the long DF representing fMRI_ON and fMRI_OFF from their native (old) polar coordinates to the (new) Cartesian coordinates, using polar transformations.\n+ Check for visual (graphical) and numeric differences between the fMRI intensities during the ON vs. OFF states\n+ Spatially smooth (blur) the matrices (in 2D) to reduce noise make them more representative of the process. May also need to temper the magnitude of the raw fMRI intensities, which can have a large range.\n+ Generate the `plot_ly` *text labels* that will be shown on mouse hover (pop-up dialogues) over each kimesurface/kime-series. These text-labels are stored in Cartesian coordinates $(-10\\leq x\\leq 10,-10\\leq y\\leq 10)$, but are computed using the polar coordinates $(1\\leq t\\leq 10,-\\pi\\leq \\phi<\\pi)$ and the polar-to-Cartesian transformation. The labels are $21\\times21$ arrays including the triple $(t, \\phi, fMRIvalue)$. Separate text-labels are generated for each kimesurface (ON vs. OFF stimuli).\n+ Generate the $21\\times21$ kime-domain Cartesian grid by polar-transforming the polar coordinates $(t,\\phi)$ into Cartesian counterparts $(x,y)$.\n+ Interpolate the fMRI intensities (natively anchored at $(t,\\phi)$) to $fMRI(x,y), \\forall -11\\leq x,y \\leq 11, \\sqrt{x^2+y^2}\\leq 10$.\n+ Use `plot_ly` to display in 3D the kime-series as 2D manifolds (kimesurfaces) over the Cartesian domain.\n\n\n## Function main step: Time-series to kimesurfaces Mapping\n\n### Generate the *kime-phases*\n\nRandomly generate $8$ $phi=\\phi$ kime-phases for each of the $10$ *time radii*. \nThis yields an $8\\times 10$ array (*phi_8_vec*) of kime phase directions. These directions can be obtained by different strategies, e.g., (1) *uniform* or *Laplace distribution* sampling over the interval $[-\\pi:\\pi)$; (2) randomly sampling with/without replacement from known kime-phases obtained from similar processes; (3) use an $AR(p)$ autoregressive model with memory (affected by prior samples at earlier $p$ times), etc.\n\nOptionally, order all kime-phases (rows) from small to large for each column.\n\n\n### Structural Data Preprocessing\n\nHere should be included any *study-specific data preprocessing*. \nIn the case of fMRI series, we may need to split off the individual repeated measurement\nfMRI time-series from the master (single) fMRI time-series according to the \nspecific event-related fMRI design.\n\nFor simplicity, consider a *simulated binary stimulus paradigm* (e.g., *activation (ON)* and \n*rest (OFF)* event-related design). We can split the $160$-timepoint fMRI series \ninto $80$ ON (Activation) and $80$ OFF (rest) states, or sub-series, consisting of \n$8$ repeats, each of length $10$ time points, where each time point corresponds \nto about $2.5\\ s$ of clock time.\n\n\n\n\n\n### Intensity Data Preprocessing\n\nIn practice, some spatial smoothing (blurring) the 1D time-series or their 2D array (tensor representations as 2D matrices ($row=repeat$, $column=time$) to reduce noise and\nmake the data more natural (low-pass filtering, avoiding high-pitch noise). \nSometimes, we may also need to temper the magnitude of the raw time-series intensities,\nwhich can have a large range.\n\n\n### Generate `plotly` labels\n\nGenerate the `plot_ly` text labels that will be shown over the graph, upon mouse hovering (pop-up dialogues) over each kimesurface/kime-series. These text-labels are stored in Cartesian coordinates $(-10\\leq x\\leq 10,-10\\leq y\\leq 10)$, but are computed using the polar coordinates $(1\\leq t\\leq 10,-\\pi\\leq \\phi<\\pi)$ and the polar-to-Cartesian transformation. The labels are $21\\times 21$ arrays including the triple $(t, \\phi, fMRIvalue)$. Separate text-labels are generated for each kimesurface (*ON vs. OFF stimuli*).\n\n\n\n\n\n### Cartesian space interpolation\n\nInterpolate the fMRI intensities, natively anchored at polar (kime) coordinates)\n$\\left (\\underbrace{t}_{time},\\underbrace{\\phi}_{repeat} \\right)$, into Cartesian\ncoordinates $fMRI(x,y), \\forall -11\\leq x,y \\leq 11, x^2+y^2\\leq 10$. \nNote that for specificity, we hard-coded *polar-grid parameterization* to\n*time* $t\\in\\{1,2,3, \\cdots,10\\},\\ |T|=10$ and *phase* \n$\\phi=seq\\left (from=-\\pi, to=\\pi, step=\\frac{2\\pi}{20}\\right )\\in\\{-3.1415927, -2.8274334, \\cdots, 0.0,\\cdots, 2.8274334,  3.1415927 \\},\\ |\\Phi|=21$.\n\n\n\n\n### Cartesian representation\n\nGenerate the $21\\times 21$ kime-domain Cartesian grid hovering texts.\n\n\n\n\n\n\n\n\n\n\n\nThe last two kimesurface plots are almost identical as the interpolation process is fairly robust.\n\n### Generate a long data-frame\n\nConvert the entire dataset into a *long data-frame*, i.e., construct a data-frame (DF) with \n$\\underbrace{160}_{total}=\\underbrace{2}_{binary\\\\ On/Off}\\times \\underbrace{8}_{repeats}\\times \\underbrace{10}_{timepoints}$ *rows* and $4$ *columns* representing *time* ($1:10$), *phases* ($8$), *states* ($2$), and *fMRI_value* (Complex or Real time-series intensity). \nThen, transform the long DF representing the *fMRI_ON* and *fMRI_OFF* time-sources\nfrom their native (old) *polar coordinates* to the (new) *Cartesian coordinates*, \nusing polar transformations.\n\n\n### Display kimesurfaces\n\nUse `plot_ly` to display in 3D the kime-series as 2D manifolds (kimesurfaces) over the Cartesian domain. In this specific binary case-study, we demonstrate the following $3$ kimesurface\nreconstructions:\n\n - the *On kimesurface*\n - the *Off kimesurface*, and \n - the difference *On - Off kimesurface*.\n\n\n## Autoregressive Kime-Phase Modeling\n\nAbove we demonstrated transforming repeated sampling longitudinal processes \n(time-series) as 2D manifolds (kimesurfaces) using a *kime-phase prior distribution*,\nsuch as the truncated Laplace phase distribution.\n\nAn alternative numerical protocols utilizes [autoregressive model](https://en.wikipedia.org/wiki/Autoregressive_model), $AR(p)$. For instance, \nhere is an $AR(1)$ *kime-phase model* $\\hat{\\theta}_{t}=\\alpha_1 \\theta_{t-1}+ \\varepsilon _{t}$,\nwhere $\\varepsilon_{t}\\sim N(0,\\sigma_{\\varepsilon}^2)$ (white noise) or \n$\\varepsilon_{t}\\sim \\operatorname {Laplace}(\\mu=0,scale=\\sigma_{\\varepsilon}^2)$ (Laplace phase), \n$\\theta_{t}\\equiv \\hat{\\theta}_{t} {\\text{ mod }} 2\\pi \\sim \\Phi_{[-\\pi,\\pi)}(t)$, and \nthe (time-dependent) *kime-phase distribution* $\\Phi_{[-\\pi,\\pi)}(t)$ is compactly \nsupported over the (periodic) interval $[-\\pi,\\pi)$. \n\n - When $|\\alpha_1 |<1$,This $AR(1)$ model is *weak-stationary* and represents the output of a stable filter with white noise input. In this case, $\\forall\\ t$, the mean $\\mu=\\mathbb{E} (\\theta_{t})$ is constant, due to the model's weak stationarity. Since, $\\mathbb{E} (\\theta_{t})=\\alpha_1 \\mathbb{E} (\\theta_{t-1}) + \\mathbb{E} (\\varepsilon_{t}),$ $\\Longrightarrow \\mu =\\alpha \\mu +0,$. therefore, the (stationary) mean is trivial, $\\mu =0$, and the (stationary) variance is constant, ${\\text{var}}(\\theta_{t})=\\mathbb{E} (\\theta_{t}^{2}) - \\mu ^{2}={\\frac {\\sigma _{\\varepsilon}^{2}}{1-\\alpha ^{2}}}.$ This stationarity is due to the fact that ${\\text {var}}(\\theta_{t})=\\alpha ^{2}{\\text{var}}(\\theta_{t-1})+\\sigma_{\\varepsilon }^{2}$. \n - However, if $\\alpha =1$, the variance of $\\theta_t$ depends on time lag $t$. Hence, \nthe variance of the series diverges to infinity as $t\\to\\infty$, implying that\nthe model is *non-stationary*. \n\nIn the more general case, the $AR(p)$ autoregressive model is \n$${\\hat{\\theta}}_{t}= \\sum_{i=1}^{p}\\alpha_{i} \\theta_{t-i} + \\varepsilon _{t},\n\\ \\ \\theta_{t}\\equiv \\hat{\\theta}_{t} {\\text{ mod }} 2\\pi \\sim \\Phi_{[-\\pi,\\pi)}(t)$$\n\nwhere the coefficients $\\alpha_{i}, \\ i\\in\\{1, 2, \\cdots, p\\}$}} are hyper-parameters\nthat can be set, estimated, or optimized to control the covariance function of the model. \nThe $AR(p)$ autoregressive model may also be expressed using the *backshift operator* $B$\n\n$$\\hat{\\theta}_{t} = \\sum_{i=1}^{p}\\alpha_{i}B^{i}\\theta_{t} + \\varepsilon _{t},\n\\ \\ \\theta_{t}\\equiv \\hat{\\theta}_{t} {\\text{ mod }} 2\\pi \\sim \\Phi_{[-\\pi,\\pi)}(t).$$\n\nRearranging the terms on both hands sides, $\\alpha [B]X_{t} = \\varepsilon_{t}$, where\n$\\alpha(z)\\equiv  1 - \\sum_{i=1}^{p} \\alpha_{i}z^{i}$, each $z_{i}\\in\\mathbb{C}$\nsatisfies $|z_{i}|>1$, and the *backshift operator* \n$B^{i}\\theta_{t}=\\theta_{t-i},\\ \\forall\\ i\\in\\mathbb{N}$. \n\nLet's run the same fMRI kimesurface reconstruction we did above (using the Laplace kime-phase\nprior distribution model) on the $AR(p=1)$ kime-phase temporal dynamics $t\\in\\{1,2,3,\\cdots,10\\}$,\nand visually compare the fMRI *On*, *Off*, and *On-Off difference* kimesurface reconstructions.\nAs expected these kimesurafces look smoother and analytic.\n\nThese examples connect to several ongoing spacekime analytics R&D projects, including\n[kimesurface analyticity](https://www.socr.umich.edu/TCIU/HTMLs/Chapter3_Radon_NikodymDerivatives.html), [kimesurface regularization](https://www.socr.umich.edu/TCIU/HTMLs/Chapter4_Laplace_Transform_Timeseries_Kimesurfaces.html), and \n[distribution-time dynamics](https://www.socr.umich.edu/TCIU/HTMLs/Chapter3_ReproducingKernelHilbertSpaces.html).\n\n\nIn the example above, the $AR(1)$ model for a fixed fMRI sequence *repeat index* $r$ is\n\n$$fMRI_t(r) - \\mu(r) = \\alpha_1(r)(fMRI_{t-1}(r) - \\mu(r)) + \\varepsilon_t(r)\\ .$$\nIn this experiment, for the first fMRI *repeat index*, $r=1$, the estimated \n$AR(p=1)$ model *coefficients* and *residuals* were:\n\n - *Slope*, `r attributes(phi_8_vec_AR1[[1]]$coef)$names[1]`, \n$\\alpha_1(r)=$ `r phi_8_vec_AR1[[1]]$coef[1]`, and \n - *Mean*, `r attributes(phi_8_vec_AR1[[1]]$coef)$names[2]`, $\\mu(r)=$ `r phi_8_vec_AR1[[1]]$coef[2]`.\n - The corresponding $AR(1)$ model residuals were $\\{\\varepsilon_t(r)\\}_{t=1}^{10} =\\{$ `r as.vector(phi_8_vec_AR1[[1]]$residuals)` $\\}$.\n\nObservation: As expected, the $AR(p=1)$ (longitudinal) model of the kime-phases \nstabilizes with time. This may be important when kimesurface analyticity, \nsmoothness, or other properties of the *time-series to manifold* transformations\nmay be desirable. Let's also illustrate the resulting\n*On*, *Off*, and *On-Off difference* kimesurface reconstructions.\nThese ($AR(p=1)$ *regularized*) kimesurfaces can be contrasted against their earlier \ncounterparts, which used the raw Laplace kime-phase samples without $AR(1)$ modeling.\n\n\n### Generate `plotly` labels\n\nGenerate the `plot_ly` text labels that will be shown over the graph, upon mouse hovering (pop-up dialogues) over each kimesurface/kime-series. These text-labels are stored in Cartesian coordinates $(-10\\leq x\\leq 10,-10\\leq y\\leq 10)$, but are computed using the polar coordinates $(1\\leq t\\leq 10,-\\pi\\leq \\phi<\\pi)$ and the polar-to-Cartesian transformation. The labels are $21\\times 21$ arrays including the triple $(t, \\phi, fMRIvalue)$. Separate text-labels are generated for each kimesurface (*ON vs. OFF stimuli*).\n\n\n\n### Cartesian space interpolation\n\nInterpolate the fMRI intensities, natively anchored at polar (kime) coordinates)\n$\\left (\\underbrace{t}_{time},\\underbrace{\\phi}_{repeat} \\right)$, into Cartesian\ncoordinates $fMRI(x,y), \\forall -11\\leq x,y \\leq 11, x^2+y^2\\leq 10$. \nNote that for specificity, we hard-coded *polar-grid parameterization* to\n*time* $t\\in\\{1,2,3, \\cdots,10\\},\\ |T|=10$ and *phase* \n$\\phi=seq\\left (from=-\\pi, to=\\pi, step=\\frac{2\\pi}{20}\\right )\\in\\{-3.1415927, -2.8274334, \\cdots, 0.0,\\cdots, 2.8274334,  3.1415927 \\},\\ |\\Phi|=21$.\n\n\n\n\n\n### Cartesian representation\n\nGenerate the $21\\times 21$ kime-domain Cartesian grid hovering texts.\n\n\n\n\n\n\n\n\n\n\n## Analytical Time-series to kimesurface Transformation (*Laplace*)\n\n### Data Preparation\n\nFirst plot the simulated *On* (stimulus) and *Off* (rest) fMRI time-series at a fixed\nvoxel location $(44,42,33)\\in\\mathbb{R}^3$, along with the averaged (pooled) \nOn and Off signal over all $8$ repeats in the single run (epoch) of $160$ time-points.\n\n\nNext, we'll define and apply the Laplace Transform (LT) and its inverse (ILT) and use them to \nshow the *analytical kimesurface reconstruction*.\n\n### Discrete LT\n\n\nLet's test the discrete LT using the $\\sin(x),\\cos(x)$ function.\n\n\n\n\n\nCompare the *above numerical calculation of the Laplace Transform* (LT) \nof $f(x)=\\cos(x)$ against the *below kimesurface of the exact analytical* \n(ground truth integration) of the LT of $f(x)=\\cos(x)$, which is \n\n$$F(z)\\equiv \\mathcal{L}(f)(z)\\equiv \\int_0^{2\\pi}f(t)e^{-zt}dt = \\frac{z-e^{-2\\pi z}z}{1+z^2}\\ .$$\n\n\nThe visual agreement between the *exact* and *numerical* calculations of the kimesurface\n$F(z)$ corresponding to the signal $f(x)=\\cos(x)$ can also be checked by \ncomputing the average surface difference as shown below.\n\n\n\n\n\n\nNext, apply the discrete LT to the *average-On* (`onAvg`) and *average-Off signals* (`offAvg`), interpolating from their original size, $n=10$, to a new *supersampled* size $n=200$, and transforming the time support *from* $t\\in[1:10]$\nin increments of $\\Delta t=1$, *to* $t' \\in[0,2\\pi)$, in increments of $\\Delta t'=\\frac{n}{n+0.5}\\times \\frac{1}{(200-1)2\\pi}.$\n\nThis *numerical longitudinal data preprocessing* is done purely to establish \nsome homologies in the structure of the *LT domain*, i.e., the input space \nsignals (time-series), and the *LT Range*, i.e., the output space \nmanifold (kimesurface). See the [DSPA2 signal interpolation appendix](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_10_Spatiotemporal_Interpolation.html) to find out how to regularize either \n[regularly (equally-spaced) sampled longitudinal data](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_10_Spatiotemporal_Interpolation.html#21_Regularly_spaced_sample) or \n[*irregularly* (unequally-spaced) sampled longitudinal data](https://socr.umich.edu/DSPA2/DSPA2_notes/DSPA_Appendix_10_Spatiotemporal_Interpolation.html#22_Irregularly_spaced_sample).\n\n\n\n\n\n\n\n## Time-series to Kimesurface Mapping using Integral Transforms\n\nNext, we will explore alternative strategies to map repeated measurement time-series\ninto kimesurfaces. These approaches attempt to resolve the issues with mapping the highly irregular (non-analytic/non-holomorphic) kimesurfaces to more locally smooth analytic functions.\n\n### Integral Transformation of Stiching-based Kimesurface Recontrucitons\n\n*Protocol*:\n\n - Apply the standard stitching strategy to transform the repeated time-series into a kimesurface using a random sample of kime-phases, $\\varphi\\sim\\Phi_{[-\\pi,\\pi)}$.\n - Use the inverse of an integral transform, such as Hilbert, Fourier, and ..., to map the irregular ($\\mathbb{C}$-valued) kimesurface into a spacetime-like locally smooth (analytic?) manifold.\n - Explore inference based on these spacetime-like kimesurface reconstructions and contrast these against other statistical/data-analytic/AI tools for prediction, classification based on the original time-series.\n\n*Integral transforms* are mathematical operators maping functions from one domain to another, often simplifying the analysis of problems by transforming *differential equations* into *algebraic equations* or by converting *convolutions* into *products.* Each transform has specific properties, applications, and interpretations, making them essential tools in areas like signal processing, physics, and engineering. Below are commontly used integral transforms, along with their interrelations and interpretations of their forward and reverse transforms.\n\n#### Fourier Transform\n\nThe Fourier Transform, one of the most widely used integral transforms, decomposes a function into its constituent frequencies, transforming a time-domain signal into the frequency domain (*k-space*). For a continuous function \\( f(t) \\), the Fourier transform \\( \\mathcal{F}\\{f(t)\\} = F(\\omega) \\) is defined by\n\\(F(\\omega) = \\int_{-\\infty}^{\\infty} f(t) e^{-i\\omega t} \\, dt .\\)\n\nThe inverse Fourier transform recovers \\( f(t) \\) from \\( F(\\omega) \\) using\n\\(f(t) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} F(\\omega) e^{i\\omega t} \\, d\\omega .\\)\n\nThe *forward* Fourier Transform (FT) maps a time-domain signal into the frequency domain, where \\( F(\\omega) \\) represents the amplitude and phase of the frequencies present in the original signal. Whereas the *inverse* FT reconstructs the time-domain representation of the signal by summing over all frequency components weighted by their amplitudes and phases.\n\n#### Laplace Transform\n\nThe *Laplace Transform* (LT) is closely related to the Fourier Transform but is typically used for functions defined on \\( [0, \\infty) \\), i.e., time-series. It is particularly useful in solving linear differential equations and control theory problems. For a function of time, \\( f(t) \\), the Laplace transform \n\\( \\mathcal{L}\\{f(t)\\} = F(s) \\) is defined by\n\\(F(s) = \\int_0^{\\infty} f(t) e^{-st} \\, dt .\\)\n\nThen, the *inverse* Laplace transform, used to recover \\( f(t) \\) from \\( F(s) \\), is \\(f(t) = \\frac{1}{2\\pi i} \\int_{\\gamma - i\\infty}^{\\gamma + i\\infty} F(s) e^{st} \\, ds .\\) The *forward* LT sends a time-domain function into the complex \n$\\mathbb{C}$-domain, capturing both growth and oscillatory behavior. The *inverse* LT similarly recovers the time-domain function from its \\( z \\)-domain representation, often involving complex analysis techniques like contour integration.\n\n#### Hilbert Transform\n\nThe *Hilbert Transform* (HT) is an integral transform that provides a phase shift to each frequency component of a signal. It is particularly useful in signal processing for creating analytic signals and in the study of harmonic analysis.\nFor a function \\( f(t) \\), the Hilbert transform \n\\( \\mathcal{H}\\{f(t)\\} = \\tilde{f}(t) \\) is defined by\n\\(\\tilde{f}(t) = \\frac{1}{\\pi} \\text{P.V.} \\int_{-\\infty}^{\\infty} \\frac{f(\\tau)}{t - \\tau} \\, d\\tau ,\\)\nwhere P.V. denotes the [Cauchy principal value](https://en.wikipedia.org/wiki/Cauchy_principal_value) of the integral.\n\nThe HT produces a signal where each frequency component of the original signal is phase-shifted by \\( 90^\\circ \\). The combination of the original signal and its Hilbert transform creates an analytic signal (complex signal with only positive frequency components). Applying the Hilbert transform twice to a function $u()$\nyields $\\operatorname {H} {\\bigl (}\\operatorname {H} (u){\\bigr )}(t)=-u(t)$, \nassuming the integrals defining both iterations converge in a suitable sense. \nHence, the inverse HT is $H^{(-1)}=-\\operatorname {H}$. This links the Hilbert transform of $u(t)$ to the Fourier transform of $u(t)$. The Hilbert transform is an operator\n$$\\overbrace{\\mathcal {F}}^{FT}{\\bigl (}\\overbrace{\\operatorname {H}}^{HT} (u){\\bigr )}(\\omega )=-i\\operatorname {sgn}(\\omega )\\cdot {\\overbrace{\\mathcal {F}}^{FT}}(u)(\\omega ).$$\n\nAs the operator $\\operatorname {sgn}(\\omega)$ captures the sign of the argument, this relations applies to the three common FT definitions. The HT is typically applied to real-valued signals to extract the imaginary part of an analytic signal.\n\n#### Z-Transform\n\nThe *Z-transform* is the discrete counterpart of the Laplace Transform, typically used for discrete-time signals. It is extensively used in digital signal processing and control theory. For a discrete sequence \\( f[n] \\), the *forward* Z-transform \\( \\mathcal{Z}\\{f[n]\\} = F(z) \\) is defined by\n\\(F(z) = \\sum_{n=-\\infty}^{\\infty} f[n] z^{-n} .\\) The *inverse* Z-transform is\n\\(f[n] = \\frac{1}{2\\pi i} \\oint F(z) z^{n-1} \\, dz .\\)\n\nForward ZT converts a discrete-time sequence into a complex frequency domain where \\( z\\in\\mathbb{C} \\), where as the *inverse* ZT recovers the original discrete-time sequence from its $z$-domain representation, typically involving residue calculus or partial fraction expansion.\n\n#### Mellin Transform\n\nThe *Mellin Transform* (MT) is another integral transform often used in problems involving scaling, which connects multiplicative convolutions with additive convolutions. For a function \\( f(x) \\), the Mellin transform \\( \\mathcal{M}\\{f(x)\\} = F(s) \\) is \\(F(s) = \\int_0^{\\infty} x^{s-1} f(x) \\, dx .\\)\nThe *inverse* MT is \\(f(x) = \\frac{1}{2\\pi i} \\int_{c - i\\infty}^{c + i\\infty} F(s) x^{-s} \\, ds .\\) The forward MT converts a function into the Mellin domain, which is useful when analyzing problems that exhibit scaling properties (e.g., in image processing or fractal analysis). Whereas the *inverse* MT reconstructs the function from its Mellin transform, often using contour integration techniques.\n\n - The *Fourier transform* is a special case of the *Laplace transform* where the real part of \\( z \\) (in the Laplace domain) is set to zero, i.e., \\( z = i\\omega \\). Thus, the Laplace Transform generalizes the Fourier Transform by considering exponential growth/decay in addition to oscillations. Similarly, the Hilbert transform is closely related to the Fourier transform, as it can be viewed as a frequency-domain filter that shifts the phase of the positive frequencies by \\( -90^\\circ \\) and the negative frequencies by \\( +90^\\circ \\). This makes the Hilbert transform useful for analytic signal generation. The Z-transform can be viewed as a discrete-time version of the Laplace transform, just as the Discrete-Time Fourier transform (DTFT) is the discrete counterpart of the continuous Fourier Transform. When \\( z = e^{i\\omega} \\), the Z-transform becomes the DTFT.\n\n - Finally, the *Mellin transform* is related to the *Fourier Transform* by a logarithmic scaling of the input variable. If a function's domain is logarithmically transformed, the Mellin transform becomes a Fourier transform in the logarithmic domain.\n\n### Fourier Transform Reconstructions\n\n*Protocol*:\n\n - Render the *basic stitching kimesurfaces* reconstructed in the native space. these will provide the baseline for contrasting the subsequent kime-space *kimesurface reconstructions using stitching in the Fourier domain*.\n - Apply the *FT to each time-series* instance of the repeated fMRI (*on* and *Off*) measurement time-series.\n - *K-space stitching together* (using random kime-phase draws, $\\varphi\\sim\\Phi_{[-\\pi,\\pi)}$) all these complex-valued FT series into a kimesurface in the Fourier domain.\n - *IFT the k-space constructed kimesurfaces* into the native space and characterize it's local smoothness, relative to the smoothness of the *kimesurface reconstructions obtained via basic stitching in the native space*.\n\n#### Kimesurface Reconstructions via Basic Stitching in the Native-space\n\n\n\n#### Kimesurface Reconstructions via Fourier-space Stitching\n\nNext, we will examine the kimesurface reconstructions via *k-space stitching together*. This process uses random kime-phase draws, $\\varphi\\sim\\Phi_{[-\\pi,\\pi)}$, e.g., Laplace phase distribution) coupled with\nthe complex-valued FT series of the original repeated measurement fMRI time-series into a kimesurface in the Fourier domain. We will contrast the *IFT of the k-space constructed kimesurfaces* back into the native space and characterize it's local smoothness, relative to the smoothness of the *kimesurface reconstructions obtained via basic stitching in the native space*.\n \n\nWe can also consider using other *integral transforms* to obtain alternative kimesurface reconstructions in the native space.",
      "word_count": 3152
    },
    {
      "title": "Interactive plotly Example",
      "content": "For most of these examples, users may need to review/explore/extend the \ncore functionality in the \n[TCIU-package source-code (CRAN)](https://cran.r-project.org/web/packages/TCIU/index.html) \nto *customize* the [TCIU functionality (GitHub)](https://github.com/SOCR/TCIU) for \nthe application specific needs!\n\n## Plotly method: interactive way\n\nThe function `fmri_image()` is used to create images for front view, side view, and top view of the fMRI image.\n\n\n### Manual examples\n\nA plot *without* (spatio-temporal) *mask* restrictions.\n\n\nA plot *with* (spatio-temporal) *mask* restrictions.\n\n\n## Forecasting with time series\n\nThe function `fmri_ts_forecast()` fits the [ARIMA models](https://socr.umich.edu/DSPA2/DSPA2_notes/12_LongitudinalDataAnalysis.html) \nfor each *voxel* (spatial volume element) location. This function is based on the `TSplot_gen()` function from package `TSplotly`.",
      "word_count": 99
    },
    {
      "title": "Motor area detection",
      "content": "If there are concrete spatial locations (regions, voxels, coordinates) that are \nof specific interest, then one needs to focus on these locations. We'll demonstrate this \nusing fMRI brain activation (simulated) in the somatosensory (motor) cortex.\n\n## fMRI data simulation\n\nThe function `fmri_simulate_func()` is used to *simulate* real-valued fMRI data with\nspecified dimensions (locations and extents).\n\n\n\n## Stimulus detection\n\nThe integrated function `fmri_stimulus_detect()` is designed to apply multiple \nanalytical methods for activation detection, in this case in the (human brain) motor area.\n\nExamples of parametric and non-parametric statistical tests already built in include:\n\n - \"*t-test*\" and \"*Wilcoxon-test\"*, which can be applied to all real*-valued fMRI data,\n - \"*Hotelling's T2*\", \"*Wilk's Lambda*\" and \"*gLRT*\" methods, which can be applied to all *complex-valued* fMRI data,\n - \"*on_off_diff*\" and \"*HRF*\" (accounting for the *hemodynamic response function*) methods, which can be applied to $4D$ real-valued fMRI data where the first method is calculating on-off difference period polar volume to get p-values and the second method is using hemodynamic response function and linear regression,\n - The *post-hoc stat-mapping* filtering can be also applied to the calculated p-values if specified in the parameter or use the function `fmri_post_hoc()`.\n\n\n### Examples\n\n\nSummarize the corresponding p-values.",
      "word_count": 197
    },
    {
      "title": "Motor area visualization",
      "content": "## Visualization and comparison of p-value\n\n### 3D visualization for p-value\n\n\n\n### 2D visualization for p-value\n\nGenerate 2D plots of the 2D p-value (projection images) in sagittal, coronal and axial views.\n\nPlot *without isocontours*.\n\n\n\nPlot *with isocontours*.\n\n\n## Comparison of performance of different methods on the same fMRI data\n\n### 3D p-value comparison\n\nThe function `fmri_pval_comparison_3d()` is used to visualize two p-value maps\nshowing their differences in detecting stimulated brain areas in 3D scenes.\nSince our original fMRI is too big to use here for different statistical tests,\nin this example, we compare the differences of stimulated parts of two different \nfMRI data using the same mask.\n\n\n### 2D p-value comparison\n\nThe function `fmri_pval_comparison_2d()` displays the p-values (generated by \ndifferent statistical tests on the same fMRI data) exposing their difference \nvia 2D plots. For simplicity here we only compare two different 3D arrays of\np-values.",
      "word_count": 145
    },
    {
      "title": "Tri-phase ROI-based Spacekime Analytics",
      "content": "Below we demonstrate a three-tier statistical analysis (*tri-phase*) of regional activation.\n\n*Notes*: \n\n - For large volumes, these calculations may be expensive (i.e., stats mapping may take a significant time)!\n - The following examples are specific to $4D$ fMRI spacekime analytics. In most situations, these processing steps need to be adapted to the concrete data format and the specific application domain. In practice, some of the [TCIU package functions](https://github.com/SOCR/TCIU) may be used as *templates* to extend this spacekime functionality to *alternative data formats* and *different data structures.* \n\n## Phase 1: Detect Potential Activated ROI\n\nFirst, identify large local (regional areas) associated with activations/task stimuli.\n\n\n## Phase 2: ROI-Based Tensor-on-Tensor Regression\n\n\n## Phase 3: FDR Correction and Spatial Clustering\n\n                           \n## 3D visualization based on the activated areas by regions",
      "word_count": 127
    },
    {
      "title": "Statistical Inference on Kimesurfaces",
      "content": "## Quantification of distances between kimesurfaces\n\n[This paper by Daubechies and colleagues](https://doi.org/10.1073/pnas.1112822108) \nshows one approach to quantify the similarities and differences between pairs of\n2D surfaces (embedded in 3D) using their local structures and global information \ncontained in inter-structure geometric relationships:\n\n - Conformal Wasserstein Distance (cW)\n - Conformal Wasserstein Neighborhood Dissimilarity Distance (cWn)\n - Continuous Procrustes Distance Between Surfaces\n\nBelow, we demonstrate one example of computing the *Wasserstein distance* and the \n*Procrustes distance* between a pair of kimesurfaces,  \n\n\n\n## `R` functionality and `R` packages for surface distance calculations\n\n - [dist: Distance Matrix Computation](https://rdrr.io/r/stats/dist.html)\n - [Distance Sampling](https://distancesampling.org/R/), see the [vignettes](https://distancesampling.org/R/vignettes/Project-migration.Rmd)\n - [dsm: Density Surface Modelling of Distance Sampling Data](https://cran.r-project.org/web/packages/dsm/)\n - [topoDistance: Calculating Topographic Paths and Distances](https://cran.r-project.org/web/packages/topoDistance/), the the [vignettes](https://cran.r-project.org/web/packages/topoDistance/vignettes/)\n - [Procrustes shape or size-and-shape distance between two configurations](https://rdrr.io/cran/shapes/man/procdist.html)\n\n## Kimesurface *Tensor Linear Modeling* (TLM)\n\nCapitalizing on previous work, [Lock's TLM, DOI: 10.1080/10618600.2017.1401544](https://doi.org/10.1080/10618600.2017.1401544) and \n[Spacekime Analytics, DOI: 10.1007/s00521-021-06789-8](https://doi.org/10.1007%2Fs00521-021-06789-8), we can perform *tensor linear modeling (TLM)* on kimesurfaces. As parametric 2D manifolds, \nkimesurfaces are second-order *tensors*, or multidimensional arrays extending\nto higher dimensions the multivariate linear models, where measured scalar (or vector) *outcomes*\n$Y_n$) are regressed on two-way (design) matrices \n$X_{n\\times k}$ $(n\\ (samples) \\times k\\ (features))$\nrepresenting the observed inputs (*predictors* or *covariates*). \n\nThe tensor representations of kimesurfaces encoding the repeated measurement longitudinal\ndata are stored as multidimensional arrays with dimensions reflecting, time, repetition,\nsubjects, clinical traits, brain regions, frequencies, and other observable characteristics\nthat may play a role in describing the output (tensor), i.e., complex-valued \n($\\mathbb{C}$) kimesurface intensity. Suppose we have a number of kimesurfaces, one\nkimesurface corresponding to one subject, parameterized on a 2D grid \n$100 (timepoints) \\times 100 (repeats)$. The entire collection of kimesurfaces\nmay be a 4D array (4th order tensor) of dimensions \n\n$$\\underbrace{\\overbrace{\\mathcal{X}}^{kimesurface}}_{design\\ tensor}=\n\\left (\\underbrace{traits}_{phenotypes}, \\underbrace{\\overbrace{100}^{timepoints}, \n\\overbrace{100}^{repeats}}_{\\kappa\\in\\mathbb{C}}, \\overbrace{2}^{f(\\kappa)\\in\\mathbb{C}} \\right ).$$\n\nAssume also that the outcome tensor $\\mathcal{Y}_{N, Q_1, \\cdots, Q_M}$, of dimensions\n$\\left (\\underbrace{traits}_{phenotypes}, attributes\\right )$, is predicted \nusing the observed kimesurface tensor $\\mathcal{X}_{N, P_1, \\cdots, P_L}$. \nThen, the tensor linear model\nfitting $\\mathcal{Y}= \\langle \\mathcal{X},\\ \\mathcal{B}\\rangle_L + \\mathcal{E}$ allows us to estimate\nthe two tensors $\\mathcal{B}_{P_1, \\cdots, P_L; Q_1, \\cdots, Q_M}$ , representing the TLM *effect-sizes* (tensor coefficients), and $\\mathcal{E}_{N, Q_1, \\cdots, Q_M}$, denoting the *residual error tensor*. \n\nThe (contracted) *tensor product*, \n$\\langle \\mathcal{U},\\ \\mathcal{V}\\rangle_L$ operates on an order ($K+L$) tensor,\nrepresenting the TLM_{I_{1} \\times \\cdots \\times I_{K} \\times P_{1} \\times \\cdots \\times P_{L}}$\nand an order ($L+M$) tensor \n$\\mathcal{V}_{P_{1} \\times \\cdots \\times P_{L} \\times Q_{1} \\times \\cdots \\times Q_{M}}$\nand returns another tensor of order ($K+M$), contracting the dimensions \n$\\left (P_{1} \\times \\cdots \\times P_{L}\\right )$. This is different from\nthe general *outer product* of the same two tensors $\\mathcal{U}$ and $\\mathcal{V}$, which yields a different\ntensor of dimensions $(K +2L+M)$. The *tensor product* contracts the common $L$\ndimensions shared by the two tensors $\\mathcal{U}$ abd $\\mathcal{V}$:\n\n$$\\langle{\\mathbb{U}},{\\mathbb{V}}\\rangle_{L} \\left[ {i_{1} , \\ldots , i_{K} ;q_{1} ,\n\\ldots , q_{M} } \\right] = \\mathop \\sum \\limits_{{p_{1} = 1}}^{{P_{1} }} \\cdots \n\\mathop \\sum \\limits_{{p_{L} = 1}}^{{P_{L} }} {\\mathbb{U}}\\left[ {i_{1} , \n\\ldots , i_{K} ;p_{1} , \\ldots , p_{L} } \\right]{\\mathbb{V}}\\left[ {p_{1} , \n\\ldots , p_{L} ;q_{1} , \\ldots , q_{M} } \\right] \\ .$$\n\nIn TLM, the first $L$ modes of the *effects tensor* $\\mathcal{B}$ *contract* the dimensions \nof the covariate tensor, $\\mathcal{X}$, and do not show in the outcome tensor \n$\\mathcal{Y}$. On the other hand, the last $M$ modes of the *effects tensor* $\\mathcal{B}$ *expand*\nalong the modes of the outcome tensor $\\mathcal{Y}$, and are not present in the \ncovariate (data) tensor $\\mathcal{X}$. When sufficient data are available to \nfit the tensor linear model, we can the estimate the *effect tensor* $\\mathcal{B}$ \nand the *residual error tensor* $\\mathcal{E}$. \n\nThe fitted model facilitates *prediction*, *regression*, *forecasting*, and \n*extrapolation* of the outcome tensor $\\mathcal{Y}$ using new or *prospective data*, \n$\\mathcal{X}'$. More specifically, For any *outcome tensor index-set* \n$(q_1, \\cdots, q_M)$ and $\\forall\\ 1\\leq n\\leq N$, the \n[TLM prediction of the corresponding tensor outcome](https://doi.org/10.1007/s00521-021-06789-8)\nis expressed as follows\n\n$$\\underbrace{\\mathcal{Y}' \\left({n,q_{1} , \\ldots , q_{M} } \\right )}_{TLM\\ prediction}\n\\cong \\mathop \\sum \\limits_{{p_{1} = 1}}^{{P_{1} }} \\cdots \\mathop \n\\sum \\limits_{{p_{L} = 1}}^{{P_{L} }} \\underbrace{{\\mathcal{X}'}\\left ({n,p_{1} , \n\\ldots , p_{L} } \\right )}_{new\\ data\\ tensor} \\ \n\\underbrace{\\widehat{\\mathcal{B}} \\left ( {p_{1} , \\ldots , p_{L} ;q_{1} , \\ldots , q_{M} }\n\\right )}_{Estimated\\ effects\\ tensor} \\ .$$\n\nOnce the *effects-tensor* ${\\widehat{\\mathcal{B}}}$ is estimated, the \n*residual tensor*, $\\widehat{\\mathcal{E}}_{N, Q_1, \\cdots, Q_M}$, is computed by\n\n$$\\widehat{\\mathcal{E}}= \\mathcal{Y} - \\langle \\mathcal{X},\\ {\\widehat{\\mathcal{B}}}\\rangle_L\\ .$$\n\nBelow we show *two simple TLM examples*. The first one is a simulation involving $\\sin()$,\nthe *sine* function with different frequencies and the second one uses the *On* and \n*Off* fMRI dataset. In both cases, the first step involves transforming the\nraw longitudinal time-courses to kimesurfaces. Then, the outcomes \n(*sine function period*, in the first example, and *On/Off fMRI stimuli*, \nin the second example) are predicted by the fitted tensor linear model (TLM).\n2D visualizations of the *observed* vs. *predicted* outcomes are shown as scatter plots.\n\nThese examples are intentionally oversimplified to demonstrate the mechanics of\nspacekime analytics using TLM. In practice, research investigators need to draft \nexpropriate analytical protocols that reflect the underlying assumptions \n(e.g., tensor rank decomposition), study design, research hypotheses,\nexpected outcomes, and scientific validity.\n\n\nOf course, the most interesting applications of spacekime analytics reflect\nmultiple repeated measurement data. For instance, we can use the $\\sin(\\cdot)$\nfunction to simulate 10, or 100, noisy signals, corrupted with white noise,\nthat represent multiple repeated observations. Then, we can contrast\nthe extrapolation results from extending the predictions forward in time \nby using various model-based and model-free methods, including spacekime analytics. For instance, the *out-of-temporal-scope spacekime analytic predictions* \nmay be based on applying the [Inverse Laplace Transform to the kimesurface models](https://www.socr.umich.edu/TCIU/HTMLs/Chapter4_Laplace_Transform_Timeseries_Kimesurfaces.html) obtained by first interpolating in the spacekime domain, and then transforming the kimesurface models back into spacetime for validation and contrasting against the predictions of alternative methods. \n\n## *Topological Kimesurface Analyses* (TKA)\n\n[Topological Data Analysis (TDA)](https://en.wikipedia.org/wiki/Topological_data_analysis)\nfacilitates statistical inference, analytics and modeling of point cloud data \nvia extraction and quantification of topological information about the \nunderlying space that the observed data is embedded in.  \nExamples of such *topological characterizations*\ninclude estimation of distance functions, distance to a measure functions,\nkNN density estimators, kernel density estimators, and kernel distances. \nTDA aims to capture salient topological features of the sub- or super-level \nsets of these functions by quantifying the embedding space\n[persistent homology](https://en.wikipedia.org/wiki/Persistent_homology). \n\nThere are a number of algorithms for computing the persistent homology of the\nRips filtration, which represents just one for the persistent homology of \nthe sub- and super-level sets of any functions evaluated over a grid of points,\ne.g, C++ libraries *GUDHI, Dionysus*, and *PHAT*, and `R` packages [TDA](https://cran.r-project.org/web/packages/TDA),\n[TDAstats](https://cran.r-project.org/web/packages/TDAstats) and \n[tdaverse](https://github.com/tdaverse/tdaverse). \n\nObtaining reliable estimates of the persistence homology of kimesurfaces facilitates \ndiagrammatic depictions and quantitative analytics of the induced\n*topological characterizations* (functions, distances, and distributions).\nFor repeated measurements longitudinal data (such as time-series)Specifically,\n*topological kimesurface analyses* (TKA) enables the identification \nand explication of spatiotemporal structure of the corresponding \nkimesurface representations.\n\n### Quantitative TKA\n\nThe examples below use the [TDA framework](https://cran.r-project.org/web/packages/TDA/vignettes/article.pdf) to showcase the basic steps in TKA/TDA and describe some quantitative kimesurface\nanalytical protocols. Examples of *topological quantization functions* that will \nbe demonstrated include the following:\n\n - The *distance function* is defined $\\forall y \\in \\mathbb{R}^d$ by $\\Delta(y) = \\inf_{x\\in X} |x − y|_{L_2}$.\n - Given a *probability measure* $P$ , the *distance to measure (DTM)* function is defined $\\forall y \\in \\mathbb{R}^d$ by $d_{m_o}(y)=\\left ( \\frac{1}{m_o} \\int_{0}^{m_o} {\\left ( G^{-1}_y(u)\\right )^r\\ du} \\right )^{\\frac{1}{r}}$, where $G_y(u)= P\\left (|X − y|\\leq t\\right )$, and the *tuning parameters* (smoothness) $m_o\\in (0, 1)$ and $r \\in [1,\\infty)$ control the (smoothness/analytic) properties of the DTM. As $m_o \\uparrow$, the DTM function becomes *smoother*. The DTM is a smoother version of the *distance function*. For discrete kimesurfaces, $X = \\{x_1, \\cdots , x_n\\}$, the *distance to measure* function is defined by $\\hat{d}_{m_o}(y)=\\left ( \\frac{1}{k} \\sum_{x_i\\in N_k(y)} {\\left ( ||x_i - y||^r\\right )} \\right )^{\\frac{1}{r}}$, where $k = \\lceil m_o \\times n\\rceil$ and the $k$-nearest neighbors $y\\in N_k(y)$ surround the discrete kimesurfaces, $X = \\{x_1, \\cdots , x_n\\}$.\n - $\\forall y \\in \\mathbb{R}^d$, the $k$-*nearest neighbor density estimator*, is defined by $\\hat{\\delta}_k(y)=\\frac{k}{n\\ \\nu_d\\ r_k^d(y)}$, where $\\nu_d$ is the volume of the Euclidean $d$-dimensional unit ball and $r_k^d(\\cdot)$ is the Euclidean distance from point $y$ to its $k^{th}$ closest neighbor among the points on the kimesurface $X$.\n - $\\forall y \\in \\mathbb{R}^d$, the *Gaussian Kernel Density Estimator (KDE)*, is defined by $\\hat{p}_h(y)=\\frac{1}{n(h\\sqrt{2\\pi})^d} \\sum_{i=1}^{n}{e^{-\\frac{||y-x_i||_2^2}{2h^2}}}$, where $h$ is the kernel smoothing parameter.\n - *Density Clustering* using the function `TDA::clusterTree()` provides a mechanism to segment, partition, and classify kimesurfaces. Suppose $f$ is the (kimesurface) *density* of a (kimesurface) *probability distribution* $P$ and we have obtained/observed a sample of kimesurfaces $X = \\{x_1, \\cdots , x_n\\}\\subset \\mathbb{R}^d$. Given a threshold value $\\lambda \\gt 0$, denote the corresponding super-level set of $f$ by $L_f (\\lambda) \\equiv  closure\\left (\\{x\\in \\mathbb{R}^s : f (x) \\gt \\lambda\\}\\right )$, whose $d$-dimensional subsets are *high-density regions*.\n\nThe high-density clusters of $P$ are the maximally connected subsets of \n$L_f (\\lambda)$. The evolution and the hierarchy of the high-density clusters\nof $P$ can be tracked by the level-sets dynamics corresponding to\n$\\lambda\\in \\mathbb{R}^+$. This evolution $0\\leftarrow \\lambda\\rightarrow \\infty$ yields the cluster density tree of the distribution $P$, defined as the\ncollection of sets $T\\equiv \\{L_f(\\lambda),\\ \\forall\\lambda \\geq 0\\}$\nthat satisfy the (hierarchical-clustering) *tree property*, i.e.,\n$\\forall A, B \\in T$, either $A \\subset B$, or $B \\subset A$, or \n$A\\cap B = \\emptyset$. This $\\lambda$-*tree construction* can be augmented\nby the $\\alpha$-tree and $\\kappa$-tree constructions, which encode the\nprobability content of each tree branch, rather than the probability density\nlevel. *Cluster trees* are useful in high dimensional data analytics (HDDA) such as feature rich point-cloud datasets and kimesurfaces whose spatiotemporal \norganization (structure) may be challenging to explicate in the native space.\n\n\n\n### Parametric and Nonparametric Statistical Inference on Kimesurfaces\n\nBoth classical *parametric* and *nonparametric* (e.g., permutation) tests can be\nused to identify the statistical significance between kimesurfaces. In general,\nas the kimesurface distributions and the kimesurface topological \ncharacterizations are relatively unknown, the parametric assumptions may be \n*invalid* and TDA/TKA-based statistical inference on persistent homology is\nbest quantified using *nonparametric tests*. Suppose we have\na pair of (point-clouds) kimesurfaces $X$ and $Y$ (think of the *fMRI-ON* and *fMRI-Off*\ntime-series runs). recall that in *classical statistical inference*, \nwe compare the *data-driven estimates* of specific *population parameters* \n(e.g., mean, median) of each population (e.g., fMRI activation vs. rest) using \na *null* ($H_o$) and an *alternative (research)* ($H_a$) *hypotheses*:\n\n$$H_o:\\mu_X=\\mu_Y\\ \\ vs.\\ \\  H_a:\\mu_X \\not= \\mu_Y\\ .$$\n\nSuppose a function $T$ returns the persistent homology of a point-cloud (kimesurface). The *kimesurface distribution parameters* (e.g., medians)\ncorresponding to the pair of fMRI paradigms (On vs. Off), are statistically\ncontrasted using corresponding (proper) *proxy measures* of the underlying kimesurface distributions (e.g., *sample* means, medians, variance, etc.).\nWithout *a priori* parametric assumptions, we can assess\nthe following hypotheses using a nonparametric\n[permutation test](https://doi.org/10.1007/s41468-017-0008-7) to explicate\nthe statistical inference comparing the quantitative TKA \ndescriptions of the pair of kimesurfaces:\n\n$$H_o: T(X)=T(Y)\\ \\ vs.\\ \\  H_a:T(X) \\not= T(Y)\\ .$$\n\nNote that the permutation-test calculations below are computationally expensive.\nTo expedite the compilation (*knitting*) of the Rmd into HTML5, the following \nexamples use only (homologous) portions of the pair of kimesurfaces. Hence, the actual statistical significance (e.g., p-values) are *coarse approximations* of\nthe corresponding p-values. In practice, the *exact p-values* should always be used.\n\n\nIn this simple example, the *1-cycle of the persistent homology* represents a single topological quantification of the fMRI kimesurfaces\ncorresponding to the *On* and *Off* stimuli. The statistical significance\nquantifying the evidence to reject the null hypotheses, \n$H_o: T(X)=T(Y)\\ \\ vs.\\ \\  H_a:T(X) \\not= T(Y)$, is represented by\nthe computed *p-value=* `r onn_off_PermTest[[2]]$pvalue`.\n\n### Background on Topological Data Analysis\n\n*Simplicial complex* representation of point cloud data, *persistent homology* quantification, and *topological data analysis* (TDA) rely on some of the following basic concepts.  \n\n - A $k$-*simplex* is denoted by $[v_0,v_1, \\cdots ,v_k]$ and represents the *convex hull* of $k+1$ affinely independent points $v_0,v_1, \\cdots ,v_k$. For example, the $0$-simplex $[v_0]$ is just the single *point* $v_0$, whereas the $1$-simplex $[v_0,v_1]$ is the *edge* (line-segment) between the vertices $v_0$ and $v_1$, and the $2$-simplex $[v_0,v_1,v_2]$ is the *triangle* bordered by the three $1$-simplices (edges) $[v_0,v_1]$, $[v_1,v_2]$, and $[v_0,v_2]$.\n - A $j$-simplex $[u_0, u_1, \\cdots ,u_j]$ is a *face* of another $k$-simplex $[v_0,v_1, \\cdots ,v_k]$ when $\\{u_0, u_1, \\cdots ,u_j\\}\\subset \\{v_0,v_1, \\cdots ,v_k\\}$.\n - A *simplicial complex* $K$ is a countable set of simplices where (1) every face of a simplex in $K$ is also in $K$, and (2) when two simplices $\\sigma_1,\\sigma_2\\in K$, their intersection is *either empty* or a *face* of both simplices $\\sigma_1,\\sigma_2$.\n - For a finite *simplicial complex* $K$, a *simplicial k-chain* is a formal linear combination (over $\\mathbb{C}$) of $k$-simplices in $K$. The set of $k$-chains forms a vector space $C_k(K)$. For each $k$-simplex, and by a linear extension, for each $k$-chain, the *boundary map* $\\partial_k: C_k(K) \\to C_{k-1}(K)$ is defined by\n\n$$\\partial_k([v_0, v_1, \\cdots ,v_k]) = \\sum_{j=0}^k {\n(-1)^j[v_0,\\cdots ,\\hat{v_j}, \\cdots ,v_k]}\\ \n\\overbrace{\\underbrace{=}_{-1\\equiv +1}}^{\\text{in }\\mathbb{Z}_2}\\ \n\\sum_{j=0}^k [v_0,\\cdots ,\\hat{v_j}, \\cdots ,v_k]\\ ,$$\n\nThe second equality above follows since $\\mathbb{Z}_2$ is the coefficient group.\nFor the *boundary map*, $\\partial_k$, the elements of \n$B_k(K) = {\\text {img}}\\ \\partial _{k+1}$ are the *boundaries* and \nthe elements of $Z_k(K)={\\text {ker}}\\ \\partial_k$ are the  *cycles.* \nFor instance, the $1$-cycle represents the elements of\n$Z_1(K)={\\text {ker}}\\ \\partial_1$, where \n$\\partial_1: C_1(K) \\to C_{0}(K)$.\n\nNote that concatenating boundary maps yields elements in the *kernel*,\n$\\partial_{k+1}\\circ \\partial_k=0$, i.e., $B_k(K) \\subseteq Z_k(K)$. \nFor the *simplicial complex* $K$, this property suggests the following\n$k^{th}$ *homology group* definition\n\n$$H_k(K)\\equiv Z_k(K)/B_k(K)\\ .$$\n\nThe *TKA topological barcode plots* above may have different ranges\nfor the horizontal and/or vertical axes, which may aid or complicate the \ndirect comparison between the kimesurfaces. \nThe persistent homology of the two kimesurfaces are compared using\nthe *Wasserstein metric* (Wasserstein-1 is the Earth Mover's Distance). \nThe interpretation of the *magnitude of the Wasserstein metric* for a \npair of kimesurfaces is difficult without a baseline, i.e.,\n*reference distribution*. The nonparametric *permutation test* permutes the \npoints between the ON and OFF fMRI kimesurfaces to derive the\nstatistical significance, reflecting the power to reject the null hypothesis.\nAdditional details about statistical TDA/TKA inference using permutation tests \nis provided in this article [Hypothesis testing for topological data analysis, DOI: 10.1007/s41468-017-0008-7](https://doi.org/10.1007/s41468-017-0008-7).\n \n\n<!--html_preserve-->\n<div>\n    \t<footer><center>\n\t\t\t<a href=\"https://www.socr.umich.edu/\">SOCR Resource</a>\n\t\t\t\tVisitor number <img class=\"statcounter\" src=\"https://c.statcounter.com/5714596/0/038e9ac4/0/\" alt=\"Web Analytics\" align=\"middle\" border=\"0\">\n\t\t\t\t<script type=\"text/javascript\">\n\t\t\t\t\tvar d = new Date();\n\t\t\t\t\tdocument.write(\" | \" + d.getFullYear() + \" | \");\n\t\t\t\t</script> \n\t\t\t\t<a href=\"https://socr.umich.edu/img/SOCR_Email.png\"><img alt=\"SOCR Email\"\n\t \t\t\ttitle=\"SOCR Email\" src=\"https://socr.umich.edu/img/SOCR_Email.png\"\n\t \t\t\tstyle=\"border: 0px solid ;\"></a>\n\t \t\t </center>\n\t \t</footer>\n\n\t<!-- Start of StatCounter Code -->\n\t\t<script type=\"text/javascript\">\n\t\t\tvar sc_project=5714596; \n\t\t\tvar sc_invisible=1; \n\t\t\tvar sc_partition=71; \n\t\t\tvar sc_click_stat=1; \n\t\t\tvar sc_security=\"038e9ac4\"; \n\t\t</script>\n\t\t\n\t\t<script type=\"text/javascript\" src=\"https://www.statcounter.com/counter/counter.js\"></script>\n\t<!-- End of StatCounter Code -->\n\t\n\t<!-- GoogleAnalytics -->\n\t\t<script src=\"https://www.google-analytics.com/urchin.js\" type=\"text/javascript\"> </script>\n\t\t<script type=\"text/javascript\"> _uacct = \"UA-676559-1\"; urchinTracker(); </script>\n\t<!-- End of GoogleAnalytics Code -->\n</div>\n<!--/html_preserve-->",
      "word_count": 2470
    }
  ],
  "tables": [
    {
      "section": "Main",
      "content": "    code_folding: hide\n---",
      "row_count": 2
    }
  ],
  "r_code": [
    {
      "section": "Main",
      "code": "knitr::opts_chunk$set(echo = TRUE,cache = FALSE, warning = FALSE)",
      "line_count": 1
    },
    {
      "section": "Preliminary setup",
      "code": "library(TCIU)\nlibrary(DT)\nlibrary(\"R.matlab\")\n# library(AnalyzeFMRI) # https://cran.r-project.org/web/packages/AnalyzeFMRI/index.html\nlibrary(ggfortify)\nlibrary(plotly)\nlibrary(manipulateWidget)\nlibrary(transport)\nlibrary(shapes)",
      "line_count": 9
    },
    {
      "section": "Longitudinal Data Import",
      "code": "# pathname <- file.path(\"./test_data\", \"subj1_run1_complex_all.mat\")\nmat1 = readMat(\"./test_data/subj1_run1_complex_all.mat\")\nbigim1 = mat1$bigim[,64:1,,]\nbigim1_mod = Mod(bigim1) # Modulus\nsmoothmod = GaussSmoothArray(bigim1_mod,sigma = diag(3,3))\n# dim(bigim1) = 64 64 40\n# bigim1 contains the complex image space\n# dimensions are 64x*64y*40z*160t, corresponding to x,y,z,time\nload(\"./test_data/mask.rda\") # load the 3D nifti data of the mask\nload(\"./test_data/mask_label.rda\") # load the 3D nifti data of the mask with labels\nload(\"./test_data/mask_dict.rda\") # load the label index and label name\nlabel_index = mask_dict$index\nlabel_name = as.character(mask_dict$name)\nlabel_mask = mask_label\nload(\"./test_data/hemody.rda\") # load the hemodynamic contour of the brain",
      "line_count": 15
    },
    {
      "section": "Longitudinal Data Import",
      "code": "library(plotly)\nlibrary(dplyr)\n\n# 1. Simulate On/Off fMRI time-series data\nsimulate_fmri_data <- function(n_time = 80, n_runs = 5, subjects = 20) {\n  set.seed(123)\n  \n  # Example: 'ON' data\n  arr_on <- array(\n    rnorm(n_time * n_runs * subjects, mean=0, sd=1),\n    dim = c(n_time, subjects, n_runs)\n  )\n  # 'OFF' could be something different. For demonstration, let's shift it\n  arr_off <- array(\n    rnorm(n_time * n_runs * subjects, mean=1, sd=1),\n    dim = c(n_time, subjects, n_runs)\n  )\n  \n  list(ON = arr_on, OFF = arr_off)\n}\n\n# 2. Display the On and Off series\n# This function converts the 3D array data into a tidy data frame format\n# Calculates the mean time series for each condition (ON/OFF)\n# Creates an interactive plot with:\n# \n# Individual run data shown with low opacity\n# Mean condition data shown with thicker lines\n# Interactive tooltips with details on hover\n# Legend distinguishing between conditions and runs\n# Appropriate axis labels and title\n# Function to create interactive plotly visualization of fMRI data\nplot_fmri_timeseries <- function(fmri_data, subjects = c(1), title=\"On/Off fMRI Time-Series Data\") {\n  # Extract data from the simulation\n  on_data <- fmri_data$ON[ , subjects, ]\n  off_data <- fmri_data$OFF[ , subjects, ]\n  \n  # fix the dimensions\n  on_data  <- array(on_data, dim = c(dim(on_data)[1], length(subjects), dim(on_data)[2]))\n  off_data <- array(off_data, dim = c(dim(off_data)[1], length(subjects), dim(off_data)[2]))\n    \n  n_time <- dim(on_data)[1]\n  n_runs <- dim(on_data)[3]\n  \n  # Create a data frame for plotting\n  plot_data <- data.frame()\n  \n  # Process ON data\n  for (run in 1:n_runs) {\n    temp_df <- data.frame(Time = 1:n_time, Value = on_data[, 1, run],\n                          Condition = \"ON\", Run = paste(\"Run\", run))\n    plot_data <- rbind(plot_data, temp_df)\n  }\n  \n  # Process OFF data\n  for (run in 1:n_runs) {\n    temp_df <- data.frame(Time = 1:n_time, Value = off_data[, 1, run],\n                          Condition = \"OFF\", Run = paste(\"Run\", run))\n    plot_data <- rbind(plot_data, temp_df)\n  }\n  \n  # Calculate mean values for each condition across runs\n  mean_data <- plot_data %>%\n    group_by(Time, Condition) %>%\n    summarize(Mean_Value = mean(Value), .groups = 'drop')\n  \n  # Create interactive plot\n  p <- plot_ly() %>%\n    # Add individual run traces with lower opacity\n    add_trace(data = plot_data, x = ~Time, y = ~Value, color = ~Condition,\n               type = 'scatter', mode = 'lines', linetype = ~Run, opacity = 0.3,\n               showlegend = TRUE, hoverinfo = 'text', text = ~paste('Condition:',\n                  Condition, '<br>Run:', Run, '<br>Time:', Time, '<br>Value:', round(Value, 3))\n    ) %>%\n    # Add mean traces with higher opacity and wider lines\n    add_trace(data = mean_data, x = ~Time, y = ~Mean_Value, color = ~Condition,\n               type = 'scatter', mode = 'lines', line = list(width = 4),\n               name = ~paste(Condition, \"Mean\"), hoverinfo = 'text',\n               text = ~paste('Condition:', Condition, 'Mean', \n                   '<br>Time:', Time, '<br>Value:', round(Mean_Value, 3))\n    ) %>%\n    layout(title = title,\n      xaxis = list(title = \"Time Point\"), yaxis = list(title = \"Signal Value\"),\n      legend = list(orientation = 'h', y=-0.1), hovermode = \"closest\")\n  return(p)\n}\n\n# 2.1 Generate simulated data\nfmri_data <- simulate_fmri_data(n_time = 80, n_runs = 5, subjects = 20)\n# 2.2 Create interactive plot\nplot_fmri_timeseries(fmri_data=fmri_data, subjects = c(1), title=\"Simulated On/Off fMRI Time-Series Data\")\n\n\n# 3. The triple Kimesurface visualization function\nvisualize_kimesurfaces_tripleREV <- function(fmri_data) {\n  t_min <- 1;     t_max <- dim(fmri_data$ON)[1]\n  th_min<- 1;     th_max<- dim(fmri_data$ON)[2]*dim(fmri_data$ON)[3]\n  \n  t_seq     <- c(t_min:t_max)\n  theta_seq <- c(th_min:th_max)\n  \n  # flatten the repeats within subject over runs (5) and across subjects (20) == th_max\n  # into a single dimensions, random sampling for theta,\n  reshapedOn <- matrix(fmri_data$ON, nrow = th_max, ncol = t_max)\n  reshapedOff <- matrix(fmri_data$OFF, nrow = th_max, ncol = t_max)\n  \n  # 2D surface in (t,theta) space\n  fig <- plot_ly() %>%\n    # First: ON\n    add_surface(\n      z = reshapedOn,\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"ON\",\n      scene      = \"scene1\"\n    ) %>%\n    layout(\n      scene = list(\n        domain     = list(x = c(0, 0.33), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"time (t)\"),\n        yaxis = list(title = \"Runs * Participants (θ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    # Second: OFF\n    add_surface(\n      z = reshapedOff,\n      colorscale = \"Viridis\",\n      showscale  = FALSE,\n      name       = \"OFF\",\n      scene      = \"scene2\"\n    ) %>%\n    layout(\n      scene2 = list(\n        domain     = list(x = c(0.33, 0.66), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"time (t)\"),\n        yaxis = list(title = \"Runs * Participants (θ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    # Third: Overlay\n    add_surface(\n      z = reshapedOn,\n      colorscale = \"Viridis\",\n      opacity    = 0.5,\n      showscale  = FALSE,\n      name       = \"ON (overlay)\",\n      scene      = \"scene3\"\n    ) %>%\n    add_surface(\n      z = reshapedOff,\n      colorscale = \"Portland\",\n      opacity    = 0.8,\n      showscale  = FALSE,\n      name       = \"OFF (overlay)\",\n      scene      = \"scene3\"\n    ) %>%\n    layout(\n      scene3 = list(\n        domain     = list(x = c(0.66, 1), y = c(0, 1)),\n        aspectmode = \"cube\",\n        xaxis = list(title = \"time (t)\"),\n        yaxis = list(title = \"Runs * Participants (θ)\"),\n        zaxis = list(title = \"Intensity\")\n      )\n    ) %>%\n    layout(\n      title      = \"Kimesurface Visualization of fMRI ON and OFF\",\n      showlegend = TRUE,\n      legend     = list(x=0.85, y=0.1),\n      annotations= list(\n        list(showarrow=FALSE, text='(ON)',  xref='paper', yref='paper',\n             x=0.15, y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OFF)', xref='paper', yref='paper',\n             x=0.5,  y=0.95, xanchor='center', yanchor='bottom',\n             font=list(size=16)),\n        list(showarrow=FALSE, text='(OVERLAY)',\n             xref='paper', yref='paper', x=0.85, y=0.95,\n             xanchor='center', yanchor='bottom',\n             font=list(size=16))\n      )\n    ) %>%\n    # Sync the cameras\n    onRender(\"\n      function(el) {\n        el.on('plotly_relayout', function(d) {\n          const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n          if (camera.length) {\n            const scenes = Object.keys(el.layout).filter((key) => /^scene\\\\d*/.test(key));\n            const new_layout = {};\n            scenes.forEach(key => {\n              new_layout[key] = {...el.layout[key], camera: {...d[camera]}};\n            });\n            Plotly.relayout(el, new_layout);\n          }\n        });\n      }\n    \")\n  \n  fig\n}\n\n# 4. Display the kime-surfaces\nfmri_data <- simulate_fmri_data()\nfig <- visualize_kimesurfaces_tripleREV(fmri_data)\nfig",
      "line_count": 209
    },
    {
      "section": "Time-series graphs",
      "code": "# reference_plot = sample[[4]]\nfmri_time_series(bigim1, c(44,42,33), is.4d = TRUE) #, ref = reference_plot)",
      "line_count": 2
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# plot Laplacian\n# ggfortify::ggdistribution(extraDistr::dlaplace, seq(-pi, pi, 0.01), m=0, s=0.5)\n\nt <- seq(-pi, pi, 0.01)\nf_t <- extraDistr::dlaplace(t, mu=0, sigma=0.5)\nplot_ly(x=t, y=f_t, type=\"scatter\", mode=\"lines\", name=\"Laplace Distribution\") %>%\n  layout(title=\"Laplace Distribution: Kime-Phase Prior\")\n\n# randomly generate 8 phi kime-phases for each of the 10 time radii\nphi_8_vec <- matrix(NA, ncol=10, nrow = 8)\nfor (t in 1:10) { \n  # for a given t, generate 8 new phases\n  set.seed(t);\n  phi_8_vec[ ,t] <-\n    extraDistr::rlaplace(8, mu=0, sigma=0.5)\n  # rank-order the phases for consistency\n  # within the same foliation leaf\n  phi_8_vec[ ,t] <- sort(phi_8_vec[ ,t])\n  # force phases in [-pi: pi)\n  for (i in 1:8) {\n    if (phi_8_vec[i,t] < -pi) \n      phi_8_vec[i,t] <- -pi\n    if (phi_8_vec[i,t] >= pi) \n      phi_8_vec[i,t] <- pi\n  }\n}\n# order all kime-phases (rows) from small to large for each column\n# phi_8_vec_ordered <- apply(phi_8_vec, 2, sort)",
      "line_count": 28
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "fMRI_ON<-bigim1_mod[40,42,33,][c(rep(TRUE,10),rep(FALSE,10))]\nfMRI_OFF<-bigim1_mod[40,42,33,][c(rep(FALSE,10),rep(TRUE,10))]",
      "line_count": 2
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# Convert the long DF representing fMRI_ON and fMRI_OFF from polar coordinates to Cartesian coordinates\nlibrary(spatstat)\n\nmatrix_ON <- matrix(0, nrow = 21, ncol = 21) \nmatrix_OFF <- matrix(0, nrow = 21, ncol = 21) \nfor (t in 1:10) {\n  for (p in 1:8) {\n    x = 11+t*cos(phi_8_vec[p,t])\n    y = 11+t*sin(phi_8_vec[p,t])\n    matrix_ON[x,y]  <- fMRI_ON[(p-1)*10 +t] # What is matrix_ON?\n    matrix_OFF[x,y] <- fMRI_OFF[(p-1)*10 +t]\n  }\n}\n# smooth/blur the matrices\n# matrix_ON_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_ON), sigma=0.5))\n# matrix_OFF_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_OFF), sigma=0.5))\nmatrix_ON_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_ON), sigma=0.5))\nmatrix_OFF_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_OFF), sigma=0.5))",
      "line_count": 18
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# fix the plot_ly Text Labels\nx <- vector()\ny <- vector()\ni <- 1\nfor (t in 1:10) {\n  for (p in 1:8) {\n    x[i] = 11+t*cos(phi_8_vec[p,t])\n    y[i] = 11+t*sin(phi_8_vec[p,t])\n    i <- i+1\n  }\n}",
      "line_count": 11
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# hoverText <- cbind(x=1:21, y=1:21, height=as.vector(t(matrix_ON_smooth))) # tail(mytext)\n# custom_txt <- matrix(NA, nrow=21, ncol=21)\n# hoverTextOFF <- cbind(x=1:21, y=1:21, height=as.vector(t(matrix_OFF_smooth))) # tail(mytext)\n# custom_txtOFF <- matrix(NA, nrow=21, ncol=21)\n# \n# for (x in 1:21) {\n#    for (y in 1:21) {\n#      t = sqrt((x-11)^2 + (y-11)^2)\n#      p = atan2(y-11, x-11)\n#      custom_txt[x,y] <- paste(' fMRI: ', round(hoverText[(x-1)*21+y, 3], 3),\n#                     '\\n time: ', round(t, 0),\n#                     '\\n phi: ', round(p, 2)) \n#      custom_txtOFF[x,y] <- paste(' fMRI: ', round(hoverTextOFF[(x-1)*21+y, 3], 3),\n#                     '\\n time: ', round(t, 0),\n#                     '\\n phi: ', round(p, 2)) \n#    }\n# }",
      "line_count": 17
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# xx2 <- 11 + c(-10:10) %o% cos(seq(-pi, pi, 2*pi/20))\n# yy2 <- 11 + c(-10:10)  %o% sin(seq(-pi, pi, 2*pi/20))\nxx2 <- 11 + seq(0,10,1/2) %o% cos(seq(-pi, pi, 2*pi/20))\nyy2 <- 11 + seq(0,10,1/2)  %o% sin(seq(-pi, pi, 2*pi/20))\n#zz2 <- as.vector(matrix_ON_smooth) %o% rep(1, 21*21)\nzz2 <- matrix_ON_smooth\nww2 <- matrix_OFF_smooth\ndd2 <- matrix_ON_smooth-matrix_OFF_smooth\n\n#plot 2D into 3D and make the text of the diameter (time), height (r), and phase (phi)\nf <- list(family = \"Courier New, monospace\", size = 18, color = \"black\")\nx <- list(title = \"k1\", titlefont = f)\ny <- list(title = \"k2\", titlefont = f)\nz <- list(title = \"fMRI Kime-series\", titlefont = f)",
      "line_count": 14
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# matrix_ON_smooth,matrix_OFF_smooth is indexed in Cartesian coordinates\n# Reinterpolate the fMRI intensities according to Polar grid\nlibrary(akima)\nON_transformed <- matrix(0, nrow = 21, ncol = 21)\nOFF_transformed <- matrix(0, nrow = 21, ncol = 21)\nON_OFF_transformed <- matrix(0, nrow = 21, ncol = 21)\n\ncart_x <- as.vector(rep(seq(1,21),21))\ncart_y <- as.vector(sort(rep(seq(1,21),21)))\ncart_z_on <- as.vector(matrix_ON_smooth)\ncart_z_diff <- as.vector(matrix_ON_smooth-matrix_OFF_smooth)\ncart_z_off <- as.vector(matrix_OFF_smooth)\n\nfor(i in 1:21){\n  for(j in 1:21){\n    #interpolations\n    int_res_on <- interp(cart_x,cart_y,cart_z_on,xx2[i,j],yy2[i,j])\n    int_res_off <- interp(cart_x,cart_y,cart_z_off,xx2[i,j],yy2[i,j])\n    int_res_diff <- interp(cart_x,cart_y,cart_z_diff,xx2[i,j],yy2[i,j])\n    #insert data\n    ON_transformed[i,j] = as.numeric(int_res_on$z)\n    OFF_transformed[i,j] = as.numeric(int_res_off$z)\n    ON_OFF_transformed[i,j] = as.numeric(int_res_diff$z)\n    # if None set to 0\n    if(is.na(ON_transformed[i,j])){\n      ON_transformed[i,j] = 0\n    }\n    if(is.na(ON_OFF_transformed[i,j])){\n      ON_OFF_transformed[i,j] = 0\n    }\n    if(is.na(OFF_transformed[i,j])){\n      ON_OFF_transformed[i,j] = 0\n    }\n  }\n}\n# plot_ly(x = xx2,y = yy2,z = ON_transformed) %>% add_surface()",
      "line_count": 36
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# hoverText <- cbind(x=1:21, y=1:21, height=as.vector(t(matrix_ON_smooth))) # tail(mytext)\ncustom_txt <- matrix(NA, nrow=21, ncol=21)\n# hoverTextOFF <- cbind(x=1:21, y=1:21, height=as.vector(t(matrix_OFF_smooth))) # tail(mytext)\ncustom_txtOFF <- matrix(NA, nrow=21, ncol=21)\ncustom_txt_DIFF <- matrix(NA, nrow=21, ncol=21)\ncustom_txt_ON_OFF <- matrix(NA, nrow=21, ncol=21)\n\nfor (xdir in 1:21) {\n   for (ydir in 1:21) {\n     custom_txt[xdir,ydir] <- paste(' fMRI: ', round(ON_transformed[xdir,ydir], 3),\n                    '\\n time: ', round((xdir-1)/2, 0),\n                    '\\n phi: ', round(-pi+pi/10*(ydir-1), 2))\n     custom_txtOFF[xdir,ydir] <- paste(' fMRI: ', round(OFF_transformed[xdir,ydir], 3),\n                    '\\n time: ', round((xdir-1)/2, 0),\n                    '\\n phi: ', round(-pi+pi/10*(ydir-1), 2))\n     custom_txt_DIFF[xdir,ydir] <- paste(' fMRI: ', round(ON_transformed[xdir,ydir]-OFF_transformed[xdir,ydir], 3),\n                    '\\n time: ', round((xdir-1)/2, 0),\n                    '\\n phi: ', round(-pi+pi/10*(ydir-1), 2))\n     custom_txt_ON_OFF[xdir,ydir] <- paste(' fMRI: ', round(ON_OFF_transformed[xdir,ydir], 3),\n                    '\\n time: ', round((xdir-1)/2, 0),\n                    '\\n phi: ', round(-pi+pi/10*(ydir-1), 2))\n   }\n}",
      "line_count": 23
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "plot_ly(x = xx2,y = yy2,z = ON_transformed, type = \"surface\", colors=c(\"#FFFFFF\",\"#0000FF\"),\n          text = custom_txt, hoverinfo = \"text\", showlegend = FALSE) %>%\n    add_trace(x=11, y=11, z=0:0.15, type=\"scatter3d\", mode=\"lines\",\n              line = list(width = 10, color=\"red\"), name=\"Space(x)\",\n              hoverinfo=\"none\", showlegend = FALSE) %>%\n    layout(dragmode = \"turntable\", title = \"ON kimesurface/Kime-Series at a fixed voxel location\",scene = list(xaxis = x, yaxis = y, zaxis = z), showlegend = FALSE)\n    # ",
      "line_count": 7
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "plot_ly(x = ~xx2, y = ~yy2, z = ~OFF_transformed, type = \"surface\",colors=c(\"#FFFFFF\",\"#0000FF\"),   # scatterpolar\n          text = custom_txtOFF, hoverinfo = \"text\", showlegend = FALSE) %>% \n    #add_trace(x=~xx2, y=~yy2, z=~ww2, colors = c(\"blue\", \"yellow\"),\n    #          type=\"surface\", text = custom_txtOFF, hoverinfo = \"text\",\n    #          opacity=0.3, showscale = FALSE, showlegend = FALSE) %>%\n    # trace the main Z-axis\n    add_trace(x=11, y=11, z=0:0.15, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color=\"red\"), name=\"Space(x)\", \n              hoverinfo=\"none\", showlegend = FALSE) %>%\n    layout(dragmode = \"turntable\", title = \"OFF kimesurface/Kime-Series at a fixed voxel location\",\n           scene = list(xaxis = x, yaxis = y, zaxis = z), showlegend = FALSE)\n# x <- as.vector(rep(seq(0.5,20.5),21))\n# y <- as.vector(sort(rep(seq(0.5,20.5),21)))\n# z <- as.vector(matrix_ON_smooth)\n# intper <- interp(x,y,z)\n# plot_ly(x = intper$x,y = intper$y,z = matrix_ON_smooth) %>% add_surface()",
      "line_count": 16
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "plot_ly(x = ~xx2, y = ~yy2, z = ~ON_transformed-OFF_transformed, type = \"surface\",colors=c(\"#FFFF00\",\"#FFFFFF\",\"#0000FF\"),   # scatterpolar\n          text = custom_txt_DIFF, hoverinfo = \"text\", showlegend = FALSE) %>% \n    #add_trace(x=~xx2, y=~yy2, z=~ww2, colors = c(\"blue\", \"yellow\"),\n    #          type=\"surface\", text = custom_txtOFF, hoverinfo = \"text\",\n    #          opacity=0.3, showscale = FALSE, showlegend = FALSE) %>%\n    # trace the main Z-axis\n    add_trace(x=11, y=11, z=0:0.15, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color=\"red\"), name=\"Space(x)\", \n              hoverinfo=\"none\", showlegend = FALSE) %>%\n    layout(dragmode = \"turntable\", title = \"Raw ON-OFF difference kimesurface/Kime-Series at a fixed voxel location\",\n           scene = list(xaxis = x, yaxis = y, zaxis = z), showlegend = FALSE)\n# x <- as.vector(rep(seq(0.5,20.5),21))",
      "line_count": 12
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "#plot 2D into 3D and make the text of the diameter (time), height (r), and phase (phi)\nzd <- list(title = \"fMRI Kime-ON/OFF difference\", titlefont = f)\ndd2 <- matrix_ON_smooth-matrix_OFF_smooth\n# dd2scale<-fmri_split_ab_bl(dd2)\nplot_ly(x = ~xx2, y = ~yy2, z = ~ON_OFF_transformed, type = \"surface\", #colors = dd2scale, \n        colors=c(\"#FFFF00\",\"#FFFFFF\",\"#0000FF\"),  # scatterpolar\n          text = custom_txt_ON_OFF, hoverinfo = \"text\", showlegend = FALSE) %>% \n    #add_trace(x=~xx2, y=~yy2, z=~ww2, colors = c(\"blue\", \"yellow\"),\n    #          type=\"surface\", text = custom_txtOFF, hoverinfo = \"text\",\n    #          opacity=0.3, showscale = FALSE, showlegend = FALSE) %>%\n    # trace the main Z-axis\n    add_trace(x=11, y=11, z=-0.15:0.15, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color=\"red\"), name=\"Space(x)\", \n              hoverinfo=\"none\", showlegend = FALSE) %>%\n    layout(dragmode = \"turntable\", title = \"Difference for ON & OFF kimesurface/Kime-Series at a fixed voxel location\",\n           scene = list(xaxis = x, yaxis = y, zaxis = zd), showlegend = FALSE)",
      "line_count": 16
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# datatable(fmri_kimesurface(bigim1_mod,c(44,42,33))[[1]])",
      "line_count": 1
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# fmri_kimesurface(bigim1_mod,c(44,42,33))[[2]]  # On kimesurface\n# fmri_kimesurface(bigim1_mod,c(44,42,33))[[3]]  # Off kimesurface\n# fmri_kimesurface(bigim1_mod,c(44,42,33))[[4]]  # Difference On - Off kimesurface",
      "line_count": 3
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# AR(1) model for generating 8 phi kime-phases for each of the 10 time radii\n# phi_8_vec_AR1 <- matrix(NA, ncol=10, nrow = 8)\nlibrary(tidyr)\n\n# Initialize all the phases: all repeats: 1<=i<=8, and times: 1<=t<=10\nfor (t in 1:10) { \n    phi_8_vec[ , t] <- extraDistr::rlaplace(8, mu=0, sigma=0.5) \n}\n\n# AR(1) Modeling for all 8 fMRI repeats; for ARIMA(p,q,r), update order=c(p,q,r)\nphi_8_vec_AR1 <- list()\nfor (i in 1:8) {\n    phi_8_vec_AR1[[i]] <- arima(phi_8_vec[i , ], order=c(1,0,0))\n}\n\n# AI modeling and forcing all phases in [-pi: pi), modulo or via wrap around correction\nfor (i in 1:8) { \n  for (t in 2:10) { # fitting AR(p=1) model starts with t=1+p=2 \n    # Use AR(1) models to adjust the phases\n    phi_8_vec[i, t] <- phi_8_vec_AR1[[i]]$coef[2] + \n      phi_8_vec_AR1[[i]]$coef[1] * (phi_8_vec[i, t-1] - phi_8_vec_AR1[[i]]$coef[2]) \n      + phi_8_vec_AR1[[i]]$residuals[t]  ## Should the random error (residuals) be added???\n    \n    # force all phases in [-pi: pi), e.g., phi_8_vec_AR1[i,t] %% pi  (wrap around)\n    if (phi_8_vec[i,t] < -pi) \n      phi_8_vec[i,t] <- phi_8_vec[i,t] %% pi\n    if (phi_8_vec[i,t] >= pi) \n      phi_8_vec[i,t] <- ((phi_8_vec[i,t] + pi) %% pi) -pi\n  }\n}\n\nphi_8_vec_AR1_df <- as.data.frame(t(phi_8_vec))\nphi_8_vec_AR1_df$time <- c(1:10)\nphi_8_vec_AR1_df_long <- phi_8_vec_AR1_df %>%\n  pivot_longer(!time, names_to = \"repeats\", values_to = \"values\")\n  \nplot_ly(data = phi_8_vec_AR1_df_long,x = ~time, y=~values, type=\"scatter\", mode=\"lines\", \n        color = ~repeats, name= ~repeats) %>%\n  layout(title=\"AR(1) Kime-Phase Prior Model based on Laplace Noise\", \n         legend = list(title=\"Repeats\", orientation = 'h', y=-0.2))",
      "line_count": 40
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# Convert the long DF representing fMRI_ON and fMRI_OFF from polar coordinates to Cartesian coordinates\nlibrary(spatstat)\n\nmatrix_ON <- matrix(0, nrow = 21, ncol = 21) \nmatrix_OFF <- matrix(0, nrow = 21, ncol = 21) \nfor (t in 1:10) {\n  for (p in 1:8) {\n    x = 11+t*cos(phi_8_vec[p,t])\n    y = 11+t*sin(phi_8_vec[p,t])\n    matrix_ON[x,y]  <- fMRI_ON[(p-1)*10 +t] # What is matrix_ON?\n    matrix_OFF[x,y] <- fMRI_OFF[(p-1)*10 +t]\n  }\n}\n# smooth/blur the matrices\nmatrix_ON_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_ON), sigma=0.5))\nmatrix_OFF_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_OFF), sigma=0.5))",
      "line_count": 16
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# fix the plot_ly Text Labels\nx <- vector()\ny <- vector()\ni <- 1\nfor (t in 1:10) {\n  for (p in 1:8) {\n    x[i] = 11+t*cos(phi_8_vec[p,t])\n    y[i] = 11+t*sin(phi_8_vec[p,t])\n    i <- i+1\n  }\n}",
      "line_count": 11
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# xx2 <- 11 + c(-10:10) %o% cos(seq(-pi, pi, 2*pi/20))\n# yy2 <- 11 + c(-10:10)  %o% sin(seq(-pi, pi, 2*pi/20))\nxx2 <- 11 + seq(0,10,1/2) %o% cos(seq(-pi, pi, 2*pi/20))\nyy2 <- 11 + seq(0,10,1/2)  %o% sin(seq(-pi, pi, 2*pi/20))\n#zz2 <- as.vector(matrix_ON_smooth) %o% rep(1, 21*21)\nzz2 <- matrix_ON_smooth\nww2 <- matrix_OFF_smooth\ndd2 <- matrix_ON_smooth-matrix_OFF_smooth\n\n#plot 2D into 3D and make the text of the diameter (time), height (r), and phase (phi)\nf <- list(family = \"Courier New, monospace\", size = 18, color = \"black\")\nx <- list(title = \"k1\", titlefont = f)\ny <- list(title = \"k2\", titlefont = f)\nz <- list(title = \"AR(1) fMRI Kime-series\", titlefont = f)",
      "line_count": 14
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# matrix_ON_smooth,matrix_OFF_smooth is indexed in Cartesian coordinates\n# Reinterpolate the fMRI intensities according to Polar grid\nlibrary(akima)\nON_transformed <- matrix(0, nrow = 21, ncol = 21)\nOFF_transformed <- matrix(0, nrow = 21, ncol = 21)\nON_OFF_transformed <- matrix(0, nrow = 21, ncol = 21)\n\ncart_x <- as.vector(rep(seq(1,21),21))\ncart_y <- as.vector(sort(rep(seq(1,21),21)))\ncart_z_on <- as.vector(matrix_ON_smooth)\ncart_z_diff <- as.vector(matrix_ON_smooth-matrix_OFF_smooth)\ncart_z_off <- as.vector(matrix_OFF_smooth)\n\nfor(i in 1:21){\n  for(j in 1:21){\n    #interpolations\n    int_res_on <- interp(cart_x,cart_y,cart_z_on,xx2[i,j],yy2[i,j])\n    int_res_off <- interp(cart_x,cart_y,cart_z_off,xx2[i,j],yy2[i,j])\n    int_res_diff <- interp(cart_x,cart_y,cart_z_diff,xx2[i,j],yy2[i,j])\n    #insert data\n    ON_transformed[i,j] = as.numeric(int_res_on$z)\n    OFF_transformed[i,j] = as.numeric(int_res_off$z)\n    ON_OFF_transformed[i,j] = as.numeric(int_res_diff$z)\n    # if None set to 0\n    if(is.na(ON_transformed[i,j])){\n      ON_transformed[i,j] = 0\n    }\n    if(is.na(ON_OFF_transformed[i,j])){\n      ON_OFF_transformed[i,j] = 0\n    }\n    if(is.na(OFF_transformed[i,j])){\n      ON_OFF_transformed[i,j] = 0\n    }\n  }\n}\n# plot_ly(x = xx2,y = yy2,z = ON_transformed) %>% add_surface()",
      "line_count": 36
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# hoverText <- cbind(x=1:21, y=1:21, height=as.vector(t(matrix_ON_smooth))) # tail(mytext)\ncustom_txt <- matrix(NA, nrow=21, ncol=21)\n# hoverTextOFF <- cbind(x=1:21, y=1:21, height=as.vector(t(matrix_OFF_smooth))) # tail(mytext)\ncustom_txtOFF <- matrix(NA, nrow=21, ncol=21)\ncustom_txt_DIFF <- matrix(NA, nrow=21, ncol=21)\ncustom_txt_ON_OFF <- matrix(NA, nrow=21, ncol=21)\n\nfor (xdir in 1:21) {\n   for (ydir in 1:21) {\n     custom_txt[xdir,ydir] <- paste(' AR(p=1) fMRI: ', round(ON_transformed[xdir,ydir], 3),\n                    '\\n time: ', round((xdir-1)/2, 0),\n                    '\\n phi: ', round(-pi+pi/10*(ydir-1), 2))\n     custom_txtOFF[xdir,ydir] <- paste(' fMRI: ', round(OFF_transformed[xdir,ydir], 3),\n                    '\\n time: ', round((xdir-1)/2, 0),\n                    '\\n phi: ', round(-pi+pi/10*(ydir-1), 2))\n     custom_txt_DIFF[xdir,ydir] <- paste(' fMRI: ', round(ON_transformed[xdir,ydir]-OFF_transformed[xdir,ydir], 3),\n                    '\\n time: ', round((xdir-1)/2, 0),\n                    '\\n phi: ', round(-pi+pi/10*(ydir-1), 2))\n     custom_txt_ON_OFF[xdir,ydir] <- paste(' fMRI: ', round(ON_OFF_transformed[xdir,ydir], 3),\n                    '\\n time: ', round((xdir-1)/2, 0),\n                    '\\n phi: ', round(-pi+pi/10*(ydir-1), 2))\n   }\n}",
      "line_count": 23
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "plot_ly(x = xx2,y = yy2,z = ON_transformed, type = \"surface\", colors=c(\"#FFFFFF\",\"#0000FF\"),\n          text = custom_txt, hoverinfo = \"text\", showlegend = FALSE) %>%\n    add_trace(x=11, y=11, z=0:0.15, type=\"scatter3d\", mode=\"lines\",\n              line = list(width = 10, color=\"red\"), name=\"Space(x)\",\n              hoverinfo=\"none\", showlegend = FALSE) %>%\n    layout(dragmode=\"turntable\", \n           title=\"Kime-Phase AR(1) Model:\\n ON kimesurface at a fixed voxel location\",\n           scene=list(xaxis=x, yaxis = y, zaxis = z)) %>% hide_colorbar()",
      "line_count": 8
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "plot_ly(x = ~xx2, y = ~yy2, z = ~OFF_transformed, type = \"surface\",colors=c(\"#FFFFFF\",\"#0000FF\"),   # scatterpolar\n          text = custom_txtOFF, hoverinfo = \"text\", showlegend = FALSE) %>% \n    #add_trace(x=~xx2, y=~yy2, z=~ww2, colors = c(\"blue\", \"yellow\"),\n    #          type=\"surface\", text = custom_txtOFF, hoverinfo = \"text\",\n    #          opacity=0.3, showscale = FALSE, showlegend = FALSE) %>%\n    # trace the main Z-axis\n    add_trace(x=11, y=11, z=0:0.15, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color=\"red\"), name=\"Space(x)\", \n              hoverinfo=\"none\", showlegend = FALSE) %>%\n    layout(dragmode = \"turntable\", \n           title = \"Kime-Phase AR(1) Model: OFF kimesurface at a fixed voxel location\",\n           scene = list(xaxis = x, yaxis = y, zaxis = z)) %>% hide_colorbar()",
      "line_count": 12
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "plot_ly(x = ~xx2, y = ~yy2, z = ~ON_transformed-OFF_transformed, type = \"surface\",colors=c(\"#FFFF00\",\"#FFFFFF\",\"#0000FF\"),   # scatterpolar\n          text = custom_txt_DIFF, hoverinfo = \"text\", showlegend = FALSE) %>% \n    #add_trace(x=~xx2, y=~yy2, z=~ww2, colors = c(\"blue\", \"yellow\"),\n    #          type=\"surface\", text = custom_txtOFF, hoverinfo = \"text\",\n    #          opacity=0.3, showscale = FALSE, showlegend = FALSE) %>%\n    # trace the main Z-axis\n    add_trace(x=11, y=11, z=0:0.15, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color=\"red\"), name=\"Space(x)\", \n              hoverinfo=\"none\", showlegend = FALSE) %>%\n    layout(dragmode = \"turntable\", \n           title = \"Kime-Phase AR(1) Model:\\n Raw ON-OFF difference kimesurface at a fixed voxel location\",\n           scene = list(xaxis = x, yaxis = y, zaxis = z)) %>% hide_colorbar()",
      "line_count": 12
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "#plot 2D into 3D and make the text of the diameter (time), height (r), and phase (phi)\nzd <- list(title = \"AR(1) fMRI Kime-ON/OFF difference\", titlefont = f)\ndd2 <- matrix_ON_smooth-matrix_OFF_smooth\n# dd2scale<-fmri_split_ab_bl(dd2)\nplot_ly(x = ~xx2, y = ~yy2, z = ~ON_OFF_transformed, type = \"surface\", #colors = dd2scale, \n        colors=c(\"#FFFF00\",\"#FFFFFF\",\"#0000FF\"),  # scatterpolar\n          text = custom_txt_ON_OFF, hoverinfo = \"text\", showlegend = FALSE) %>% \n    #add_trace(x=~xx2, y=~yy2, z=~ww2, colors = c(\"blue\", \"yellow\"),\n    #          type=\"surface\", text = custom_txtOFF, hoverinfo = \"text\",\n    #          opacity=0.3, showscale = FALSE, showlegend = FALSE) %>%\n    # trace the main Z-axis\n    add_trace(x=11, y=11, z=-0.15:0.15, type=\"scatter3d\", mode=\"lines\", \n              line = list(width = 10, color=\"red\"), name=\"Space(x)\", \n              hoverinfo=\"none\", showlegend = FALSE) %>%\n    layout(dragmode = \"turntable\", \n           title = \"Kime-Phase AR(1) Model:\\n Difference for ON & OFF kimesurfaces at a fixed voxel location\",\n           scene = list(xaxis = x, yaxis = y, zaxis = zd)) %>% hide_colorbar()",
      "line_count": 17
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# Extract just the On kime-series at voxel (44,42,33), each time-series has 8 repeats!\nonFMRISeries <- \n  bigim1_mod[44,42,33, c(1:10, 21:30, 41:50, 61:70, 81:90, 101:110, 121:130, 141:150)]\n# the corresponding Off kime-series at voxel (44,42,33) will be the temporal complement\noffFMRISeries <- \n  bigim1_mod[44,42,33, -c(1:10, 21:30, 41:50, 61:70, 81:90, 101:110, 121:130, 141:150)]\n\nt_indx <- seq(1, 80, 1) # index of time (not actual time value)\nf_On <- onFMRISeries\nf_Off <- offFMRISeries\n\nvline <- function(x=0, color = \"lightgray\") {\n  list(type=\"line\", y0=0, y1=1, yref=\"paper\", name=\"time break points\", \n       opacity = 0.5, x0=x, x1=x, line=list(color=color))\n}\n\nhline <- function(y = 0, color = \"blue\") {\n  list(type=\"line\", x0=0, x1=1, xref=\"paper\", name=\"intensity break points\",\n       opacity = 0.3, y0=y, y1=y, line=list(color=color))\n}\n\nplot_ly() %>%\n  # On fMRI time-series\n  add_trace(x=t_indx, y=f_On, type=\"scatter\", mode=\"lines\", name=\"On time-series\") %>%\n  # On fMRI time-series\n  add_trace(x=t_indx, y=f_Off, type=\"scatter\", mode=\"lines\", name=\"Off time-series\") %>%\n  # Repeated measurement break points\n  # add_trace(x=c(10,20,30,40,50,60,70,80), y=f_Off, type=\"scatter\", mode=\"lines\", name=\"Off time-series\") %>%\n  layout(title=\"3D fMRI Simulation: On & Off Time-series at Voxel(44,42,33)\",\n         shapes = list(\n           vline(10),vline(20),vline(30),vline(40),vline(50),vline(60),vline(70),vline(80)),\n         legend = list(orientation='h', y=-0.2))\n\n# Compute and plot against each other the Average On and Average Off time-series\nseriesAvg <- function(f=0, period=0) {\n  tempAvg <- rep(0,period)  # initialize avg signal\n  for (i in c(1:period)) {\n    counter =0  #  empirically count the number of repeated samples (here it's 8)\n    for (j in c(1:length(f))) {\n      if (j %% period == i-1) {  # e.g., 159 %% 10 # [1] 9\n        tempAvg[i] = tempAvg[i] + f[j]\n        counter = counter + 1\n      }\n    }\n    tempAvg[i] = tempAvg[i]/counter\n  }\n  return(tempAvg)\n}\n\nperiod <- 10\nonAvg  <- seriesAvg(f=f_On,  period=period) \noffAvg <- seriesAvg(f=f_Off, period=period) \n\nplot_ly() %>%\n  # Average On fMRI time-series\n  add_trace(x=c(1:period), y=onAvg, type=\"scatter\", mode=\"lines\", name=\"On Average\") %>%\n  # On fMRI time-series\n  add_trace(x=c(1:period), y=offAvg, type=\"scatter\", mode=\"lines\", name=\"Off Average\") %>%\n  # Repeated measurement break points\n  layout(title=\n  \"3D fMRI Simulation: On & Off Time-series\\n (averaged over all 8 repeats) at Voxel (44,42,33)\",\n  legend = list(orientation='h', y=-0.2))",
      "line_count": 62
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# create the LT\nNuLT = function(datax, datay, inputz, k = 3, fitwarning = FALSE, \n                mirror = FALSE, range = 2*pi) {\n  \n  datax = as.numeric(datax)\n  datay = as.numeric(datay)\n\n  n = length(datax)\n  x1 = n/(n+0.5)*((datax-min(datax))/(max(datax)-min(datax)))*range\n  \n  if(mirror){\n    x1 = c(x1,rev(2*range - x1))/2\n    n = 2*n\n    datay = c(datay, rev(datay))\n    plot(x1, datay)\n  }\n  \n  #generate the coefficients in indefinite integral of t^n*exp(-zt)\n  coef = 1;\n  coefm = as.matrix(coef)\n  for(i in 1:k){\n    coefm = cbind(coefm,0)\n    coef = c(coef*i,1)\n    coefm = rbind(coefm,coef)\n  }\n  # these coefficients ordered by ^0, ^1, ^2, ... in column format\n  \n  # compute 1, z, z^2...,z^k\n  zz = cbind(1,inputz)\n  zt = inputz\n  for (i in 2:k){\n    zt = zt*inputz\n    zz = cbind(zz,zt)\n  }\n  zd = zt*inputz\n  \n  # compute 1, x, x^2...,x^k\n  tx = x1;\n  xm = cbind(1,x1)\n  for (i in 2:k){\n    tx = tx*x1\n    xm = cbind(xm,tx)\n  }\n  \n  \n  # sum over intervals\n  result = 0*inputz\n  ii = 1\n  while(ii+k <= n) {\n    A = xm[seq(ii,ii+k),c(0:k+1)]\n    b = datay[seq(ii,ii+k)]\n    # polyfit might be faster when using polynomial basis, while matrix inverse, `solve()`,\n    # is the more general approach that works for any function basis\n    polyc = as.numeric(solve(A,b))\n\n  \n    #ordered by ^0, ^1, ^2, ... in column format\n    \n    # Enter a new function variable qualityCheck=FALSE\n    # check fit quality; this step can be skipped for speed/efficiency\n    # if (qualityCheck) { .... }\n    \n    if (fitwarning){\n      xx = seq(A[1,2],A[k+1,2],length.out = 100);\n      yy = polyval(rev(polyc),xx)\n      if(max(abs(yy-mean(b)))>2*max(abs(b-mean(b)))){\n        print(c(\"Warning: Poor Fit at \",ii,\", Largest Deviation is\",\n                max(abs(yy-mean(b)))))\n        print(c(\"Spline Polynomial is\", polyc),3);\n        #print(c(polyval(rev(polyc),A[,2]),b))\n        plot(xx, yy, main=\"Polynomial fit\", ylab=\"\", type=\"l\", col=\"blue\")\n        lines(A[,2],b, col=\"red\")\n        legend(\"topleft\",c(\"fit\",\"data\"),fill=c(\"blue\",\"red\"))\n        print(\" \")\n      }\n    }\n    \n    # Use vector/matrix operations to avoid looping, \n    # some of the expressions look weird\n    # May need to actually compare the efficiency/speed of\n    # vector based vs. standard numeric calculations\n    \n    m1 = t(t(polyc*coefm)*A[1,])\n    m11 = as.numeric(tapply(m1, col(m1)-row(m1), sum))[0:k+1] \n    \n    m2 = t(t(polyc*coefm)*A[k+1,])\n    m22 = as.numeric(tapply(m2, col(m2)-row(m2), sum))[0:k+1]\n    \n    intgl = (exp(-inputz*A[1,2])*colSums(t(zz)*m11)-\n               exp(-inputz*A[k+1,2])*colSums(t(zz)*m22))/zd\n    result = result+intgl\n    ii=ii+k\n  }\n  \n  # Computations over the last interval\n  if(ii < n){\n    nk = n-ii;\n    A = xm[seq(ii,ii+nk),c(0:nk+1)]\n    b = datay[seq(ii,ii+nk)]\n    nc = as.numeric(solve(A,b))\n    nc = c(nc,seq(0,0,length.out = k-nk))\n    \n    A = xm[seq(ii,ii+nk),]\n    m1 = t(t(nc*coefm)*A[1,])\n    m11 = as.numeric(tapply(m1, col(m1)-row(m1), sum))[0:k+1]\n    \n    m2 = t(t(nc*coefm)*A[nk+1,])\n    m22 = as.numeric(tapply(m2, col(m2)-row(m2), sum))[0:k+1]\n    \n    # cc = colSums(coefm*polyc)\n    intgl = (exp(-inputz*A[1,2])*colSums(t(zz)*m11)-\n               exp(-inputz*A[nk+1,2])*colSums(t(zz)*m22))/zd\n    result = result+intgl\n  }\n  #offset = 0.05*pi\n  #result = result+datay[n]*(exp(-2*pi*inputz)-exp(-(2*pi+offset)*inputz))/inputz\n  return(result)\n}",
      "line_count": 118
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "datax = seq(1,200)\n\nn = length(datax)\n\nx1 = n/(n+0.5)*((datax-min(datax))/(max(datax)-min(datax)))*(2*pi)\n\ndatay = cos(x1)  # test function!!!\n\nLout = 61\nrange_limit <- 20\nx2 <- seq(from = 0.1, to = range_limit, length.out = Lout)\ny2 <- seq(from = 0, to = range_limit, length.out = Lout)\n\nx2_g = x2 %o% seq(1,1, length.out = Lout)    \ny2_g =  seq(1,1, length.out = Lout)%o%y2 \nz2_grid = x2 %o% y2\n\nargz = as.vector(x2_g + 1i*y2_g)\nLTz = NuLT(x1, datay, argz)\nrec1 = matrix(LTz,nrow = Lout)\n\nrecm = abs(rec1)\nrecr = Re(rec1)\nreci = Im(rec1)\nph = reci/recm\nsurf_color <- atan2(reci,recr)\n# colorscale = cbind(seq(-pi, pi, by=1/10, rainbow(11)))\np <-  plot_ly(hoverinfo=\"none\", showscale = TRUE) %>%\n    add_trace(x = x2_g, y = y2_g, z = surf_color, \n    # F-magnitude or Re(F),   # z = Im(z2_grid),  # Real or Imaginary part of F(t)\n          surfacecolor=log(recm), # colorscale=colorscale, #Phase-based color\n          type = 'surface', opacity=1, visible=T) %>%\n  layout(title = \n    \"Truncated Laplace transform of cos(x), Color = Mag(Z)\", \n         showlegend = TRUE,\n         scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1.0), \n              xaxis=list(title= \"Real=Re(z)\"), yaxis=list(title = \"Imaginary=Im(z)\"),\n              zaxis=list(title= \"Z = tan-1(Im(L[f](z))/Re(L[f](z))))\")) ) # 1:1:1 aspect ratio\np",
      "line_count": 39
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "z_val <- (x2_g+y2_g*1i)\nground_truth <- (z_val - exp(-2*pi*z_val)*z_val)/(1+z_val^2)\nsurf_ground_truth <- atan2(Im(ground_truth),Re(ground_truth))\nplot_ly(hoverinfo=\"none\", showscale = TRUE) %>%add_trace(x = x2_g, y = y2_g, z = surf_ground_truth,surfacecolor=log(abs(ground_truth)),type = 'surface', opacity=1, visible=T)%>%layout(title = \n    \"Ground Truth for the truncated Laplace transform of cos(x), Color = Mag(Z)\",scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1.0), \n              xaxis=list(title= \"Real=Re(z)\"), yaxis=list(title = \"Imaginary=Im(z)\"),\n              zaxis=list(title= \"Z = tan-1(Im(L[f](z))/Re(L[f](z)))\")) )\n",
      "line_count": 8
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "print(paste0(\"The average difference between the ground truth and the numerical integration is \",\n             sum(abs(ground_truth -rec1))/length(ground_truth)))",
      "line_count": 2
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# datax = seq(1,200)\n# \n# n = length(datax)\n# \n# x1 = n/(n+0.5)*((datax-min(datax))/(max(datax)-min(datax)))*(2*pi)\n# \n# datay = sin(x1)  # test function!!!\n# \n# Lout = 61\n# range_limit <- 20\n# x2 <- seq(from = 0.1, to = range_limit, length.out = Lout)\n# y2 <- seq(from = 0, to = range_limit, length.out = Lout)\n# \n# x2_g = x2 %o% seq(1,1, length.out = Lout)    \n# y2_g =  seq(1,1, length.out = Lout)%o%y2 \n# z2_grid = x2 %o% y2\n# \n# argz = as.vector(x2_g + 1i*y2_g)\n# LTz = NuLT(x1, datay, argz)\n# rec1 = matrix(LTz,nrow = Lout)\n# \n# recm = abs(rec1)\n# recr = Re(rec1)\n# reci = Im(rec1)\n# ph = reci/recm\n# surf_color <- atan2(reci,recr)\n# # colorscale = cbind(seq(-pi, pi, by=1/10, rainbow(11)))\n# p <-  plot_ly(hoverinfo=\"none\", showscale = TRUE) %>%\n#     add_trace(x = x2_g, y = y2_g, z = surf_color, \n#     # F-magnitude or Re(F),   # z = Im(z2_grid),  # Real or Imaginary part of F(t)\n#           surfacecolor=log(recm), # colorscale=colorscale, #Phase-based color\n#           type = 'surface', opacity=1, visible=T) %>%\n#   layout(title = \n#     \"Laplace transform of the sin(x), Color = log(mag)\", \n#          showlegend = TRUE,\n#          scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1.0), \n#               xaxis=list(title= \"Real=Re(z)\"), yaxis=list(title = \"Imaginary=Im(z)\"),\n#               zaxis=list(title= \"Z = tan-1(Im(L[f](z))/Re(L[f](z)))\")) ) # 1:1:1 aspect ratio\n# p",
      "line_count": 39
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# z_val <- (x2_g+y2_g*1i)\n# ground_truth <- (1 - exp(-2*pi*z_val))/(1+z_val^2)\n# surf_ground_truth <- atan2(Im(ground_truth),Re(ground_truth))\n# plot_ly(hoverinfo=\"none\", showscale = TRUE) %>%add_trace(x = x2_g, y = y2_g, z = surf_ground_truth,surfacecolor=log(abs(ground_truth)),type = 'surface', opacity=1, visible=T)%>%layout(title = \n#     \"Ground Truth for the truncated Laplace transform of sin(x), Color = Mag(Z)\",scene = list(aspectmode = \"manual\", aspectratio = list(x=1, y=1, z=1.0), \n#               xaxis=list(title= \"Real=Re(z)\"), yaxis=list(title = \"Imaginary=Im(z)\"),\n#               zaxis=list(title= \"Z = tan-1(Im(L[f](z))/Re(L[f](z)))\")) )\n",
      "line_count": 8
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "datax = seq(1,200)\nn = length(datax)\nx_old <- c(1:10)\nx1 = n/(n+0.5)*((datax-min(datax))/(max(datax)-min(datax)))*(2*pi)\n# longitudinal data series are: onAvg & offAvg\nxnew <- x1\nspl_onAvg <- spline(x=x_old, y=onAvg, xmin=min(x_old), xmax=max(x_old), n=200)\nspl_offAvg <- spline(x=x_old, y=offAvg, xmin=min(x_old), xmax=max(x_old), n=200)\n\nplot_ly(type=\"scatter\", mode=\"markers\") %>%\n  add_trace(x=x_old, y=onAvg, name=\"Raw ON-Avg\", \n            marker=list(size=20, color=\"lightblue\", sizemode=\"area\")) %>%\n  add_trace(x=x_old, y=offAvg, name=\"Raw OFF-Avg\",\n            marker=list(size=20, color=\"orange\", sizemode=\"area\")) %>%\n  add_trace(x=spl_onAvg$x, y=spl_onAvg$y, type=\"scatter\", mode=\"markers+lines\",\n            name=\"Spline ON-Avg Model\", marker=list(size=8, color=\"blue\"),\n            line = list(color = \"blue\", width = 4)) %>%\n  add_trace(x=spl_offAvg$x, y=spl_offAvg$y, type=\"scatter\", mode=\"markers+lines\",\n            name=\"Spline OFF-Avg Model\", marker=list(size=8, color=\"red\"),\n            line = list(color = \"red\", width = 4)) %>%\n  layout(title=\"Spline Modeling of 1D ON and OFF fMRI data\\n (averaged over repeated samples)\",\n         legend = list(orientation = 'h', y=-0.2)) %>%\n  hide_colorbar()\n\n# datay = sin(x1)  # test function!!!\n\n# Define a time-series to kimesurface plotting function\nplotKimeSurface <- function(datay = sin(x1),index=\"\", \n           title=\"Laplace transform of the Time-Series, Color = phase(Z)\") {\n  Lout = 61\n  range_limit <- 20\n  x2 <- seq(from = 0.1, to = range_limit, length.out = Lout)\n  y2 <- seq(from = 0, to = range_limit, length.out = Lout)\n  \n  x2_g = x2 %o% seq(1,1, length.out = Lout)    \n  y2_g =  seq(1,1, length.out = Lout)%o%y2 \n  # z2_grid = x2 %o% y2\n  \n  argz = as.vector(x2_g + 1i*y2_g)\n  # print(argz)\n  LTz = NuLT(x1, datay, argz)\n  rec1 = matrix(LTz,nrow = Lout)\n  \n  recm = abs(rec1)\n  recr = Re(rec1)\n  reci = Im(rec1)\n  ph = reci/recm\n  surf_color <- atan2(reci,recr)\n  # colorscale = cbind(seq(-pi, pi, by=1/10, rainbow(11)))\n  p <-  plot_ly(hoverinfo=\"none\", showscale = TRUE,\n           scene = paste(\"scene\",as.character(index),sep = \"\")) %>%\n      add_trace(x = x2_g, y = y2_g, z = surf_color, \n      # F-magnitude or Re(F),   # z=Im(z2_grid),  # Real or Imaginary part of F(t)\n            surfacecolor=log(recm), # colorscale=colorscale, #Phase-based color\n            type = 'surface', opacity=1, visible=T) %>%\n      layout(title = title, showlegend = TRUE,scene=list(aspectmode=\"manual\", aspectratio=list(x=1, y=1, z=1.0), \n                xaxis=list(title= \"Real\"), yaxis=list(title = \"Imaginary\"),\n                zaxis=list(title= \"Z = phase\")) ) # 1:1:1 aspect ratio)\n  \n  return(list(\"plot\"=p,\"phase\"=surf_color,\"magnitude\"=recm,\"x_grid\"=x2_g,\"y_grid\"=y2_g))\n}\n#paste(\"scene\",as.character(index),sep = \"\")\n# list(aspectmode=\"manual\", aspectratio=list(x=1, y=1, z=1.0), \n#                 xaxis=list(title= \"Real\"), yaxis=list(title = \"Imaginary\"),\n#                 zaxis=list(title= \"Z = log(mag(Lf(x+iy)))\")) ) # 1:1:1 aspect ratio\npOn  <- plotKimeSurface(datay=spl_onAvg$y, \"\",\n           title=\"ON fMRI ((44,42,33): Laplace transform of Avg Time-Series, Color = phase(Z)\")\npOff <- plotKimeSurface(datay=spl_offAvg$y,2, \n           title=\"OFF fMRI ((44,42,33): Laplace transform of Avg Time-Series, Color = phase(Z)\")\n\n# combineWidgets(pOn, pOff)\n\n# synch both 3D scenes in 1 3D plot\n# install.packages(\"manipulateWidget\")\n# subplot(pOn, pOff, nrows = 1, shareX = TRUE)\n\n# main_plot <- subplot(pOn, pOff, nrows = 2, shareX = TRUE, margin = 0.06) %>% \n#   layout(title = \"Kimesurfaces On (activation) and Off (rest) fMRI voxel (44,42,33)\", \n#          scene  = list(domain = list(x = c(0, 0.5), y = c(0.5, 1)), aspectmode = \"cube\"), \n#          scene2 = list(domain = list(x = c(0.2, 0.7), y = c(0.5, 1)), aspectmode = \"cube\"))\n# \n# main_plot %>% \n#   htmlwidgets::onRender(\n#     \"function(x, el) {\n#       x.on('plotly_relayout', function(d) {\n#         const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n#         if (camera.length) {\n#           const scenes = Object.keys(x.layout).filter((key) => /^scene\\\\d*/.test(key));\n#           const new_layout = {};\n#           scenes.forEach(key => {\n#             new_layout[key] = {...x.layout[key], camera: {...d[camera]}};\n#           });\n#           Plotly.relayout(x, new_layout);\n#         }\n#       });\n#     }\")",
      "line_count": 96
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "\nlibrary(plotly)\nlibrary(htmlwidgets)\n\n# Generate some example 3D data\n# ... (Create your pOn and pOff plots here)\ndiff_plot <- plot_ly(hoverinfo=\"none\", showscale = TRUE,\n           scene = \"scene3\") %>%\n      add_trace(x = pOn$x_grid, y = pOn$y_grid, z = pOn$phase - pOff$phase, \n      # F-magnitude or Re(F),   # z=Im(z2_grid),  # Real or Imaginary part of F(t)\n            surfacecolor=pOn$magnitude-pOff$magnitude, # colorscale=colorscale, #Phase-based color\n            type = 'surface', opacity=1, visible=T) %>%\n      layout(title = title, showlegend = TRUE,scene3=list(aspectmode=\"manual\", aspectratio=list(x=1, y=1, z=1.0), \n                xaxis=list(title= \"Real\"), yaxis=list(title = \"Imaginary\"),\n                zaxis=list(title= \"Z = Phase\")) )\n# Combine them into a subplot\nmain_plot <- subplot(pOn$plot, pOff$plot,diff_plot) %>%\n  layout(\n    title = \"kimesurfaces (Left: On; Right: Off; Bottom: Kimesurface Difference (On vs. Off))\",\n    scene  = list(domain = list(x = c(0, 0.5), y = c(0.5, 1)), aspectmode = \"cube\"),\n    scene2 = list(domain = list(x = c(0.5, 1), y = c(0.5, 1)), aspectmode = \"cube\"),\n    scene3 = list(domain = list(x = c(0.25, 0.75), y = c(0, 0.5)), aspectmode = \"cube\")\n  )\n#https://stackoverflow.com/questions/77757102/possible-to-synchronize-3d-scatter-plotly-plots-in-r\nmain_plot %>%\n  htmlwidgets::onRender(\n    \"function(x, el) {\n      x.on('plotly_relayout', function(d) {\n        const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n        if (camera.length) {\n          const scenes = Object.keys(x.layout).filter((key) => /^scene\\\\d*/.test(key));\n          const new_layout = {};\n          scenes.forEach(key => {\n            new_layout[key] = {...x.layout[key], camera: {...d[camera]}};\n          });\n          Plotly.relayout(x, new_layout);\n        }\n      });\n    }\")",
      "line_count": 39
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "library(spatstat)\nlibrary(plotly)\nlibrary(htmlwidgets)\n\n# Extract just the On kime-series at voxel (44,42,33), each time-series includes 10 time-points and has 8 repeats!\n# onFMRISeries <- bigim1_mod[44,42,33, c(1:10, 21:30, 41:50, 61:70, \n#                                        81:90, 101:110, 121:130, 141:150)]\n# # the corresponding Off kime-series at voxel (44,42,33) will be the temporal complement\n# offFMRISeries <- bigim1_mod[44,42,33, -c(1:10, 21:30, 41:50, 61:70, \n#                                          81:90, 101:110, 121:130, 141:150)]\n\n# t_indx <- seq(1, 80, 1) # index of time (not actual time value)\n# f_On <- onFMRISeries\n# f_Off <- offFMRISeries\n\n# Compute and plot against each other the Average On and Average Off time-series\nperiod <- 10   # repeated measurement period\nnumSeries <- 8 # number of fMRI timeseries in the entire run (for each of On and Off signals)\nextract8fMRI_TimeSeries <- function(f=0, period=0) {\n  # Split the fMRI vector into (numSeries=8) individual time-courses\n  fMRI_splitSeries <- split(f, ceiling(seq_along(f) / period))\n  return(fMRI_splitSeries)\n}\n\n# 1. Extract numSeries=8 series for stitching and kimesurface reconstruction\nfMRI_ON_Series <- extract8fMRI_TimeSeries(f=f_On, period=10)\nfMRI_OFF_Series <- extract8fMRI_TimeSeries(f=f_Off, period=10)\n\n# 1.a. Stitch together (using random kime-phase draws, $\\varphi\\sim\\Phi_{[-\\pi,\\pi)}$) all these complex-valued FT series into a kimesurface in k-space.\nphi_8_vec <- matrix(NA, ncol=period, nrow = numSeries)\nfor (t in 1:period) { \n  # for a given t, generate 8 new phases\n  set.seed(t);\n  phi_8_vec[ ,t] <- extraDistr::rlaplace(numSeries, mu=0, sigma=0.5)\n  # rank-order the phases for consistency\n  # within the same foliation leaf\n  phi_8_vec[ ,t] <- sort(phi_8_vec[ ,t])\n  # force phases in [-pi: pi)\n  for (i in 1:numSeries) {\n    if (phi_8_vec[i,t] < -pi) phi_8_vec[i,t] <- -pi\n    if (phi_8_vec[i,t] >= pi) phi_8_vec[i,t] <- pi\n  }\n}\n\nmatrix_ON <- matrix(0, nrow = 2*period+1, ncol = 2*period+1) \nmatrix_OFF <- matrix(0, nrow = 2*period+1, ncol = 2*period+1) \nfor (t in 1:period) {  # POLAR to CARTESIAN coordinates\n  for (p in 1:numSeries) {\n    x = (period+1) + t*cos(phi_8_vec[p,t])\n    y = (period+1) + t*sin(phi_8_vec[p,t])\n    matrix_ON[x,y]  <- fMRI_ON_Series[[p]][t]\n    matrix_OFF[x,y] <- fMRI_OFF_Series[[p]][t]\n  }\n}\n# smooth/blur the matrices\n# matrix_ON_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_ON), sigma=0.5))\n# matrix_OFF_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_OFF), sigma=0.5))\nmatrix_ON_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_ON), sigma=0.5))\nmatrix_OFF_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_OFF), sigma=0.5))\n\n# Display the Re() and Im() parts of the complex k-space kimesurfaces\n# Load necessary libraries\n# Create sequences for x and y axes\nx <- seq(1, 2*period+1, length.out = 2*period+1)\ny <- seq(1, 2*period+1, length.out = 2*period+1)\n\n# Create the first surface plot\npON_Re <- plot_ly(x=x, y=y, z=Re(matrix_ON), type=\"surface\", \n                  scene='scene1', name=\"Re(ON)\") %>% \n  layout(title = \"Re(fMRI-ON Basic Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npOFF_Re <- plot_ly(x=x, y=y, z=Re(matrix_OFF), type=\"surface\", \n                   scene='scene2', name=\"Re(OFF)\") %>% \n  layout(title = \"Re(fMRI-OFF Basic Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npDIFF_Re <- plot_ly(x=x, y=y, z=Re(matrix_ON-matrix_OFF), type=\"surface\",\n                    scene='scene3', name=\"Re(Diff)\") %>% \n  layout(title = \"Re(fMRI-ON - fMRI-OFF Basic Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\n# Scene titles\nannotations=list(list(showarrow=FALSE, text='(ON)', \n                      xref='scene',yref='scene',zref='scene', x=0.0,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='(OFF)', \n                      xref='scene2',yref='scene',zref='scene', x=0.35,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='(DIFF)', \n                      xref='scene3',yref='scene',zref='scene', x=0.7,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)))\n# Combine the plots\ncombined_plot <- subplot(pON_Re, pOFF_Re, pDIFF_Re) %>% #, nrows=2,margin=0.05) %>%\n  layout(title=\"Native-space Reconstruction of fMRI ON and OFF Kimesurfaces using Basic Stitching\", annotations=annotations)\n\n# Display the synchronized plot\ncombined_plot %>% htmlwidgets::onRender(\n    \"function(x, el) {\n      x.on('plotly_relayout', function(d) {\n        const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n        if (camera.length) {\n          const scenes = Object.keys(x.layout).filter((key) => /^scene\\\\d*/.test(key));\n          const new_layout = {};\n          scenes.forEach(key => {\n            new_layout[key] = {...x.layout[key], camera: {...d[camera]}};\n          });\n          Plotly.relayout(x, new_layout);\n        }\n      });\n    }\")",
      "line_count": 111
    },
    {
      "section": "Kime-series/kimesurfaces (spacekime analytics protocol)",
      "code": "# 2. Apply the FT to each instance of the repeated measurement time-series.\nlibrary(spatstat)\n\nFT_fMRI_ON_Series <- list()\nFT_fMRI_OFF_Series <- list()\nfor (i in c(1:numSeries)) {\n  FT_fMRI_ON_Series[[i]] = fft(fMRI_ON_Series[[i]])\n  FT_fMRI_OFF_Series[[i]] = fft(fMRI_OFF_Series[[i]])\n}\n\n# 3. Stitch together (using random kime-phase draws, $\\varphi\\sim\\Phi_{[-\\pi,\\pi)}$) all these complex-valued FT series into a kimesurface in k-space.\nphi_8_vec <- matrix(NA, ncol=period, nrow = numSeries)\nfor (t in 1:period) { \n  # for a given t, generate 8 new phases\n  set.seed(t);\n  phi_8_vec[ ,t] <- extraDistr::rlaplace(numSeries, mu=0, sigma=0.5)\n  # rank-order the phases for consistency\n  # within the same foliation leaf\n  phi_8_vec[ ,t] <- sort(phi_8_vec[ ,t])\n  # force phases in [-pi: pi)\n  for (i in 1:numSeries) {\n    if (phi_8_vec[i,t] < -pi) \n      phi_8_vec[i,t] <- -pi\n    if (phi_8_vec[i,t] >= pi) \n      phi_8_vec[i,t] <- pi\n  }\n}\n\nmatrix_ON <- matrix(0, nrow = 2*period+1, ncol = 2*period+1) \nmatrix_OFF <- matrix(0, nrow = 2*period+1, ncol = 2*period+1) \nfor (t in 1:period) {  # POLAR to CARTESIAN coordinates\n  for (p in 1:numSeries) {\n    x = (period+1) + t*cos(phi_8_vec[p,t])\n    y = (period+1) + t*sin(phi_8_vec[p,t])\n    matrix_ON[x,y]  <- FT_fMRI_ON_Series[[p]][t]\n    matrix_OFF[x,y] <- FT_fMRI_OFF_Series[[p]][t]\n  }\n}\n# smooth/blur the matrices\n# matrix_ON_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_ON), sigma=0.5))\n# matrix_OFF_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_OFF), sigma=0.5))\nmatrix_ON_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_ON), sigma=0.5))\nmatrix_OFF_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_OFF), sigma=0.5))\n\n# Display the Re() and Im() parts of the complex k-space kimesurfaces\n# Load necessary libraries\n# library(plotly)\n# library(htmlwidgets)\n\n# Create sequences for x and y axes\nx <- seq(1, 2*period+1, length.out = 2*period+1)\ny <- seq(1, 2*period+1, length.out = 2*period+1)\n\n# Create the first surface plot\npON_Re <- plot_ly(x=x, y=y, z=Re(matrix_ON), type=\"surface\", \n                  scene='scene1', name=\"Re(ON)\") %>% \n  layout(title = \"Re(fMRI-ON Kime Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npOFF_Re <- plot_ly(x=x, y=y, z=Re(matrix_OFF), type=\"surface\", \n                   scene='scene2', name=\"Re(OFF)\") %>% \n  layout(title = \"Re(fMRI-OFF Kime Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npDIFF_Re <- plot_ly(x=x, y=y, z=Re(matrix_ON-matrix_OFF), type=\"surface\",\n                    scene='scene3', name=\"Re(Diff)\") %>% \n  layout(title = \"Re(fMRI-ON - fMRI-OFF Kime Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npON_Im <- plot_ly(x=x, y=y, z=Im(matrix_ON), type = \"surface\", \n                  scene='scene4', name=\"Im(On)\") %>% \n  layout(title = \"Im(fMRI-ON Kime Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npOFF_Im <- plot_ly(x=x, y=y, z=Im(matrix_OFF), type = \"surface\", \n                  scene='scene5', name=\"Im(Off)\") %>% \n  layout(title = \"Im(fMRI-OFF Kime Stiching)\") %>% hide_colorbar()\npDIFF_Im <- plot_ly(x=x, y=y, z=Im(matrix_ON-matrix_OFF), type = \"surface\", \n                  scene='scene6', name=\"Im(Diff)\") %>% \n  layout(title = \"Im(fMRI-ON - fMRI-OFF Kime Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\n\n# Scene titles\nannotations=list(list(showarrow=FALSE, text='Re(ON)', \n                      xref='scene',yref='scene',zref='scene', x=0.0,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Re(OFF)', \n                      xref='scene2',yref='scene',zref='scene', x=0.35,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Re(DIFF)', \n                      xref='scene3',yref='scene',zref='scene', x=0.7,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Im(ON)', \n                      xref='scene4',yref='scene',zref='scene', x=0.0,y=0,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Im(OFF)', \n                      xref='scene5',yref='scene',zref='scene', x=0.35,y=0,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Im(DIFF)', \n                      xref='scene6',yref='scene',zref='scene', x=0.7,y=0,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)))\n\n# Combine the plots\ncombined_plot <- subplot(pON_Re, pOFF_Re, pDIFF_Re, \n                         pON_Im, pOFF_Im, pDIFF_Im) %>% #, nrows=2,margin=0.05) %>%\n  layout(title=\"Real (Re) and Imaginary (Im) fMRI-ON vs. fMRI-OFF Kime Stitching Surfaces\", \n         scene=list(domain=list(x=c(0, 0.33), y=c(0.5,1)), aspectmode=\"cube\"), \n         scene2=list(domain=list(x=c(0.33, 0.66), y=c(0.5,1)), aspectmode=\"cube\"),\n         scene3=list(domain=list(x=c(0.7, 1), y = c(0.5,1)), aspectmode=\"cube\"),\n         scene4=list(domain=list(x=c(0, 0.33), y=c(0.0,0.5)), aspectmode=\"cube\"), \n         scene5=list(domain=list(x=c(0.33,0.66), y=c(0.0,0.5)), aspectmode=\"cube\"),\n         scene6=list(domain=list(x=c(0.7, 1), y = c(0.0,0.5)), aspectmode=\"cube\"),\n         annotations = annotations)\n\n# Display the synchronized plot\ncombined_plot %>% htmlwidgets::onRender(\n    \"function(x, el) {\n      x.on('plotly_relayout', function(d) {\n        const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n        if (camera.length) {\n          const scenes = Object.keys(x.layout).filter((key) => /^scene\\\\d*/.test(key));\n          const new_layout = {};\n          scenes.forEach(key => {\n            new_layout[key] = {...x.layout[key], camera: {...d[camera]}};\n          });\n          Plotly.relayout(x, new_layout);\n        }\n      });\n    }\")\n\n# 4.  IFT the k-space constructed kimesurface into spacetime and \n# characterize it's local smoothness, relative to the smoothness \n# of the original k-space kimesurface.\n# matrix_ON, matrix_OFF, and (matrix_ON - matrix_OFF)\nIFT_matrix_ON <- fft(matrix_ON, inverse = T)\nIFT_matrix_OFF <- fft(matrix_OFF, inverse = T)\n\n# smooth/blur the matrices\n# matrix_ON_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_ON), sigma=0.5))\n# matrix_OFF_smooth <- (1/10000)*as.matrix(blur(as.im(matrix_OFF), sigma=0.5))\nRe_IFT_matrix_ON_smooth <- \n  (1/100)*as.matrix(blur(as.im(Re(IFT_matrix_ON)), sigma=2.0))\nRe_IFT_matrix_OFF_smooth <- \n  (1/100)*as.matrix(blur(as.im(Re(IFT_matrix_OFF)), sigma=2.0))\nIm_IFT_matrix_ON_smooth <- \n  (1/100)*as.matrix(blur(as.im(Im(IFT_matrix_ON)), sigma=2.0))\nIm_IFT_matrix_OFF_smooth <- \n  (1/100)*as.matrix(blur(as.im(Im(IFT_matrix_OFF)), sigma=2.0))\nMag_IFT_matrix_ON_smooth <- \n  (1/100)*as.matrix(blur(as.im(Mod(IFT_matrix_ON)), sigma=2.0))\nMag_IFT_matrix_OFF_smooth <- \n  (1/100)*as.matrix(blur(as.im(Mod(IFT_matrix_OFF)), sigma=2.0))\n\n# # Create sequences for x and y axes\n# x <- seq(1, 2*period+1, length.out = 2*period+1)\n# y <- seq(1, 2*period+1, length.out = 2*period+1)\n\n# Create the first surface plot\npON_Re <- plot_ly(x=x, y=y, z=Re_IFT_matrix_ON_smooth, type=\"surface\", \n                  scene='scene1', name=\"Re(ON)\") %>% \n  layout(title = \"Re(fMRI-ON K-space Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npOFF_Re <- plot_ly(x=x, y=y, z=Re_IFT_matrix_OFF_smooth, type=\"surface\", \n                   scene='scene2', name=\"Re(OFF)\") %>% \n  layout(title = \"Re(fMRI-OFF K-space Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npDIFF_Re <- plot_ly(x=x, y=y, \n                z=(Re_IFT_matrix_ON_smooth - Re_IFT_matrix_OFF_smooth),\n                type=\"surface\", scene='scene3', name=\"Re(Diff)\") %>% \n  layout(title = \"Re(fMRI-ON - fMRI-OFF K-space Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npON_Im <- plot_ly(x=x, y=y, z=Im_IFT_matrix_ON_smooth, type = \"surface\", \n                  scene='scene4', name=\"Im(On)\") %>% \n  layout(title = \"Im(fMRI-ON K-space Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npOFF_Im <- plot_ly(x=x, y=y, z=Im_IFT_matrix_OFF_smooth, type = \"surface\", \n                  scene='scene5', name=\"Im(Off)\") %>% \n  layout(title = \"Im(fMRI-OFF K-space Stiching)\") %>% hide_colorbar()\npDIFF_Im <- plot_ly(x=x,y=y,z=(Im_IFT_matrix_ON_smooth - Im_IFT_matrix_OFF_smooth),\n                  type=\"surface\", scene='scene6', name=\"Im(Diff)\") %>% \n  layout(title = \"Im(fMRI-ON - fMRI-OFF K-space Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npON_Mag <- plot_ly(x=x, y=y, z=Mag_IFT_matrix_ON_smooth, type = \"surface\", \n                  scene='scene7', name=\"Mag(On)\") %>% \n  layout(title = \"Mag(fMRI-ON K-space Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\npOFF_Mag <- plot_ly(x=x, y=y, z=Mag_IFT_matrix_OFF_smooth, type = \"surface\", \n                  scene='scene8', name=\"Mag(Off)\") %>% \n  layout(title = \"Mag(fMRI-OFF K-space Stiching)\") %>% hide_colorbar()\npDIFF_Mag <- plot_ly(x=x,y=y,\n                     z=(Mag_IFT_matrix_ON_smooth - Mag_IFT_matrix_OFF_smooth),\n                  type=\"surface\", scene='scene9', name=\"Im(Diff)\") %>% \n  layout(title = \"Mag(fMRI-ON - fMRI-OFF K-space Stiching)\", \n         scene = list(domain=list(x=c(-period, period), y=c(-period, period)),\n                      aspectmode = \"cube\")) %>% hide_colorbar()\n# Scene titles\nannotations=list(list(showarrow=FALSE, text='Re(ON)', \n                      xref='scene',yref='scene',zref='scene', x=0.0,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Re(OFF)', \n                      xref='scene2',yref='scene',zref='scene', x=0.35,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Re(DIFF)', \n                      xref='scene3',yref='scene',zref='scene', x=0.7,y=0.9,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Im(ON)', \n                      xref='scene4',yref='scene',zref='scene', x=0.0,y=0.5,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Im(OFF)', \n                      xref='scene5',yref='scene',zref='scene', x=0.3,y=0.5,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Im(DIFF)', \n                      xref='scene6',yref='scene',zref='scene', x=0.6,y=0.5,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Mag(ON)', \n                      xref='scene7',yref='scene',zref='scene', x=0.0,y=0,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Mag(OFF)', \n                      xref='scene8',yref='scene',zref='scene', x=0.35,y=0,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)),\n                 list(showarrow=FALSE, text='Mag(DIFF)', \n                      xref='scene9',yref='scene',zref='scene', x=0.7,y=0,z=0.1,\n                      xanchor='left',yanchor='bottom',font=list(size=16)))\n\n# Combine the plots\ncombined_plot <- subplot(pON_Re, pOFF_Re, pDIFF_Re, \n                         pON_Im, pOFF_Im, pDIFF_Im, \n                         pON_Mag, pOFF_Mag, pDIFF_Mag) %>%\n  layout(title=\"Real (Re), Imaginary (Im) and Magnitude of\\n the fMRI-ON vs. fMRI-OFF Fourier-space Stitching Surfaces\", \n         scene=list(domain=list(x=c(0, 0.33), y=c(0.67,1)), aspectmode=\"cube\"), \n         scene2=list(domain=list(x=c(0.33,0.66),y=c(0.67,1)), aspectmode=\"cube\"),\n         scene3=list(domain=list(x=c(0.7, 1), y=c(0.67,1)), aspectmode=\"cube\"),\n         scene4=list(domain=list(x=c(0, 0.33), y=c(0.33,0.66)), aspectmode=\"cube\"), \n         scene5=list(domain=list(x=c(0.33,0.66),y=c(0.33,0.66)), aspectmode=\"cube\"),\n         scene6=list(domain=list(x=c(0.7, 1), y = c(0.33,0.66)), aspectmode=\"cube\"),\n         scene7=list(domain=list(x=c(0, 0.33), y=c(0.0,0.33)), aspectmode=\"cube\"), \n         scene8=list(domain=list(x=c(0.33,0.66), y=c(0.0,0.33)), aspectmode=\"cube\"),\n         scene9=list(domain=list(x=c(0.7, 1), y = c(0.0,0.33)), aspectmode=\"cube\"),\n         annotations = annotations)\n\n# Display the synchronized plot\ncombined_plot %>% htmlwidgets::onRender(\n    \"function(x, el) {\n      x.on('plotly_relayout', function(d) {\n        const camera = Object.keys(d).filter((key) => /\\\\.camera$/.test(key));\n        if (camera.length) {\n          const scenes = Object.keys(x.layout).filter((key) => /^scene\\\\d*/.test(key));\n          const new_layout = {};\n          scenes.forEach(key => {\n            new_layout[key] = {...x.layout[key], camera: {...d[camera]}};\n          });\n          Plotly.relayout(x, new_layout);\n        }\n      });\n    }\")",
      "line_count": 262
    },
    {
      "section": "Interactive plotly Example",
      "code": "bigim1_mask<-bigim1_mod\nfor (i in 1:160) {\n  bigim1_mask[,,,i]<-bigim1_mask[,,,i]*mask\n}",
      "line_count": 4
    },
    {
      "section": "Interactive plotly Example",
      "code": "fmri_image(bigim1_mod, option = \"manually\", voxel_location = c(40,40,30), time = 4)",
      "line_count": 1
    },
    {
      "section": "Interactive plotly Example",
      "code": "fmri_image(bigim1_mask, option = \"manually\", voxel_location = c(40,40,30), time = 4)",
      "line_count": 1
    },
    {
      "section": "Interactive plotly Example",
      "code": "fmri_ts_forecast(smoothmod,c(41,44,33))",
      "line_count": 1
    },
    {
      "section": "Motor area detection",
      "code": "fmri_generate = fmri_simulate_func(dim_data = c(64, 64, 40), mask = mask, \n                                   ons = c(1, 21, 41, 61, 81, 101, 121, 141), \n                                   dur = c(10, 10, 10, 10, 10, 10, 10, 10))",
      "line_count": 3
    },
    {
      "section": "Motor area detection",
      "code": "# statistical method HRF needs parameter ons and dur\npval1 = fmri_stimulus_detect(fmridata= bigim1_mod, mask = mask,\n                             stimulus_idx = c(1:160)[rep(c(TRUE,FALSE), c(10,10))],\n                             method = \"HRF\" , \n                             ons = c(1, 21, 41, 61, 81, 101, 121, 141), \n                             dur = c(10, 10, 10, 10, 10, 10, 10, 10) )\n\n# statistical method t-test for real-valued fMRI data\npval2 = fmri_stimulus_detect(fmridata= bigim1_mod, mask = mask,\n                             stimulus_idx = c(1:160)[rep(c(TRUE,FALSE), c(10,10))],\n                             method = \"t-test\")\n\n# statistical method Wilk's Lambda for complex-valued data\npval3 = fmri_stimulus_detect(fmridata = bigim1, mask = mask,\n                             stimulus_idx = c(1:160)[rep(c(TRUE,FALSE), c(10,10)) ], \n                             method = \"Wilks-Lambda\" )\n\n# do the fdr correction and the spatial clustering\n# pval4 is the pval1 after the post-hoc processing\npval4 = fmri_post_hoc(pval1, fdr_corr = \"fdr\",\n                    \t\t\t\t\t\t spatial_cluster.thr = 0.05,\n                    \t\t\t\t\t\t spatial_cluster.size = 5, \n                    \t\t\t\t\t\t show_comparison = FALSE)\n",
      "line_count": 24
    },
    {
      "section": "Motor area detection",
      "code": "summary(pval1)\nsummary(pval2)\nsummary(pval3)\nsummary(pval4)",
      "line_count": 4
    },
    {
      "section": "Motor area visualization",
      "code": "pval1_3d = fmri_3dvisual(pval1, mask, p_threshold = 0.05, method=\"scale_p\", multi_pranges=TRUE, title=\"Accounting for HRF\")\n\npval1_3d$plot",
      "line_count": 3
    },
    {
      "section": "Motor area visualization",
      "code": "pval4_3D = fmri_3dvisual(pval4, mask, p_threshold = 0.05, method=\"scale_p\",\n                         multi_pranges=TRUE, title=\"HRF method with post-hoc correction\")\n\npval4_3D$plot",
      "line_count": 4
    },
    {
      "section": "Motor area visualization",
      "code": "for(axis in c(\"x\", \"y\", \"z\")){\n  axis_i = switch(axis, \n                  \"x\" = {35},\n                  \"y\" = {30},\n                  \"z\" = {22})\n  print(fmri_2dvisual(pval1, list(axis, axis_i), \n                      hemody_data=NULL, mask=mask, \n                      p_threshold = 0.05, legend_show = TRUE, \n                      method = \"scale_p\",\n                      color_pal = \"YlOrRd\", multi_pranges=TRUE))\n}\n\t\t\t",
      "line_count": 12
    },
    {
      "section": "Motor area visualization",
      "code": "for(axis in c(\"x\", \"y\", \"z\")){\n  axis_i = switch(axis, \n                  \"x\" = {35},\n                  \"y\" = {30},\n                  \"z\" = {22})\n  print(fmri_2dvisual(pval1, list(axis, axis_i), \n                      hemody_data=hemody, mask=mask, \n                      p_threshold = 0.05, legend_show = TRUE, \n                      method = \"scale_p\",\n                      color_pal = \"YlOrRd\", multi_pranges=TRUE))\n}",
      "line_count": 11
    },
    {
      "section": "Motor area visualization",
      "code": "fmri_pval_comparison_3d(list(pval1, pval2), mask, \n    \t\t\t\t            list(0.05, 0.05), list(\"scale_p\", \"scale_p\"), \n    \t\t\t\t            multi_pranges=FALSE)",
      "line_count": 3
    },
    {
      "section": "Motor area visualization",
      "code": "fmri_pval_comparison_2d(list(pval2, pval1), \n      \t\t\t\t           list('t-test', 'HRF'),\n      \t\t\t\t           list(list(35, 33, 22), list(40, 26, 33)), \n      \t\t\t\t           hemody_data = NULL, \n      \t\t\t\t           mask = mask, p_threshold = 0.05, \n      \t\t\t\t           legend_show = FALSE, method = 'scale_p',\n      \t\t\t\t           color_pal = \"YlOrRd\", multi_pranges=FALSE)",
      "line_count": 7
    },
    {
      "section": "Tri-phase ROI-based Spacekime Analytics",
      "code": "phase1_pval = fmri_ROI_phase1(bigim1_mod, mask_label, mask_dict,\n                              stimulus_idx = c(1:160)[rep(c(TRUE,FALSE),\n                                                          c(10,10))])$all_ROI$pval_t",
      "line_count": 3
    },
    {
      "section": "Tri-phase ROI-based Spacekime Analytics",
      "code": "phase2_pval = fmri_ROI_phase2(fmridata = bigim1_mod, \n                              label_mask = mask_label, label_dict = mask_dict, \n                              stimulus_idx = c(1, 21, 41, 61, 81, 101, 121, 141),\n                              stimulus_dur = c(10, 10, 10, 10, 10, 10, 10, 10),\n                              rrr_rank = 3, fmri.design_order = 2,\n                              fmri.stimulus_TR = 3, method = \"t_test\")",
      "line_count": 6
    },
    {
      "section": "Tri-phase ROI-based Spacekime Analytics",
      "code": "phase3_pval = fmri_post_hoc(phase2_pval , fdr_corr = \"fdr\",\n                            spatial_cluster.thr = 0.05,\n                            spatial_cluster.size = 5, \n                            show_comparison = FALSE)",
      "line_count": 4
    },
    {
      "section": "Tri-phase ROI-based Spacekime Analytics",
      "code": "fmri_3dvisual_region(TCIU::phase1_pval, label_mask, label_index,\n                     label_name, title = \"Phase 1 p-values\", rank = \"value\")",
      "line_count": 2
    },
    {
      "section": "Tri-phase ROI-based Spacekime Analytics",
      "code": "fmri_3dvisual_region(TCIU::phase1_pval, label_mask, label_index,\n                     label_name, 5, title = \"pPhase-1 top five p-values\", rank = \"value\")",
      "line_count": 2
    },
    {
      "section": "Tri-phase ROI-based Spacekime Analytics",
      "code": "# for 3D visualization, user needs to include empty region in the label\nlabel_index = c(0, label_index)\nlabel_name = c(\"empty\", label_name)\nfmri_3dvisual_region(TCIU::phase2_pval, label_mask, label_index,\n                    label_name, title = \"Phase-2 p-values\")",
      "line_count": 5
    },
    {
      "section": "Tri-phase ROI-based Spacekime Analytics",
      "code": "fmri_3dvisual_region(list(TCIU::phase2_pval,TCIU::phase3_pval), label_mask, label_index,\n                    label_name, title = \"Contrasting Phase 2 & Phase 3 p-values\")",
      "line_count": 2
    },
    {
      "section": "Statistical Inference on Kimesurfaces",
      "code": "# Wasserstein distance (transport package)\n\n#' Takes a time-series (1D vector), temporal longitudinal data, \n#' and converts it to complex-values kimesurface\n#' \n#' @param datay A numerical vector.\n#' @returns A list of 7 objects representing \n#'              [[1]] x-grid points of (2D) kimesurface magnitude\n#'              [[2]] y-grid points (2D) of kimesurface magnitude\n#'              [[3]] LT kimesurface (complex-number)\n#'              [[4]] LT kimesurface magnitude\n#'              [[5]] LT kimesurface Real-part\n#'              [[6]] LT kimesurface Imaginary-part\n#'              [[7]] LT kimesurface phase\n#' @examples\n#' testTS2KS <- timeSeries2KimeSurface(datay = sin(seq(-pi, pi, length.out=200)))\ntimeSeries2KimeSurface <- function(datay = sin(x1)) {\n  Lout = 61\n  range_limit <- 20\n  x2 <- seq(from = 0.1, to = range_limit, length.out = Lout)\n  y2 <- seq(from = 0, to = range_limit, length.out = Lout)\n  \n  x2_g = x2 %o% seq(1,1, length.out = Lout)\n  y2_g =  seq(1,1, length.out = Lout) %o% y2\n\n  z2_grid = x2 %o% y2\n  \n  argz = as.vector(x2_g + 1i*y2_g)\n  LTz = NuLT(x1, datay, argz)\n  rec1 = matrix(LTz,nrow = Lout)\n  \n  recm = abs(rec1)\n  recr = Re(rec1)\n  reci = Im(rec1)\n  ph = reci/recm\n  surf_color <- atan2(reci,recr)\n  # resultKimesurface <- list()\n  # resultKimesurface[[1]] <- x2_g  # x-grid points of (2D) kimesurface magnitude\n  # resultKimesurface[[2]] <- y2_g  # y-grid points (2D) of kimesurface magnitude\n  # resultKimesurface[[3]] <- rec1  # LT kimesurface (complex-number)\n  # resultKimesurface[[4]] <- recm  # LT kimesurface magnitude\n  # resultKimesurface[[5]] <- recr  # LT kimesurface Real-part\n  # resultKimesurface[[6]] <- reci  # LT kimesurface Imaginary-part\n  # resultKimesurface[[7]] <- surf_color # LT kimesurface phase\n  p2D <- plot_ly(z=matrix(recm, nrow = sqrt(length(recm))), type=\"heatmap\")\n  p3D <- plot_ly(x=x2_g, y=y2_g, z=matrix(recm, nrow = sqrt(length(recm))),\n                 type=\"surface\")\n  #  plot_ly(x=x2_g, y=y2_g, z=matrix(log(recm), nrow = sqrt(length(recm))), type=\"surface\")\n  return(list(\"x_grid\"=x2_g, \"y_grid\"=y2_g, \"complexLT_KS\"=rec1, \"magLT_KS\"=recm,\n              \"realLT_KS\"=recr, \"imaginaryLT_KS\"=reci, \"phaseLT_KS\"=surf_color,\n              \"plot_ly2D\" = p2D, \"plot_ly3D\" = p3D))\n}\n\nkimesurface_SplOnAvg <- timeSeries2KimeSurface(datay = spl_onAvg$y)\nkimesurface_SplOffAvg <- timeSeries2KimeSurface(datay = spl_offAvg$y)\n\n# Compute the Wasserstein Distance Between the On and Off kimesurfaces \n# convert the matrices LT to pgrid\n# Input arrays must be prob mass functions (>=0)\nwDistanceMagLT_KS_p1 <- wasserstein(pgrid(kimesurface_SplOnAvg$magLT_KS),\n            pgrid(kimesurface_SplOffAvg$magLT_KS), p=1, prob=FALSE)\nwDistanceMagLT_KS_p2 <- wasserstein(pgrid(kimesurface_SplOnAvg$magLT_KS),\n            pgrid(kimesurface_SplOffAvg$magLT_KS), p=2, prob=FALSE)\n\nwDistanceRealLT_KS_p1 <- wasserstein(pgrid(abs(kimesurface_SplOnAvg$realLT_KS)),\n            pgrid(abs(kimesurface_SplOffAvg$realLT_KS)), p=1, prob=FALSE)\nwDistanceRealLT_KS_p2 <- wasserstein(pgrid(abs(kimesurface_SplOnAvg$realLT_KS)),\n            pgrid(abs(kimesurface_SplOffAvg$realLT_KS)), p=2, prob=FALSE)\n\n# Plot p1 and p2 Wasserstein Distances Between the On and Off kimesurfaces\nWassersteinDistances <- c(\"Wasserstein P1 Distance\", \"Wasserstein P2 Distance\")\nKimeSurfaceMagnitude <- c(wDistanceMagLT_KS_p1, wDistanceMagLT_KS_p2)\nKimeSurfaceRealPart  <- c(wDistanceRealLT_KS_p1, wDistanceRealLT_KS_p2)\nKS_DataFrame <- data.frame(WassersteinDistances, KimeSurfaceMagnitude, KimeSurfaceRealPart)\n\nplot_ly(KS_DataFrame, x = ~WassersteinDistances, y = ~KimeSurfaceMagnitude,\n               type = 'bar', name = 'kimesurface (Complex) Magnitude') %>% \n  add_trace(y = ~KimeSurfaceRealPart, name = 'kimesurface Real Part') %>% \n  layout(title=\"Wasserstein Distances Between the kimesurfaces \\n corresponding to the (avg) ON and OFF fMRI Stimuli\",\n         yaxis = list(title = 'Wasserstein Distances'), \n         xaxis=list(title=\"p-norm (1 or 2)\"), barmode = 'group')\n\n### Procrustes distance  (shapes package)\n# procdist(x, y,type=\"full\",reflect=FALSE)\n# type - string indicating the type of distance; \"full\" full Procrustes distance, \"partial\" partial Procrustes distance, \"Riemannian\" Riemannian shape distance, \"sizeandshape\" size-and-shape Riemannian/Procrustes distance\n\ndistanceMagLT_KS_Procrustes <- procdist(kimesurface_SplOnAvg$magLT_KS,\n            kimesurface_SplOffAvg$magLT_KS, type=\"full\")\ndistanceMagLT_KS_Riemannian <- procdist(kimesurface_SplOnAvg$magLT_KS,\n            kimesurface_SplOffAvg$magLT_KS, type=\"Riemannian\")\n\ndistanceRealLT_KS_Procrustes <- procdist(kimesurface_SplOnAvg$realLT_KS,\n            kimesurface_SplOffAvg$realLT_KS, type=\"full\")\ndistancerealLT_KS_Riemannian <- procdist(kimesurface_SplOnAvg$realLT_KS,\n            kimesurface_SplOffAvg$realLT_KS, type=\"Riemannian\")\n\nProcrustesDistances <- c(\"Procrustes Distance\", \"Riemannian Distance\")\nKimeSurfaceMagnitude <- c(distanceMagLT_KS_Procrustes, distanceMagLT_KS_Riemannian)\nKimeSurfaceRealPart  <- c(distanceRealLT_KS_Procrustes, distancerealLT_KS_Riemannian)\n\nKS_DataFrame <- data.frame(ProcrustesDistances, KimeSurfaceMagnitude, KimeSurfaceRealPart)\n\nplot_ly(KS_DataFrame, x = ~ProcrustesDistances, y = ~KimeSurfaceMagnitude,\n               type = 'bar', name = 'kimesurface (Complex) Magnitude') %>% \n  add_trace(y = ~KimeSurfaceRealPart, name = 'kimesurface Real Part') %>% \n  layout(title=\"Procrustes & Riemannian Distances Between the kimesurfaces \\n corresponding to the (avg) ON and OFF fMRI Stimuli\",\n         yaxis = list(title = 'Topological Shape Distances'), \n         xaxis=list(title=\"Procrustes & Riemannian Distances\"), barmode = 'group')",
      "line_count": 108
    },
    {
      "section": "Statistical Inference on Kimesurfaces",
      "code": "library(MultiwayRegression)\n# 1. Simulation example\n\n# TO DO: generalize this function to allow inserting any dataY/function input!!!\ntimeSeries2KimeSurfaceTensor <- function(datay = sin(x1), freq = c(1:10)) {\n  Lout = 61\n  range_limit <- 20\n  x2 <- seq(from = 0.1, to = range_limit, length.out = Lout)\n  y2 <- seq(from = 0, to = range_limit, length.out = Lout)\n  \n  x2_g = x2 %o% seq(1,1, length.out = Lout)\n  y2_g =  seq(1,1, length.out = Lout) %o% y2\n\n  z2_grid = x2 %o% y2\n  \n  argz = as.vector(x2_g + 1i*y2_g)\n  \n  # compute all 10 sine-frequency (kimesurface) simulated samples\n  arr3D <- array(0, c(freq[length(freq)], Lout, Lout))\n  for (i in freq) {\n    LTz = NuLT(x1, sin(i*x1), argz)\n    arr3D[i, , ] = matrix(LTz, nrow = Lout)\n  }\n  return(arr3D)  # Complex-valued!!!!\n}\n\n# str(X) #  num [1:10, 1:61, 1:61]\n# str(Y) #  num [1:10, 1:2] univariate scalar 1:10 (sine frequency)\nksComplex <- timeSeries2KimeSurfaceTensor(datay = sin(x1), freq = c(1:10))\nY <- cbind(c(1:10), c(1,0,0,0,0,0,0,0,0,0))\n\n# Mind the TLM regularization (Ridge penalty, L2) to prevent singularities\ntlModel <- rrr(X=Re(ksComplex), Y=Y, R=1, lambda = 0.01) # Fit rank 1 model with Ridge regularization\nY_pred <- ctprod(A=Re(ksComplex), B=tlModel$B, 2) \n\nplot_ly(x=Y[ , 1], y=Y_pred[,2], type=\"scatter\", mode=\"markers+lines\") %>%\n  layout(title=\"Simulated Sine Function Kimesurface TLM\", \n         xaxis=list(title=\"Actual Sine Period\"), \n         yaxis=list(title=\"TLM-predicted Period\"))\n\n# 2. fMRI Data example\nfMRI2KimeSurfaceTensor <- function(datay = sin(x1)) {\n  Lout = 61\n  range_limit <- 20\n  x2 <- seq(from = 0.1, to = range_limit, length.out = Lout)\n  y2 <- seq(from = 0, to = range_limit, length.out = Lout)\n  \n  x2_g = x2 %o% seq(1,1, length.out = Lout)\n  y2_g =  seq(1,1, length.out = Lout) %o% y2\n\n  z2_grid = x2 %o% y2\n  \n  argz = as.vector(x2_g + 1i*y2_g)\n  \n  # compute all 10 sine-frequency (kimesurface) simulated samples\n  arr3D <- array(0, c(1, Lout, Lout))\n  LTz = NuLT(x1, datay, argz)\n  arr3D[1, , ] = matrix(LTz, nrow = Lout)\n  \n  return(arr3D)  # Complex-valued!!!!\n}\n\nks1 <- fMRI2KimeSurfaceTensor(datay = spl_onAvg$y)\nks2 <- fMRI2KimeSurfaceTensor(datay = spl_offAvg$y)\nLout <-  61\narrKS3D <- array(c(ks1, ks2), c(2, Lout, Lout))\n\n# str(X) #  num [1:2, 1:61, 1:61]\n# str(Y) #  num [1:2, 1:2] univariate scalar 1:2 (fMRI ON and OFF stimuli)\nY <- cbind(c(1:2), c(1,0))  # On and Off fMRI stimulation paradigm\n\n# Mind the TLM regularization (Ridge penalty, L2) to prevent singularities\ntlModel <- rrr(X=Re(arrKS3D), Y=Y, R=1, lambda = 0.01) # Fit rank 1 model with Ridge regularization\nY_pred <- ctprod(A=Re(arrKS3D), B=tlModel$B, 2) \n\nplot_ly(x=Y[ , 1], y=Y_pred[,2], type=\"scatter\", mode=\"markers+lines\") %>%\n  layout(title=\"Simple fMRI Kimesurface TLM\", \n         xaxis=list(title=\"Actual On/Off Stimulus\"), \n         yaxis=list(title=\"TLM-predicted On/Off Paradigm\"))",
      "line_count": 79
    },
    {
      "section": "Statistical Inference on Kimesurfaces",
      "code": "library(TDA)\n# 1. Simulation example\n# str(X) #  num [1:10, 1:61, 1:61]\n# str(Y) #  num [1:10, 1:2] univariate scalar 1:10 (sine frequency)\n# ksComplex <- timeSeries2KimeSurfaceTensor(datay = sin(x1), freq = c(1:10))\n# Y <- cbind(c(1:10), c(1,0,0,0,0,0,0,0,0,0))\n\n#  1.1 Plot the kimesurfaces of the sine-functions corresponding to different periods\n#  1.1.A Plot the Native Sine functions\nplot_ly(x=x1, y=sin(x1), type=\"scatter\", mode=\"lines\", name=\"Period=1\") %>%\n  add_trace(y=sin(4*x1), name=\"Period=4\") %>%\n  add_trace(y=sin(9*x1), name=\"Period=9\") %>%\n  layout(title=\"Original Sine-functions with Different Periods\", \n         legend = list(orientation='h', y=-0.2))\n#  1.1.B Plot the Corresponding sine-kimesurfaces\nplot_ly(z=Re(ksComplex)[1, , ], type=\"surface\", name=\"Period=1\") %>%\n  add_surface(z=1+Re(ksComplex)[4, , ], type=\"surface\", name=\"Period=4\", opacity=0.4) %>%\n  add_surface(z=-1+Re(ksComplex)[9, , ], type=\"surface\", name=\"Period=9\", opacity=0.4) %>%\n  layout(title=\"Kimesurfaces of Sine-functions with Different Periods (1,4,9)\") %>%\n  hide_colorbar()\n\n\n# 1.2 Compute the distance function for each point on the Grid\n# Re(ksComplex)[1, , ]) is the Real part of the kimesurface of sin(x)\n\n# Construct the 2D kimesurface domain grid\nLout = 61\nrange_limit <- 20\nXseq <- seq(from = 0.1, to = range_limit, length.out = Lout)\nYseq <- seq(from = 0, to = range_limit, length.out = Lout)\n\nx2 <- seq(from = 0.1, to = range_limit, length.out = Lout)\ny2 <- seq(from = 0, to = range_limit, length.out = Lout)\nksGrid <- expand.grid(x2, y2)\n\n# Unwind the complex-value 2D kimesurface over the 61*61 grid into\n# a 2D a matrix (m=61*61) * (d=2), m is the number of points on the kimesurface X\n# and d is the dimension of the space, corresponding to \n# the kimesurface Re(KS) and Im(KS) parts\nksVector <- c(ksComplex[1, , ])\nksX <- cbind(R=Re(ksVector), I=Im(ksVector))\n\nksDistance <- distFct(X = ksX, Grid = ksGrid)\n# plot_ly(z=matrix(ksDistance, ncol=length(Yseq), nrow=length(Xseq)), \n#         type=\"surface\", name=\"Distance Function\")\n\n# 1.3 distance to measure (DTM) function\nksDTM <- dtm(X = ksX, Grid = ksGrid, m0 = 0.1)\n# plot_ly(z=matrix(ksDTM, ncol=length(Yseq), nrow=length(Xseq)), \n#         type=\"surface\", name=\"Distance to Measure (DTM)\")\n\n# 1.4 k-nearest neighbor density estimator function\n# ks_kNN <- knnDE(X = Re(ksComplex)[1, , ], Grid = z2_grid, k = 30)\n# ksVector <- c(ksComplex[9, , ])\n# ksX <- cbind(R=Re(ksVector), I=Im(ksVector))\nks_kNN <- knnDE(X = ksX, Grid = ksGrid, k = 10)\n# plot_ly(z=matrix(ks_kNN, ncol=length(Yseq), nrow=length(Xseq)), \n#         type=\"surface\", name=\"k-Nearest Neighbor (kNN) Density Estimator\")\n\n\n# 1.5 Gaussian Kernel Density Estimator (KDE) function\nksKDE <- kde(X = ksX, Grid = ksGrid, h = 2.5)\n# plot_ly(z=matrix(ksKDE, ncol=length(Yseq), nrow=length(Xseq)), \n#         type=\"surface\", name=\"Gaussian Kernel Density Estimator (KDE)\")\n\n# Joint 3D surface plot\nplot_ly(z=matrix(ksDistance, ncol=length(Yseq), nrow=length(Xseq)), \n        type=\"surface\", name=\"Distance Function\", hovertemplate = paste('(%{x}, %{y})')) %>%\n  add_surface(z=-8+matrix(ksDTM, ncol=length(Yseq), nrow=length(Xseq)), \n        name=\"Distance to Measure (DTM)\", opacity=0.4, hovertemplate = paste('(%{x}, %{y})')) %>%\n  add_surface(z=8+matrix(ks_kNN, ncol=length(Yseq), nrow=length(Xseq)), \n        name=\"k-Nearest Neighbor (kNN) Density Estimator\", opacity=0.4, \n        hovertemplate = paste('(%{x}, %{y})')) %>%\n  add_surface(z=16+matrix(ksKDE, ncol=length(Yseq), nrow=length(Xseq)), \n        name=\"Gaussian Kernel Density Estimator (KDE)\", opacity=0.4, \n        hovertemplate = paste('(%{x}, %{y})')) %>%\n  layout(title=\"Joint 3D Surface Plot (Distance, DTM, kNN & KDE)\") %>%\n  hide_colorbar()\n\n# 2. Bootstrap Confidence Bands: (1 − \\alpha) confidence band for a function \n# using the bootstrap algorithm\nksBootstrapBands <- \n  bootstrapBand(X = ksX, Grid = ksGrid, FUN = dtm, # options: distFct, kde, and dtm \n                B = 100, parallel=TRUE, alpha=0.1, m0=0.1)  # for KDE: h=0.3)\n\nplot_ly(z=matrix(ksBootstrapBands$fun, ncol=length(Yseq), nrow=length(Xseq)), \n        type=\"surface\", name=\"Distance-to-Measure (DTM) Function\", hovertemplate = paste('(%{x}, %{y})')) %>%\n  add_surface(z=-5+matrix(ksBootstrapBands$band[,1], ncol=length(Yseq), nrow=length(Xseq)), \n        name=\"Lower Bootstrap Band\", opacity=0.1, hovertemplate = paste('(%{x}, %{y})')) %>%\n  add_surface(z=5+matrix(ksBootstrapBands$band[,2], ncol=length(Yseq), nrow=length(Xseq)), \n        name=\"Upper Bootstrap Band\", opacity=0.1, hovertemplate = paste('(%{x}, %{y})')) %>%\n  layout(title=\"Bootstrap Confidence Bands for the DTM Kimesurface\") %>%\n  hide_colorbar()\n\n# 3. Density Clustering\n# The function clusterTree implements Algorithm 1 in Kent, Rinaldo, and Verstynen (2013).\n# Let f be the density of the probability distribution P generating the observed sample \n# X = {x1, . . . , xn} ⊂ Rd. For a threshold value λ > 0, the corresponding super-level set \n# of f is Lf (λ) := cl({x ∈ Rs : f (x) > λ}), and its d-dimensional  subsets are \n# high-density regions. The high-density clusters of P are the maximal connected subsets of Lf (λ).\n# By considering all the level sets simultaneously (from λ = 0 to λ = ∞), \n# we track the evolution and the hierarchy of the high-density clusters of P.\n# This leads to the notion of the cluster density tree of P defined as the collection of sets \n# T := {Lf (λ), λ ≥ 0} satisfying the tree property:\n# A, B ∈ T implies that A ⊂ B or B ⊂ A or A ∩ B = ∅. This is the λ-tree. \n# Alternatively, Kent et al. (2013) introduced the α-tree and κ-tree, which facilitate the\n# interpretation of the tree by precisely encoding the probability content of each tree branch\n# rather than the density level. Cluster trees are particularly useful for high dimensional data,\n# whose spatial organization is difficult to represent.\n\nksTree    <- clusterTree(X=ksX, k=12, density = \"knn\", \n                         Nlambda=120, printProgress=TRUE)\nksTreeKDE <- clusterTree(X=ksX, k=2, h=5.3, density=\"kde\", printProgress=TRUE)\n# ksTreeKDE <- clusterTree(X=ksX, k=10, h=0.3, density=\"kde\", printProgress=TRUE)\n\n# Plot the lambda and kappa trees of the k Nearest Neighbor (kNN) density\n# estimator, and the kernel density estimator (KDE)\npar(mfrow = c(2, 3))\n\nplot(ksTree, type = \"lambda\", main = \"Kimesurface Lambda Tree (kNN)\")\nplot(ksTree, type = \"kappa\", main = \"Kimesurface Lappa Tree (kNN)\")\nplot(ksX, pch = 19, cex = 0.6, xlim = c(-0.01, 0.01), ylim = c(-0.02, 0.0),\n     main = \"Kimesurface kNN Cluster Labels\")\nfor (i in ksTree[[\"id\"]]){\n    points(matrix(ksX[ksTree[[\"DataPoints\"]][[i]],],ncol = 2), \n           col=i, pch=19, cex = 0.6)\n}\n\nplot(ksTreeKDE, type = \"lambda\", main = \"Kimesurface Lambda Tree (KDE)\")\nplot(ksTreeKDE, type = \"kappa\", main = \"Kimesurface Kappa Tree (KDE)\")\nplot(ksX, pch = 19, cex = 0.6, xlim = c(-0.2, 0.2), ylim = c(-0.2, 0.05), \n     main = \"Kimesurface KDE Cluster Labels\")\nfor (i in ksTreeKDE[[\"id\"]]){\n    points(matrix(ksX[ksTreeKDE[[\"DataPoints\"]][[i]],],ncol = 2), \n           col=i, pch=19, cex = 0.6)\n}",
      "line_count": 136
    },
    {
      "section": "Statistical Inference on Kimesurfaces",
      "code": "# Recall:\n# ks1 <- fMRI2KimeSurfaceTensor(datay = spl_onAvg$y)\n# ks2 <- fMRI2KimeSurfaceTensor(datay = spl_offAvg$y)\n\n# Plot (again) the (average) On and Off fMRI kimesurfaces\nplot_ly(z=log(500+Re(ks1[1, , ])), name=\"fMRI On Kimesurface (Real Part)\", \n        type=\"surface\", opacity=1.0, colorscale=\"Jet\", \n        # surfacecolor=Im(ks1[1, , ]),  # Color=Im(KS)?\n        hovertemplate = paste('(%{x}, %{y})')) %>%\n    add_surface(z=log(600+Re(ks2[1, , ])), name=\"fMRI Off Kimesurface (Real Part)\",\n                opacity=0.8, # surfacecolor=Im(ks1[1, , ]),\n                hovertemplate = paste('(%{x}, %{y})')) %>%\n    layout(title=\"fMRI On and Off Paradigm Kimesurfaces: Height=Log(Re(KS))\") %>%\n    hide_colorbar()\n\nplot_ly(z=(Re(ks1[1, , ])-Re(ks2[1, , ])), type=\"surface\", colorscale=\"Jet\",\n        name=\"fMRI Diff (On-Off) Kimesurface (Real Part)\",\n        opacity=1.0, hovertemplate = paste('(%{x}, %{y})')) %>%\n  layout(title=\"fMRI Diff (On-Off) Kimesurface (Real Parts)\") %>%\n  hide_colorbar()\n\n# Unwind the complex-value 2D kimesurface over the 61*61 grid into\n# a 2D a matrix (m=61*61) * (d=2), m is the number of points on the kimesurface X\n# and d is the dimension of the space, corresponding to \n# the kimesurface Re(KS) and Im(KS) parts\n\n###################################################################\n######### For speed - \n#########  reduce the kimesurfaces from [1:61,1:61] to 1:20, [1:20]\n###################################################################\n\nplot_ly(z=(Re(ks1[1, 1:20, 1:20])-Re(ks2[1, 1:20, 1:20])), \n        type=\"surface\", colorscale=\"Jet\",\n        name=\"reduced fMRI Diff (On-Off) Kimesurface (Real Part)\",\n        opacity=1.0, hovertemplate = paste('(%{x}, %{y})')) %>%\n    layout(title=\"Reduced fMRI Diff (On-Off) Kimesurface (Real Parts)\") %>%\n    hide_colorbar()\n\nksVector_ON <- c(ks1[1, 1:20, 1:20])  # complex-values!!!\nksX_ON <- cbind(R=Re(ksVector_ON), I=Im(ksVector_ON))\n\nksVector_OFF <- c(ks2[1, 1:20, 1:20])  # complex-values!!!\nksX_OFF <- cbind(R=Re(ksVector_OFF), I=Im(ksVector_OFF))\n\n# load TDAstats\nlibrary(\"TDAstats\")\n\n# calculate homologies for both kimesurfaces\npersistentHomology_ON <- calculate_homology(ksX_ON, dim = 1)\npersistentHomology_OFF <- calculate_homology(ksX_OFF, dim = 1)\n\n# plot topological barcodes for both ON and OFF fMRI kimesurfaces\nplt_ON <- ggplotly(plot_barcode(persistentHomology_ON) +\n  ggtitle(\"On fMRI Kimesurface Persistent Homology\") +\n  xlim(c(0, 500))) \nplt_OFF <- ggplotly(plot_barcode(persistentHomology_OFF)+\n  ggtitle(\"Off fMRI Kimesurface Persistent Homology\") +\n  xlim(c(0, 500)))\n\nsubplot(plt_ON, plt_OFF) %>% \n  layout(title = 'TKA: Topological Barcodes for On (left) and Off (right) fMRI Kimesurfaces')\n\n# Stats Inference: Permutation test\n# Remove [1:400,] restriction for real studies, this is just for speed of\n# compiling the Rmd to HTML notes!\nonn_off_PermTest <- permutation_test(ksX_ON, ksX_OFF, iterations=100) #, update=1)\n\n# report the stat-significance, p-values, for 0-cycles and 1-cycles\nprint(paste0(\"On vs. Off fMRI Kimesurface permutation test p-value for 0-cycle is: \",\n             onn_off_PermTest[[1]]$pvalue))\nprint(paste0(\"On vs. Off fMRI Kimesurface permutation test p-value for 1-cycle is: \",\n             onn_off_PermTest[[2]]$pvalue))",
      "line_count": 72
    }
  ]
}